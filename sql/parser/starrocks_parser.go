// Code generated from StarRocks.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // StarRocks

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type StarRocksParser struct {
	*antlr.BaseParser
}

var StarRocksParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func starrocksParserInit() {
	staticData := &StarRocksParserStaticData
	staticData.LiteralNames = []string{
		"", "'.'", "'('", "','", "')'", "'=>'", "'['", "']'", "':'", "'{'",
		"'}'", "'ACCESS'", "'ACTIVE'", "'ADD'", "'ADMIN'", "'ADVISOR'", "'AFTER'",
		"'AGGREGATE'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANTI'", "'APPLY'",
		"'ARRAY'", "'ARRAY_AGG'", "'ARRAY_AGG_DISTINCT'", "'AS'", "'ASC'", "'ASYNC'",
		"'AUTHORS'", "'AUTHENTICATION'", "'AUTOMATED'", "'AUTO_INCREMENT'",
		"'AVG'", "'BACKEND'", "'BACKENDS'", "'BACKUP'", "'BASE'", "'BASELINE'",
		"'BEGIN'", "'BETWEEN'", "'BIGINT'", "'BINARY'", "'BITMAP'", "'BITMAP_UNION'",
		"'BLACKHOLE'", "'BLACKLIST'", "'BODY'", "'BOOLEAN'", "'BOTH'", "'BRANCH'",
		"'BROKER'", "'BUCKETS'", "'BUILTIN'", "'BY'", "'CACHE'", "'CANCEL'",
		"'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CEIL'", "'CHAIN'",
		"'CHAR'", "'CHARACTER'", "'CHARSET'", "'CHECK'", "'CLEAN'", "'CLEAR'",
		"'CLUSTER'", "'CLUSTERS'", "'CNGROUP'", "'CNGROUPS'", "'COLLATE'", "'COLLATION'",
		"'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMMITTED'", "'COMPACT'",
		"'COMPACTION'", "'COMPUTE'", "'CONFIG'", "'CONNECTION'", "'CONSISTENT'",
		"'CONVERT'", "'COSTS'", "'COUNT'", "'CREATE'", "'CROSS'", "'CUBE'",
		"'CUME_DIST'", "'CUMULATIVE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_GROUP'",
		"'CURRENT_ROLE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'",
		"'DATA'", "'DATACACHE'", "'DATABASE'", "'DATABASES'", "'DATE'", "'DATETIME'",
		"'DAY'", "'DAYS'", "'DEALLOCATE'", "'DECIMAL'", "'DECIMALV2'", "'DECIMAL32'",
		"'DECIMAL64'", "'DECIMAL128'", "'DECOMMISSION'", "'DEFAULT'", "'DELETE'",
		"'DENSE_RANK'", "'DEFERRED'", "'DIALECT'", "'DICTIONARY'", "'DICTIONARY_GET'",
		"'NTILE'", "'DESC'", "'DESCRIBE'", "'DISABLE'", "'DISTINCT'", "'DISTRIBUTED'",
		"'DISTRIBUTION'", "'DOUBLE'", "'DROP'", "'DUAL'", "'DUPLICATE'", "'DYNAMIC'",
		"'ELSE'", "'ENABLE'", "'ENCLOSE'", "'END'", "'ENGINE'", "'ENGINES'",
		"'ERRORS'", "'ESCAPE'", "'EVENTS'", "'EXCEPT'", "'EXCLUDE'", "'EXECUTE'",
		"'EXISTS'", "'EXPLAIN'", "'EXPORT'", "'EXTERNAL'", "'EXTRACT'", "'EVERY'",
		"'FAILPOINT'", "'FAILPOINTS'", "'FALSE'", "'FIELDS'", "'FILE'", "'FILES'",
		"'FILTER'", "'FIRST'", "'FIRST_VALUE'", "'FLOAT'", "'FLOOR'", "'FN'",
		"'FOLLOWING'", "'FOLLOWER'", "'FOR'", "'FORCE'", "'FORMAT'", "'FREE'",
		"'FROM'", "'FRONTEND'", "'FRONTENDS'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'",
		"'GLOBAL'", "'GRANT'", "'GRANTS'", "'GROUP'", "'GROUPS'", "'GROUPING'",
		"'GROUPING_ID'", "'GROUP_CONCAT'", "'HASH'", "'HAVING'", "'HELP'", "'HISTOGRAM'",
		"'HLL'", "'HLL_UNION'", "'HOST'", "'HOUR'", "'HOURS'", "'HUB'", "'IDENTIFIED'",
		"'IF'", "'IMPERSONATE'", "'IMMEDIATE'", "'IGNORE'", "'IMAGE'", "'IN'",
		"'INACTIVE'", "'INCREMENTAL'", "'INDEX'", "'INDEXES'", "'INFILE'", "'INNER'",
		"'INSTALL'", "'INSERT'", "'INT'", "'INTEGER'", "'INTEGRATION'", "'INTEGRATIONS'",
		"'INTERMEDIATE'", "'INTERSECT'", "'INTERVAL'", "'INTO'", "'INVOKER'",
		"'GIN'", "'OVERWRITE'", "'IS'", "'ISOLATION'", "'JOB'", "'JOIN'", "'JSON'",
		"'KEY'", "'KEYS'", "'KILL'", "'LABEL'", "'LAG'", "'LARGEINT'", "'LAST'",
		"'LAST_VALUE'", "'LATERAL'", "'LEAD'", "'LEFT'", "'LESS'", "'LEVEL'",
		"'LIKE'", "'LIMIT'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'",
		"'LOCATION'", "'LOCATIONS'", "'LOGS'", "'LOGICAL'", "'MANUAL'", "'MAP'",
		"'MAPPING'", "'MAPPINGS'", "'MASKING'", "'MATCH'", "'MATERIALIZED'",
		"'MAX'", "'MAXVALUE'", "'MERGE'", "'MICROSECOND'", "'MILLISECOND'",
		"'MIN'", "'MINUTE'", "'MINUTES'", "'MINUS'", "'META'", "'MOD'", "'MODE'",
		"'MODIFY'", "'MONTH'", "'MULTIPLE'", "'NAME'", "'NAMES'", "'NEGATIVE'",
		"'NGRAMBF'", "'NO'", "'NODE'", "'NODES'", "'NONE'", "'NOT'", "'NULL'",
		"'NULLS'", "'NUMBER'", "'NUMERIC'", "'OBSERVER'", "'OF'", "'OFF'", "'OFFSET'",
		"'ON'", "'ONLY'", "'OPEN'", "'OPERATE'", "'OPTIMIZE'", "'OPTIMIZER'",
		"'OPTION'", "'OR'", "'ORDER'", "'OUTER'", "'OUTFILE'", "'OVER'", "'?'",
		"'PARTITION'", "'PARTITIONS'", "'PASSWORD'", "'PATH'", "'PAUSE'", "'PENDING'",
		"'PERCENT_RANK'", "'PERCENTILE'", "'PERCENTILE_UNION'", "'PLAN'", "'PLUGIN'",
		"'PLUGINS'", "'PIPE'", "'PIPES'", "'PIVOT'", "'POLICY'", "'POLICIES'",
		"'PRECEDING'", "'PREDICATE'", "'PREPARE'", "'PRIMARY'", "'PRIORITY'",
		"'PRIVILEGES'", "'PROBABILITY'", "'PROC'", "'PROCEDURE'", "'PROCESSLIST'",
		"'PROFILE'", "'PROFILELIST'", "'PROPERTIES'", "'PROPERTY'", "'PROVIDER'",
		"'PROVIDERS'", "'QUALIFY'", "'QUARTER'", "'QUERY'", "'QUERIES'", "'QUEUE'",
		"'QUOTA'", "'RANDOM'", "'RANGE'", "'RANK'", "'READ'", "'REASON'", "'RECOVER'",
		"'REFRESH'", "'REWRITE'", "'REGEXP'", "'RELEASE'", "'REMOVE'", "'RENAME'",
		"'REPAIR'", "'REPEATABLE'", "'REPLACE'", "'REPLACE_IF_NOT_NULL'", "'REPLICA'",
		"'REPOSITORY'", "'REPOSITORIES'", "'RESOURCE'", "'RESOURCES'", "'RESTORE'",
		"'RESUME'", "'RETAIN'", "'RETENTION'", "'RETURNS'", "'RETRY'", "'REVOKE'",
		"'REVERT'", "'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'", "'ROLLBACK'",
		"'ROLLUP'", "'ROUTINE'", "'ROW'", "'ROWS'", "'ROW_NUMBER'", "'RULE'",
		"'RULES'", "'RUNNING'", "'SAMPLE'", "'SCHEDULE'", "'SCHEDULER'", "'SCHEMA'",
		"'SCHEMAS'", "'SECOND'", "'SECURITY'", "'SELECT'", "'SEMI'", "'SEPARATOR'",
		"'SERIALIZABLE'", "'SESSION'", "'SET'", "'SETS'", "'SET_VAR'", "'SIGNED'",
		"'SKIP_HEADER'", "'SHOW'", "'SMALLINT'", "'SNAPSHOT'", "'SNAPSHOTS'",
		"'SQLBLACKLIST'", "'STARROCKS'", "'START'", "'STATS'", "'STATUS'", "'STOP'",
		"'STORAGE'", "'STREAM'", "'STRING'", "'TEXT'", "'SUBMIT'", "'SUM'",
		"'SUSPEND'", "'SYNC'", "'SYSTEM'", "'SYSTEM_TIME'", "'SWAP'", "'STRUCT'",
		"'TABLE'", "'TABLES'", "'TABLET'", "'TABLETS'", "'TAG'", "'TASK'", "'TEMPORARY'",
		"'TERMINATED'", "'THAN'", "'THEN'", "'TIME'", "'TIMES'", "'TIMESTAMP'",
		"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TINYINT'", "'TRANSACTION'", "'TRANSLATE'",
		"'TO'", "'TRACE'", "'TRIGGERS'", "'TRIM_SPACE'", "'TRUE'", "'TRUNCATE'",
		"'TYPE'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'", "'UNION'", "'UNIQUE'",
		"'UNINSTALL'", "'UNSET'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'",
		"'USER'", "'USERS'", "'USING'", "'VALUE'", "'VALUES'", "'VARBINARY'",
		"'VARCHAR'", "'VARIABLES'", "'VECTOR'", "'VERBOSE'", "'VERSION'", "'VIEW'",
		"'VIEWS'", "'VOLUME'", "'VOLUMES'", "'WAREHOUSE'", "'WAREHOUSES'", "'WARNINGS'",
		"'WEEK'", "'WHEN'", "'WHERE'", "'WHITELIST'", "'WITH'", "'WORK'", "'WRITE'",
		"'YEAR'", "'LOCK'", "'UNLOCK'", "'LOW_PRIORITY'", "'DISK'", "'BEFORE'",
		"'$$'", "'FIELD'", "'PERSISTENT'", "'='", "", "'<'", "'<='", "'>'",
		"'>='", "'<=>'", "'[*]'", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'",
		"'&&'", "'!'", "'DIV'", "'&'", "'|'", "'^'", "'~'", "'BITSHIFTLEFT'",
		"'BITSHIFTRIGHT'", "'BITSHIFTRIGHTLOGICAL'", "'->'", "'@'", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "';'", "'...'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "ACCESS", "ACTIVE", "ADD",
		"ADMIN", "ADVISOR", "AFTER", "AGGREGATE", "ALL", "ALTER", "ANALYZE",
		"AND", "ANTI", "APPLY", "ARRAY", "ARRAY_AGG", "ARRAY_AGG_DISTINCT",
		"AS", "ASC", "ASYNC", "AUTHORS", "AUTHENTICATION", "AUTOMATED", "AUTO_INCREMENT",
		"AVG", "BACKEND", "BACKENDS", "BACKUP", "BASE", "BASELINE", "BEGIN",
		"BETWEEN", "BIGINT", "BINARY", "BITMAP", "BITMAP_UNION", "BLACKHOLE",
		"BLACKLIST", "BODY", "BOOLEAN", "BOTH", "BRANCH", "BROKER", "BUCKETS",
		"BUILTIN", "BY", "CACHE", "CANCEL", "CASE", "CAST", "CATALOG", "CATALOGS",
		"CEIL", "CHAIN", "CHAR", "CHARACTER", "CHARSET", "CHECK", "CLEAN", "CLEAR",
		"CLUSTER", "CLUSTERS", "CNGROUP", "CNGROUPS", "COLLATE", "COLLATION",
		"COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "COMPACT", "COMPACTION",
		"COMPUTE", "CONFIG", "CONNECTION", "CONSISTENT", "CONVERT", "COSTS",
		"COUNT", "CREATE", "CROSS", "CUBE", "CUME_DIST", "CUMULATIVE", "CURRENT",
		"CURRENT_DATE", "CURRENT_GROUP", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
		"CURRENT_USER", "DATA", "DATACACHE", "DATABASE", "DATABASES", "DATE",
		"DATETIME", "DAY", "DAYS", "DEALLOCATE", "DECIMAL", "DECIMALV2", "DECIMAL32",
		"DECIMAL64", "DECIMAL128", "DECOMMISSION", "DEFAULT", "DELETE", "DENSE_RANK",
		"DEFERRED", "DIALECT", "DICTIONARY", "DICTIONARY_GET", "NTILE", "DESC",
		"DESCRIBE", "DISABLE", "DISTINCT", "DISTRIBUTED", "DISTRIBUTION", "DOUBLE",
		"DROP", "DUAL", "DUPLICATE", "DYNAMIC", "ELSE", "ENABLE", "ENCLOSE",
		"END", "ENGINE", "ENGINES", "ERRORS", "ESCAPE", "EVENTS", "EXCEPT",
		"EXCLUDE", "EXECUTE", "EXISTS", "EXPLAIN", "EXPORT", "EXTERNAL", "EXTRACT",
		"EVERY", "FAILPOINT", "FAILPOINTS", "FALSE", "FIELDS", "FILE", "FILES",
		"FILTER", "FIRST", "FIRST_VALUE", "FLOAT", "FLOOR", "FN", "FOLLOWING",
		"FOLLOWER", "FOR", "FORCE", "FORMAT", "FREE", "FROM", "FRONTEND", "FRONTENDS",
		"FULL", "FUNCTION", "FUNCTIONS", "GLOBAL", "GRANT", "GRANTS", "GROUP",
		"GROUPS", "GROUPING", "GROUPING_ID", "GROUP_CONCAT", "HASH", "HAVING",
		"HELP", "HISTOGRAM", "HLL", "HLL_UNION", "HOST", "HOUR", "HOURS", "HUB",
		"IDENTIFIED", "IF", "IMPERSONATE", "IMMEDIATE", "IGNORE", "IMAGE", "IN",
		"INACTIVE", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INNER", "INSTALL",
		"INSERT", "INT", "INTEGER", "INTEGRATION", "INTEGRATIONS", "INTERMEDIATE",
		"INTERSECT", "INTERVAL", "INTO", "INVOKER", "GIN", "OVERWRITE", "IS",
		"ISOLATION", "JOB", "JOIN", "JSON", "KEY", "KEYS", "KILL", "LABEL",
		"LAG", "LARGEINT", "LAST", "LAST_VALUE", "LATERAL", "LEAD", "LEFT",
		"LESS", "LEVEL", "LIKE", "LIMIT", "LIST", "LOAD", "LOCAL", "LOCALTIME",
		"LOCALTIMESTAMP", "LOCATION", "LOCATIONS", "LOGS", "LOGICAL", "MANUAL",
		"MAP", "MAPPING", "MAPPINGS", "MASKING", "MATCH", "MATERIALIZED", "MAX",
		"MAXVALUE", "MERGE", "MICROSECOND", "MILLISECOND", "MIN", "MINUTE",
		"MINUTES", "MINUS", "META", "MOD", "MODE", "MODIFY", "MONTH", "MULTIPLE",
		"NAME", "NAMES", "NEGATIVE", "NGRAMBF", "NO", "NODE", "NODES", "NONE",
		"NOT", "NULL", "NULLS", "NUMBER", "NUMERIC", "OBSERVER", "OF", "OFF",
		"OFFSET", "ON", "ONLY", "OPEN", "OPERATE", "OPTIMIZE", "OPTIMIZER",
		"OPTION", "OR", "ORDER", "OUTER", "OUTFILE", "OVER", "PARAMETER", "PARTITION",
		"PARTITIONS", "PASSWORD", "PATH", "PAUSE", "PENDING", "PERCENT_RANK",
		"PERCENTILE", "PERCENTILE_UNION", "PLAN", "PLUGIN", "PLUGINS", "PIPE",
		"PIPES", "PIVOT", "POLICY", "POLICIES", "PRECEDING", "PREDICATE", "PREPARE",
		"PRIMARY", "PRIORITY", "PRIVILEGES", "PROBABILITY", "PROC", "PROCEDURE",
		"PROCESSLIST", "PROFILE", "PROFILELIST", "PROPERTIES", "PROPERTY", "PROVIDER",
		"PROVIDERS", "QUALIFY", "QUARTER", "QUERY", "QUERIES", "QUEUE", "QUOTA",
		"RANDOM", "RANGE", "RANK", "READ", "REASON", "RECOVER", "REFRESH", "REWRITE",
		"REGEXP", "RELEASE", "REMOVE", "RENAME", "REPAIR", "REPEATABLE", "REPLACE",
		"REPLACE_IF_NOT_NULL", "REPLICA", "REPOSITORY", "REPOSITORIES", "RESOURCE",
		"RESOURCES", "RESTORE", "RESUME", "RETAIN", "RETENTION", "RETURNS",
		"RETRY", "REVOKE", "REVERT", "RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK",
		"ROLLUP", "ROUTINE", "ROW", "ROWS", "ROW_NUMBER", "RULE", "RULES", "RUNNING",
		"SAMPLE", "SCHEDULE", "SCHEDULER", "SCHEMA", "SCHEMAS", "SECOND", "SECURITY",
		"SELECT", "SEMI", "SEPARATOR", "SERIALIZABLE", "SESSION", "SET", "SETS",
		"SET_VAR", "SIGNED", "SKIP_HEADER", "SHOW", "SMALLINT", "SNAPSHOT",
		"SNAPSHOTS", "SQLBLACKLIST", "STARROCKS", "START", "STATS", "STATUS",
		"STOP", "STORAGE", "STREAM", "STRING", "TEXT", "SUBMIT", "SUM", "SUSPEND",
		"SYNC", "SYSTEM", "SYSTEM_TIME", "SWAP", "STRUCT", "TABLE", "TABLES",
		"TABLET", "TABLETS", "TAG", "TASK", "TEMPORARY", "TERMINATED", "THAN",
		"THEN", "TIME", "TIMES", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF",
		"TINYINT", "TRANSACTION", "TRANSLATE", "TO", "TRACE", "TRIGGERS", "TRIM_SPACE",
		"TRUE", "TRUNCATE", "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNION",
		"UNIQUE", "UNINSTALL", "UNSET", "UNSIGNED", "UPDATE", "USAGE", "USE",
		"USER", "USERS", "USING", "VALUE", "VALUES", "VARBINARY", "VARCHAR",
		"VARIABLES", "VECTOR", "VERBOSE", "VERSION", "VIEW", "VIEWS", "VOLUME",
		"VOLUMES", "WAREHOUSE", "WAREHOUSES", "WARNINGS", "WEEK", "WHEN", "WHERE",
		"WHITELIST", "WITH", "WORK", "WRITE", "YEAR", "LOCK", "UNLOCK", "LOW_PRIORITY",
		"DISK", "BEFORE", "DOUBLE_DOLLAR", "FIELD", "PERSISTENT", "EQ", "NEQ",
		"LT", "LTE", "GT", "GTE", "EQ_FOR_NULL", "ARRAY_ELEMENT", "PLUS_SYMBOL",
		"MINUS_SYMBOL", "ASTERISK_SYMBOL", "SLASH_SYMBOL", "PERCENT_SYMBOL",
		"LOGICAL_OR", "LOGICAL_AND", "LOGICAL_NOT", "INT_DIV", "BITAND", "BITOR",
		"BITXOR", "BITNOT", "BIT_SHIFT_LEFT", "BIT_SHIFT_RIGHT", "BIT_SHIFT_RIGHT_LOGICAL",
		"ARROW", "AT", "INTEGER_VALUE", "DECIMAL_VALUE", "DOUBLE_VALUE", "SINGLE_QUOTED_TEXT",
		"DOUBLE_QUOTED_TEXT", "BINARY_SINGLE_QUOTED_TEXT", "BINARY_DOUBLE_QUOTED_TEXT",
		"LETTER_IDENTIFIER", "DIGIT_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "DOT_IDENTIFIER",
		"SIMPLE_COMMENT", "BRACKETED_COMMENT", "OPTIMIZER_HINT", "SEMICOLON",
		"DOTDOTDOT", "WS", "ATTACHMENT", "CONCAT",
	}
	staticData.RuleNames = []string{
		"sqlStatements", "singleStatement", "emptyStatement", "statement", "useDatabaseStatement",
		"useCatalogStatement", "setCatalogStatement", "showDatabasesStatement",
		"alterDbQuotaStatement", "createDbStatement", "dropDbStatement", "showCreateDbStatement",
		"alterDatabaseRenameStatement", "recoverDbStmt", "showDataStmt", "showDataDistributionStmt",
		"createTableStatement", "columnDesc", "charsetName", "defaultDesc",
		"generatedColumnDesc", "indexDesc", "engineDesc", "charsetDesc", "collateDesc",
		"keyDesc", "orderByDesc", "columnNullable", "typeWithNullable", "aggStateDesc",
		"aggDesc", "rollupDesc", "rollupItem", "dupKeys", "fromRollup", "orReplace",
		"ifNotExists", "createTableAsSelectStatement", "dropTableStatement",
		"cleanTemporaryTableStatement", "alterTableStatement", "createIndexStatement",
		"dropIndexStatement", "indexType", "showTableStatement", "showTemporaryTablesStatement",
		"showCreateTableStatement", "showColumnStatement", "showTableStatusStatement",
		"refreshTableStatement", "showAlterStatement", "descTableStatement",
		"createTableLikeStatement", "showIndexStatement", "recoverTableStatement",
		"truncateTableStatement", "cancelAlterTableStatement", "showPartitionsStatement",
		"recoverPartitionStatement", "createViewStatement", "alterViewStatement",
		"dropViewStatement", "columnNameWithComment", "submitTaskStatement",
		"taskClause", "dropTaskStatement", "taskScheduleDesc", "createMaterializedViewStatement",
		"mvPartitionExprs", "materializedViewDesc", "showMaterializedViewsStatement",
		"dropMaterializedViewStatement", "alterMaterializedViewStatement", "refreshMaterializedViewStatement",
		"cancelRefreshMaterializedViewStatement", "adminSetConfigStatement",
		"adminSetReplicaStatusStatement", "adminShowConfigStatement", "adminShowReplicaDistributionStatement",
		"adminShowReplicaStatusStatement", "adminRepairTableStatement", "adminCancelRepairTableStatement",
		"adminCheckTabletsStatement", "adminSetPartitionVersion", "killStatement",
		"syncStatement", "adminSetAutomatedSnapshotOnStatement", "adminSetAutomatedSnapshotOffStatement",
		"alterSystemStatement", "cancelAlterSystemStatement", "showComputeNodesStatement",
		"createExternalCatalogStatement", "showCreateExternalCatalogStatement",
		"dropExternalCatalogStatement", "showCatalogsStatement", "alterCatalogStatement",
		"createStorageVolumeStatement", "typeDesc", "locationsDesc", "showStorageVolumesStatement",
		"dropStorageVolumeStatement", "alterStorageVolumeStatement", "alterStorageVolumeClause",
		"modifyStorageVolumePropertiesClause", "modifyStorageVolumeCommentClause",
		"descStorageVolumeStatement", "setDefaultStorageVolumeStatement", "updateFailPointStatusStatement",
		"showFailPointStatement", "createDictionaryStatement", "dropDictionaryStatement",
		"refreshDictionaryStatement", "showDictionaryStatement", "cancelRefreshDictionaryStatement",
		"dictionaryColumnDesc", "dictionaryName", "alterClause", "addFrontendClause",
		"dropFrontendClause", "modifyFrontendHostClause", "addBackendClause",
		"dropBackendClause", "decommissionBackendClause", "modifyBackendClause",
		"addComputeNodeClause", "dropComputeNodeClause", "modifyBrokerClause",
		"alterLoadErrorUrlClause", "createImageClause", "cleanTabletSchedQClause",
		"decommissionDiskClause", "cancelDecommissionDiskClause", "disableDiskClause",
		"cancelDisableDiskClause", "createIndexClause", "dropIndexClause", "tableRenameClause",
		"swapTableClause", "modifyPropertiesClause", "modifyCommentClause",
		"optimizeRange", "optimizeClause", "addColumnClause", "addColumnsClause",
		"dropColumnClause", "modifyColumnClause", "columnRenameClause", "reorderColumnsClause",
		"rollupRenameClause", "compactionClause", "subfieldName", "nestedFieldName",
		"addFieldClause", "dropFieldClause", "createOrReplaceTagClause", "createOrReplaceBranchClause",
		"dropBranchClause", "dropTagClause", "tableOperationClause", "tagOptions",
		"branchOptions", "snapshotRetention", "refRetain", "maxSnapshotAge",
		"minSnapshotsToKeep", "snapshotId", "timeUnit", "integer_list", "dropPersistentIndexClause",
		"addPartitionClause", "dropPartitionClause", "truncatePartitionClause",
		"modifyPartitionClause", "replacePartitionClause", "partitionRenameClause",
		"insertStatement", "insertLabelOrColumnAliases", "columnAliasesOrByName",
		"updateStatement", "deleteStatement", "createRoutineLoadStatement",
		"alterRoutineLoadStatement", "dataSource", "loadProperties", "colSeparatorProperty",
		"rowDelimiterProperty", "importColumns", "columnProperties", "jobProperties",
		"dataSourceProperties", "stopRoutineLoadStatement", "resumeRoutineLoadStatement",
		"pauseRoutineLoadStatement", "showRoutineLoadStatement", "showRoutineLoadTaskStatement",
		"showCreateRoutineLoadStatement", "showStreamLoadStatement", "analyzeStatement",
		"analyzeColumnClause", "dropStatsStatement", "histogramStatement", "analyzeHistogramStatement",
		"dropHistogramStatement", "createAnalyzeStatement", "dropAnalyzeJobStatement",
		"showAnalyzeStatement", "showStatsMetaStatement", "showHistogramMetaStatement",
		"killAnalyzeStatement", "analyzeProfileStatement", "createBaselinePlanStatement",
		"dropBaselinePlanStatement", "showBaselinePlanStatement", "createResourceGroupStatement",
		"dropResourceGroupStatement", "alterResourceGroupStatement", "showResourceGroupStatement",
		"showResourceGroupUsageStatement", "createResourceStatement", "alterResourceStatement",
		"dropResourceStatement", "showResourceStatement", "classifier", "showFunctionsStatement",
		"dropFunctionStatement", "createFunctionStatement", "inlineFunction",
		"typeList", "loadStatement", "labelName", "dataDescList", "dataDesc",
		"formatProps", "brokerDesc", "resourceDesc", "showLoadStatement", "showLoadWarningsStatement",
		"cancelLoadStatement", "alterLoadStatement", "cancelCompactionStatement",
		"showAuthorStatement", "showBackendsStatement", "showBrokerStatement",
		"showCharsetStatement", "showCollationStatement", "showDeleteStatement",
		"showDynamicPartitionStatement", "showEventsStatement", "showEnginesStatement",
		"showFrontendsStatement", "showPluginsStatement", "showRepositoriesStatement",
		"showOpenTableStatement", "showPrivilegesStatement", "showProcedureStatement",
		"showProcStatement", "showProcesslistStatement", "showProfilelistStatement",
		"showRunningQueriesStatement", "showStatusStatement", "showTabletStatement",
		"showTransactionStatement", "showTriggersStatement", "showUserPropertyStatement",
		"showVariablesStatement", "showWarningStatement", "helpStatement", "createUserStatement",
		"dropUserStatement", "alterUserStatement", "showUserStatement", "showAuthenticationStatement",
		"executeAsStatement", "createRoleStatement", "alterRoleStatement", "dropRoleStatement",
		"showRolesStatement", "grantRoleStatement", "revokeRoleStatement", "setRoleStatement",
		"setDefaultRoleStatement", "grantRevokeClause", "grantPrivilegeStatement",
		"revokePrivilegeStatement", "showGrantsStatement", "authOption", "privObjectName",
		"privObjectNameList", "privFunctionObjectNameList", "privilegeTypeList",
		"privilegeType", "privObjectType", "privObjectTypePlural", "createSecurityIntegrationStatement",
		"alterSecurityIntegrationStatement", "dropSecurityIntegrationStatement",
		"showSecurityIntegrationStatement", "showCreateSecurityIntegrationStatement",
		"createGroupProviderStatement", "dropGroupProviderStatement", "showGroupProvidersStatement",
		"showCreateGroupProviderStatement", "backupStatement", "cancelBackupStatement",
		"showBackupStatement", "restoreStatement", "cancelRestoreStatement",
		"showRestoreStatement", "showSnapshotStatement", "createRepositoryStatement",
		"dropRepositoryStatement", "addSqlBlackListStatement", "delSqlBlackListStatement",
		"showSqlBlackListStatement", "showWhiteListStatement", "addBackendBlackListStatement",
		"delBackendBlackListStatement", "showBackendBlackListStatement", "dataCacheTarget",
		"createDataCacheRuleStatement", "showDataCacheRulesStatement", "dropDataCacheRuleStatement",
		"clearDataCacheRulesStatement", "dataCacheSelectStatement", "exportStatement",
		"cancelExportStatement", "showExportStatement", "installPluginStatement",
		"uninstallPluginStatement", "createFileStatement", "dropFileStatement",
		"showSmallFilesStatement", "createPipeStatement", "dropPipeStatement",
		"alterPipeClause", "alterPipeStatement", "descPipeStatement", "showPipeStatement",
		"setStatement", "setVar", "transaction_characteristics", "transaction_access_mode",
		"isolation_level", "isolation_types", "setExprOrDefault", "setUserPropertyStatement",
		"roleList", "executeScriptStatement", "unsupportedStatement", "lock_item",
		"lock_type", "alterPlanAdvisorAddStatement", "truncatePlanAdvisorStatement",
		"alterPlanAdvisorDropStatement", "showPlanAdvisorStatement", "createWarehouseStatement",
		"dropWarehouseStatement", "suspendWarehouseStatement", "resumeWarehouseStatement",
		"setWarehouseStatement", "showWarehousesStatement", "showClustersStatement",
		"showNodesStatement", "alterWarehouseStatement", "createCNGroupStatement",
		"dropCNGroupStatement", "enableCNGroupStatement", "disableCNGroupStatement",
		"alterCNGroupStatement", "beginStatement", "commitStatement", "rollbackStatement",
		"translateStatement", "dialect", "translateSQL", "queryStatement", "queryRelation",
		"withClause", "queryNoWith", "queryPeriod", "periodType", "queryPrimary",
		"subquery", "rowConstructor", "sortItem", "limitConstExpr", "limitElement",
		"querySpecification", "fromClause", "groupingElement", "groupingSet",
		"commonTableExpression", "setQuantifier", "selectItem", "excludeClause",
		"relations", "relation", "relationPrimary", "pivotClause", "pivotAggregationExpression",
		"pivotValue", "sampleClause", "argumentList", "namedArgumentList", "namedArgument",
		"joinRelation", "crossOrInnerJoinType", "outerAndSemiJoinType", "bracketHint",
		"hintMap", "joinCriteria", "columnAliases", "partitionNames", "keyPartitions",
		"tabletList", "prepareStatement", "prepareSql", "executeStatement",
		"deallocateStatement", "replicaList", "expressionsWithDefault", "expressionOrDefault",
		"mapExpressionList", "mapExpression", "expressionSingleton", "expression",
		"expressionList", "booleanExpression", "predicate", "tupleInSubquery",
		"predicateOperations", "valueExpression", "primaryExpression", "literalExpression",
		"functionCall", "aggregationFunction", "userVariable", "systemVariable",
		"columnReference", "informationFunctionExpression", "specialDateTimeExpression",
		"specialFunctionExpression", "windowFunction", "whenClause", "over",
		"ignoreNulls", "windowFrame", "frameBound", "backupRestoreObjectDesc",
		"tableDesc", "backupRestoreTableDesc", "explainDesc", "optimizerTrace",
		"partitionExpr", "partitionDesc", "listPartitionDesc", "singleItemListPartitionDesc",
		"multiItemListPartitionDesc", "multiListPartitionValues", "singleListPartitionValues",
		"listPartitionValues", "listPartitionValue", "stringList", "literalExpressionList",
		"rangePartitionDesc", "singleRangePartition", "multiRangePartition",
		"partitionRangeDesc", "partitionKeyDesc", "partitionValueList", "keyPartition",
		"partitionValue", "distributionClause", "distributionDesc", "refreshSchemeDesc",
		"statusDesc", "properties", "extProperties", "propertyList", "userPropertyList",
		"property", "inlineProperties", "inlineProperty", "varType", "comment",
		"outfile", "fileFormat", "string", "binary", "comparisonOperator", "booleanValue",
		"interval", "taskInterval", "taskUnitIdentifier", "unitIdentifier",
		"unitBoundary", "type", "arrayType", "mapType", "subfieldDesc", "subfieldDescs",
		"structType", "typeParameter", "baseType", "decimalType", "qualifiedName",
		"tableName", "writeBranch", "identifier", "identifierWithAlias", "identifierWithAliasList",
		"identifierList", "identifierOrString", "identifierOrStringList", "identifierOrStringOrStar",
		"user", "assignment", "assignmentList", "number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 537, 8202, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7,
		477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2,
		482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7,
		486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2,
		491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7,
		495, 2, 496, 7, 496, 2, 497, 7, 497, 2, 498, 7, 498, 2, 499, 7, 499, 2,
		500, 7, 500, 2, 501, 7, 501, 2, 502, 7, 502, 2, 503, 7, 503, 2, 504, 7,
		504, 2, 505, 7, 505, 2, 506, 7, 506, 2, 507, 7, 507, 2, 508, 7, 508, 2,
		509, 7, 509, 2, 510, 7, 510, 2, 511, 7, 511, 2, 512, 7, 512, 2, 513, 7,
		513, 2, 514, 7, 514, 2, 515, 7, 515, 2, 516, 7, 516, 2, 517, 7, 517, 2,
		518, 7, 518, 2, 519, 7, 519, 1, 0, 4, 0, 1042, 8, 0, 11, 0, 12, 0, 1043,
		1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1052, 8, 1, 1, 2, 1, 2, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3,
		1296, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1312, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7,
		1318, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1326, 8, 7, 3, 7,
		1328, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1346, 8, 8, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1353, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1358, 8, 9, 1, 9,
		1, 9, 3, 9, 1362, 8, 9, 1, 9, 3, 9, 1365, 8, 9, 1, 9, 3, 9, 1368, 8, 9,
		1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1374, 8, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 1379, 8, 10, 1, 10, 1, 10, 3, 10, 1383, 8, 10, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1406, 8, 14,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1414, 8, 15, 1, 16, 1,
		16, 3, 16, 1418, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1424, 8, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 1431, 8, 16, 10, 16, 12, 16,
		1434, 9, 16, 1, 16, 1, 16, 5, 16, 1438, 8, 16, 10, 16, 12, 16, 1441, 9,
		16, 1, 16, 1, 16, 3, 16, 1445, 8, 16, 1, 16, 3, 16, 1448, 8, 16, 1, 16,
		3, 16, 1451, 8, 16, 1, 16, 3, 16, 1454, 8, 16, 1, 16, 3, 16, 1457, 8, 16,
		1, 16, 3, 16, 1460, 8, 16, 1, 16, 3, 16, 1463, 8, 16, 1, 16, 3, 16, 1466,
		8, 16, 1, 16, 3, 16, 1469, 8, 16, 1, 16, 3, 16, 1472, 8, 16, 1, 17, 1,
		17, 3, 17, 1476, 8, 17, 1, 17, 3, 17, 1479, 8, 17, 1, 17, 3, 17, 1482,
		8, 17, 1, 17, 3, 17, 1485, 8, 17, 1, 17, 3, 17, 1488, 8, 17, 1, 17, 1,
		17, 1, 17, 3, 17, 1493, 8, 17, 1, 17, 3, 17, 1496, 8, 17, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1506, 8, 18, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1518,
		8, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 1528,
		8, 21, 3, 21, 1530, 8, 21, 1, 21, 3, 21, 1533, 8, 21, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 23, 3, 23, 1540, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		3, 23, 1547, 8, 23, 1, 23, 3, 23, 1550, 8, 23, 1, 23, 1, 23, 1, 24, 3,
		24, 1555, 8, 24, 1, 24, 1, 24, 3, 24, 1559, 8, 24, 1, 24, 1, 24, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 3,
		27, 1574, 8, 27, 1, 28, 1, 28, 3, 28, 1578, 8, 28, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 5, 29, 1585, 8, 29, 10, 29, 12, 29, 1588, 9, 29, 1, 29, 1,
		29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30,
		1601, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 1608, 8, 31, 10,
		31, 12, 31, 1611, 9, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 3, 32, 1618,
		8, 32, 1, 32, 3, 32, 1621, 8, 32, 1, 32, 3, 32, 1624, 8, 32, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 1635, 8, 35,
		1, 36, 1, 36, 1, 36, 3, 36, 1640, 8, 36, 1, 37, 1, 37, 3, 37, 1644, 8,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1650, 8, 37, 1, 37, 1, 37, 1, 37,
		1, 37, 1, 37, 5, 37, 1657, 8, 37, 10, 37, 12, 37, 1660, 9, 37, 1, 37, 1,
		37, 5, 37, 1664, 8, 37, 10, 37, 12, 37, 1667, 9, 37, 1, 37, 1, 37, 1, 37,
		5, 37, 1672, 8, 37, 10, 37, 12, 37, 1675, 9, 37, 3, 37, 1677, 8, 37, 1,
		37, 1, 37, 3, 37, 1681, 8, 37, 1, 37, 3, 37, 1684, 8, 37, 1, 37, 3, 37,
		1687, 8, 37, 1, 37, 3, 37, 1690, 8, 37, 1, 37, 3, 37, 1693, 8, 37, 1, 37,
		3, 37, 1696, 8, 37, 1, 37, 3, 37, 1699, 8, 37, 1, 37, 1, 37, 1, 37, 1,
		38, 1, 38, 3, 38, 1706, 8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1711, 8, 38,
		1, 38, 1, 38, 3, 38, 1715, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1730, 8, 40,
		10, 40, 12, 40, 1733, 9, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 5, 40, 1743, 8, 40, 10, 40, 12, 40, 1746, 9, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1756, 8, 40, 10, 40,
		12, 40, 1759, 9, 40, 3, 40, 1761, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 3, 41, 1771, 8, 41, 3, 41, 1773, 8, 41, 1, 41,
		3, 41, 1776, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1,
		43, 1, 43, 1, 44, 1, 44, 3, 44, 1789, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44,
		1794, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1800, 8, 44, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 3, 45, 1807, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 1813, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1821,
		8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 1827, 8, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 3, 47, 1835, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		3, 47, 1841, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1848, 8,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1854, 8, 48, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1865, 8, 49, 10, 49, 12,
		49, 1868, 9, 49, 1, 49, 1, 49, 3, 49, 1872, 8, 49, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 3, 50, 1880, 8, 50, 1, 50, 1, 50, 3, 50, 1884, 8,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1891, 8, 50, 10, 50, 12,
		50, 1894, 9, 50, 3, 50, 1896, 8, 50, 1, 50, 3, 50, 1899, 8, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1907, 8, 50, 1, 50, 1, 50, 3,
		50, 1911, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1918, 8, 50,
		10, 50, 12, 50, 1921, 9, 50, 3, 50, 1923, 8, 50, 1, 50, 3, 50, 1926, 8,
		50, 3, 50, 1928, 8, 50, 1, 51, 1, 51, 1, 51, 3, 51, 1933, 8, 51, 1, 51,
		1, 51, 3, 51, 1937, 8, 51, 1, 52, 1, 52, 3, 52, 1941, 8, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 3, 52, 1947, 8, 52, 1, 52, 1, 52, 3, 52, 1951, 8, 52,
		1, 52, 3, 52, 1954, 8, 52, 1, 52, 3, 52, 1957, 8, 52, 1, 52, 1, 52, 1,
		52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1969, 8, 53,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1979, 8,
		55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1985, 8, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 5, 56, 1993, 8, 56, 10, 56, 12, 56, 1996, 9, 56, 1,
		56, 3, 56, 1999, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56,
		2007, 8, 56, 1, 57, 1, 57, 3, 57, 2011, 8, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 3, 57, 2018, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57,
		2025, 8, 57, 10, 57, 12, 57, 2028, 9, 57, 3, 57, 2030, 8, 57, 1, 57, 3,
		57, 2033, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59,
		1, 59, 3, 59, 2044, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 2050, 8,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2057, 8, 59, 10, 59, 12,
		59, 2060, 9, 59, 1, 59, 1, 59, 3, 59, 2064, 8, 59, 1, 59, 3, 59, 2067,
		8, 59, 1, 59, 1, 59, 3, 59, 2071, 8, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 2083, 8, 60, 10, 60, 12,
		60, 2086, 9, 60, 1, 60, 1, 60, 3, 60, 2090, 8, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 2114,
		8, 60, 1, 60, 1, 60, 3, 60, 2118, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 3,
		61, 2124, 8, 61, 1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 2130, 8, 62, 1, 63,
		1, 63, 1, 63, 3, 63, 2135, 8, 63, 1, 63, 5, 63, 2138, 8, 63, 10, 63, 12,
		63, 2141, 9, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2147, 8, 63, 1, 64,
		1, 64, 3, 64, 2151, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2157, 8,
		65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 2165, 8, 66, 1, 66,
		1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3,
		67, 2178, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 2185, 8, 67,
		10, 67, 12, 67, 2188, 9, 67, 1, 67, 1, 67, 5, 67, 2192, 8, 67, 10, 67,
		12, 67, 2195, 9, 67, 1, 67, 1, 67, 3, 67, 2199, 8, 67, 1, 67, 3, 67, 2202,
		8, 67, 1, 67, 5, 67, 2205, 8, 67, 10, 67, 12, 67, 2208, 9, 67, 1, 67, 1,
		67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68, 2218, 8, 68, 10, 68,
		12, 68, 2221, 9, 68, 1, 68, 1, 68, 3, 68, 2225, 8, 68, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 2234, 8, 69, 1, 70, 1, 70, 1, 70,
		1, 70, 1, 70, 3, 70, 2241, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2247,
		8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 2254, 8, 71, 1, 71, 1,
		71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2266,
		8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 2274, 8, 72, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2283, 8, 73, 3, 73,
		2285, 8, 73, 1, 73, 3, 73, 2288, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2293,
		8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2298, 8, 73, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 3, 74, 2306, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 2317, 8, 75, 1, 76, 1, 76, 1, 76, 1,
		76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 2331,
		8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 2340, 8,
		78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 2349, 8, 79,
		1, 79, 1, 79, 3, 79, 2353, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3,
		80, 2360, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 2368,
		8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1,
		83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 2386, 8, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 3, 84, 2395, 8, 84, 1, 84, 3,
		84, 2398, 8, 84, 1, 84, 1, 84, 3, 84, 2402, 8, 84, 1, 85, 1, 85, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 2415, 8,
		86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88,
		1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 2434, 8, 89, 10,
		89, 12, 89, 2437, 9, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91,
		1, 91, 1, 91, 1, 91, 3, 91, 2449, 8, 91, 1, 91, 1, 91, 3, 91, 2453, 8,
		91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93,
		1, 93, 3, 93, 2466, 8, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 3,
		94, 2474, 8, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96,
		1, 96, 1, 96, 1, 96, 3, 96, 2487, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3,
		96, 2493, 8, 96, 1, 96, 3, 96, 2496, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97,
		1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 2511,
		8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 2518, 8, 100, 1,
		100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 5,
		101, 2529, 8, 101, 10, 101, 12, 101, 2532, 9, 101, 1, 102, 1, 102, 3, 102,
		2536, 8, 102, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 1, 107, 3, 107, 2566, 8, 107, 3, 107, 2568, 8, 107, 1, 107,
		1, 107, 1, 107, 1, 107, 3, 107, 2574, 8, 107, 3, 107, 2576, 8, 107, 1,
		108, 1, 108, 1, 108, 1, 108, 3, 108, 2582, 8, 108, 1, 108, 1, 108, 1, 108,
		3, 108, 2587, 8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 109, 1, 109, 5, 109, 2598, 8, 109, 10, 109, 12, 109, 2601, 9, 109,
		1, 109, 1, 109, 3, 109, 2605, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 3,
		110, 2611, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112,
		3, 112, 2620, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1,
		114, 1, 114, 1, 114, 1, 114, 1, 114, 3, 114, 2633, 8, 114, 1, 115, 1, 115,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 1, 116, 3, 116, 2684, 8, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1,
		118, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
		119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 2706, 8, 120,
		10, 120, 12, 120, 2709, 9, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120,
		3, 120, 2716, 8, 120, 3, 120, 2718, 8, 120, 1, 121, 1, 121, 1, 121, 1,
		121, 1, 121, 5, 121, 2725, 8, 121, 10, 121, 12, 121, 2728, 9, 121, 1, 121,
		1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 2735, 8, 121, 3, 121, 2737, 8,
		121, 1, 121, 3, 121, 2740, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122,
		5, 122, 2747, 8, 122, 10, 122, 12, 122, 2750, 9, 122, 1, 123, 1, 123, 1,
		123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1,
		123, 1, 123, 3, 123, 2765, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124,
		1, 124, 5, 124, 2773, 8, 124, 10, 124, 12, 124, 2776, 9, 124, 1, 124, 1,
		124, 1, 124, 1, 124, 1, 124, 3, 124, 2783, 8, 124, 3, 124, 2785, 8, 124,
		1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 5, 125, 2793, 8, 125, 10,
		125, 12, 125, 2796, 9, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 3,
		125, 2803, 8, 125, 3, 125, 2805, 8, 125, 1, 126, 1, 126, 1, 126, 1, 126,
		1, 126, 1, 126, 5, 126, 2813, 8, 126, 10, 126, 12, 126, 2816, 9, 126, 1,
		126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 5, 126, 2824, 8, 126, 10,
		126, 12, 126, 2827, 9, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 2833,
		8, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 2840, 8, 127, 1,
		128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1,
		130, 1, 130, 1, 130, 1, 130, 5, 130, 2855, 8, 130, 10, 130, 12, 130, 2858,
		9, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 5, 131, 2870, 8, 131, 10, 131, 12, 131, 2873, 9, 131, 1,
		131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 5,
		132, 2884, 8, 132, 10, 132, 12, 132, 2887, 9, 132, 1, 132, 1, 132, 1, 132,
		1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 2899, 8,
		133, 10, 133, 12, 133, 2902, 9, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 2914, 8, 134, 3, 134,
		2916, 8, 134, 1, 134, 3, 134, 2919, 8, 134, 1, 135, 1, 135, 1, 135, 1,
		135, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1,
		138, 1, 138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 140, 1, 141, 3, 141, 2945, 8, 141, 1, 141, 3, 141, 2948, 8, 141,
		1, 141, 3, 141, 2951, 8, 141, 1, 141, 3, 141, 2954, 8, 141, 1, 141, 3,
		141, 2957, 8, 141, 1, 141, 3, 141, 2960, 8, 141, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 3, 142, 2968, 8, 142, 1, 142, 1, 142, 3, 142, 2972,
		8, 142, 1, 142, 3, 142, 2975, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1,
		143, 1, 143, 5, 143, 2983, 8, 143, 10, 143, 12, 143, 2986, 9, 143, 1, 143,
		1, 143, 1, 143, 3, 143, 2991, 8, 143, 1, 143, 3, 143, 2994, 8, 143, 1,
		144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 3001, 8, 144, 1, 144, 3, 144,
		3004, 8, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 3012,
		8, 145, 1, 145, 1, 145, 3, 145, 3016, 8, 145, 1, 145, 3, 145, 3019, 8,
		145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1,
		147, 1, 147, 1, 147, 3, 147, 3032, 8, 147, 1, 147, 3, 147, 3035, 8, 147,
		1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 149, 3, 149, 3043, 8, 149, 1,
		149, 1, 149, 1, 149, 3, 149, 3048, 8, 149, 1, 150, 1, 150, 3, 150, 3052,
		8, 150, 1, 151, 1, 151, 1, 151, 1, 151, 5, 151, 3058, 8, 151, 10, 151,
		12, 151, 3061, 9, 151, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152,
		1, 152, 1, 152, 1, 152, 3, 152, 3072, 8, 152, 1, 152, 3, 152, 3075, 8,
		152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 3084,
		8, 153, 1, 154, 1, 154, 3, 154, 3088, 8, 154, 1, 154, 1, 154, 1, 154, 1,
		154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 3100, 8, 154,
		1, 154, 1, 154, 1, 154, 3, 154, 3105, 8, 154, 1, 155, 1, 155, 3, 155, 3109,
		8, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155,
		1, 155, 1, 155, 3, 155, 3121, 8, 155, 1, 155, 1, 155, 1, 155, 3, 155, 3126,
		8, 155, 1, 156, 1, 156, 1, 156, 1, 156, 3, 156, 3132, 8, 156, 1, 156, 1,
		156, 1, 157, 1, 157, 1, 157, 1, 157, 3, 157, 3140, 8, 157, 1, 157, 1, 157,
		1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 159, 3, 159, 3151, 8,
		159, 1, 159, 3, 159, 3154, 8, 159, 1, 160, 1, 160, 1, 160, 1, 160, 3, 160,
		3160, 8, 160, 1, 160, 3, 160, 3163, 8, 160, 1, 160, 3, 160, 3166, 8, 160,
		1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161,
		1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 3, 161, 3182, 8, 161, 1, 162, 1,
		162, 1, 162, 1, 162, 1, 163, 1, 163, 1, 163, 1, 164, 1, 164, 1, 164, 1,
		165, 1, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1, 167, 1, 167, 5, 167, 3202,
		8, 167, 10, 167, 12, 167, 3205, 9, 167, 1, 167, 1, 167, 1, 168, 1, 168,
		1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 169, 1, 169, 3, 169, 3218, 8,
		169, 1, 169, 1, 169, 1, 169, 3, 169, 3223, 8, 169, 1, 169, 3, 169, 3226,
		8, 169, 1, 169, 3, 169, 3229, 8, 169, 1, 169, 1, 169, 3, 169, 3233, 8,
		169, 1, 169, 1, 169, 3, 169, 3237, 8, 169, 1, 169, 3, 169, 3240, 8, 169,
		1, 169, 3, 169, 3243, 8, 169, 3, 169, 3245, 8, 169, 1, 170, 1, 170, 3,
		170, 3249, 8, 170, 1, 170, 1, 170, 1, 170, 3, 170, 3254, 8, 170, 1, 170,
		1, 170, 1, 170, 1, 170, 3, 170, 3260, 8, 170, 1, 170, 3, 170, 3263, 8,
		170, 1, 170, 3, 170, 3266, 8, 170, 1, 170, 1, 170, 3, 170, 3270, 8, 170,
		1, 170, 1, 170, 1, 170, 3, 170, 3275, 8, 170, 1, 170, 1, 170, 3, 170, 3279,
		8, 170, 1, 170, 1, 170, 3, 170, 3283, 8, 170, 1, 170, 1, 170, 1, 170, 3,
		170, 3288, 8, 170, 1, 170, 1, 170, 1, 170, 3, 170, 3293, 8, 170, 1, 170,
		1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 3300, 8, 170, 3, 170, 3302, 8,
		170, 1, 171, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1,
		172, 1, 172, 3, 172, 3314, 8, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172,
		3, 172, 3321, 8, 172, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 3328,
		8, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 175, 3, 175, 3336, 8,
		175, 1, 175, 1, 175, 1, 175, 1, 175, 3, 175, 3342, 8, 175, 1, 175, 3, 175,
		3345, 8, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 3, 175, 3352, 8,
		175, 1, 175, 5, 175, 3355, 8, 175, 10, 175, 12, 175, 3358, 9, 175, 1, 175,
		3, 175, 3361, 8, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 5, 175, 3368,
		8, 175, 10, 175, 12, 175, 3371, 9, 175, 3, 175, 3373, 8, 175, 1, 176, 1,
		176, 1, 176, 1, 176, 3, 176, 3379, 8, 176, 1, 177, 1, 177, 1, 177, 3, 177,
		3384, 8, 177, 1, 178, 3, 178, 3387, 8, 178, 1, 178, 3, 178, 3390, 8, 178,
		1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 3399, 8,
		178, 1, 179, 3, 179, 3402, 8, 179, 1, 179, 3, 179, 3405, 8, 179, 1, 179,
		1, 179, 1, 179, 1, 179, 3, 179, 3411, 8, 179, 1, 179, 1, 179, 3, 179, 3415,
		8, 179, 1, 179, 1, 179, 3, 179, 3419, 8, 179, 1, 180, 1, 180, 1, 180, 1,
		180, 1, 180, 1, 180, 3, 180, 3427, 8, 180, 1, 180, 1, 180, 1, 180, 1, 180,
		1, 180, 1, 180, 5, 180, 3435, 8, 180, 10, 180, 12, 180, 3438, 9, 180, 3,
		180, 3440, 8, 180, 1, 180, 3, 180, 3443, 8, 180, 1, 180, 1, 180, 1, 180,
		3, 180, 3448, 8, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181, 1,
		181, 3, 181, 3457, 8, 181, 1, 181, 1, 181, 1, 181, 1, 181, 5, 181, 3463,
		8, 181, 10, 181, 12, 181, 3466, 9, 181, 3, 181, 3468, 8, 181, 1, 181, 3,
		181, 3471, 8, 181, 1, 181, 3, 181, 3474, 8, 181, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 3, 183, 3486, 8,
		183, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 185, 1,
		185, 1, 185, 1, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 3, 187, 3504,
		8, 187, 1, 187, 1, 187, 1, 187, 3, 187, 3509, 8, 187, 5, 187, 3511, 8,
		187, 10, 187, 12, 187, 3514, 9, 187, 1, 187, 1, 187, 1, 188, 1, 188, 1,
		189, 1, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 3,
		190, 3529, 8, 190, 1, 190, 1, 190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191,
		1, 191, 1, 191, 3, 191, 3540, 8, 191, 1, 191, 1, 191, 1, 192, 1, 192, 1,
		192, 1, 192, 1, 192, 1, 192, 1, 192, 3, 192, 3551, 8, 192, 1, 192, 1, 192,
		1, 193, 1, 193, 3, 193, 3557, 8, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1,
		193, 1, 193, 3, 193, 3565, 8, 193, 1, 193, 3, 193, 3568, 8, 193, 1, 193,
		1, 193, 3, 193, 3572, 8, 193, 1, 193, 1, 193, 3, 193, 3576, 8, 193, 1,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 5, 193, 3583, 8, 193, 10, 193, 12,
		193, 3586, 9, 193, 3, 193, 3588, 8, 193, 1, 193, 3, 193, 3591, 8, 193,
		1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 3599, 8, 194, 1,
		194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1,
		195, 3, 195, 3611, 8, 195, 1, 195, 1, 195, 1, 196, 1, 196, 3, 196, 3617,
		8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 3625, 8,
		196, 1, 196, 3, 196, 3628, 8, 196, 1, 196, 1, 196, 3, 196, 3632, 8, 196,
		1, 196, 1, 196, 3, 196, 3636, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1,
		196, 5, 196, 3643, 8, 196, 10, 196, 12, 196, 3646, 9, 196, 3, 196, 3648,
		8, 196, 1, 196, 3, 196, 3651, 8, 196, 1, 197, 1, 197, 3, 197, 3655, 8,
		197, 1, 197, 1, 197, 1, 197, 3, 197, 3660, 8, 197, 1, 197, 3, 197, 3663,
		8, 197, 1, 197, 1, 197, 1, 197, 3, 197, 3668, 8, 197, 1, 197, 3, 197, 3671,
		8, 197, 1, 198, 1, 198, 1, 198, 1, 198, 5, 198, 3677, 8, 198, 10, 198,
		12, 198, 3680, 9, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 5, 198,
		3687, 8, 198, 10, 198, 12, 198, 3690, 9, 198, 1, 198, 1, 198, 1, 198, 1,
		198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 5, 198, 3702, 8, 198,
		10, 198, 12, 198, 3705, 9, 198, 1, 198, 1, 198, 3, 198, 3709, 8, 198, 1,
		199, 1, 199, 1, 199, 3, 199, 3714, 8, 199, 1, 199, 1, 199, 1, 199, 1, 200,
		1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200,
		3, 200, 3729, 8, 200, 1, 200, 3, 200, 3732, 8, 200, 1, 201, 1, 201, 1,
		201, 1, 201, 3, 201, 3738, 8, 201, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202,
		1, 202, 1, 202, 1, 202, 1, 202, 5, 202, 3749, 8, 202, 10, 202, 12, 202,
		3752, 9, 202, 1, 203, 1, 203, 1, 203, 3, 203, 3757, 8, 203, 1, 203, 1,
		203, 3, 203, 3761, 8, 203, 1, 203, 1, 203, 1, 203, 3, 203, 3766, 8, 203,
		1, 203, 1, 203, 1, 203, 3, 203, 3771, 8, 203, 1, 203, 1, 203, 1, 203, 3,
		203, 3776, 8, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 5, 203,
		3784, 8, 203, 10, 203, 12, 203, 3787, 9, 203, 1, 203, 1, 203, 3, 203, 3791,
		8, 203, 1, 203, 3, 203, 3794, 8, 203, 1, 203, 1, 203, 3, 203, 3798, 8,
		203, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3807,
		8, 204, 1, 205, 1, 205, 1, 205, 3, 205, 3812, 8, 205, 1, 205, 1, 205, 3,
		205, 3816, 8, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 5, 205, 3823,
		8, 205, 10, 205, 12, 205, 3826, 9, 205, 3, 205, 3828, 8, 205, 1, 205, 3,
		205, 3831, 8, 205, 1, 206, 1, 206, 1, 206, 3, 206, 3836, 8, 206, 1, 206,
		1, 206, 1, 206, 1, 206, 3, 206, 3842, 8, 206, 1, 206, 1, 206, 1, 206, 1,
		206, 1, 206, 5, 206, 3849, 8, 206, 10, 206, 12, 206, 3852, 9, 206, 3, 206,
		3854, 8, 206, 1, 206, 3, 206, 3857, 8, 206, 1, 207, 1, 207, 1, 207, 1,
		207, 1, 207, 3, 207, 3864, 8, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207,
		5, 207, 3871, 8, 207, 10, 207, 12, 207, 3874, 9, 207, 3, 207, 3876, 8,
		207, 1, 207, 3, 207, 3879, 8, 207, 1, 208, 1, 208, 1, 208, 1, 208, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
		1, 209, 1, 209, 5, 209, 3897, 8, 209, 10, 209, 12, 209, 3900, 9, 209, 3,
		209, 3902, 8, 209, 1, 210, 1, 210, 3, 210, 3906, 8, 210, 1, 210, 1, 210,
		1, 210, 3, 210, 3911, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3916, 8,
		210, 1, 211, 1, 211, 1, 211, 1, 211, 1, 212, 1, 212, 1, 212, 1, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 1, 213, 3, 213, 3931, 8, 213, 1, 213, 1, 213,
		3, 213, 3935, 8, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 5, 213, 3942,
		8, 213, 10, 213, 12, 213, 3945, 9, 213, 3, 213, 3947, 8, 213, 1, 213, 1,
		213, 1, 213, 1, 213, 1, 213, 5, 213, 3954, 8, 213, 10, 213, 12, 213, 3957,
		9, 213, 1, 213, 1, 213, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 215,
		1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 5, 215, 3974, 8,
		215, 10, 215, 12, 215, 3977, 9, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1,
		215, 1, 215, 1, 215, 1, 215, 1, 215, 5, 215, 3988, 8, 215, 10, 215, 12,
		215, 3991, 9, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215,
		1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215,
		1, 215, 1, 215, 5, 215, 4011, 8, 215, 10, 215, 12, 215, 4014, 9, 215, 1,
		215, 1, 215, 3, 215, 4018, 8, 215, 1, 216, 1, 216, 3, 216, 4022, 8, 216,
		1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 3, 216, 4029, 8, 216, 1, 216, 1,
		216, 1, 216, 3, 216, 4034, 8, 216, 3, 216, 4036, 8, 216, 1, 217, 1, 217,
		1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4047, 8,
		217, 1, 218, 1, 218, 3, 218, 4051, 8, 218, 1, 218, 1, 218, 1, 218, 3, 218,
		4056, 8, 218, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 220, 1,
		220, 1, 220, 1, 220, 1, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1,
		222, 1, 223, 1, 223, 3, 223, 4077, 8, 223, 1, 223, 3, 223, 4080, 8, 223,
		1, 223, 1, 223, 1, 223, 3, 223, 4085, 8, 223, 1, 223, 1, 223, 1, 223, 1,
		223, 3, 223, 4091, 8, 223, 1, 224, 1, 224, 3, 224, 4095, 8, 224, 1, 224,
		1, 224, 1, 224, 3, 224, 4100, 8, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1,
		224, 1, 225, 1, 225, 1, 225, 3, 225, 4110, 8, 225, 1, 225, 3, 225, 4113,
		8, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225,
		1, 225, 1, 225, 3, 225, 4125, 8, 225, 1, 225, 3, 225, 4128, 8, 225, 1,
		226, 1, 226, 1, 226, 1, 227, 3, 227, 4134, 8, 227, 1, 227, 1, 227, 5, 227,
		4138, 8, 227, 10, 227, 12, 227, 4141, 9, 227, 1, 227, 1, 227, 3, 227, 4145,
		8, 227, 1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 4151, 8, 228, 1, 228, 3,
		228, 4154, 8, 228, 1, 228, 1, 228, 3, 228, 4158, 8, 228, 1, 228, 1, 228,
		3, 228, 4162, 8, 228, 1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 4168, 8,
		228, 1, 228, 1, 228, 1, 228, 3, 228, 4173, 8, 228, 3, 228, 4175, 8, 228,
		1, 229, 1, 229, 1, 229, 3, 229, 4180, 8, 229, 1, 229, 1, 229, 1, 230, 1,
		230, 1, 230, 1, 230, 5, 230, 4188, 8, 230, 10, 230, 12, 230, 4191, 9, 230,
		1, 230, 1, 230, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 4199, 8, 231, 1,
		231, 1, 231, 1, 231, 1, 231, 3, 231, 4205, 8, 231, 1, 231, 1, 231, 1, 231,
		1, 231, 3, 231, 4211, 8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 4217,
		8, 231, 1, 231, 3, 231, 4220, 8, 231, 1, 231, 3, 231, 4223, 8, 231, 1,
		231, 3, 231, 4226, 8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231,
		4233, 8, 231, 1, 231, 1, 231, 3, 231, 4237, 8, 231, 1, 231, 1, 231, 3,
		231, 4241, 8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 4248,
		8, 231, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 4254, 8, 231, 1, 231, 1,
		231, 3, 231, 4258, 8, 231, 1, 231, 1, 231, 3, 231, 4262, 8, 231, 3, 231,
		4264, 8, 231, 1, 232, 1, 232, 1, 232, 1, 232, 3, 232, 4270, 8, 232, 1,
		232, 1, 232, 1, 232, 3, 232, 4275, 8, 232, 1, 232, 1, 232, 1, 232, 3, 232,
		4280, 8, 232, 1, 232, 1, 232, 1, 232, 3, 232, 4285, 8, 232, 1, 232, 1,
		232, 1, 233, 1, 233, 1, 233, 3, 233, 4292, 8, 233, 1, 233, 1, 233, 1, 233,
		1, 233, 3, 233, 4298, 8, 233, 3, 233, 4300, 8, 233, 1, 234, 1, 234, 1,
		234, 1, 234, 3, 234, 4306, 8, 234, 1, 235, 1, 235, 1, 235, 3, 235, 4311,
		8, 235, 1, 235, 1, 235, 3, 235, 4315, 8, 235, 1, 235, 1, 235, 3, 235, 4319,
		8, 235, 1, 235, 1, 235, 1, 235, 1, 235, 1, 235, 5, 235, 4326, 8, 235, 10,
		235, 12, 235, 4329, 9, 235, 3, 235, 4331, 8, 235, 1, 235, 3, 235, 4334,
		8, 235, 1, 236, 1, 236, 1, 236, 1, 236, 1, 236, 3, 236, 4341, 8, 236, 1,
		236, 1, 236, 3, 236, 4345, 8, 236, 1, 236, 3, 236, 4348, 8, 236, 1, 236,
		1, 236, 1, 236, 1, 236, 1, 236, 3, 236, 4355, 8, 236, 1, 237, 1, 237, 1,
		237, 1, 237, 3, 237, 4361, 8, 237, 1, 237, 1, 237, 3, 237, 4365, 8, 237,
		1, 238, 1, 238, 1, 238, 1, 238, 1, 238, 1, 238, 3, 238, 4373, 8, 238, 1,
		238, 1, 238, 3, 238, 4377, 8, 238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 239,
		1, 240, 1, 240, 1, 240, 1, 241, 1, 241, 1, 241, 1, 242, 1, 242, 1, 242,
		1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 3, 243, 4399, 8, 243, 1,
		243, 1, 243, 1, 243, 1, 243, 3, 243, 4405, 8, 243, 1, 244, 1, 244, 1, 244,
		1, 244, 1, 244, 1, 244, 3, 244, 4413, 8, 244, 1, 245, 1, 245, 1, 245, 1,
		245, 3, 245, 4419, 8, 245, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246,
		3, 246, 4427, 8, 246, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 4433, 8,
		247, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 4439, 8, 247, 1, 248, 1, 248,
		1, 248, 1, 249, 1, 249, 1, 249, 1, 250, 1, 250, 1, 250, 1, 251, 1, 251,
		1, 251, 1, 252, 1, 252, 1, 252, 1, 252, 1, 253, 1, 253, 1, 253, 1, 254,
		1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 1, 254, 3, 254, 4467, 8, 254, 1,
		255, 1, 255, 1, 255, 1, 255, 1, 256, 1, 256, 3, 256, 4475, 8, 256, 1, 256,
		1, 256, 1, 256, 3, 256, 4480, 8, 256, 1, 257, 1, 257, 1, 257, 1, 257, 3,
		257, 4486, 8, 257, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 3, 258, 4493,
		8, 258, 1, 259, 1, 259, 3, 259, 4497, 8, 259, 1, 259, 1, 259, 1, 259, 1,
		259, 1, 259, 3, 259, 4504, 8, 259, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260,
		1, 260, 1, 260, 1, 260, 3, 260, 4514, 8, 260, 1, 260, 1, 260, 3, 260, 4518,
		8, 260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 5, 260, 4525, 8, 260, 10,
		260, 12, 260, 4528, 9, 260, 3, 260, 4530, 8, 260, 1, 260, 3, 260, 4533,
		8, 260, 3, 260, 4535, 8, 260, 1, 261, 1, 261, 1, 261, 1, 261, 3, 261, 4541,
		8, 261, 1, 261, 1, 261, 3, 261, 4545, 8, 261, 1, 262, 1, 262, 3, 262, 4549,
		8, 262, 1, 262, 1, 262, 1, 262, 3, 262, 4554, 8, 262, 1, 262, 1, 262, 1,
		262, 1, 262, 3, 262, 4560, 8, 262, 1, 263, 1, 263, 1, 263, 1, 263, 3, 263,
		4566, 8, 263, 1, 263, 1, 263, 3, 263, 4570, 8, 263, 1, 263, 1, 263, 1,
		263, 1, 263, 3, 263, 4576, 8, 263, 1, 263, 1, 263, 3, 263, 4580, 8, 263,
		3, 263, 4582, 8, 263, 1, 264, 1, 264, 3, 264, 4586, 8, 264, 1, 264, 1,
		264, 1, 264, 1, 264, 1, 264, 3, 264, 4593, 8, 264, 1, 265, 1, 265, 1, 265,
		3, 265, 4598, 8, 265, 1, 266, 1, 266, 1, 266, 1, 267, 1, 267, 1, 267, 1,
		267, 1, 267, 3, 267, 4608, 8, 267, 1, 267, 1, 267, 3, 267, 4612, 8, 267,
		1, 267, 1, 267, 1, 267, 3, 267, 4617, 8, 267, 1, 267, 3, 267, 4620, 8,
		267, 1, 268, 1, 268, 1, 268, 1, 268, 3, 268, 4626, 8, 268, 1, 268, 1, 268,
		1, 269, 1, 269, 1, 269, 1, 269, 3, 269, 4634, 8, 269, 1, 269, 1, 269, 1,
		269, 1, 269, 1, 269, 1, 269, 1, 269, 3, 269, 4643, 8, 269, 1, 269, 1, 269,
		1, 269, 1, 269, 1, 269, 1, 269, 3, 269, 4651, 8, 269, 1, 269, 1, 269, 1,
		269, 1, 269, 3, 269, 4657, 8, 269, 1, 269, 1, 269, 1, 269, 1, 269, 3, 269,
		4663, 8, 269, 1, 270, 1, 270, 1, 270, 1, 271, 1, 271, 1, 271, 1, 271, 1,
		271, 1, 271, 1, 271, 3, 271, 4675, 8, 271, 3, 271, 4677, 8, 271, 1, 272,
		1, 272, 1, 272, 1, 272, 1, 272, 1, 272, 3, 272, 4685, 8, 272, 1, 273, 1,
		273, 1, 273, 1, 273, 1, 273, 3, 273, 4692, 8, 273, 1, 273, 1, 273, 3, 273,
		4696, 8, 273, 1, 274, 1, 274, 1, 274, 1, 274, 3, 274, 4702, 8, 274, 1,
		274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 275, 1, 275, 1, 275, 1,
		275, 3, 275, 4714, 8, 275, 1, 275, 1, 275, 1, 276, 1, 276, 1, 276, 1, 277,
		1, 277, 1, 277, 1, 277, 3, 277, 4725, 8, 277, 1, 277, 1, 277, 1, 277, 1,
		277, 1, 277, 1, 277, 1, 277, 1, 277, 3, 277, 4735, 8, 277, 1, 278, 1, 278,
		1, 278, 1, 278, 3, 278, 4741, 8, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1,
		278, 1, 278, 1, 278, 1, 278, 3, 278, 4751, 8, 278, 1, 279, 1, 279, 1, 279,
		1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279,
		4764, 8, 279, 1, 279, 1, 279, 1, 279, 3, 279, 4769, 8, 279, 1, 280, 1,
		280, 1, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4777, 8, 280, 1, 280, 1, 280,
		1, 280, 1, 281, 3, 281, 4783, 8, 281, 1, 281, 1, 281, 1, 281, 3, 281, 4788,
		8, 281, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 5, 282,
		4797, 8, 282, 10, 282, 12, 282, 4800, 9, 282, 1, 282, 1, 282, 1, 282, 1,
		282, 1, 282, 3, 282, 4807, 8, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282,
		1, 282, 1, 282, 1, 282, 1, 282, 3, 282, 4818, 8, 282, 1, 282, 1, 282, 1,
		282, 1, 282, 3, 282, 4824, 8, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282,
		1, 282, 1, 282, 3, 282, 4833, 8, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1,
		282, 1, 282, 1, 282, 1, 282, 1, 282, 3, 282, 4844, 8, 282, 1, 282, 1, 282,
		1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 3, 282,
		4856, 8, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1, 282, 1,
		282, 1, 282, 1, 282, 1, 282, 3, 282, 4869, 8, 282, 1, 282, 1, 282, 1, 282,
		1, 282, 1, 282, 3, 282, 4876, 8, 282, 3, 282, 4878, 8, 282, 1, 283, 1,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 5, 283, 4887, 8, 283, 10,
		283, 12, 283, 4890, 9, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3,
		283, 4906, 8, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4939, 8, 283, 1,
		283, 1, 283, 1, 283, 3, 283, 4944, 8, 283, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 3, 284, 4952, 8, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1,
		284, 1, 284, 3, 284, 4960, 8, 284, 1, 285, 1, 285, 1, 285, 3, 285, 4965,
		8, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 4973, 8,
		285, 3, 285, 4975, 8, 285, 1, 286, 1, 286, 1, 286, 3, 286, 4980, 8, 286,
		1, 287, 1, 287, 1, 287, 5, 287, 4985, 8, 287, 10, 287, 12, 287, 4988, 9,
		287, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1,
		288, 1, 288, 5, 288, 5000, 8, 288, 10, 288, 12, 288, 5003, 9, 288, 1, 289,
		1, 289, 1, 289, 5, 289, 5008, 8, 289, 10, 289, 12, 289, 5011, 9, 289, 1,
		290, 1, 290, 3, 290, 5015, 8, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290,
		1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290,
		1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 3, 290,
		5039, 8, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1,
		290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 3, 290, 5056,
		8, 290, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291,
		1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 3, 291, 5072, 8, 291, 1,
		292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1,
		292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 3,
		292, 5092, 8, 292, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 294,
		1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 295, 1, 295, 1, 295,
		1, 295, 1, 295, 1, 296, 1, 296, 1, 296, 1, 296, 1, 297, 1, 297, 1, 297,
		1, 297, 1, 297, 1, 297, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298, 1, 298,
		1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 300, 1, 300, 1, 300, 1, 300,
		1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 302, 1, 302, 1, 302,
		1, 302, 1, 302, 1, 302, 1, 302, 3, 302, 5150, 8, 302, 1, 302, 1, 302, 3,
		302, 5154, 8, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 302,
		1, 302, 1, 302, 5, 302, 5165, 8, 302, 10, 302, 12, 302, 5168, 9, 302, 1,
		302, 1, 302, 3, 302, 5172, 8, 302, 1, 302, 1, 302, 3, 302, 5176, 8, 302,
		1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 3, 303, 5185, 8,
		303, 1, 304, 1, 304, 1, 304, 1, 304, 3, 304, 5191, 8, 304, 1, 305, 1, 305,
		1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305,
		3, 305, 5204, 8, 305, 1, 305, 1, 305, 1, 305, 1, 305, 3, 305, 5210, 8,
		305, 3, 305, 5212, 8, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 5, 305,
		5219, 8, 305, 10, 305, 12, 305, 5222, 9, 305, 1, 305, 1, 305, 3, 305, 5226,
		8, 305, 1, 305, 1, 305, 3, 305, 5230, 8, 305, 1, 306, 1, 306, 1, 306, 1,
		306, 1, 306, 1, 306, 1, 306, 3, 306, 5239, 8, 306, 1, 307, 1, 307, 1, 307,
		1, 307, 3, 307, 5245, 8, 307, 1, 307, 1, 307, 3, 307, 5249, 8, 307, 1,
		308, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 3, 308, 5257, 8, 308, 1, 309,
		1, 309, 1, 309, 3, 309, 5262, 8, 309, 1, 309, 1, 309, 1, 309, 1, 309, 1,
		309, 3, 309, 5269, 8, 309, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309, 3, 309,
		5276, 8, 309, 1, 310, 1, 310, 1, 310, 1, 310, 1, 311, 1, 311, 1, 311, 1,
		311, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 5, 312, 5291, 8, 312, 10,
		312, 12, 312, 5294, 9, 312, 1, 313, 1, 313, 1, 313, 1, 314, 1, 314, 1,
		314, 1, 315, 1, 315, 1, 315, 1, 315, 1, 315, 1, 315, 5, 315, 5308, 8, 315,
		10, 315, 12, 315, 5311, 9, 315, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316,
		1, 316, 5, 316, 5319, 8, 316, 10, 316, 12, 316, 5322, 9, 316, 1, 317, 1,
		317, 1, 317, 1, 317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1,
		319, 1, 319, 1, 319, 1, 319, 1, 319, 1, 319, 3, 319, 5340, 8, 319, 1, 319,
		1, 319, 1, 319, 3, 319, 5345, 8, 319, 1, 319, 1, 319, 3, 319, 5349, 8,
		319, 1, 320, 1, 320, 1, 320, 1, 320, 1, 321, 1, 321, 1, 321, 1, 321, 1,
		321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 323, 1, 323, 1, 323, 1, 323, 1,
		323, 5, 323, 5369, 8, 323, 10, 323, 12, 323, 5372, 9, 323, 1, 323, 1, 323,
		1, 323, 1, 323, 3, 323, 5378, 8, 323, 1, 323, 3, 323, 5381, 8, 323, 1,
		324, 1, 324, 1, 324, 1, 324, 3, 324, 5387, 8, 324, 1, 324, 1, 324, 1, 324,
		1, 324, 1, 324, 3, 324, 5394, 8, 324, 1, 324, 3, 324, 5397, 8, 324, 1,
		324, 3, 324, 5400, 8, 324, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 5406,
		8, 325, 1, 325, 1, 325, 1, 325, 1, 325, 3, 325, 5412, 8, 325, 1, 326, 1,
		326, 1, 326, 1, 326, 3, 326, 5418, 8, 326, 1, 326, 1, 326, 1, 326, 1, 326,
		3, 326, 5424, 8, 326, 1, 326, 1, 326, 1, 326, 1, 326, 1, 326, 5, 326, 5431,
		8, 326, 10, 326, 12, 326, 5434, 9, 326, 3, 326, 5436, 8, 326, 1, 326, 3,
		326, 5439, 8, 326, 1, 327, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5446,
		8, 327, 1, 328, 1, 328, 1, 328, 1, 328, 1, 329, 1, 329, 1, 329, 1, 329,
		1, 329, 3, 329, 5457, 8, 329, 1, 329, 1, 329, 1, 330, 1, 330, 1, 330, 1,
		330, 1, 330, 3, 330, 5466, 8, 330, 1, 330, 1, 330, 1, 331, 1, 331, 1, 331,
		1, 331, 3, 331, 5474, 8, 331, 1, 332, 1, 332, 1, 332, 1, 332, 1, 332, 1,
		332, 3, 332, 5482, 8, 332, 1, 332, 1, 332, 1, 332, 1, 333, 1, 333, 1, 333,
		1, 333, 3, 333, 5491, 8, 333, 1, 333, 1, 333, 1, 334, 1, 334, 1, 334, 1,
		334, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 3, 334, 5504, 8, 334, 1, 335,
		1, 335, 1, 335, 1, 335, 1, 335, 1, 336, 1, 336, 1, 336, 1, 336, 1, 337,
		1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 3, 337, 5523, 8,
		337, 1, 337, 1, 337, 1, 337, 1, 337, 1, 337, 5, 337, 5530, 8, 337, 10,
		337, 12, 337, 5533, 9, 337, 3, 337, 5535, 8, 337, 1, 337, 3, 337, 5538,
		8, 337, 1, 338, 1, 338, 1, 338, 1, 338, 5, 338, 5544, 8, 338, 10, 338,
		12, 338, 5547, 9, 338, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 3, 339,
		5554, 8, 339, 1, 339, 1, 339, 3, 339, 5558, 8, 339, 1, 339, 1, 339, 1,
		339, 3, 339, 5563, 8, 339, 1, 339, 1, 339, 1, 339, 3, 339, 5568, 8, 339,
		3, 339, 5570, 8, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1,
		339, 1, 339, 3, 339, 5580, 8, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339,
		1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 3, 339, 5592, 8, 339, 1, 339, 1,
		339, 1, 339, 1, 339, 1, 339, 3, 339, 5599, 8, 339, 1, 339, 1, 339, 1, 339,
		1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 3, 339, 5610, 8, 339, 1,
		339, 1, 339, 3, 339, 5614, 8, 339, 1, 340, 1, 340, 1, 340, 1, 340, 1, 340,
		1, 340, 1, 340, 1, 340, 1, 340, 1, 340, 3, 340, 5626, 8, 340, 1, 341, 1,
		341, 1, 341, 1, 341, 3, 341, 5632, 8, 341, 1, 342, 1, 342, 1, 342, 1, 342,
		1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 3, 343, 5645, 8,
		343, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 5651, 8, 344, 1, 345, 1, 345,
		1, 345, 1, 345, 3, 345, 5657, 8, 345, 1, 345, 1, 345, 1, 346, 1, 346, 1,
		346, 5, 346, 5664, 8, 346, 10, 346, 12, 346, 5667, 9, 346, 1, 347, 1, 347,
		1, 347, 1, 347, 1, 347, 1, 347, 1, 348, 1, 348, 1, 348, 1, 348, 1, 348,
		5, 348, 5680, 8, 348, 10, 348, 12, 348, 5683, 9, 348, 1, 348, 1, 348, 3,
		348, 5687, 8, 348, 1, 349, 1, 349, 3, 349, 5691, 8, 349, 1, 349, 3, 349,
		5694, 8, 349, 1, 349, 1, 349, 1, 350, 1, 350, 3, 350, 5700, 8, 350, 1,
		350, 3, 350, 5703, 8, 350, 1, 350, 3, 350, 5706, 8, 350, 1, 351, 1, 351,
		1, 351, 1, 351, 1, 351, 1, 351, 1, 352, 1, 352, 1, 352, 1, 352, 1, 353,
		1, 353, 1, 353, 1, 353, 1, 353, 1, 353, 1, 354, 1, 354, 1, 354, 1, 354,
		1, 355, 1, 355, 1, 355, 1, 355, 1, 355, 3, 355, 5733, 8, 355, 1, 355, 1,
		355, 3, 355, 5737, 8, 355, 1, 355, 3, 355, 5740, 8, 355, 1, 356, 1, 356,
		1, 356, 1, 356, 3, 356, 5746, 8, 356, 1, 356, 1, 356, 1, 357, 1, 357, 1,
		357, 1, 357, 3, 357, 5754, 8, 357, 1, 357, 1, 357, 1, 358, 1, 358, 1, 358,
		1, 358, 3, 358, 5762, 8, 358, 1, 358, 1, 358, 1, 359, 1, 359, 3, 359, 5768,
		8, 359, 1, 359, 1, 359, 3, 359, 5772, 8, 359, 1, 359, 1, 359, 1, 360, 1,
		360, 1, 360, 1, 360, 3, 360, 5780, 8, 360, 1, 361, 1, 361, 1, 361, 1, 361,
		1, 361, 1, 361, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 3, 362,
		5794, 8, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 3,
		362, 5803, 8, 362, 3, 362, 5805, 8, 362, 1, 363, 1, 363, 1, 363, 1, 363,
		1, 363, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364,
		3, 364, 5820, 8, 364, 1, 364, 1, 364, 3, 364, 5824, 8, 364, 1, 364, 3,
		364, 5827, 8, 364, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365,
		3, 365, 5836, 8, 365, 1, 365, 1, 365, 3, 365, 5840, 8, 365, 1, 366, 1,
		366, 1, 366, 1, 366, 1, 366, 1, 366, 1, 366, 1, 367, 1, 367, 1, 367, 1,
		367, 1, 367, 1, 367, 1, 367, 1, 368, 1, 368, 1, 368, 1, 368, 1, 368, 1,
		368, 1, 368, 1, 368, 1, 369, 1, 369, 1, 369, 1, 369, 1, 369, 3, 369, 5869,
		8, 369, 1, 369, 1, 369, 3, 369, 5873, 8, 369, 3, 369, 5875, 8, 369, 1,
		370, 1, 370, 3, 370, 5879, 8, 370, 1, 370, 1, 370, 3, 370, 5883, 8, 370,
		1, 370, 3, 370, 5886, 8, 370, 1, 370, 3, 370, 5889, 8, 370, 1, 370, 3,
		370, 5892, 8, 370, 1, 371, 1, 371, 3, 371, 5896, 8, 371, 1, 371, 1, 371,
		3, 371, 5900, 8, 371, 1, 371, 3, 371, 5903, 8, 371, 1, 371, 3, 371, 5906,
		8, 371, 1, 371, 3, 371, 5909, 8, 371, 1, 372, 1, 372, 1, 372, 1, 372, 1,
		373, 1, 373, 1, 374, 4, 374, 5918, 8, 374, 11, 374, 12, 374, 5919, 1, 375,
		1, 375, 3, 375, 5924, 8, 375, 1, 375, 1, 375, 3, 375, 5928, 8, 375, 1,
		376, 3, 376, 5931, 8, 376, 1, 376, 1, 376, 1, 377, 1, 377, 1, 377, 1, 377,
		5, 377, 5939, 8, 377, 10, 377, 12, 377, 5942, 9, 377, 1, 378, 1, 378, 1,
		378, 1, 378, 1, 378, 1, 378, 5, 378, 5950, 8, 378, 10, 378, 12, 378, 5953,
		9, 378, 3, 378, 5955, 8, 378, 1, 378, 3, 378, 5958, 8, 378, 1, 379, 3,
		379, 5961, 8, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379,
		3, 379, 5970, 8, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1,
		379, 3, 379, 5979, 8, 379, 1, 379, 1, 379, 1, 379, 1, 379, 3, 379, 5985,
		8, 379, 1, 379, 1, 379, 1, 379, 1, 379, 1, 379, 3, 379, 5992, 8, 379, 1,
		380, 1, 380, 1, 381, 1, 381, 1, 381, 3, 381, 5999, 8, 381, 1, 381, 1, 381,
		1, 381, 3, 381, 6004, 8, 381, 1, 381, 1, 381, 1, 381, 1, 381, 3, 381, 6010,
		8, 381, 1, 381, 5, 381, 6013, 8, 381, 10, 381, 12, 381, 6016, 9, 381, 1,
		382, 1, 382, 1, 382, 1, 382, 1, 383, 1, 383, 1, 383, 1, 383, 1, 384, 1,
		384, 3, 384, 6028, 8, 384, 1, 384, 1, 384, 3, 384, 6032, 8, 384, 1, 385,
		1, 385, 1, 385, 3, 385, 6037, 8, 385, 1, 386, 1, 386, 1, 386, 1, 386, 3,
		386, 6043, 8, 386, 1, 386, 1, 386, 1, 386, 1, 386, 1, 386, 3, 386, 6050,
		8, 386, 1, 387, 1, 387, 3, 387, 6054, 8, 387, 1, 387, 1, 387, 1, 387, 5,
		387, 6059, 8, 387, 10, 387, 12, 387, 6062, 9, 387, 1, 387, 1, 387, 1, 387,
		3, 387, 6067, 8, 387, 1, 387, 1, 387, 1, 387, 3, 387, 6072, 8, 387, 1,
		387, 1, 387, 3, 387, 6076, 8, 387, 1, 387, 1, 387, 1, 387, 1, 387, 1, 387,
		3, 387, 6083, 8, 387, 1, 388, 1, 388, 1, 388, 3, 388, 6088, 8, 388, 3,
		388, 6090, 8, 388, 1, 388, 1, 388, 3, 388, 6094, 8, 388, 1, 389, 1, 389,
		1, 389, 3, 389, 6099, 8, 389, 1, 389, 1, 389, 1, 389, 1, 389, 3, 389, 6105,
		8, 389, 1, 389, 1, 389, 1, 389, 1, 389, 1, 389, 1, 389, 1, 389, 5, 389,
		6114, 8, 389, 10, 389, 12, 389, 6117, 9, 389, 1, 389, 1, 389, 1, 389, 3,
		389, 6122, 8, 389, 1, 390, 1, 390, 3, 390, 6126, 8, 390, 1, 390, 1, 390,
		5, 390, 6130, 8, 390, 10, 390, 12, 390, 6133, 9, 390, 1, 390, 1, 390, 1,
		391, 1, 391, 3, 391, 6139, 8, 391, 1, 391, 1, 391, 1, 391, 1, 391, 1, 391,
		1, 392, 1, 392, 1, 393, 1, 393, 3, 393, 6150, 8, 393, 1, 393, 1, 393, 3,
		393, 6154, 8, 393, 3, 393, 6156, 8, 393, 1, 393, 1, 393, 1, 393, 1, 393,
		3, 393, 6162, 8, 393, 1, 393, 1, 393, 3, 393, 6166, 8, 393, 3, 393, 6168,
		8, 393, 1, 394, 1, 394, 1, 394, 1, 394, 1, 394, 5, 394, 6175, 8, 394, 10,
		394, 12, 394, 6178, 9, 394, 1, 394, 1, 394, 1, 395, 1, 395, 1, 395, 3,
		395, 6185, 8, 395, 1, 395, 5, 395, 6188, 8, 395, 10, 395, 12, 395, 6191,
		9, 395, 1, 396, 1, 396, 5, 396, 6195, 8, 396, 10, 396, 12, 396, 6198, 9,
		396, 1, 396, 1, 396, 1, 396, 5, 396, 6203, 8, 396, 10, 396, 12, 396, 6206,
		9, 396, 1, 396, 1, 396, 3, 396, 6210, 8, 396, 1, 397, 1, 397, 3, 397, 6214,
		8, 397, 1, 397, 3, 397, 6217, 8, 397, 1, 397, 3, 397, 6220, 8, 397, 1,
		397, 3, 397, 6223, 8, 397, 1, 397, 3, 397, 6226, 8, 397, 1, 397, 3, 397,
		6229, 8, 397, 1, 397, 3, 397, 6232, 8, 397, 1, 397, 3, 397, 6235, 8, 397,
		1, 397, 1, 397, 3, 397, 6239, 8, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1,
		397, 5, 397, 6246, 8, 397, 10, 397, 12, 397, 6249, 9, 397, 1, 397, 1, 397,
		3, 397, 6253, 8, 397, 1, 397, 1, 397, 3, 397, 6257, 8, 397, 3, 397, 6259,
		8, 397, 1, 397, 1, 397, 3, 397, 6263, 8, 397, 1, 397, 1, 397, 3, 397, 6267,
		8, 397, 3, 397, 6269, 8, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 3,
		397, 6276, 8, 397, 1, 397, 1, 397, 3, 397, 6280, 8, 397, 3, 397, 6282,
		8, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397,
		3, 397, 6292, 8, 397, 1, 397, 1, 397, 3, 397, 6296, 8, 397, 3, 397, 6298,
		8, 397, 1, 397, 1, 397, 1, 397, 3, 397, 6303, 8, 397, 1, 397, 1, 397, 3,
		397, 6307, 8, 397, 3, 397, 6309, 8, 397, 1, 397, 1, 397, 1, 397, 1, 397,
		3, 397, 6315, 8, 397, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 5, 398, 6322,
		8, 398, 10, 398, 12, 398, 6325, 9, 398, 1, 398, 1, 398, 1, 398, 3, 398,
		6330, 8, 398, 1, 398, 1, 398, 1, 398, 1, 398, 1, 398, 5, 398, 6337, 8,
		398, 10, 398, 12, 398, 6340, 9, 398, 1, 398, 1, 398, 1, 398, 1, 399, 1,
		399, 3, 399, 6347, 8, 399, 1, 399, 1, 399, 3, 399, 6351, 8, 399, 3, 399,
		6353, 8, 399, 1, 400, 1, 400, 3, 400, 6357, 8, 400, 1, 400, 3, 400, 6360,
		8, 400, 1, 400, 1, 400, 3, 400, 6364, 8, 400, 3, 400, 6366, 8, 400, 1,
		401, 1, 401, 3, 401, 6370, 8, 401, 1, 402, 1, 402, 3, 402, 6374, 8, 402,
		1, 403, 1, 403, 1, 403, 5, 403, 6379, 8, 403, 10, 403, 12, 403, 6382, 9,
		403, 1, 404, 1, 404, 1, 404, 1, 404, 1, 405, 1, 405, 3, 405, 6390, 8, 405,
		1, 405, 3, 405, 6393, 8, 405, 1, 405, 1, 405, 3, 405, 6397, 8, 405, 1,
		405, 1, 405, 3, 405, 6401, 8, 405, 1, 405, 3, 405, 6404, 8, 405, 1, 405,
		1, 405, 1, 405, 3, 405, 6409, 8, 405, 1, 406, 1, 406, 1, 406, 1, 406, 1,
		406, 1, 406, 3, 406, 6417, 8, 406, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407,
		1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407,
		1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407,
		1, 407, 1, 407, 1, 407, 1, 407, 3, 407, 6446, 8, 407, 1, 408, 1, 408, 1,
		408, 1, 408, 5, 408, 6452, 8, 408, 10, 408, 12, 408, 6455, 9, 408, 1, 408,
		1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 3, 408,
		6466, 8, 408, 1, 409, 1, 409, 1, 409, 1, 409, 1, 410, 1, 410, 1, 410, 1,
		410, 1, 410, 1, 410, 1, 410, 5, 410, 6479, 8, 410, 10, 410, 12, 410, 6482,
		9, 410, 1, 410, 1, 410, 3, 410, 6486, 8, 410, 1, 411, 1, 411, 1, 411, 1,
		411, 5, 411, 6492, 8, 411, 10, 411, 12, 411, 6495, 9, 411, 1, 411, 1, 411,
		1, 412, 3, 412, 6500, 8, 412, 1, 412, 1, 412, 1, 412, 1, 412, 1, 412, 5,
		412, 6507, 8, 412, 10, 412, 12, 412, 6510, 9, 412, 1, 412, 1, 412, 1, 412,
		3, 412, 6515, 8, 412, 1, 412, 1, 412, 1, 412, 3, 412, 6520, 8, 412, 1,
		413, 1, 413, 1, 413, 1, 413, 1, 413, 5, 413, 6527, 8, 413, 10, 413, 12,
		413, 6530, 9, 413, 1, 413, 1, 413, 1, 414, 1, 414, 1, 414, 1, 414, 1, 414,
		5, 414, 6539, 8, 414, 10, 414, 12, 414, 6542, 9, 414, 1, 414, 1, 414, 1,
		415, 1, 415, 1, 415, 1, 415, 1, 415, 1, 416, 1, 416, 3, 416, 6553, 8, 416,
		1, 417, 1, 417, 1, 417, 1, 417, 1, 417, 1, 417, 1, 417, 1, 417, 5, 417,
		6563, 8, 417, 10, 417, 12, 417, 6566, 9, 417, 3, 417, 6568, 8, 417, 1,
		418, 1, 418, 1, 418, 1, 418, 1, 419, 1, 419, 1, 419, 1, 419, 1, 419, 5,
		419, 6579, 8, 419, 10, 419, 12, 419, 6582, 9, 419, 1, 419, 1, 419, 1, 420,
		1, 420, 1, 420, 1, 420, 5, 420, 6590, 8, 420, 10, 420, 12, 420, 6593, 9,
		420, 1, 420, 1, 420, 1, 421, 1, 421, 3, 421, 6599, 8, 421, 1, 422, 1, 422,
		1, 422, 5, 422, 6604, 8, 422, 10, 422, 12, 422, 6607, 9, 422, 1, 423, 1,
		423, 1, 423, 1, 423, 1, 424, 1, 424, 1, 424, 1, 425, 1, 425, 3, 425, 6618,
		8, 425, 1, 425, 1, 425, 1, 425, 3, 425, 6623, 8, 425, 1, 425, 1, 425, 1,
		425, 1, 425, 1, 425, 1, 425, 5, 425, 6631, 8, 425, 10, 425, 12, 425, 6634,
		9, 425, 1, 426, 1, 426, 1, 426, 5, 426, 6639, 8, 426, 10, 426, 12, 426,
		6642, 9, 426, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 3, 427, 6650,
		8, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427,
		1, 427, 1, 427, 1, 427, 5, 427, 6663, 8, 427, 10, 427, 12, 427, 6666, 9,
		427, 1, 428, 1, 428, 3, 428, 6670, 8, 428, 1, 428, 3, 428, 6673, 8, 428,
		1, 429, 1, 429, 1, 429, 1, 429, 4, 429, 6679, 8, 429, 11, 429, 12, 429,
		6680, 1, 429, 1, 429, 3, 429, 6685, 8, 429, 1, 429, 1, 429, 1, 429, 1,
		429, 1, 429, 1, 430, 3, 430, 6693, 8, 430, 1, 430, 1, 430, 1, 430, 1, 430,
		1, 430, 1, 430, 3, 430, 6701, 8, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1,
		430, 1, 430, 3, 430, 6709, 8, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430,
		1, 430, 3, 430, 6717, 8, 430, 1, 430, 1, 430, 3, 430, 6721, 8, 430, 1,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 5,
		431, 6750, 8, 431, 10, 431, 12, 431, 6753, 9, 431, 1, 432, 1, 432, 1, 432,
		1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432,
		1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432,
		1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432,
		1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432,
		1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 4, 432,
		6802, 8, 432, 11, 432, 12, 432, 6803, 1, 432, 1, 432, 3, 432, 6808, 8,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 4, 432, 6814, 8, 432, 11, 432, 12,
		432, 6815, 1, 432, 1, 432, 3, 432, 6820, 8, 432, 1, 432, 1, 432, 1, 432,
		3, 432, 6825, 8, 432, 1, 432, 1, 432, 3, 432, 6829, 8, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 3, 432, 6835, 8, 432, 1, 432, 1, 432, 1, 432, 1, 432,
		1, 432, 3, 432, 6842, 8, 432, 1, 432, 1, 432, 1, 432, 3, 432, 6847, 8,
		432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 3, 432, 6856,
		8, 432, 1, 432, 1, 432, 3, 432, 6860, 8, 432, 1, 432, 1, 432, 1, 432, 1,
		432, 1, 432, 3, 432, 6867, 8, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432,
		1, 432, 3, 432, 6875, 8, 432, 1, 432, 1, 432, 1, 432, 1, 432, 3, 432, 6881,
		8, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432, 1, 432,
		3, 432, 6891, 8, 432, 1, 432, 1, 432, 3, 432, 6895, 8, 432, 1, 432, 1,
		432, 1, 432, 1, 432, 5, 432, 6901, 8, 432, 10, 432, 12, 432, 6904, 9, 432,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 3, 433, 6916, 8, 433, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1,
		434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 5, 434, 6930, 8, 434,
		10, 434, 12, 434, 6933, 9, 434, 3, 434, 6935, 8, 434, 1, 434, 1, 434, 1,
		434, 1, 434, 1, 434, 1, 434, 5, 434, 6943, 8, 434, 10, 434, 12, 434, 6946,
		9, 434, 3, 434, 6948, 8, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1,
		434, 3, 434, 6956, 8, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434,
		1, 434, 1, 434, 5, 434, 6966, 8, 434, 10, 434, 12, 434, 6969, 9, 434, 3,
		434, 6971, 8, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 1, 434, 5, 434,
		6979, 8, 434, 10, 434, 12, 434, 6982, 9, 434, 3, 434, 6984, 8, 434, 1,
		434, 1, 434, 3, 434, 6988, 8, 434, 3, 434, 6990, 8, 434, 1, 435, 1, 435,
		1, 435, 3, 435, 6995, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1,
		435, 3, 435, 7003, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 3, 435,
		7010, 8, 435, 3, 435, 7012, 8, 435, 1, 435, 1, 435, 1, 435, 5, 435, 7017,
		8, 435, 10, 435, 12, 435, 7020, 9, 435, 3, 435, 7022, 8, 435, 1, 435, 1,
		435, 1, 435, 1, 435, 3, 435, 7028, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435,
		1, 435, 1, 435, 3, 435, 7036, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1,
		435, 1, 435, 3, 435, 7044, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435,
		1, 435, 3, 435, 7052, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1,
		435, 5, 435, 7060, 8, 435, 10, 435, 12, 435, 7063, 9, 435, 3, 435, 7065,
		8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435,
		1, 435, 1, 435, 5, 435, 7077, 8, 435, 10, 435, 12, 435, 7080, 9, 435, 3,
		435, 7082, 8, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 3, 435, 7089,
		8, 435, 1, 435, 1, 435, 1, 435, 5, 435, 7094, 8, 435, 10, 435, 12, 435,
		7097, 9, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 5, 435, 7104, 8,
		435, 10, 435, 12, 435, 7107, 9, 435, 3, 435, 7109, 8, 435, 1, 435, 1, 435,
		3, 435, 7113, 8, 435, 1, 435, 1, 435, 3, 435, 7117, 8, 435, 1, 436, 1,
		436, 1, 436, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 3, 437, 7127, 8, 437,
		1, 437, 1, 437, 1, 438, 1, 438, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439,
		1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439,
		1, 439, 3, 439, 7148, 8, 439, 1, 439, 1, 439, 1, 439, 3, 439, 7153, 8,
		439, 1, 439, 1, 439, 1, 439, 3, 439, 7158, 8, 439, 3, 439, 7160, 8, 439,
		1, 440, 1, 440, 1, 440, 3, 440, 7165, 8, 440, 1, 440, 1, 440, 1, 440, 3,
		440, 7170, 8, 440, 1, 440, 1, 440, 1, 440, 3, 440, 7175, 8, 440, 1, 440,
		3, 440, 7178, 8, 440, 1, 440, 1, 440, 1, 440, 3, 440, 7183, 8, 440, 1,
		440, 1, 440, 1, 440, 3, 440, 7188, 8, 440, 3, 440, 7190, 8, 440, 1, 441,
		1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441,
		1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441,
		1, 441, 5, 441, 7212, 8, 441, 10, 441, 12, 441, 7215, 9, 441, 3, 441, 7217,
		8, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441,
		1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441,
		1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441,
		1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441,
		1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441,
		1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 5, 441, 7268, 8, 441, 10, 441,
		12, 441, 7271, 9, 441, 3, 441, 7273, 8, 441, 1, 441, 1, 441, 1, 441, 1,
		441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1,
		441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1,
		441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1,
		441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1,
		441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1,
		441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1, 441, 1,
		441, 3, 441, 7333, 8, 441, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 3, 442, 7353, 8, 442, 1, 442, 1, 442, 1, 442, 1,
		442, 1, 442, 3, 442, 7360, 8, 442, 1, 442, 1, 442, 5, 442, 7364, 8, 442,
		10, 442, 12, 442, 7367, 9, 442, 3, 442, 7369, 8, 442, 1, 442, 1, 442, 3,
		442, 7373, 8, 442, 1, 442, 1, 442, 1, 442, 1, 442, 3, 442, 7379, 8, 442,
		1, 442, 1, 442, 5, 442, 7383, 8, 442, 10, 442, 12, 442, 7386, 9, 442, 3,
		442, 7388, 8, 442, 1, 442, 1, 442, 3, 442, 7392, 8, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 3, 442, 7398, 8, 442, 1, 442, 1, 442, 5, 442, 7402, 8,
		442, 10, 442, 12, 442, 7405, 9, 442, 3, 442, 7407, 8, 442, 1, 442, 1, 442,
		3, 442, 7411, 8, 442, 1, 442, 1, 442, 1, 442, 1, 442, 3, 442, 7417, 8,
		442, 1, 442, 1, 442, 5, 442, 7421, 8, 442, 10, 442, 12, 442, 7424, 9, 442,
		3, 442, 7426, 8, 442, 1, 442, 1, 442, 3, 442, 7430, 8, 442, 3, 442, 7432,
		8, 442, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 444, 1, 444, 1, 444,
		3, 444, 7442, 8, 444, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 5, 444, 7449,
		8, 444, 10, 444, 12, 444, 7452, 9, 444, 3, 444, 7454, 8, 444, 1, 444, 1,
		444, 1, 444, 1, 444, 1, 444, 5, 444, 7461, 8, 444, 10, 444, 12, 444, 7464,
		9, 444, 3, 444, 7466, 8, 444, 1, 444, 3, 444, 7469, 8, 444, 1, 444, 1,
		444, 1, 445, 1, 445, 1, 445, 1, 446, 1, 446, 1, 446, 1, 446, 1, 446, 1,
		446, 1, 446, 1, 446, 1, 446, 1, 446, 1, 446, 1, 446, 1, 446, 1, 446, 1,
		446, 1, 446, 3, 446, 7492, 8, 446, 1, 447, 1, 447, 1, 447, 1, 447, 1, 447,
		1, 447, 1, 447, 1, 447, 1, 447, 3, 447, 7503, 8, 447, 1, 448, 1, 448, 1,
		448, 1, 448, 1, 448, 1, 448, 1, 448, 3, 448, 7512, 8, 448, 3, 448, 7514,
		8, 448, 1, 448, 1, 448, 1, 448, 1, 448, 3, 448, 7520, 8, 448, 1, 448, 1,
		448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 3, 448, 7530, 8, 448,
		3, 448, 7532, 8, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 1, 448, 3,
		448, 7540, 8, 448, 3, 448, 7542, 8, 448, 3, 448, 7544, 8, 448, 1, 449,
		1, 449, 3, 449, 7548, 8, 449, 1, 450, 1, 450, 3, 450, 7552, 8, 450, 1,
		450, 1, 450, 3, 450, 7556, 8, 450, 1, 451, 1, 451, 3, 451, 7560, 8, 451,
		1, 452, 1, 452, 1, 452, 3, 452, 7565, 8, 452, 1, 453, 1, 453, 3, 453, 7569,
		8, 453, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454,
		5, 454, 7579, 8, 454, 10, 454, 12, 454, 7582, 9, 454, 3, 454, 7584, 8,
		454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1,
		454, 1, 454, 5, 454, 7596, 8, 454, 10, 454, 12, 454, 7599, 9, 454, 3, 454,
		7601, 8, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 3, 454, 7608, 8,
		454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 5, 454, 7615, 8, 454, 10,
		454, 12, 454, 7618, 9, 454, 3, 454, 7620, 8, 454, 1, 454, 1, 454, 1, 454,
		1, 454, 1, 454, 3, 454, 7627, 8, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1,
		454, 1, 454, 1, 454, 1, 454, 5, 454, 7637, 8, 454, 10, 454, 12, 454, 7640,
		9, 454, 3, 454, 7642, 8, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1, 454, 1,
		454, 1, 454, 1, 454, 1, 454, 1, 454, 5, 454, 7654, 8, 454, 10, 454, 12,
		454, 7657, 9, 454, 3, 454, 7659, 8, 454, 1, 455, 1, 455, 3, 455, 7663,
		8, 455, 1, 456, 1, 456, 1, 456, 1, 456, 3, 456, 7669, 8, 456, 1, 456, 1,
		456, 1, 456, 1, 456, 1, 456, 3, 456, 7676, 8, 456, 1, 457, 1, 457, 1, 457,
		1, 457, 3, 457, 7682, 8, 457, 1, 457, 1, 457, 1, 457, 1, 457, 1, 457, 3,
		457, 7689, 8, 457, 1, 458, 1, 458, 1, 458, 1, 458, 5, 458, 7695, 8, 458,
		10, 458, 12, 458, 7698, 9, 458, 1, 458, 1, 458, 1, 459, 1, 459, 1, 459,
		1, 459, 5, 459, 7706, 8, 459, 10, 459, 12, 459, 7709, 9, 459, 1, 459, 1,
		459, 1, 460, 1, 460, 3, 460, 7715, 8, 460, 1, 461, 1, 461, 3, 461, 7719,
		8, 461, 1, 462, 1, 462, 1, 462, 1, 462, 5, 462, 7725, 8, 462, 10, 462,
		12, 462, 7728, 9, 462, 1, 462, 1, 462, 1, 463, 1, 463, 1, 463, 1, 463,
		5, 463, 7736, 8, 463, 10, 463, 12, 463, 7739, 9, 463, 1, 463, 1, 463, 1,
		464, 1, 464, 3, 464, 7745, 8, 464, 1, 465, 1, 465, 1, 465, 1, 465, 3, 465,
		7751, 8, 465, 1, 465, 1, 465, 1, 465, 1, 465, 3, 465, 7757, 8, 465, 1,
		466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1,
		466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1,
		466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 1, 466, 3, 466, 7785,
		8, 466, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467, 1, 467,
		1, 467, 1, 468, 1, 468, 1, 468, 1, 468, 3, 468, 7800, 8, 468, 1, 468, 1,
		468, 1, 468, 1, 468, 1, 468, 1, 468, 3, 468, 7808, 8, 468, 1, 469, 1, 469,
		1, 469, 1, 469, 5, 469, 7814, 8, 469, 10, 469, 12, 469, 7817, 9, 469, 1,
		469, 1, 469, 1, 470, 1, 470, 1, 470, 1, 470, 1, 471, 1, 471, 3, 471, 7827,
		8, 471, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7835, 8,
		472, 1, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7841, 8, 472, 1, 473, 1, 473,
		1, 473, 1, 473, 1, 473, 1, 473, 3, 473, 7849, 8, 473, 1, 473, 1, 473, 1,
		473, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 1, 473, 3, 473, 7860, 8, 473,
		3, 473, 7862, 8, 473, 1, 474, 1, 474, 3, 474, 7866, 8, 474, 1, 474, 1,
		474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 3, 474, 7875, 8, 474, 1, 474,
		1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 1, 474, 3, 474, 7884, 8, 474, 1,
		475, 1, 475, 1, 476, 1, 476, 1, 476, 1, 476, 1, 476, 5, 476, 7893, 8, 476,
		10, 476, 12, 476, 7896, 9, 476, 1, 476, 1, 476, 1, 477, 1, 477, 1, 477,
		1, 478, 1, 478, 1, 478, 1, 478, 5, 478, 7907, 8, 478, 10, 478, 12, 478,
		7910, 9, 478, 1, 478, 1, 478, 1, 479, 1, 479, 1, 479, 5, 479, 7917, 8,
		479, 10, 479, 12, 479, 7920, 9, 479, 1, 480, 1, 480, 1, 480, 1, 480, 1,
		481, 1, 481, 5, 481, 7928, 8, 481, 10, 481, 12, 481, 7931, 9, 481, 1, 482,
		1, 482, 1, 482, 1, 482, 1, 483, 1, 483, 1, 484, 1, 484, 1, 484, 1, 485,
		1, 485, 1, 485, 1, 485, 3, 485, 7946, 8, 485, 1, 485, 3, 485, 7949, 8,
		485, 1, 486, 1, 486, 1, 486, 1, 486, 3, 486, 7955, 8, 486, 1, 487, 1, 487,
		1, 488, 1, 488, 1, 489, 1, 489, 1, 490, 1, 490, 1, 491, 1, 491, 1, 491,
		1, 491, 1, 492, 1, 492, 1, 492, 1, 492, 1, 493, 1, 493, 1, 494, 1, 494,
		1, 495, 1, 495, 1, 496, 1, 496, 1, 496, 1, 496, 1, 496, 3, 496, 7984, 8,
		496, 1, 497, 1, 497, 1, 497, 1, 497, 1, 497, 1, 498, 1, 498, 1, 498, 1,
		498, 1, 498, 1, 498, 1, 498, 1, 499, 1, 499, 3, 499, 8000, 8, 499, 1, 499,
		1, 499, 1, 500, 1, 500, 1, 500, 5, 500, 8007, 8, 500, 10, 500, 12, 500,
		8010, 9, 500, 1, 501, 1, 501, 1, 501, 1, 501, 1, 501, 1, 502, 1, 502, 1,
		502, 1, 502, 1, 503, 1, 503, 1, 503, 3, 503, 8024, 8, 503, 1, 503, 1, 503,
		3, 503, 8028, 8, 503, 1, 503, 1, 503, 3, 503, 8032, 8, 503, 1, 503, 1,
		503, 3, 503, 8036, 8, 503, 1, 503, 1, 503, 3, 503, 8040, 8, 503, 1, 503,
		1, 503, 3, 503, 8044, 8, 503, 1, 503, 1, 503, 3, 503, 8048, 8, 503, 1,
		503, 1, 503, 3, 503, 8052, 8, 503, 1, 503, 1, 503, 3, 503, 8056, 8, 503,
		1, 503, 1, 503, 3, 503, 8060, 8, 503, 1, 503, 1, 503, 1, 503, 1, 503, 1,
		503, 1, 503, 1, 503, 3, 503, 8069, 8, 503, 1, 503, 1, 503, 3, 503, 8073,
		8, 503, 1, 503, 1, 503, 1, 503, 1, 503, 1, 503, 1, 503, 1, 503, 1, 503,
		3, 503, 8083, 8, 503, 1, 503, 1, 503, 3, 503, 8087, 8, 503, 3, 503, 8089,
		8, 503, 1, 504, 1, 504, 1, 504, 1, 504, 1, 504, 3, 504, 8096, 8, 504, 1,
		504, 3, 504, 8099, 8, 504, 1, 505, 1, 505, 1, 505, 1, 505, 5, 505, 8105,
		8, 505, 10, 505, 12, 505, 8108, 9, 505, 1, 506, 1, 506, 1, 507, 3, 507,
		8113, 8, 507, 1, 507, 1, 507, 1, 507, 1, 507, 1, 507, 1, 508, 1, 508, 1,
		508, 1, 508, 3, 508, 8124, 8, 508, 1, 509, 1, 509, 1, 509, 3, 509, 8129,
		8, 509, 1, 510, 1, 510, 1, 510, 1, 510, 5, 510, 8135, 8, 510, 10, 510,
		12, 510, 8138, 9, 510, 1, 510, 1, 510, 1, 511, 1, 511, 1, 511, 1, 511,
		5, 511, 8146, 8, 511, 10, 511, 12, 511, 8149, 9, 511, 1, 511, 1, 511, 1,
		512, 1, 512, 3, 512, 8155, 8, 512, 1, 513, 1, 513, 1, 513, 5, 513, 8160,
		8, 513, 10, 513, 12, 513, 8163, 9, 513, 1, 514, 1, 514, 1, 514, 3, 514,
		8168, 8, 514, 1, 515, 1, 515, 1, 515, 1, 515, 1, 515, 1, 515, 1, 515, 1,
		515, 1, 515, 1, 515, 1, 515, 3, 515, 8181, 8, 515, 1, 516, 1, 516, 1, 516,
		1, 516, 1, 517, 1, 517, 1, 517, 5, 517, 8190, 8, 517, 10, 517, 12, 517,
		8193, 9, 517, 1, 518, 1, 518, 1, 518, 3, 518, 8198, 8, 518, 1, 519, 1,
		519, 1, 519, 1, 4124, 5, 762, 850, 854, 862, 864, 520, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234,
		236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264,
		266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294,
		296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324,
		326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354,
		356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384,
		386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414,
		416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444,
		446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474,
		476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504,
		506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534,
		536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564,
		566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594,
		596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624,
		626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654,
		656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684,
		686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714,
		716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744,
		746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774,
		776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804,
		806, 808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834,
		836, 838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864,
		866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894,
		896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924,
		926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954,
		956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984,
		986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010,
		1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034,
		1036, 1038, 0, 65, 1, 1, 533, 533, 2, 0, 172, 172, 202, 202, 2, 0, 104,
		104, 387, 387, 2, 0, 151, 151, 429, 429, 4, 0, 17, 17, 134, 134, 323, 323,
		452, 452, 4, 0, 44, 44, 220, 220, 276, 276, 467, 467, 2, 0, 77, 77, 157,
		157, 3, 0, 76, 76, 294, 294, 376, 376, 1, 0, 125, 126, 2, 0, 205, 206,
		227, 228, 2, 0, 219, 219, 280, 280, 2, 0, 13, 13, 270, 270, 2, 0, 29, 29,
		418, 418, 2, 0, 127, 127, 137, 137, 2, 0, 167, 167, 286, 286, 2, 0, 202,
		202, 441, 441, 2, 0, 38, 38, 94, 94, 3, 0, 109, 109, 194, 194, 265, 265,
		2, 0, 218, 218, 221, 221, 2, 0, 175, 175, 384, 384, 2, 0, 224, 224, 409,
		409, 2, 0, 54, 54, 178, 178, 2, 0, 17, 17, 423, 423, 2, 0, 176, 176, 328,
		328, 1, 0, 425, 426, 2, 0, 142, 142, 476, 476, 1, 0, 459, 460, 2, 0, 27,
		27, 55, 55, 1, 0, 60, 61, 2, 0, 173, 173, 519, 519, 2, 0, 71, 71, 73, 73,
		3, 0, 420, 420, 435, 435, 469, 469, 3, 0, 145, 145, 266, 266, 451, 451,
		2, 0, 28, 28, 125, 125, 2, 0, 161, 161, 233, 233, 2, 0, 18, 18, 128, 128,
		1, 0, 145, 146, 1, 0, 303, 304, 2, 0, 110, 110, 132, 132, 2, 0, 21, 21,
		507, 507, 2, 0, 297, 297, 506, 506, 3, 0, 240, 240, 350, 350, 372, 372,
		3, 0, 268, 268, 503, 505, 509, 509, 1, 0, 501, 502, 2, 0, 501, 502, 513,
		513, 1, 0, 106, 107, 2, 0, 166, 166, 320, 320, 1, 0, 176, 177, 1, 0, 423,
		424, 1, 0, 470, 471, 2, 0, 125, 126, 149, 149, 5, 0, 20, 20, 88, 88, 250,
		250, 386, 386, 468, 468, 5, 0, 18, 18, 249, 249, 346, 346, 434, 434, 463,
		463, 2, 0, 120, 120, 199, 199, 2, 0, 12, 12, 203, 203, 4, 0, 178, 178,
		244, 244, 395, 395, 468, 468, 1, 0, 522, 523, 1, 0, 524, 525, 1, 0, 493,
		499, 2, 0, 156, 156, 445, 445, 4, 0, 108, 108, 193, 193, 264, 264, 389,
		389, 9, 0, 108, 108, 193, 193, 261, 262, 264, 264, 271, 271, 337, 337,
		389, 389, 477, 477, 484, 484, 2, 0, 62, 62, 164, 164, 2, 0, 111, 115, 284,
		285, 93, 0, 11, 12, 14, 17, 22, 23, 25, 26, 29, 40, 43, 43, 45, 49, 51,
		54, 56, 57, 59, 63, 66, 66, 68, 73, 75, 75, 77, 81, 83, 86, 88, 89, 93,
		95, 102, 103, 106, 110, 116, 116, 121, 123, 127, 127, 129, 130, 134, 135,
		137, 147, 150, 155, 157, 158, 160, 161, 164, 167, 170, 171, 173, 174, 177,
		178, 180, 180, 185, 186, 188, 189, 191, 196, 198, 198, 201, 201, 203, 204,
		206, 206, 209, 209, 213, 215, 217, 217, 221, 221, 223, 224, 230, 230, 233,
		233, 238, 239, 242, 242, 244, 244, 247, 258, 260, 260, 263, 267, 269, 280,
		283, 289, 291, 293, 295, 296, 304, 309, 311, 321, 324, 327, 329, 342, 344,
		344, 346, 349, 352, 352, 354, 355, 357, 368, 370, 370, 373, 378, 381, 386,
		389, 390, 392, 395, 397, 397, 399, 400, 403, 413, 415, 418, 420, 422, 424,
		429, 431, 431, 433, 437, 439, 440, 442, 444, 446, 450, 453, 454, 457, 457,
		459, 460, 462, 462, 464, 464, 466, 477, 480, 480, 482, 489, 491, 492, 500,
		500, 534, 534, 9249, 0, 1041, 1, 0, 0, 0, 2, 1051, 1, 0, 0, 0, 4, 1053,
		1, 0, 0, 0, 6, 1295, 1, 0, 0, 0, 8, 1297, 1, 0, 0, 0, 10, 1300, 1, 0, 0,
		0, 12, 1303, 1, 0, 0, 0, 14, 1327, 1, 0, 0, 0, 16, 1345, 1, 0, 0, 0, 18,
		1347, 1, 0, 0, 0, 20, 1369, 1, 0, 0, 0, 22, 1384, 1, 0, 0, 0, 24, 1389,
		1, 0, 0, 0, 26, 1395, 1, 0, 0, 0, 28, 1405, 1, 0, 0, 0, 30, 1407, 1, 0,
		0, 0, 32, 1415, 1, 0, 0, 0, 34, 1473, 1, 0, 0, 0, 36, 1505, 1, 0, 0, 0,
		38, 1507, 1, 0, 0, 0, 40, 1519, 1, 0, 0, 0, 42, 1522, 1, 0, 0, 0, 44, 1534,
		1, 0, 0, 0, 46, 1539, 1, 0, 0, 0, 48, 1554, 1, 0, 0, 0, 50, 1562, 1, 0,
		0, 0, 52, 1566, 1, 0, 0, 0, 54, 1573, 1, 0, 0, 0, 56, 1575, 1, 0, 0, 0,
		58, 1579, 1, 0, 0, 0, 60, 1600, 1, 0, 0, 0, 62, 1602, 1, 0, 0, 0, 64, 1614,
		1, 0, 0, 0, 66, 1625, 1, 0, 0, 0, 68, 1629, 1, 0, 0, 0, 70, 1634, 1, 0,
		0, 0, 72, 1639, 1, 0, 0, 0, 74, 1641, 1, 0, 0, 0, 76, 1703, 1, 0, 0, 0,
		78, 1716, 1, 0, 0, 0, 80, 1760, 1, 0, 0, 0, 82, 1762, 1, 0, 0, 0, 84, 1777,
		1, 0, 0, 0, 86, 1783, 1, 0, 0, 0, 88, 1786, 1, 0, 0, 0, 90, 1801, 1, 0,
		0, 0, 92, 1814, 1, 0, 0, 0, 94, 1824, 1, 0, 0, 0, 96, 1842, 1, 0, 0, 0,
		98, 1855, 1, 0, 0, 0, 100, 1927, 1, 0, 0, 0, 102, 1929, 1, 0, 0, 0, 104,
		1938, 1, 0, 0, 0, 106, 1961, 1, 0, 0, 0, 108, 1970, 1, 0, 0, 0, 110, 1974,
		1, 0, 0, 0, 112, 2006, 1, 0, 0, 0, 114, 2008, 1, 0, 0, 0, 116, 2034, 1,
		0, 0, 0, 118, 2040, 1, 0, 0, 0, 120, 2117, 1, 0, 0, 0, 122, 2119, 1, 0,
		0, 0, 124, 2127, 1, 0, 0, 0, 126, 2131, 1, 0, 0, 0, 128, 2150, 1, 0, 0,
		0, 130, 2152, 1, 0, 0, 0, 132, 2158, 1, 0, 0, 0, 134, 2171, 1, 0, 0, 0,
		136, 2224, 1, 0, 0, 0, 138, 2233, 1, 0, 0, 0, 140, 2235, 1, 0, 0, 0, 142,
		2248, 1, 0, 0, 0, 144, 2273, 1, 0, 0, 0, 146, 2275, 1, 0, 0, 0, 148, 2299,
		1, 0, 0, 0, 150, 2307, 1, 0, 0, 0, 152, 2318, 1, 0, 0, 0, 154, 2324, 1,
		0, 0, 0, 156, 2332, 1, 0, 0, 0, 158, 2341, 1, 0, 0, 0, 160, 2354, 1, 0,
		0, 0, 162, 2361, 1, 0, 0, 0, 164, 2369, 1, 0, 0, 0, 166, 2377, 1, 0, 0,
		0, 168, 2392, 1, 0, 0, 0, 170, 2403, 1, 0, 0, 0, 172, 2405, 1, 0, 0, 0,
		174, 2416, 1, 0, 0, 0, 176, 2423, 1, 0, 0, 0, 178, 2427, 1, 0, 0, 0, 180,
		2438, 1, 0, 0, 0, 182, 2442, 1, 0, 0, 0, 184, 2456, 1, 0, 0, 0, 186, 2461,
		1, 0, 0, 0, 188, 2469, 1, 0, 0, 0, 190, 2475, 1, 0, 0, 0, 192, 2480, 1,
		0, 0, 0, 194, 2497, 1, 0, 0, 0, 196, 2501, 1, 0, 0, 0, 198, 2505, 1, 0,
		0, 0, 200, 2512, 1, 0, 0, 0, 202, 2521, 1, 0, 0, 0, 204, 2535, 1, 0, 0,
		0, 206, 2537, 1, 0, 0, 0, 208, 2540, 1, 0, 0, 0, 210, 2544, 1, 0, 0, 0,
		212, 2549, 1, 0, 0, 0, 214, 2556, 1, 0, 0, 0, 216, 2577, 1, 0, 0, 0, 218,
		2588, 1, 0, 0, 0, 220, 2606, 1, 0, 0, 0, 222, 2612, 1, 0, 0, 0, 224, 2616,
		1, 0, 0, 0, 226, 2621, 1, 0, 0, 0, 228, 2632, 1, 0, 0, 0, 230, 2634, 1,
		0, 0, 0, 232, 2683, 1, 0, 0, 0, 234, 2685, 1, 0, 0, 0, 236, 2689, 1, 0,
		0, 0, 238, 2693, 1, 0, 0, 0, 240, 2700, 1, 0, 0, 0, 242, 2719, 1, 0, 0,
		0, 244, 2741, 1, 0, 0, 0, 246, 2764, 1, 0, 0, 0, 248, 2766, 1, 0, 0, 0,
		250, 2786, 1, 0, 0, 0, 252, 2832, 1, 0, 0, 0, 254, 2834, 1, 0, 0, 0, 256,
		2841, 1, 0, 0, 0, 258, 2844, 1, 0, 0, 0, 260, 2849, 1, 0, 0, 0, 262, 2863,
		1, 0, 0, 0, 264, 2878, 1, 0, 0, 0, 266, 2892, 1, 0, 0, 0, 268, 2907, 1,
		0, 0, 0, 270, 2920, 1, 0, 0, 0, 272, 2924, 1, 0, 0, 0, 274, 2927, 1, 0,
		0, 0, 276, 2931, 1, 0, 0, 0, 278, 2934, 1, 0, 0, 0, 280, 2938, 1, 0, 0,
		0, 282, 2944, 1, 0, 0, 0, 284, 2961, 1, 0, 0, 0, 286, 2976, 1, 0, 0, 0,
		288, 2995, 1, 0, 0, 0, 290, 3005, 1, 0, 0, 0, 292, 3020, 1, 0, 0, 0, 294,
		3026, 1, 0, 0, 0, 296, 3036, 1, 0, 0, 0, 298, 3042, 1, 0, 0, 0, 300, 3051,
		1, 0, 0, 0, 302, 3053, 1, 0, 0, 0, 304, 3062, 1, 0, 0, 0, 306, 3076, 1,
		0, 0, 0, 308, 3104, 1, 0, 0, 0, 310, 3125, 1, 0, 0, 0, 312, 3127, 1, 0,
		0, 0, 314, 3135, 1, 0, 0, 0, 316, 3143, 1, 0, 0, 0, 318, 3150, 1, 0, 0,
		0, 320, 3159, 1, 0, 0, 0, 322, 3181, 1, 0, 0, 0, 324, 3183, 1, 0, 0, 0,
		326, 3187, 1, 0, 0, 0, 328, 3190, 1, 0, 0, 0, 330, 3193, 1, 0, 0, 0, 332,
		3195, 1, 0, 0, 0, 334, 3197, 1, 0, 0, 0, 336, 3208, 1, 0, 0, 0, 338, 3244,
		1, 0, 0, 0, 340, 3301, 1, 0, 0, 0, 342, 3303, 1, 0, 0, 0, 344, 3320, 1,
		0, 0, 0, 346, 3322, 1, 0, 0, 0, 348, 3329, 1, 0, 0, 0, 350, 3335, 1, 0,
		0, 0, 352, 3378, 1, 0, 0, 0, 354, 3383, 1, 0, 0, 0, 356, 3386, 1, 0, 0,
		0, 358, 3401, 1, 0, 0, 0, 360, 3420, 1, 0, 0, 0, 362, 3449, 1, 0, 0, 0,
		364, 3475, 1, 0, 0, 0, 366, 3485, 1, 0, 0, 0, 368, 3487, 1, 0, 0, 0, 370,
		3492, 1, 0, 0, 0, 372, 3497, 1, 0, 0, 0, 374, 3500, 1, 0, 0, 0, 376, 3517,
		1, 0, 0, 0, 378, 3519, 1, 0, 0, 0, 380, 3521, 1, 0, 0, 0, 382, 3532, 1,
		0, 0, 0, 384, 3543, 1, 0, 0, 0, 386, 3554, 1, 0, 0, 0, 388, 3592, 1, 0,
		0, 0, 390, 3603, 1, 0, 0, 0, 392, 3614, 1, 0, 0, 0, 394, 3652, 1, 0, 0,
		0, 396, 3708, 1, 0, 0, 0, 398, 3710, 1, 0, 0, 0, 400, 3718, 1, 0, 0, 0,
		402, 3733, 1, 0, 0, 0, 404, 3739, 1, 0, 0, 0, 406, 3797, 1, 0, 0, 0, 408,
		3806, 1, 0, 0, 0, 410, 3808, 1, 0, 0, 0, 412, 3832, 1, 0, 0, 0, 414, 3858,
		1, 0, 0, 0, 416, 3880, 1, 0, 0, 0, 418, 3901, 1, 0, 0, 0, 420, 3903, 1,
		0, 0, 0, 422, 3917, 1, 0, 0, 0, 424, 3921, 1, 0, 0, 0, 426, 3924, 1, 0,
		0, 0, 428, 3960, 1, 0, 0, 0, 430, 4017, 1, 0, 0, 0, 432, 4035, 1, 0, 0,
		0, 434, 4046, 1, 0, 0, 0, 436, 4048, 1, 0, 0, 0, 438, 4057, 1, 0, 0, 0,
		440, 4063, 1, 0, 0, 0, 442, 4067, 1, 0, 0, 0, 444, 4070, 1, 0, 0, 0, 446,
		4074, 1, 0, 0, 0, 448, 4092, 1, 0, 0, 0, 450, 4106, 1, 0, 0, 0, 452, 4129,
		1, 0, 0, 0, 454, 4133, 1, 0, 0, 0, 456, 4174, 1, 0, 0, 0, 458, 4179, 1,
		0, 0, 0, 460, 4183, 1, 0, 0, 0, 462, 4263, 1, 0, 0, 0, 464, 4265, 1, 0,
		0, 0, 466, 4299, 1, 0, 0, 0, 468, 4301, 1, 0, 0, 0, 470, 4307, 1, 0, 0,
		0, 472, 4354, 1, 0, 0, 0, 474, 4356, 1, 0, 0, 0, 476, 4366, 1, 0, 0, 0,
		478, 4378, 1, 0, 0, 0, 480, 4383, 1, 0, 0, 0, 482, 4386, 1, 0, 0, 0, 484,
		4389, 1, 0, 0, 0, 486, 4392, 1, 0, 0, 0, 488, 4406, 1, 0, 0, 0, 490, 4414,
		1, 0, 0, 0, 492, 4420, 1, 0, 0, 0, 494, 4428, 1, 0, 0, 0, 496, 4440, 1,
		0, 0, 0, 498, 4443, 1, 0, 0, 0, 500, 4446, 1, 0, 0, 0, 502, 4449, 1, 0,
		0, 0, 504, 4452, 1, 0, 0, 0, 506, 4456, 1, 0, 0, 0, 508, 4459, 1, 0, 0,
		0, 510, 4468, 1, 0, 0, 0, 512, 4472, 1, 0, 0, 0, 514, 4481, 1, 0, 0, 0,
		516, 4487, 1, 0, 0, 0, 518, 4494, 1, 0, 0, 0, 520, 4534, 1, 0, 0, 0, 522,
		4536, 1, 0, 0, 0, 524, 4546, 1, 0, 0, 0, 526, 4581, 1, 0, 0, 0, 528, 4583,
		1, 0, 0, 0, 530, 4594, 1, 0, 0, 0, 532, 4599, 1, 0, 0, 0, 534, 4602, 1,
		0, 0, 0, 536, 4621, 1, 0, 0, 0, 538, 4662, 1, 0, 0, 0, 540, 4664, 1, 0,
		0, 0, 542, 4676, 1, 0, 0, 0, 544, 4678, 1, 0, 0, 0, 546, 4686, 1, 0, 0,
		0, 548, 4697, 1, 0, 0, 0, 550, 4709, 1, 0, 0, 0, 552, 4717, 1, 0, 0, 0,
		554, 4734, 1, 0, 0, 0, 556, 4750, 1, 0, 0, 0, 558, 4768, 1, 0, 0, 0, 560,
		4770, 1, 0, 0, 0, 562, 4787, 1, 0, 0, 0, 564, 4877, 1, 0, 0, 0, 566, 4943,
		1, 0, 0, 0, 568, 4959, 1, 0, 0, 0, 570, 4974, 1, 0, 0, 0, 572, 4976, 1,
		0, 0, 0, 574, 4981, 1, 0, 0, 0, 576, 4989, 1, 0, 0, 0, 578, 5004, 1, 0,
		0, 0, 580, 5055, 1, 0, 0, 0, 582, 5071, 1, 0, 0, 0, 584, 5091, 1, 0, 0,
		0, 586, 5093, 1, 0, 0, 0, 588, 5099, 1, 0, 0, 0, 590, 5106, 1, 0, 0, 0,
		592, 5111, 1, 0, 0, 0, 594, 5115, 1, 0, 0, 0, 596, 5121, 1, 0, 0, 0, 598,
		5127, 1, 0, 0, 0, 600, 5132, 1, 0, 0, 0, 602, 5136, 1, 0, 0, 0, 604, 5142,
		1, 0, 0, 0, 606, 5177, 1, 0, 0, 0, 608, 5186, 1, 0, 0, 0, 610, 5192, 1,
		0, 0, 0, 612, 5231, 1, 0, 0, 0, 614, 5240, 1, 0, 0, 0, 616, 5250, 1, 0,
		0, 0, 618, 5258, 1, 0, 0, 0, 620, 5277, 1, 0, 0, 0, 622, 5281, 1, 0, 0,
		0, 624, 5285, 1, 0, 0, 0, 626, 5295, 1, 0, 0, 0, 628, 5298, 1, 0, 0, 0,
		630, 5301, 1, 0, 0, 0, 632, 5312, 1, 0, 0, 0, 634, 5323, 1, 0, 0, 0, 636,
		5327, 1, 0, 0, 0, 638, 5333, 1, 0, 0, 0, 640, 5350, 1, 0, 0, 0, 642, 5354,
		1, 0, 0, 0, 644, 5359, 1, 0, 0, 0, 646, 5363, 1, 0, 0, 0, 648, 5382, 1,
		0, 0, 0, 650, 5401, 1, 0, 0, 0, 652, 5413, 1, 0, 0, 0, 654, 5440, 1, 0,
		0, 0, 656, 5447, 1, 0, 0, 0, 658, 5451, 1, 0, 0, 0, 660, 5460, 1, 0, 0,
		0, 662, 5469, 1, 0, 0, 0, 664, 5475, 1, 0, 0, 0, 666, 5486, 1, 0, 0, 0,
		668, 5503, 1, 0, 0, 0, 670, 5505, 1, 0, 0, 0, 672, 5510, 1, 0, 0, 0, 674,
		5514, 1, 0, 0, 0, 676, 5539, 1, 0, 0, 0, 678, 5613, 1, 0, 0, 0, 680, 5625,
		1, 0, 0, 0, 682, 5631, 1, 0, 0, 0, 684, 5633, 1, 0, 0, 0, 686, 5644, 1,
		0, 0, 0, 688, 5650, 1, 0, 0, 0, 690, 5652, 1, 0, 0, 0, 692, 5660, 1, 0,
		0, 0, 694, 5668, 1, 0, 0, 0, 696, 5686, 1, 0, 0, 0, 698, 5688, 1, 0, 0,
		0, 700, 5705, 1, 0, 0, 0, 702, 5707, 1, 0, 0, 0, 704, 5713, 1, 0, 0, 0,
		706, 5717, 1, 0, 0, 0, 708, 5723, 1, 0, 0, 0, 710, 5727, 1, 0, 0, 0, 712,
		5741, 1, 0, 0, 0, 714, 5749, 1, 0, 0, 0, 716, 5757, 1, 0, 0, 0, 718, 5765,
		1, 0, 0, 0, 720, 5775, 1, 0, 0, 0, 722, 5781, 1, 0, 0, 0, 724, 5804, 1,
		0, 0, 0, 726, 5806, 1, 0, 0, 0, 728, 5811, 1, 0, 0, 0, 730, 5828, 1, 0,
		0, 0, 732, 5841, 1, 0, 0, 0, 734, 5848, 1, 0, 0, 0, 736, 5855, 1, 0, 0,
		0, 738, 5874, 1, 0, 0, 0, 740, 5876, 1, 0, 0, 0, 742, 5893, 1, 0, 0, 0,
		744, 5910, 1, 0, 0, 0, 746, 5914, 1, 0, 0, 0, 748, 5917, 1, 0, 0, 0, 750,
		5923, 1, 0, 0, 0, 752, 5930, 1, 0, 0, 0, 754, 5934, 1, 0, 0, 0, 756, 5943,
		1, 0, 0, 0, 758, 5991, 1, 0, 0, 0, 760, 5993, 1, 0, 0, 0, 762, 5998, 1,
		0, 0, 0, 764, 6017, 1, 0, 0, 0, 766, 6021, 1, 0, 0, 0, 768, 6025, 1, 0,
		0, 0, 770, 6036, 1, 0, 0, 0, 772, 6049, 1, 0, 0, 0, 774, 6051, 1, 0, 0,
		0, 776, 6093, 1, 0, 0, 0, 778, 6121, 1, 0, 0, 0, 780, 6123, 1, 0, 0, 0,
		782, 6136, 1, 0, 0, 0, 784, 6145, 1, 0, 0, 0, 786, 6167, 1, 0, 0, 0, 788,
		6169, 1, 0, 0, 0, 790, 6181, 1, 0, 0, 0, 792, 6209, 1, 0, 0, 0, 794, 6314,
		1, 0, 0, 0, 796, 6316, 1, 0, 0, 0, 798, 6344, 1, 0, 0, 0, 800, 6356, 1,
		0, 0, 0, 802, 6367, 1, 0, 0, 0, 804, 6373, 1, 0, 0, 0, 806, 6375, 1, 0,
		0, 0, 808, 6383, 1, 0, 0, 0, 810, 6408, 1, 0, 0, 0, 812, 6416, 1, 0, 0,
		0, 814, 6445, 1, 0, 0, 0, 816, 6465, 1, 0, 0, 0, 818, 6467, 1, 0, 0, 0,
		820, 6485, 1, 0, 0, 0, 822, 6487, 1, 0, 0, 0, 824, 6519, 1, 0, 0, 0, 826,
		6521, 1, 0, 0, 0, 828, 6533, 1, 0, 0, 0, 830, 6545, 1, 0, 0, 0, 832, 6552,
		1, 0, 0, 0, 834, 6554, 1, 0, 0, 0, 836, 6569, 1, 0, 0, 0, 838, 6573, 1,
		0, 0, 0, 840, 6585, 1, 0, 0, 0, 842, 6598, 1, 0, 0, 0, 844, 6600, 1, 0,
		0, 0, 846, 6608, 1, 0, 0, 0, 848, 6612, 1, 0, 0, 0, 850, 6622, 1, 0, 0,
		0, 852, 6635, 1, 0, 0, 0, 854, 6643, 1, 0, 0, 0, 856, 6672, 1, 0, 0, 0,
		858, 6674, 1, 0, 0, 0, 860, 6720, 1, 0, 0, 0, 862, 6722, 1, 0, 0, 0, 864,
		6859, 1, 0, 0, 0, 866, 6915, 1, 0, 0, 0, 868, 6989, 1, 0, 0, 0, 870, 7116,
		1, 0, 0, 0, 872, 7118, 1, 0, 0, 0, 874, 7121, 1, 0, 0, 0, 876, 7130, 1,
		0, 0, 0, 878, 7159, 1, 0, 0, 0, 880, 7189, 1, 0, 0, 0, 882, 7332, 1, 0,
		0, 0, 884, 7431, 1, 0, 0, 0, 886, 7433, 1, 0, 0, 0, 888, 7438, 1, 0, 0,
		0, 890, 7472, 1, 0, 0, 0, 892, 7491, 1, 0, 0, 0, 894, 7502, 1, 0, 0, 0,
		896, 7543, 1, 0, 0, 0, 898, 7545, 1, 0, 0, 0, 900, 7549, 1, 0, 0, 0, 902,
		7557, 1, 0, 0, 0, 904, 7561, 1, 0, 0, 0, 906, 7568, 1, 0, 0, 0, 908, 7658,
		1, 0, 0, 0, 910, 7662, 1, 0, 0, 0, 912, 7664, 1, 0, 0, 0, 914, 7677, 1,
		0, 0, 0, 916, 7690, 1, 0, 0, 0, 918, 7701, 1, 0, 0, 0, 920, 7714, 1, 0,
		0, 0, 922, 7718, 1, 0, 0, 0, 924, 7720, 1, 0, 0, 0, 926, 7731, 1, 0, 0,
		0, 928, 7744, 1, 0, 0, 0, 930, 7746, 1, 0, 0, 0, 932, 7784, 1, 0, 0, 0,
		934, 7786, 1, 0, 0, 0, 936, 7807, 1, 0, 0, 0, 938, 7809, 1, 0, 0, 0, 940,
		7820, 1, 0, 0, 0, 942, 7826, 1, 0, 0, 0, 944, 7840, 1, 0, 0, 0, 946, 7861,
		1, 0, 0, 0, 948, 7863, 1, 0, 0, 0, 950, 7885, 1, 0, 0, 0, 952, 7887, 1,
		0, 0, 0, 954, 7899, 1, 0, 0, 0, 956, 7902, 1, 0, 0, 0, 958, 7913, 1, 0,
		0, 0, 960, 7921, 1, 0, 0, 0, 962, 7925, 1, 0, 0, 0, 964, 7932, 1, 0, 0,
		0, 966, 7936, 1, 0, 0, 0, 968, 7938, 1, 0, 0, 0, 970, 7941, 1, 0, 0, 0,
		972, 7950, 1, 0, 0, 0, 974, 7956, 1, 0, 0, 0, 976, 7958, 1, 0, 0, 0, 978,
		7960, 1, 0, 0, 0, 980, 7962, 1, 0, 0, 0, 982, 7964, 1, 0, 0, 0, 984, 7968,
		1, 0, 0, 0, 986, 7972, 1, 0, 0, 0, 988, 7974, 1, 0, 0, 0, 990, 7976, 1,
		0, 0, 0, 992, 7983, 1, 0, 0, 0, 994, 7985, 1, 0, 0, 0, 996, 7990, 1, 0,
		0, 0, 998, 7999, 1, 0, 0, 0, 1000, 8003, 1, 0, 0, 0, 1002, 8011, 1, 0,
		0, 0, 1004, 8016, 1, 0, 0, 0, 1006, 8088, 1, 0, 0, 0, 1008, 8090, 1, 0,
		0, 0, 1010, 8100, 1, 0, 0, 0, 1012, 8109, 1, 0, 0, 0, 1014, 8112, 1, 0,
		0, 0, 1016, 8123, 1, 0, 0, 0, 1018, 8125, 1, 0, 0, 0, 1020, 8130, 1, 0,
		0, 0, 1022, 8141, 1, 0, 0, 0, 1024, 8154, 1, 0, 0, 0, 1026, 8156, 1, 0,
		0, 0, 1028, 8167, 1, 0, 0, 0, 1030, 8180, 1, 0, 0, 0, 1032, 8182, 1, 0,
		0, 0, 1034, 8186, 1, 0, 0, 0, 1036, 8197, 1, 0, 0, 0, 1038, 8199, 1, 0,
		0, 0, 1040, 1042, 3, 2, 1, 0, 1041, 1040, 1, 0, 0, 0, 1042, 1043, 1, 0,
		0, 0, 1043, 1041, 1, 0, 0, 0, 1043, 1044, 1, 0, 0, 0, 1044, 1045, 1, 0,
		0, 0, 1045, 1046, 5, 0, 0, 1, 1046, 1, 1, 0, 0, 0, 1047, 1048, 3, 6, 3,
		0, 1048, 1049, 7, 0, 0, 0, 1049, 1052, 1, 0, 0, 0, 1050, 1052, 3, 4, 2,
		0, 1051, 1047, 1, 0, 0, 0, 1051, 1050, 1, 0, 0, 0, 1052, 3, 1, 0, 0, 0,
		1053, 1054, 5, 533, 0, 0, 1054, 5, 1, 0, 0, 0, 1055, 1296, 3, 750, 375,
		0, 1056, 1296, 3, 8, 4, 0, 1057, 1296, 3, 10, 5, 0, 1058, 1296, 3, 12,
		6, 0, 1059, 1296, 3, 14, 7, 0, 1060, 1296, 3, 16, 8, 0, 1061, 1296, 3,
		18, 9, 0, 1062, 1296, 3, 20, 10, 0, 1063, 1296, 3, 22, 11, 0, 1064, 1296,
		3, 24, 12, 0, 1065, 1296, 3, 26, 13, 0, 1066, 1296, 3, 28, 14, 0, 1067,
		1296, 3, 30, 15, 0, 1068, 1296, 3, 32, 16, 0, 1069, 1296, 3, 74, 37, 0,
		1070, 1296, 3, 104, 52, 0, 1071, 1296, 3, 92, 46, 0, 1072, 1296, 3, 76,
		38, 0, 1073, 1296, 3, 78, 39, 0, 1074, 1296, 3, 108, 54, 0, 1075, 1296,
		3, 110, 55, 0, 1076, 1296, 3, 88, 44, 0, 1077, 1296, 3, 102, 51, 0, 1078,
		1296, 3, 96, 48, 0, 1079, 1296, 3, 94, 47, 0, 1080, 1296, 3, 98, 49, 0,
		1081, 1296, 3, 80, 40, 0, 1082, 1296, 3, 112, 56, 0, 1083, 1296, 3, 100,
		50, 0, 1084, 1296, 3, 90, 45, 0, 1085, 1296, 3, 118, 59, 0, 1086, 1296,
		3, 120, 60, 0, 1087, 1296, 3, 122, 61, 0, 1088, 1296, 3, 114, 57, 0, 1089,
		1296, 3, 116, 58, 0, 1090, 1296, 3, 82, 41, 0, 1091, 1296, 3, 84, 42, 0,
		1092, 1296, 3, 106, 53, 0, 1093, 1296, 3, 126, 63, 0, 1094, 1296, 3, 130,
		65, 0, 1095, 1296, 3, 134, 67, 0, 1096, 1296, 3, 140, 70, 0, 1097, 1296,
		3, 142, 71, 0, 1098, 1296, 3, 144, 72, 0, 1099, 1296, 3, 146, 73, 0, 1100,
		1296, 3, 148, 74, 0, 1101, 1296, 3, 182, 91, 0, 1102, 1296, 3, 186, 93,
		0, 1103, 1296, 3, 188, 94, 0, 1104, 1296, 3, 184, 92, 0, 1105, 1296, 3,
		190, 95, 0, 1106, 1296, 3, 350, 175, 0, 1107, 1296, 3, 356, 178, 0, 1108,
		1296, 3, 358, 179, 0, 1109, 1296, 3, 360, 180, 0, 1110, 1296, 3, 362, 181,
		0, 1111, 1296, 3, 380, 190, 0, 1112, 1296, 3, 382, 191, 0, 1113, 1296,
		3, 384, 192, 0, 1114, 1296, 3, 386, 193, 0, 1115, 1296, 3, 388, 194, 0,
		1116, 1296, 3, 390, 195, 0, 1117, 1296, 3, 392, 196, 0, 1118, 1296, 3,
		150, 75, 0, 1119, 1296, 3, 152, 76, 0, 1120, 1296, 3, 154, 77, 0, 1121,
		1296, 3, 156, 78, 0, 1122, 1296, 3, 158, 79, 0, 1123, 1296, 3, 160, 80,
		0, 1124, 1296, 3, 162, 81, 0, 1125, 1296, 3, 164, 82, 0, 1126, 1296, 3,
		166, 83, 0, 1127, 1296, 3, 168, 84, 0, 1128, 1296, 3, 170, 85, 0, 1129,
		1296, 3, 694, 347, 0, 1130, 1296, 3, 172, 86, 0, 1131, 1296, 3, 174, 87,
		0, 1132, 1296, 3, 176, 88, 0, 1133, 1296, 3, 178, 89, 0, 1134, 1296, 3,
		180, 90, 0, 1135, 1296, 3, 394, 197, 0, 1136, 1296, 3, 398, 199, 0, 1137,
		1296, 3, 406, 203, 0, 1138, 1296, 3, 408, 204, 0, 1139, 1296, 3, 402, 201,
		0, 1140, 1296, 3, 404, 202, 0, 1141, 1296, 3, 410, 205, 0, 1142, 1296,
		3, 412, 206, 0, 1143, 1296, 3, 414, 207, 0, 1144, 1296, 3, 416, 208, 0,
		1145, 1296, 3, 418, 209, 0, 1146, 1296, 3, 426, 213, 0, 1147, 1296, 3,
		428, 214, 0, 1148, 1296, 3, 430, 215, 0, 1149, 1296, 3, 432, 216, 0, 1150,
		1296, 3, 434, 217, 0, 1151, 1296, 3, 436, 218, 0, 1152, 1296, 3, 438, 219,
		0, 1153, 1296, 3, 440, 220, 0, 1154, 1296, 3, 442, 221, 0, 1155, 1296,
		3, 446, 223, 0, 1156, 1296, 3, 448, 224, 0, 1157, 1296, 3, 450, 225, 0,
		1158, 1296, 3, 456, 228, 0, 1159, 1296, 3, 470, 235, 0, 1160, 1296, 3,
		472, 236, 0, 1161, 1296, 3, 474, 237, 0, 1162, 1296, 3, 476, 238, 0, 1163,
		1296, 3, 480, 240, 0, 1164, 1296, 3, 482, 241, 0, 1165, 1296, 3, 484, 242,
		0, 1166, 1296, 3, 486, 243, 0, 1167, 1296, 3, 488, 244, 0, 1168, 1296,
		3, 490, 245, 0, 1169, 1296, 3, 492, 246, 0, 1170, 1296, 3, 494, 247, 0,
		1171, 1296, 3, 496, 248, 0, 1172, 1296, 3, 498, 249, 0, 1173, 1296, 3,
		500, 250, 0, 1174, 1296, 3, 502, 251, 0, 1175, 1296, 3, 504, 252, 0, 1176,
		1296, 3, 506, 253, 0, 1177, 1296, 3, 508, 254, 0, 1178, 1296, 3, 510, 255,
		0, 1179, 1296, 3, 512, 256, 0, 1180, 1296, 3, 514, 257, 0, 1181, 1296,
		3, 516, 258, 0, 1182, 1296, 3, 518, 259, 0, 1183, 1296, 3, 520, 260, 0,
		1184, 1296, 3, 522, 261, 0, 1185, 1296, 3, 524, 262, 0, 1186, 1296, 3,
		526, 263, 0, 1187, 1296, 3, 528, 264, 0, 1188, 1296, 3, 530, 265, 0, 1189,
		1296, 3, 532, 266, 0, 1190, 1296, 3, 534, 267, 0, 1191, 1296, 3, 536, 268,
		0, 1192, 1296, 3, 538, 269, 0, 1193, 1296, 3, 540, 270, 0, 1194, 1296,
		3, 542, 271, 0, 1195, 1296, 3, 544, 272, 0, 1196, 1296, 3, 546, 273, 0,
		1197, 1296, 3, 548, 274, 0, 1198, 1296, 3, 550, 275, 0, 1199, 1296, 3,
		552, 276, 0, 1200, 1296, 3, 554, 277, 0, 1201, 1296, 3, 556, 278, 0, 1202,
		1296, 3, 558, 279, 0, 1203, 1296, 3, 560, 280, 0, 1204, 1296, 3, 564, 282,
		0, 1205, 1296, 3, 566, 283, 0, 1206, 1296, 3, 568, 284, 0, 1207, 1296,
		3, 586, 293, 0, 1208, 1296, 3, 588, 294, 0, 1209, 1296, 3, 590, 295, 0,
		1210, 1296, 3, 592, 296, 0, 1211, 1296, 3, 594, 297, 0, 1212, 1296, 3,
		596, 298, 0, 1213, 1296, 3, 598, 299, 0, 1214, 1296, 3, 600, 300, 0, 1215,
		1296, 3, 602, 301, 0, 1216, 1296, 3, 604, 302, 0, 1217, 1296, 3, 606, 303,
		0, 1218, 1296, 3, 608, 304, 0, 1219, 1296, 3, 610, 305, 0, 1220, 1296,
		3, 612, 306, 0, 1221, 1296, 3, 614, 307, 0, 1222, 1296, 3, 616, 308, 0,
		1223, 1296, 3, 618, 309, 0, 1224, 1296, 3, 620, 310, 0, 1225, 1296, 3,
		622, 311, 0, 1226, 1296, 3, 624, 312, 0, 1227, 1296, 3, 626, 313, 0, 1228,
		1296, 3, 628, 314, 0, 1229, 1296, 3, 630, 315, 0, 1230, 1296, 3, 632, 316,
		0, 1231, 1296, 3, 634, 317, 0, 1232, 1296, 3, 638, 319, 0, 1233, 1296,
		3, 640, 320, 0, 1234, 1296, 3, 642, 321, 0, 1235, 1296, 3, 644, 322, 0,
		1236, 1296, 3, 646, 323, 0, 1237, 1296, 3, 648, 324, 0, 1238, 1296, 3,
		650, 325, 0, 1239, 1296, 3, 652, 326, 0, 1240, 1296, 3, 654, 327, 0, 1241,
		1296, 3, 656, 328, 0, 1242, 1296, 3, 658, 329, 0, 1243, 1296, 3, 660, 330,
		0, 1244, 1296, 3, 662, 331, 0, 1245, 1296, 3, 676, 338, 0, 1246, 1296,
		3, 690, 345, 0, 1247, 1296, 3, 192, 96, 0, 1248, 1296, 3, 202, 101, 0,
		1249, 1296, 3, 200, 100, 0, 1250, 1296, 3, 198, 99, 0, 1251, 1296, 3, 210,
		105, 0, 1252, 1296, 3, 212, 106, 0, 1253, 1296, 3, 664, 332, 0, 1254, 1296,
		3, 666, 333, 0, 1255, 1296, 3, 670, 335, 0, 1256, 1296, 3, 674, 337, 0,
		1257, 1296, 3, 672, 336, 0, 1258, 1296, 3, 478, 239, 0, 1259, 1296, 3,
		214, 107, 0, 1260, 1296, 3, 216, 108, 0, 1261, 1296, 3, 830, 415, 0, 1262,
		1296, 3, 834, 417, 0, 1263, 1296, 3, 836, 418, 0, 1264, 1296, 3, 218, 109,
		0, 1265, 1296, 3, 220, 110, 0, 1266, 1296, 3, 222, 111, 0, 1267, 1296,
		3, 224, 112, 0, 1268, 1296, 3, 226, 113, 0, 1269, 1296, 3, 702, 351, 0,
		1270, 1296, 3, 704, 352, 0, 1271, 1296, 3, 706, 353, 0, 1272, 1296, 3,
		708, 354, 0, 1273, 1296, 3, 710, 355, 0, 1274, 1296, 3, 712, 356, 0, 1275,
		1296, 3, 714, 357, 0, 1276, 1296, 3, 716, 358, 0, 1277, 1296, 3, 718, 359,
		0, 1278, 1296, 3, 720, 360, 0, 1279, 1296, 3, 722, 361, 0, 1280, 1296,
		3, 724, 362, 0, 1281, 1296, 3, 726, 363, 0, 1282, 1296, 3, 728, 364, 0,
		1283, 1296, 3, 730, 365, 0, 1284, 1296, 3, 732, 366, 0, 1285, 1296, 3,
		734, 367, 0, 1286, 1296, 3, 736, 368, 0, 1287, 1296, 3, 738, 369, 0, 1288,
		1296, 3, 740, 370, 0, 1289, 1296, 3, 742, 371, 0, 1290, 1296, 3, 744, 372,
		0, 1291, 1296, 3, 420, 210, 0, 1292, 1296, 3, 422, 211, 0, 1293, 1296,
		3, 424, 212, 0, 1294, 1296, 3, 696, 348, 0, 1295, 1055, 1, 0, 0, 0, 1295,
		1056, 1, 0, 0, 0, 1295, 1057, 1, 0, 0, 0, 1295, 1058, 1, 0, 0, 0, 1295,
		1059, 1, 0, 0, 0, 1295, 1060, 1, 0, 0, 0, 1295, 1061, 1, 0, 0, 0, 1295,
		1062, 1, 0, 0, 0, 1295, 1063, 1, 0, 0, 0, 1295, 1064, 1, 0, 0, 0, 1295,
		1065, 1, 0, 0, 0, 1295, 1066, 1, 0, 0, 0, 1295, 1067, 1, 0, 0, 0, 1295,
		1068, 1, 0, 0, 0, 1295, 1069, 1, 0, 0, 0, 1295, 1070, 1, 0, 0, 0, 1295,
		1071, 1, 0, 0, 0, 1295, 1072, 1, 0, 0, 0, 1295, 1073, 1, 0, 0, 0, 1295,
		1074, 1, 0, 0, 0, 1295, 1075, 1, 0, 0, 0, 1295, 1076, 1, 0, 0, 0, 1295,
		1077, 1, 0, 0, 0, 1295, 1078, 1, 0, 0, 0, 1295, 1079, 1, 0, 0, 0, 1295,
		1080, 1, 0, 0, 0, 1295, 1081, 1, 0, 0, 0, 1295, 1082, 1, 0, 0, 0, 1295,
		1083, 1, 0, 0, 0, 1295, 1084, 1, 0, 0, 0, 1295, 1085, 1, 0, 0, 0, 1295,
		1086, 1, 0, 0, 0, 1295, 1087, 1, 0, 0, 0, 1295, 1088, 1, 0, 0, 0, 1295,
		1089, 1, 0, 0, 0, 1295, 1090, 1, 0, 0, 0, 1295, 1091, 1, 0, 0, 0, 1295,
		1092, 1, 0, 0, 0, 1295, 1093, 1, 0, 0, 0, 1295, 1094, 1, 0, 0, 0, 1295,
		1095, 1, 0, 0, 0, 1295, 1096, 1, 0, 0, 0, 1295, 1097, 1, 0, 0, 0, 1295,
		1098, 1, 0, 0, 0, 1295, 1099, 1, 0, 0, 0, 1295, 1100, 1, 0, 0, 0, 1295,
		1101, 1, 0, 0, 0, 1295, 1102, 1, 0, 0, 0, 1295, 1103, 1, 0, 0, 0, 1295,
		1104, 1, 0, 0, 0, 1295, 1105, 1, 0, 0, 0, 1295, 1106, 1, 0, 0, 0, 1295,
		1107, 1, 0, 0, 0, 1295, 1108, 1, 0, 0, 0, 1295, 1109, 1, 0, 0, 0, 1295,
		1110, 1, 0, 0, 0, 1295, 1111, 1, 0, 0, 0, 1295, 1112, 1, 0, 0, 0, 1295,
		1113, 1, 0, 0, 0, 1295, 1114, 1, 0, 0, 0, 1295, 1115, 1, 0, 0, 0, 1295,
		1116, 1, 0, 0, 0, 1295, 1117, 1, 0, 0, 0, 1295, 1118, 1, 0, 0, 0, 1295,
		1119, 1, 0, 0, 0, 1295, 1120, 1, 0, 0, 0, 1295, 1121, 1, 0, 0, 0, 1295,
		1122, 1, 0, 0, 0, 1295, 1123, 1, 0, 0, 0, 1295, 1124, 1, 0, 0, 0, 1295,
		1125, 1, 0, 0, 0, 1295, 1126, 1, 0, 0, 0, 1295, 1127, 1, 0, 0, 0, 1295,
		1128, 1, 0, 0, 0, 1295, 1129, 1, 0, 0, 0, 1295, 1130, 1, 0, 0, 0, 1295,
		1131, 1, 0, 0, 0, 1295, 1132, 1, 0, 0, 0, 1295, 1133, 1, 0, 0, 0, 1295,
		1134, 1, 0, 0, 0, 1295, 1135, 1, 0, 0, 0, 1295, 1136, 1, 0, 0, 0, 1295,
		1137, 1, 0, 0, 0, 1295, 1138, 1, 0, 0, 0, 1295, 1139, 1, 0, 0, 0, 1295,
		1140, 1, 0, 0, 0, 1295, 1141, 1, 0, 0, 0, 1295, 1142, 1, 0, 0, 0, 1295,
		1143, 1, 0, 0, 0, 1295, 1144, 1, 0, 0, 0, 1295, 1145, 1, 0, 0, 0, 1295,
		1146, 1, 0, 0, 0, 1295, 1147, 1, 0, 0, 0, 1295, 1148, 1, 0, 0, 0, 1295,
		1149, 1, 0, 0, 0, 1295, 1150, 1, 0, 0, 0, 1295, 1151, 1, 0, 0, 0, 1295,
		1152, 1, 0, 0, 0, 1295, 1153, 1, 0, 0, 0, 1295, 1154, 1, 0, 0, 0, 1295,
		1155, 1, 0, 0, 0, 1295, 1156, 1, 0, 0, 0, 1295, 1157, 1, 0, 0, 0, 1295,
		1158, 1, 0, 0, 0, 1295, 1159, 1, 0, 0, 0, 1295, 1160, 1, 0, 0, 0, 1295,
		1161, 1, 0, 0, 0, 1295, 1162, 1, 0, 0, 0, 1295, 1163, 1, 0, 0, 0, 1295,
		1164, 1, 0, 0, 0, 1295, 1165, 1, 0, 0, 0, 1295, 1166, 1, 0, 0, 0, 1295,
		1167, 1, 0, 0, 0, 1295, 1168, 1, 0, 0, 0, 1295, 1169, 1, 0, 0, 0, 1295,
		1170, 1, 0, 0, 0, 1295, 1171, 1, 0, 0, 0, 1295, 1172, 1, 0, 0, 0, 1295,
		1173, 1, 0, 0, 0, 1295, 1174, 1, 0, 0, 0, 1295, 1175, 1, 0, 0, 0, 1295,
		1176, 1, 0, 0, 0, 1295, 1177, 1, 0, 0, 0, 1295, 1178, 1, 0, 0, 0, 1295,
		1179, 1, 0, 0, 0, 1295, 1180, 1, 0, 0, 0, 1295, 1181, 1, 0, 0, 0, 1295,
		1182, 1, 0, 0, 0, 1295, 1183, 1, 0, 0, 0, 1295, 1184, 1, 0, 0, 0, 1295,
		1185, 1, 0, 0, 0, 1295, 1186, 1, 0, 0, 0, 1295, 1187, 1, 0, 0, 0, 1295,
		1188, 1, 0, 0, 0, 1295, 1189, 1, 0, 0, 0, 1295, 1190, 1, 0, 0, 0, 1295,
		1191, 1, 0, 0, 0, 1295, 1192, 1, 0, 0, 0, 1295, 1193, 1, 0, 0, 0, 1295,
		1194, 1, 0, 0, 0, 1295, 1195, 1, 0, 0, 0, 1295, 1196, 1, 0, 0, 0, 1295,
		1197, 1, 0, 0, 0, 1295, 1198, 1, 0, 0, 0, 1295, 1199, 1, 0, 0, 0, 1295,
		1200, 1, 0, 0, 0, 1295, 1201, 1, 0, 0, 0, 1295, 1202, 1, 0, 0, 0, 1295,
		1203, 1, 0, 0, 0, 1295, 1204, 1, 0, 0, 0, 1295, 1205, 1, 0, 0, 0, 1295,
		1206, 1, 0, 0, 0, 1295, 1207, 1, 0, 0, 0, 1295, 1208, 1, 0, 0, 0, 1295,
		1209, 1, 0, 0, 0, 1295, 1210, 1, 0, 0, 0, 1295, 1211, 1, 0, 0, 0, 1295,
		1212, 1, 0, 0, 0, 1295, 1213, 1, 0, 0, 0, 1295, 1214, 1, 0, 0, 0, 1295,
		1215, 1, 0, 0, 0, 1295, 1216, 1, 0, 0, 0, 1295, 1217, 1, 0, 0, 0, 1295,
		1218, 1, 0, 0, 0, 1295, 1219, 1, 0, 0, 0, 1295, 1220, 1, 0, 0, 0, 1295,
		1221, 1, 0, 0, 0, 1295, 1222, 1, 0, 0, 0, 1295, 1223, 1, 0, 0, 0, 1295,
		1224, 1, 0, 0, 0, 1295, 1225, 1, 0, 0, 0, 1295, 1226, 1, 0, 0, 0, 1295,
		1227, 1, 0, 0, 0, 1295, 1228, 1, 0, 0, 0, 1295, 1229, 1, 0, 0, 0, 1295,
		1230, 1, 0, 0, 0, 1295, 1231, 1, 0, 0, 0, 1295, 1232, 1, 0, 0, 0, 1295,
		1233, 1, 0, 0, 0, 1295, 1234, 1, 0, 0, 0, 1295, 1235, 1, 0, 0, 0, 1295,
		1236, 1, 0, 0, 0, 1295, 1237, 1, 0, 0, 0, 1295, 1238, 1, 0, 0, 0, 1295,
		1239, 1, 0, 0, 0, 1295, 1240, 1, 0, 0, 0, 1295, 1241, 1, 0, 0, 0, 1295,
		1242, 1, 0, 0, 0, 1295, 1243, 1, 0, 0, 0, 1295, 1244, 1, 0, 0, 0, 1295,
		1245, 1, 0, 0, 0, 1295, 1246, 1, 0, 0, 0, 1295, 1247, 1, 0, 0, 0, 1295,
		1248, 1, 0, 0, 0, 1295, 1249, 1, 0, 0, 0, 1295, 1250, 1, 0, 0, 0, 1295,
		1251, 1, 0, 0, 0, 1295, 1252, 1, 0, 0, 0, 1295, 1253, 1, 0, 0, 0, 1295,
		1254, 1, 0, 0, 0, 1295, 1255, 1, 0, 0, 0, 1295, 1256, 1, 0, 0, 0, 1295,
		1257, 1, 0, 0, 0, 1295, 1258, 1, 0, 0, 0, 1295, 1259, 1, 0, 0, 0, 1295,
		1260, 1, 0, 0, 0, 1295, 1261, 1, 0, 0, 0, 1295, 1262, 1, 0, 0, 0, 1295,
		1263, 1, 0, 0, 0, 1295, 1264, 1, 0, 0, 0, 1295, 1265, 1, 0, 0, 0, 1295,
		1266, 1, 0, 0, 0, 1295, 1267, 1, 0, 0, 0, 1295, 1268, 1, 0, 0, 0, 1295,
		1269, 1, 0, 0, 0, 1295, 1270, 1, 0, 0, 0, 1295, 1271, 1, 0, 0, 0, 1295,
		1272, 1, 0, 0, 0, 1295, 1273, 1, 0, 0, 0, 1295, 1274, 1, 0, 0, 0, 1295,
		1275, 1, 0, 0, 0, 1295, 1276, 1, 0, 0, 0, 1295, 1277, 1, 0, 0, 0, 1295,
		1278, 1, 0, 0, 0, 1295, 1279, 1, 0, 0, 0, 1295, 1280, 1, 0, 0, 0, 1295,
		1281, 1, 0, 0, 0, 1295, 1282, 1, 0, 0, 0, 1295, 1283, 1, 0, 0, 0, 1295,
		1284, 1, 0, 0, 0, 1295, 1285, 1, 0, 0, 0, 1295, 1286, 1, 0, 0, 0, 1295,
		1287, 1, 0, 0, 0, 1295, 1288, 1, 0, 0, 0, 1295, 1289, 1, 0, 0, 0, 1295,
		1290, 1, 0, 0, 0, 1295, 1291, 1, 0, 0, 0, 1295, 1292, 1, 0, 0, 0, 1295,
		1293, 1, 0, 0, 0, 1295, 1294, 1, 0, 0, 0, 1296, 7, 1, 0, 0, 0, 1297, 1298,
		5, 458, 0, 0, 1298, 1299, 3, 1010, 505, 0, 1299, 9, 1, 0, 0, 0, 1300, 1301,
		5, 458, 0, 0, 1301, 1302, 3, 974, 487, 0, 1302, 11, 1, 0, 0, 0, 1303, 1304,
		5, 396, 0, 0, 1304, 1305, 5, 60, 0, 0, 1305, 1306, 3, 1024, 512, 0, 1306,
		13, 1, 0, 0, 0, 1307, 1308, 5, 401, 0, 0, 1308, 1311, 5, 105, 0, 0, 1309,
		1310, 7, 1, 0, 0, 1310, 1312, 3, 1010, 505, 0, 1311, 1309, 1, 0, 0, 0,
		1311, 1312, 1, 0, 0, 0, 1312, 1317, 1, 0, 0, 0, 1313, 1314, 5, 240, 0,
		0, 1314, 1318, 3, 974, 487, 0, 1315, 1316, 5, 479, 0, 0, 1316, 1318, 3,
		850, 425, 0, 1317, 1313, 1, 0, 0, 0, 1317, 1315, 1, 0, 0, 0, 1317, 1318,
		1, 0, 0, 0, 1318, 1328, 1, 0, 0, 0, 1319, 1320, 5, 401, 0, 0, 1320, 1325,
		5, 388, 0, 0, 1321, 1322, 5, 240, 0, 0, 1322, 1326, 3, 974, 487, 0, 1323,
		1324, 5, 479, 0, 0, 1324, 1326, 3, 850, 425, 0, 1325, 1321, 1, 0, 0, 0,
		1325, 1323, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 1328, 1, 0, 0, 0,
		1327, 1307, 1, 0, 0, 0, 1327, 1319, 1, 0, 0, 0, 1328, 15, 1, 0, 0, 0, 1329,
		1330, 5, 19, 0, 0, 1330, 1331, 5, 104, 0, 0, 1331, 1332, 3, 1016, 508,
		0, 1332, 1333, 5, 396, 0, 0, 1333, 1334, 5, 102, 0, 0, 1334, 1335, 5, 341,
		0, 0, 1335, 1336, 3, 1016, 508, 0, 1336, 1346, 1, 0, 0, 0, 1337, 1338,
		5, 19, 0, 0, 1338, 1339, 5, 104, 0, 0, 1339, 1340, 3, 1016, 508, 0, 1340,
		1341, 5, 396, 0, 0, 1341, 1342, 5, 358, 0, 0, 1342, 1343, 5, 341, 0, 0,
		1343, 1344, 5, 519, 0, 0, 1344, 1346, 1, 0, 0, 0, 1345, 1329, 1, 0, 0,
		0, 1345, 1337, 1, 0, 0, 0, 1346, 17, 1, 0, 0, 0, 1347, 1348, 5, 90, 0,
		0, 1348, 1352, 7, 2, 0, 0, 1349, 1350, 5, 197, 0, 0, 1350, 1351, 5, 281,
		0, 0, 1351, 1353, 5, 148, 0, 0, 1352, 1349, 1, 0, 0, 0, 1352, 1353, 1,
		0, 0, 0, 1353, 1357, 1, 0, 0, 0, 1354, 1355, 3, 1016, 508, 0, 1355, 1356,
		5, 1, 0, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1354, 1, 0, 0, 0, 1357, 1358,
		1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0, 1359, 1361, 3, 1010, 505, 0, 1360,
		1362, 3, 46, 23, 0, 1361, 1360, 1, 0, 0, 0, 1361, 1362, 1, 0, 0, 0, 1362,
		1364, 1, 0, 0, 0, 1363, 1365, 3, 48, 24, 0, 1364, 1363, 1, 0, 0, 0, 1364,
		1365, 1, 0, 0, 0, 1365, 1367, 1, 0, 0, 0, 1366, 1368, 3, 952, 476, 0, 1367,
		1366, 1, 0, 0, 0, 1367, 1368, 1, 0, 0, 0, 1368, 19, 1, 0, 0, 0, 1369, 1370,
		5, 132, 0, 0, 1370, 1373, 7, 2, 0, 0, 1371, 1372, 5, 197, 0, 0, 1372, 1374,
		5, 148, 0, 0, 1373, 1371, 1, 0, 0, 0, 1373, 1374, 1, 0, 0, 0, 1374, 1378,
		1, 0, 0, 0, 1375, 1376, 3, 1016, 508, 0, 1376, 1377, 5, 1, 0, 0, 1377,
		1379, 1, 0, 0, 0, 1378, 1375, 1, 0, 0, 0, 1378, 1379, 1, 0, 0, 0, 1379,
		1380, 1, 0, 0, 0, 1380, 1382, 3, 1010, 505, 0, 1381, 1383, 5, 169, 0, 0,
		1382, 1381, 1, 0, 0, 0, 1382, 1383, 1, 0, 0, 0, 1383, 21, 1, 0, 0, 0, 1384,
		1385, 5, 401, 0, 0, 1385, 1386, 5, 90, 0, 0, 1386, 1387, 7, 2, 0, 0, 1387,
		1388, 3, 1016, 508, 0, 1388, 23, 1, 0, 0, 0, 1389, 1390, 5, 19, 0, 0, 1390,
		1391, 5, 104, 0, 0, 1391, 1392, 3, 1016, 508, 0, 1392, 1393, 5, 353, 0,
		0, 1393, 1394, 3, 1016, 508, 0, 1394, 25, 1, 0, 0, 0, 1395, 1396, 5, 347,
		0, 0, 1396, 1397, 7, 2, 0, 0, 1397, 1398, 3, 1016, 508, 0, 1398, 27, 1,
		0, 0, 0, 1399, 1400, 5, 401, 0, 0, 1400, 1406, 5, 102, 0, 0, 1401, 1402,
		5, 401, 0, 0, 1402, 1403, 5, 102, 0, 0, 1403, 1404, 5, 172, 0, 0, 1404,
		1406, 3, 1010, 505, 0, 1405, 1399, 1, 0, 0, 0, 1405, 1401, 1, 0, 0, 0,
		1406, 29, 1, 0, 0, 0, 1407, 1408, 5, 401, 0, 0, 1408, 1409, 5, 102, 0,
		0, 1409, 1410, 5, 130, 0, 0, 1410, 1411, 5, 172, 0, 0, 1411, 1413, 3, 1010,
		505, 0, 1412, 1414, 3, 824, 412, 0, 1413, 1412, 1, 0, 0, 0, 1413, 1414,
		1, 0, 0, 0, 1414, 31, 1, 0, 0, 0, 1415, 1417, 5, 90, 0, 0, 1416, 1418,
		7, 3, 0, 0, 1417, 1416, 1, 0, 0, 0, 1417, 1418, 1, 0, 0, 0, 1418, 1419,
		1, 0, 0, 0, 1419, 1423, 5, 423, 0, 0, 1420, 1421, 5, 197, 0, 0, 1421, 1422,
		5, 281, 0, 0, 1422, 1424, 5, 148, 0, 0, 1423, 1420, 1, 0, 0, 0, 1423, 1424,
		1, 0, 0, 0, 1424, 1425, 1, 0, 0, 0, 1425, 1426, 3, 1010, 505, 0, 1426,
		1427, 5, 2, 0, 0, 1427, 1432, 3, 34, 17, 0, 1428, 1429, 5, 3, 0, 0, 1429,
		1431, 3, 34, 17, 0, 1430, 1428, 1, 0, 0, 0, 1431, 1434, 1, 0, 0, 0, 1432,
		1430, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 1439, 1, 0, 0, 0, 1434,
		1432, 1, 0, 0, 0, 1435, 1436, 5, 3, 0, 0, 1436, 1438, 3, 42, 21, 0, 1437,
		1435, 1, 0, 0, 0, 1438, 1441, 1, 0, 0, 0, 1439, 1437, 1, 0, 0, 0, 1439,
		1440, 1, 0, 0, 0, 1440, 1442, 1, 0, 0, 0, 1441, 1439, 1, 0, 0, 0, 1442,
		1444, 5, 4, 0, 0, 1443, 1445, 3, 44, 22, 0, 1444, 1443, 1, 0, 0, 0, 1444,
		1445, 1, 0, 0, 0, 1445, 1447, 1, 0, 0, 0, 1446, 1448, 3, 46, 23, 0, 1447,
		1446, 1, 0, 0, 0, 1447, 1448, 1, 0, 0, 0, 1448, 1450, 1, 0, 0, 0, 1449,
		1451, 3, 50, 25, 0, 1450, 1449, 1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451,
		1453, 1, 0, 0, 0, 1452, 1454, 3, 968, 484, 0, 1453, 1452, 1, 0, 0, 0, 1453,
		1454, 1, 0, 0, 0, 1454, 1456, 1, 0, 0, 0, 1455, 1457, 3, 908, 454, 0, 1456,
		1455, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1459, 1, 0, 0, 0, 1458,
		1460, 3, 946, 473, 0, 1459, 1458, 1, 0, 0, 0, 1459, 1460, 1, 0, 0, 0, 1460,
		1462, 1, 0, 0, 0, 1461, 1463, 3, 52, 26, 0, 1462, 1461, 1, 0, 0, 0, 1462,
		1463, 1, 0, 0, 0, 1463, 1465, 1, 0, 0, 0, 1464, 1466, 3, 62, 31, 0, 1465,
		1464, 1, 0, 0, 0, 1465, 1466, 1, 0, 0, 0, 1466, 1468, 1, 0, 0, 0, 1467,
		1469, 3, 952, 476, 0, 1468, 1467, 1, 0, 0, 0, 1468, 1469, 1, 0, 0, 0, 1469,
		1471, 1, 0, 0, 0, 1470, 1472, 3, 954, 477, 0, 1471, 1470, 1, 0, 0, 0, 1471,
		1472, 1, 0, 0, 0, 1472, 33, 1, 0, 0, 0, 1473, 1475, 3, 1016, 508, 0, 1474,
		1476, 3, 992, 496, 0, 1475, 1474, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476,
		1478, 1, 0, 0, 0, 1477, 1479, 3, 36, 18, 0, 1478, 1477, 1, 0, 0, 0, 1478,
		1479, 1, 0, 0, 0, 1479, 1481, 1, 0, 0, 0, 1480, 1482, 5, 227, 0, 0, 1481,
		1480, 1, 0, 0, 0, 1481, 1482, 1, 0, 0, 0, 1482, 1484, 1, 0, 0, 0, 1483,
		1485, 3, 60, 30, 0, 1484, 1483, 1, 0, 0, 0, 1484, 1485, 1, 0, 0, 0, 1485,
		1487, 1, 0, 0, 0, 1486, 1488, 3, 54, 27, 0, 1487, 1486, 1, 0, 0, 0, 1487,
		1488, 1, 0, 0, 0, 1488, 1492, 1, 0, 0, 0, 1489, 1493, 3, 38, 19, 0, 1490,
		1493, 5, 33, 0, 0, 1491, 1493, 3, 40, 20, 0, 1492, 1489, 1, 0, 0, 0, 1492,
		1490, 1, 0, 0, 0, 1492, 1491, 1, 0, 0, 0, 1492, 1493, 1, 0, 0, 0, 1493,
		1495, 1, 0, 0, 0, 1494, 1496, 3, 968, 484, 0, 1495, 1494, 1, 0, 0, 0, 1495,
		1496, 1, 0, 0, 0, 1496, 35, 1, 0, 0, 0, 1497, 1498, 5, 64, 0, 0, 1498,
		1499, 5, 396, 0, 0, 1499, 1506, 3, 1016, 508, 0, 1500, 1501, 5, 66, 0,
		0, 1501, 1506, 3, 1016, 508, 0, 1502, 1503, 5, 65, 0, 0, 1503, 1504, 5,
		396, 0, 0, 1504, 1506, 3, 1016, 508, 0, 1505, 1497, 1, 0, 0, 0, 1505, 1500,
		1, 0, 0, 0, 1505, 1502, 1, 0, 0, 0, 1506, 37, 1, 0, 0, 0, 1507, 1517, 5,
		117, 0, 0, 1508, 1518, 3, 974, 487, 0, 1509, 1518, 5, 282, 0, 0, 1510,
		1518, 5, 100, 0, 0, 1511, 1512, 5, 2, 0, 0, 1512, 1513, 3, 1010, 505, 0,
		1513, 1514, 5, 2, 0, 0, 1514, 1515, 5, 4, 0, 0, 1515, 1516, 5, 4, 0, 0,
		1516, 1518, 1, 0, 0, 0, 1517, 1508, 1, 0, 0, 0, 1517, 1509, 1, 0, 0, 0,
		1517, 1510, 1, 0, 0, 0, 1517, 1511, 1, 0, 0, 0, 1518, 39, 1, 0, 0, 0, 1519,
		1520, 5, 27, 0, 0, 1520, 1521, 3, 850, 425, 0, 1521, 41, 1, 0, 0, 0, 1522,
		1523, 5, 205, 0, 0, 1523, 1524, 3, 1016, 508, 0, 1524, 1529, 3, 1022, 511,
		0, 1525, 1527, 3, 86, 43, 0, 1526, 1528, 3, 956, 478, 0, 1527, 1526, 1,
		0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528, 1530, 1, 0, 0, 0, 1529, 1525, 1,
		0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 1532, 1, 0, 0, 0, 1531, 1533, 3,
		968, 484, 0, 1532, 1531, 1, 0, 0, 0, 1532, 1533, 1, 0, 0, 0, 1533, 43,
		1, 0, 0, 0, 1534, 1535, 5, 140, 0, 0, 1535, 1536, 5, 493, 0, 0, 1536, 1537,
		3, 1016, 508, 0, 1537, 45, 1, 0, 0, 0, 1538, 1540, 5, 117, 0, 0, 1539,
		1538, 1, 0, 0, 0, 1539, 1540, 1, 0, 0, 0, 1540, 1546, 1, 0, 0, 0, 1541,
		1542, 5, 64, 0, 0, 1542, 1547, 5, 396, 0, 0, 1543, 1547, 5, 66, 0, 0, 1544,
		1545, 5, 65, 0, 0, 1545, 1547, 5, 396, 0, 0, 1546, 1541, 1, 0, 0, 0, 1546,
		1543, 1, 0, 0, 0, 1546, 1544, 1, 0, 0, 0, 1547, 1549, 1, 0, 0, 0, 1548,
		1550, 5, 493, 0, 0, 1549, 1548, 1, 0, 0, 0, 1549, 1550, 1, 0, 0, 0, 1550,
		1551, 1, 0, 0, 0, 1551, 1552, 3, 1024, 512, 0, 1552, 47, 1, 0, 0, 0, 1553,
		1555, 5, 117, 0, 0, 1554, 1553, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555,
		1556, 1, 0, 0, 0, 1556, 1558, 5, 74, 0, 0, 1557, 1559, 5, 493, 0, 0, 1558,
		1557, 1, 0, 0, 0, 1558, 1559, 1, 0, 0, 0, 1559, 1560, 1, 0, 0, 0, 1560,
		1561, 3, 1024, 512, 0, 1561, 49, 1, 0, 0, 0, 1562, 1563, 7, 4, 0, 0, 1563,
		1564, 5, 227, 0, 0, 1564, 1565, 3, 1022, 511, 0, 1565, 51, 1, 0, 0, 0,
		1566, 1567, 5, 298, 0, 0, 1567, 1568, 5, 55, 0, 0, 1568, 1569, 3, 1022,
		511, 0, 1569, 53, 1, 0, 0, 0, 1570, 1574, 5, 282, 0, 0, 1571, 1572, 5,
		281, 0, 0, 1572, 1574, 5, 282, 0, 0, 1573, 1570, 1, 0, 0, 0, 1573, 1571,
		1, 0, 0, 0, 1574, 55, 1, 0, 0, 0, 1575, 1577, 3, 992, 496, 0, 1576, 1578,
		3, 54, 27, 0, 1577, 1576, 1, 0, 0, 0, 1577, 1578, 1, 0, 0, 0, 1578, 57,
		1, 0, 0, 0, 1579, 1580, 3, 1016, 508, 0, 1580, 1581, 5, 2, 0, 0, 1581,
		1586, 3, 56, 28, 0, 1582, 1583, 5, 3, 0, 0, 1583, 1585, 3, 56, 28, 0, 1584,
		1582, 1, 0, 0, 0, 1585, 1588, 1, 0, 0, 0, 1586, 1584, 1, 0, 0, 0, 1586,
		1587, 1, 0, 0, 0, 1587, 1589, 1, 0, 0, 0, 1588, 1586, 1, 0, 0, 0, 1589,
		1590, 5, 4, 0, 0, 1590, 59, 1, 0, 0, 0, 1591, 1601, 5, 416, 0, 0, 1592,
		1601, 5, 258, 0, 0, 1593, 1601, 5, 263, 0, 0, 1594, 1601, 5, 356, 0, 0,
		1595, 1601, 5, 191, 0, 0, 1596, 1601, 5, 45, 0, 0, 1597, 1601, 5, 311,
		0, 0, 1598, 1601, 5, 357, 0, 0, 1599, 1601, 3, 58, 29, 0, 1600, 1591, 1,
		0, 0, 0, 1600, 1592, 1, 0, 0, 0, 1600, 1593, 1, 0, 0, 0, 1600, 1594, 1,
		0, 0, 0, 1600, 1595, 1, 0, 0, 0, 1600, 1596, 1, 0, 0, 0, 1600, 1597, 1,
		0, 0, 0, 1600, 1598, 1, 0, 0, 0, 1600, 1599, 1, 0, 0, 0, 1601, 61, 1, 0,
		0, 0, 1602, 1603, 5, 376, 0, 0, 1603, 1604, 5, 2, 0, 0, 1604, 1609, 3,
		64, 32, 0, 1605, 1606, 5, 3, 0, 0, 1606, 1608, 3, 64, 32, 0, 1607, 1605,
		1, 0, 0, 0, 1608, 1611, 1, 0, 0, 0, 1609, 1607, 1, 0, 0, 0, 1609, 1610,
		1, 0, 0, 0, 1610, 1612, 1, 0, 0, 0, 1611, 1609, 1, 0, 0, 0, 1612, 1613,
		5, 4, 0, 0, 1613, 63, 1, 0, 0, 0, 1614, 1615, 3, 1016, 508, 0, 1615, 1617,
		3, 1022, 511, 0, 1616, 1618, 3, 66, 33, 0, 1617, 1616, 1, 0, 0, 0, 1617,
		1618, 1, 0, 0, 0, 1618, 1620, 1, 0, 0, 0, 1619, 1621, 3, 68, 34, 0, 1620,
		1619, 1, 0, 0, 0, 1620, 1621, 1, 0, 0, 0, 1621, 1623, 1, 0, 0, 0, 1622,
		1624, 3, 952, 476, 0, 1623, 1622, 1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624,
		65, 1, 0, 0, 0, 1625, 1626, 5, 134, 0, 0, 1626, 1627, 5, 227, 0, 0, 1627,
		1628, 3, 1022, 511, 0, 1628, 67, 1, 0, 0, 0, 1629, 1630, 5, 172, 0, 0,
		1630, 1631, 3, 1016, 508, 0, 1631, 69, 1, 0, 0, 0, 1632, 1633, 5, 297,
		0, 0, 1633, 1635, 5, 356, 0, 0, 1634, 1632, 1, 0, 0, 0, 1634, 1635, 1,
		0, 0, 0, 1635, 71, 1, 0, 0, 0, 1636, 1637, 5, 197, 0, 0, 1637, 1638, 5,
		281, 0, 0, 1638, 1640, 5, 148, 0, 0, 1639, 1636, 1, 0, 0, 0, 1639, 1640,
		1, 0, 0, 0, 1640, 73, 1, 0, 0, 0, 1641, 1643, 5, 90, 0, 0, 1642, 1644,
		5, 429, 0, 0, 1643, 1642, 1, 0, 0, 0, 1643, 1644, 1, 0, 0, 0, 1644, 1645,
		1, 0, 0, 0, 1645, 1649, 5, 423, 0, 0, 1646, 1647, 5, 197, 0, 0, 1647, 1648,
		5, 281, 0, 0, 1648, 1650, 5, 148, 0, 0, 1649, 1646, 1, 0, 0, 0, 1649, 1650,
		1, 0, 0, 0, 1650, 1651, 1, 0, 0, 0, 1651, 1680, 3, 1010, 505, 0, 1652,
		1676, 5, 2, 0, 0, 1653, 1658, 3, 1016, 508, 0, 1654, 1655, 5, 3, 0, 0,
		1655, 1657, 3, 1016, 508, 0, 1656, 1654, 1, 0, 0, 0, 1657, 1660, 1, 0,
		0, 0, 1658, 1656, 1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0, 1659, 1665, 1, 0,
		0, 0, 1660, 1658, 1, 0, 0, 0, 1661, 1662, 5, 3, 0, 0, 1662, 1664, 3, 42,
		21, 0, 1663, 1661, 1, 0, 0, 0, 1664, 1667, 1, 0, 0, 0, 1665, 1663, 1, 0,
		0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1677, 1, 0, 0, 0, 1667, 1665, 1, 0,
		0, 0, 1668, 1673, 3, 42, 21, 0, 1669, 1670, 5, 3, 0, 0, 1670, 1672, 3,
		42, 21, 0, 1671, 1669, 1, 0, 0, 0, 1672, 1675, 1, 0, 0, 0, 1673, 1671,
		1, 0, 0, 0, 1673, 1674, 1, 0, 0, 0, 1674, 1677, 1, 0, 0, 0, 1675, 1673,
		1, 0, 0, 0, 1676, 1653, 1, 0, 0, 0, 1676, 1668, 1, 0, 0, 0, 1677, 1678,
		1, 0, 0, 0, 1678, 1679, 5, 4, 0, 0, 1679, 1681, 1, 0, 0, 0, 1680, 1652,
		1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1683, 1, 0, 0, 0, 1682, 1684,
		3, 50, 25, 0, 1683, 1682, 1, 0, 0, 0, 1683, 1684, 1, 0, 0, 0, 1684, 1686,
		1, 0, 0, 0, 1685, 1687, 3, 968, 484, 0, 1686, 1685, 1, 0, 0, 0, 1686, 1687,
		1, 0, 0, 0, 1687, 1689, 1, 0, 0, 0, 1688, 1690, 3, 908, 454, 0, 1689, 1688,
		1, 0, 0, 0, 1689, 1690, 1, 0, 0, 0, 1690, 1692, 1, 0, 0, 0, 1691, 1693,
		3, 946, 473, 0, 1692, 1691, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693, 1695,
		1, 0, 0, 0, 1694, 1696, 3, 52, 26, 0, 1695, 1694, 1, 0, 0, 0, 1695, 1696,
		1, 0, 0, 0, 1696, 1698, 1, 0, 0, 0, 1697, 1699, 3, 952, 476, 0, 1698, 1697,
		1, 0, 0, 0, 1698, 1699, 1, 0, 0, 0, 1699, 1700, 1, 0, 0, 0, 1700, 1701,
		5, 27, 0, 0, 1701, 1702, 3, 750, 375, 0, 1702, 75, 1, 0, 0, 0, 1703, 1705,
		5, 132, 0, 0, 1704, 1706, 5, 429, 0, 0, 1705, 1704, 1, 0, 0, 0, 1705, 1706,
		1, 0, 0, 0, 1706, 1707, 1, 0, 0, 0, 1707, 1710, 5, 423, 0, 0, 1708, 1709,
		5, 197, 0, 0, 1709, 1711, 5, 148, 0, 0, 1710, 1708, 1, 0, 0, 0, 1710, 1711,
		1, 0, 0, 0, 1711, 1712, 1, 0, 0, 0, 1712, 1714, 3, 1010, 505, 0, 1713,
		1715, 5, 169, 0, 0, 1714, 1713, 1, 0, 0, 0, 1714, 1715, 1, 0, 0, 0, 1715,
		77, 1, 0, 0, 0, 1716, 1717, 5, 68, 0, 0, 1717, 1718, 5, 429, 0, 0, 1718,
		1719, 5, 423, 0, 0, 1719, 1720, 5, 290, 0, 0, 1720, 1721, 5, 395, 0, 0,
		1721, 1722, 3, 974, 487, 0, 1722, 79, 1, 0, 0, 0, 1723, 1724, 5, 19, 0,
		0, 1724, 1725, 5, 423, 0, 0, 1725, 1726, 3, 1010, 505, 0, 1726, 1731, 3,
		232, 116, 0, 1727, 1728, 5, 3, 0, 0, 1728, 1730, 3, 232, 116, 0, 1729,
		1727, 1, 0, 0, 0, 1730, 1733, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1731,
		1732, 1, 0, 0, 0, 1732, 1761, 1, 0, 0, 0, 1733, 1731, 1, 0, 0, 0, 1734,
		1735, 5, 19, 0, 0, 1735, 1736, 5, 423, 0, 0, 1736, 1737, 3, 1010, 505,
		0, 1737, 1738, 5, 13, 0, 0, 1738, 1739, 5, 376, 0, 0, 1739, 1744, 3, 64,
		32, 0, 1740, 1741, 5, 3, 0, 0, 1741, 1743, 3, 64, 32, 0, 1742, 1740, 1,
		0, 0, 0, 1743, 1746, 1, 0, 0, 0, 1744, 1742, 1, 0, 0, 0, 1744, 1745, 1,
		0, 0, 0, 1745, 1761, 1, 0, 0, 0, 1746, 1744, 1, 0, 0, 0, 1747, 1748, 5,
		19, 0, 0, 1748, 1749, 5, 423, 0, 0, 1749, 1750, 3, 1010, 505, 0, 1750,
		1751, 5, 132, 0, 0, 1751, 1752, 5, 376, 0, 0, 1752, 1757, 3, 1016, 508,
		0, 1753, 1754, 5, 3, 0, 0, 1754, 1756, 3, 1016, 508, 0, 1755, 1753, 1,
		0, 0, 0, 1756, 1759, 1, 0, 0, 0, 1757, 1755, 1, 0, 0, 0, 1757, 1758, 1,
		0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1760, 1723, 1,
		0, 0, 0, 1760, 1734, 1, 0, 0, 0, 1760, 1747, 1, 0, 0, 0, 1761, 81, 1, 0,
		0, 0, 1762, 1763, 5, 90, 0, 0, 1763, 1764, 5, 205, 0, 0, 1764, 1765, 3,
		1016, 508, 0, 1765, 1766, 5, 290, 0, 0, 1766, 1767, 3, 1010, 505, 0, 1767,
		1772, 3, 1022, 511, 0, 1768, 1770, 3, 86, 43, 0, 1769, 1771, 3, 956, 478,
		0, 1770, 1769, 1, 0, 0, 0, 1770, 1771, 1, 0, 0, 0, 1771, 1773, 1, 0, 0,
		0, 1772, 1768, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773, 1775, 1, 0, 0,
		0, 1774, 1776, 3, 968, 484, 0, 1775, 1774, 1, 0, 0, 0, 1775, 1776, 1, 0,
		0, 0, 1776, 83, 1, 0, 0, 0, 1777, 1778, 5, 132, 0, 0, 1778, 1779, 5, 205,
		0, 0, 1779, 1780, 3, 1016, 508, 0, 1780, 1781, 5, 290, 0, 0, 1781, 1782,
		3, 1010, 505, 0, 1782, 85, 1, 0, 0, 0, 1783, 1784, 5, 461, 0, 0, 1784,
		1785, 7, 5, 0, 0, 1785, 87, 1, 0, 0, 0, 1786, 1788, 5, 401, 0, 0, 1787,
		1789, 5, 175, 0, 0, 1788, 1787, 1, 0, 0, 0, 1788, 1789, 1, 0, 0, 0, 1789,
		1790, 1, 0, 0, 0, 1790, 1793, 5, 424, 0, 0, 1791, 1792, 7, 1, 0, 0, 1792,
		1794, 3, 1010, 505, 0, 1793, 1791, 1, 0, 0, 0, 1793, 1794, 1, 0, 0, 0,
		1794, 1799, 1, 0, 0, 0, 1795, 1796, 5, 240, 0, 0, 1796, 1800, 3, 974, 487,
		0, 1797, 1798, 5, 479, 0, 0, 1798, 1800, 3, 850, 425, 0, 1799, 1795, 1,
		0, 0, 0, 1799, 1797, 1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 89, 1, 0,
		0, 0, 1801, 1802, 5, 401, 0, 0, 1802, 1803, 5, 429, 0, 0, 1803, 1806, 5,
		424, 0, 0, 1804, 1805, 7, 1, 0, 0, 1805, 1807, 3, 1010, 505, 0, 1806, 1804,
		1, 0, 0, 0, 1806, 1807, 1, 0, 0, 0, 1807, 1812, 1, 0, 0, 0, 1808, 1809,
		5, 240, 0, 0, 1809, 1813, 3, 974, 487, 0, 1810, 1811, 5, 479, 0, 0, 1811,
		1813, 3, 850, 425, 0, 1812, 1808, 1, 0, 0, 0, 1812, 1810, 1, 0, 0, 0, 1812,
		1813, 1, 0, 0, 0, 1813, 91, 1, 0, 0, 0, 1814, 1815, 5, 401, 0, 0, 1815,
		1820, 5, 90, 0, 0, 1816, 1821, 5, 423, 0, 0, 1817, 1821, 5, 470, 0, 0,
		1818, 1819, 5, 257, 0, 0, 1819, 1821, 5, 470, 0, 0, 1820, 1816, 1, 0, 0,
		0, 1820, 1817, 1, 0, 0, 0, 1820, 1818, 1, 0, 0, 0, 1821, 1822, 1, 0, 0,
		0, 1822, 1823, 3, 1010, 505, 0, 1823, 93, 1, 0, 0, 0, 1824, 1826, 5, 401,
		0, 0, 1825, 1827, 5, 175, 0, 0, 1826, 1825, 1, 0, 0, 0, 1826, 1827, 1,
		0, 0, 0, 1827, 1828, 1, 0, 0, 0, 1828, 1829, 7, 6, 0, 0, 1829, 1830, 7,
		1, 0, 0, 1830, 1831, 3, 1010, 505, 0, 1831, 1834, 1, 0, 0, 0, 1832, 1833,
		7, 1, 0, 0, 1833, 1835, 3, 1010, 505, 0, 1834, 1832, 1, 0, 0, 0, 1834,
		1835, 1, 0, 0, 0, 1835, 1840, 1, 0, 0, 0, 1836, 1837, 5, 240, 0, 0, 1837,
		1841, 3, 974, 487, 0, 1838, 1839, 5, 479, 0, 0, 1839, 1841, 3, 850, 425,
		0, 1840, 1836, 1, 0, 0, 0, 1840, 1838, 1, 0, 0, 0, 1840, 1841, 1, 0, 0,
		0, 1841, 95, 1, 0, 0, 0, 1842, 1843, 5, 401, 0, 0, 1843, 1844, 5, 423,
		0, 0, 1844, 1847, 5, 409, 0, 0, 1845, 1846, 7, 1, 0, 0, 1846, 1848, 3,
		1010, 505, 0, 1847, 1845, 1, 0, 0, 0, 1847, 1848, 1, 0, 0, 0, 1848, 1853,
		1, 0, 0, 0, 1849, 1850, 5, 240, 0, 0, 1850, 1854, 3, 974, 487, 0, 1851,
		1852, 5, 479, 0, 0, 1852, 1854, 3, 850, 425, 0, 1853, 1849, 1, 0, 0, 0,
		1853, 1851, 1, 0, 0, 0, 1853, 1854, 1, 0, 0, 0, 1854, 97, 1, 0, 0, 0, 1855,
		1856, 5, 348, 0, 0, 1856, 1857, 5, 151, 0, 0, 1857, 1858, 5, 423, 0, 0,
		1858, 1871, 3, 1010, 505, 0, 1859, 1860, 5, 303, 0, 0, 1860, 1861, 5, 2,
		0, 0, 1861, 1866, 3, 974, 487, 0, 1862, 1863, 5, 3, 0, 0, 1863, 1865, 3,
		974, 487, 0, 1864, 1862, 1, 0, 0, 0, 1865, 1868, 1, 0, 0, 0, 1866, 1864,
		1, 0, 0, 0, 1866, 1867, 1, 0, 0, 0, 1867, 1869, 1, 0, 0, 0, 1868, 1866,
		1, 0, 0, 0, 1869, 1870, 5, 4, 0, 0, 1870, 1872, 1, 0, 0, 0, 1871, 1859,
		1, 0, 0, 0, 1871, 1872, 1, 0, 0, 0, 1872, 99, 1, 0, 0, 0, 1873, 1874, 5,
		401, 0, 0, 1874, 1875, 5, 19, 0, 0, 1875, 1876, 5, 423, 0, 0, 1876, 1879,
		7, 7, 0, 0, 1877, 1878, 7, 1, 0, 0, 1878, 1880, 3, 1010, 505, 0, 1879,
		1877, 1, 0, 0, 0, 1879, 1880, 1, 0, 0, 0, 1880, 1883, 1, 0, 0, 0, 1881,
		1882, 5, 479, 0, 0, 1882, 1884, 3, 850, 425, 0, 1883, 1881, 1, 0, 0, 0,
		1883, 1884, 1, 0, 0, 0, 1884, 1895, 1, 0, 0, 0, 1885, 1886, 5, 298, 0,
		0, 1886, 1887, 5, 55, 0, 0, 1887, 1892, 3, 768, 384, 0, 1888, 1889, 5,
		3, 0, 0, 1889, 1891, 3, 768, 384, 0, 1890, 1888, 1, 0, 0, 0, 1891, 1894,
		1, 0, 0, 0, 1892, 1890, 1, 0, 0, 0, 1892, 1893, 1, 0, 0, 0, 1893, 1896,
		1, 0, 0, 0, 1894, 1892, 1, 0, 0, 0, 1895, 1885, 1, 0, 0, 0, 1895, 1896,
		1, 0, 0, 0, 1896, 1898, 1, 0, 0, 0, 1897, 1899, 3, 772, 386, 0, 1898, 1897,
		1, 0, 0, 0, 1898, 1899, 1, 0, 0, 0, 1899, 1928, 1, 0, 0, 0, 1900, 1901,
		5, 401, 0, 0, 1901, 1902, 5, 19, 0, 0, 1902, 1903, 5, 257, 0, 0, 1903,
		1906, 5, 470, 0, 0, 1904, 1905, 7, 1, 0, 0, 1905, 1907, 3, 1010, 505, 0,
		1906, 1904, 1, 0, 0, 0, 1906, 1907, 1, 0, 0, 0, 1907, 1910, 1, 0, 0, 0,
		1908, 1909, 5, 479, 0, 0, 1909, 1911, 3, 850, 425, 0, 1910, 1908, 1, 0,
		0, 0, 1910, 1911, 1, 0, 0, 0, 1911, 1922, 1, 0, 0, 0, 1912, 1913, 5, 298,
		0, 0, 1913, 1914, 5, 55, 0, 0, 1914, 1919, 3, 768, 384, 0, 1915, 1916,
		5, 3, 0, 0, 1916, 1918, 3, 768, 384, 0, 1917, 1915, 1, 0, 0, 0, 1918, 1921,
		1, 0, 0, 0, 1919, 1917, 1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0, 1920, 1923,
		1, 0, 0, 0, 1921, 1919, 1, 0, 0, 0, 1922, 1912, 1, 0, 0, 0, 1922, 1923,
		1, 0, 0, 0, 1923, 1925, 1, 0, 0, 0, 1924, 1926, 3, 772, 386, 0, 1925, 1924,
		1, 0, 0, 0, 1925, 1926, 1, 0, 0, 0, 1926, 1928, 1, 0, 0, 0, 1927, 1873,
		1, 0, 0, 0, 1927, 1900, 1, 0, 0, 0, 1928, 101, 1, 0, 0, 0, 1929, 1936,
		7, 8, 0, 0, 1930, 1932, 3, 1010, 505, 0, 1931, 1933, 5, 18, 0, 0, 1932,
		1931, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933, 1937, 1, 0, 0, 0, 1934,
		1935, 5, 159, 0, 0, 1935, 1937, 3, 956, 478, 0, 1936, 1930, 1, 0, 0, 0,
		1936, 1934, 1, 0, 0, 0, 1937, 103, 1, 0, 0, 0, 1938, 1940, 5, 90, 0, 0,
		1939, 1941, 7, 3, 0, 0, 1940, 1939, 1, 0, 0, 0, 1940, 1941, 1, 0, 0, 0,
		1941, 1942, 1, 0, 0, 0, 1942, 1946, 5, 423, 0, 0, 1943, 1944, 5, 197, 0,
		0, 1944, 1945, 5, 281, 0, 0, 1945, 1947, 5, 148, 0, 0, 1946, 1943, 1, 0,
		0, 0, 1946, 1947, 1, 0, 0, 0, 1947, 1948, 1, 0, 0, 0, 1948, 1950, 3, 1010,
		505, 0, 1949, 1951, 3, 908, 454, 0, 1950, 1949, 1, 0, 0, 0, 1950, 1951,
		1, 0, 0, 0, 1951, 1953, 1, 0, 0, 0, 1952, 1954, 3, 946, 473, 0, 1953, 1952,
		1, 0, 0, 0, 1953, 1954, 1, 0, 0, 0, 1954, 1956, 1, 0, 0, 0, 1955, 1957,
		3, 952, 476, 0, 1956, 1955, 1, 0, 0, 0, 1956, 1957, 1, 0, 0, 0, 1957, 1958,
		1, 0, 0, 0, 1958, 1959, 5, 240, 0, 0, 1959, 1960, 3, 1010, 505, 0, 1960,
		105, 1, 0, 0, 0, 1961, 1962, 5, 401, 0, 0, 1962, 1963, 7, 9, 0, 0, 1963,
		1964, 7, 1, 0, 0, 1964, 1965, 3, 1010, 505, 0, 1965, 1968, 1, 0, 0, 0,
		1966, 1967, 7, 1, 0, 0, 1967, 1969, 3, 1010, 505, 0, 1968, 1966, 1, 0,
		0, 0, 1968, 1969, 1, 0, 0, 0, 1969, 107, 1, 0, 0, 0, 1970, 1971, 5, 347,
		0, 0, 1971, 1972, 5, 423, 0, 0, 1972, 1973, 3, 1010, 505, 0, 1973, 109,
		1, 0, 0, 0, 1974, 1975, 5, 446, 0, 0, 1975, 1976, 5, 423, 0, 0, 1976, 1978,
		3, 1010, 505, 0, 1977, 1979, 3, 824, 412, 0, 1978, 1977, 1, 0, 0, 0, 1978,
		1979, 1, 0, 0, 0, 1979, 111, 1, 0, 0, 0, 1980, 1981, 5, 57, 0, 0, 1981,
		1982, 5, 19, 0, 0, 1982, 1984, 5, 423, 0, 0, 1983, 1985, 7, 7, 0, 0, 1984,
		1983, 1, 0, 0, 0, 1984, 1985, 1, 0, 0, 0, 1985, 1986, 1, 0, 0, 0, 1986,
		1987, 5, 172, 0, 0, 1987, 1998, 3, 1010, 505, 0, 1988, 1989, 5, 2, 0, 0,
		1989, 1994, 5, 519, 0, 0, 1990, 1991, 5, 3, 0, 0, 1991, 1993, 5, 519, 0,
		0, 1992, 1990, 1, 0, 0, 0, 1993, 1996, 1, 0, 0, 0, 1994, 1992, 1, 0, 0,
		0, 1994, 1995, 1, 0, 0, 0, 1995, 1997, 1, 0, 0, 0, 1996, 1994, 1, 0, 0,
		0, 1997, 1999, 5, 4, 0, 0, 1998, 1988, 1, 0, 0, 0, 1998, 1999, 1, 0, 0,
		0, 1999, 2007, 1, 0, 0, 0, 2000, 2001, 5, 57, 0, 0, 2001, 2002, 5, 19,
		0, 0, 2002, 2003, 5, 257, 0, 0, 2003, 2004, 5, 470, 0, 0, 2004, 2005, 5,
		172, 0, 0, 2005, 2007, 3, 1010, 505, 0, 2006, 1980, 1, 0, 0, 0, 2006, 2000,
		1, 0, 0, 0, 2007, 113, 1, 0, 0, 0, 2008, 2010, 5, 401, 0, 0, 2009, 2011,
		5, 429, 0, 0, 2010, 2009, 1, 0, 0, 0, 2010, 2011, 1, 0, 0, 0, 2011, 2012,
		1, 0, 0, 0, 2012, 2013, 5, 304, 0, 0, 2013, 2014, 5, 172, 0, 0, 2014, 2017,
		3, 1010, 505, 0, 2015, 2016, 5, 479, 0, 0, 2016, 2018, 3, 850, 425, 0,
		2017, 2015, 1, 0, 0, 0, 2017, 2018, 1, 0, 0, 0, 2018, 2029, 1, 0, 0, 0,
		2019, 2020, 5, 298, 0, 0, 2020, 2021, 5, 55, 0, 0, 2021, 2026, 3, 768,
		384, 0, 2022, 2023, 5, 3, 0, 0, 2023, 2025, 3, 768, 384, 0, 2024, 2022,
		1, 0, 0, 0, 2025, 2028, 1, 0, 0, 0, 2026, 2024, 1, 0, 0, 0, 2026, 2027,
		1, 0, 0, 0, 2027, 2030, 1, 0, 0, 0, 2028, 2026, 1, 0, 0, 0, 2029, 2019,
		1, 0, 0, 0, 2029, 2030, 1, 0, 0, 0, 2030, 2032, 1, 0, 0, 0, 2031, 2033,
		3, 772, 386, 0, 2032, 2031, 1, 0, 0, 0, 2032, 2033, 1, 0, 0, 0, 2033, 115,
		1, 0, 0, 0, 2034, 2035, 5, 347, 0, 0, 2035, 2036, 5, 303, 0, 0, 2036, 2037,
		3, 1016, 508, 0, 2037, 2038, 5, 172, 0, 0, 2038, 2039, 3, 1010, 505, 0,
		2039, 117, 1, 0, 0, 0, 2040, 2043, 5, 90, 0, 0, 2041, 2042, 5, 297, 0,
		0, 2042, 2044, 5, 356, 0, 0, 2043, 2041, 1, 0, 0, 0, 2043, 2044, 1, 0,
		0, 0, 2044, 2045, 1, 0, 0, 0, 2045, 2049, 5, 470, 0, 0, 2046, 2047, 5,
		197, 0, 0, 2047, 2048, 5, 281, 0, 0, 2048, 2050, 5, 148, 0, 0, 2049, 2046,
		1, 0, 0, 0, 2049, 2050, 1, 0, 0, 0, 2050, 2051, 1, 0, 0, 0, 2051, 2063,
		3, 1010, 505, 0, 2052, 2053, 5, 2, 0, 0, 2053, 2058, 3, 124, 62, 0, 2054,
		2055, 5, 3, 0, 0, 2055, 2057, 3, 124, 62, 0, 2056, 2054, 1, 0, 0, 0, 2057,
		2060, 1, 0, 0, 0, 2058, 2056, 1, 0, 0, 0, 2058, 2059, 1, 0, 0, 0, 2059,
		2061, 1, 0, 0, 0, 2060, 2058, 1, 0, 0, 0, 2061, 2062, 5, 4, 0, 0, 2062,
		2064, 1, 0, 0, 0, 2063, 2052, 1, 0, 0, 0, 2063, 2064, 1, 0, 0, 0, 2064,
		2066, 1, 0, 0, 0, 2065, 2067, 3, 968, 484, 0, 2066, 2065, 1, 0, 0, 0, 2066,
		2067, 1, 0, 0, 0, 2067, 2070, 1, 0, 0, 0, 2068, 2069, 5, 390, 0, 0, 2069,
		2071, 7, 10, 0, 0, 2070, 2068, 1, 0, 0, 0, 2070, 2071, 1, 0, 0, 0, 2071,
		2072, 1, 0, 0, 0, 2072, 2073, 5, 27, 0, 0, 2073, 2074, 3, 750, 375, 0,
		2074, 119, 1, 0, 0, 0, 2075, 2076, 5, 19, 0, 0, 2076, 2077, 5, 470, 0,
		0, 2077, 2089, 3, 1010, 505, 0, 2078, 2079, 5, 2, 0, 0, 2079, 2084, 3,
		124, 62, 0, 2080, 2081, 5, 3, 0, 0, 2081, 2083, 3, 124, 62, 0, 2082, 2080,
		1, 0, 0, 0, 2083, 2086, 1, 0, 0, 0, 2084, 2082, 1, 0, 0, 0, 2084, 2085,
		1, 0, 0, 0, 2085, 2087, 1, 0, 0, 0, 2086, 2084, 1, 0, 0, 0, 2087, 2088,
		5, 4, 0, 0, 2088, 2090, 1, 0, 0, 0, 2089, 2078, 1, 0, 0, 0, 2089, 2090,
		1, 0, 0, 0, 2090, 2091, 1, 0, 0, 0, 2091, 2092, 5, 27, 0, 0, 2092, 2093,
		3, 750, 375, 0, 2093, 2118, 1, 0, 0, 0, 2094, 2095, 5, 19, 0, 0, 2095,
		2096, 5, 470, 0, 0, 2096, 2097, 3, 1010, 505, 0, 2097, 2098, 5, 396, 0,
		0, 2098, 2099, 5, 390, 0, 0, 2099, 2100, 7, 10, 0, 0, 2100, 2118, 1, 0,
		0, 0, 2101, 2102, 5, 19, 0, 0, 2102, 2103, 5, 470, 0, 0, 2103, 2104, 3,
		1010, 505, 0, 2104, 2105, 5, 396, 0, 0, 2105, 2106, 3, 952, 476, 0, 2106,
		2118, 1, 0, 0, 0, 2107, 2108, 5, 19, 0, 0, 2108, 2109, 5, 470, 0, 0, 2109,
		2110, 3, 1010, 505, 0, 2110, 2111, 7, 11, 0, 0, 2111, 2113, 5, 121, 0,
		0, 2112, 2114, 5, 406, 0, 0, 2113, 2112, 1, 0, 0, 0, 2113, 2114, 1, 0,
		0, 0, 2114, 2115, 1, 0, 0, 0, 2115, 2116, 3, 750, 375, 0, 2116, 2118, 1,
		0, 0, 0, 2117, 2075, 1, 0, 0, 0, 2117, 2094, 1, 0, 0, 0, 2117, 2101, 1,
		0, 0, 0, 2117, 2107, 1, 0, 0, 0, 2118, 121, 1, 0, 0, 0, 2119, 2120, 5,
		132, 0, 0, 2120, 2123, 5, 470, 0, 0, 2121, 2122, 5, 197, 0, 0, 2122, 2124,
		5, 148, 0, 0, 2123, 2121, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124, 2125,
		1, 0, 0, 0, 2125, 2126, 3, 1010, 505, 0, 2126, 123, 1, 0, 0, 0, 2127, 2129,
		3, 1016, 508, 0, 2128, 2130, 3, 968, 484, 0, 2129, 2128, 1, 0, 0, 0, 2129,
		2130, 1, 0, 0, 0, 2130, 125, 1, 0, 0, 0, 2131, 2132, 5, 415, 0, 0, 2132,
		2134, 5, 428, 0, 0, 2133, 2135, 3, 1010, 505, 0, 2134, 2133, 1, 0, 0, 0,
		2134, 2135, 1, 0, 0, 0, 2135, 2139, 1, 0, 0, 0, 2136, 2138, 3, 128, 64,
		0, 2137, 2136, 1, 0, 0, 0, 2138, 2141, 1, 0, 0, 0, 2139, 2137, 1, 0, 0,
		0, 2139, 2140, 1, 0, 0, 0, 2140, 2142, 1, 0, 0, 0, 2141, 2139, 1, 0, 0,
		0, 2142, 2146, 5, 27, 0, 0, 2143, 2147, 3, 74, 37, 0, 2144, 2147, 3, 350,
		175, 0, 2145, 2147, 3, 646, 323, 0, 2146, 2143, 1, 0, 0, 0, 2146, 2144,
		1, 0, 0, 0, 2146, 2145, 1, 0, 0, 0, 2147, 127, 1, 0, 0, 0, 2148, 2151,
		3, 952, 476, 0, 2149, 2151, 3, 132, 66, 0, 2150, 2148, 1, 0, 0, 0, 2150,
		2149, 1, 0, 0, 0, 2151, 129, 1, 0, 0, 0, 2152, 2153, 5, 132, 0, 0, 2153,
		2154, 5, 428, 0, 0, 2154, 2156, 3, 1010, 505, 0, 2155, 2157, 5, 169, 0,
		0, 2156, 2155, 1, 0, 0, 0, 2156, 2157, 1, 0, 0, 0, 2157, 131, 1, 0, 0,
		0, 2158, 2164, 5, 385, 0, 0, 2159, 2160, 5, 407, 0, 0, 2160, 2161, 5, 2,
		0, 0, 2161, 2162, 3, 974, 487, 0, 2162, 2163, 5, 4, 0, 0, 2163, 2165, 1,
		0, 0, 0, 2164, 2159, 1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2166, 1,
		0, 0, 0, 2166, 2167, 5, 153, 0, 0, 2167, 2168, 5, 2, 0, 0, 2168, 2169,
		3, 984, 492, 0, 2169, 2170, 5, 4, 0, 0, 2170, 133, 1, 0, 0, 0, 2171, 2172,
		5, 90, 0, 0, 2172, 2173, 5, 257, 0, 0, 2173, 2177, 5, 470, 0, 0, 2174,
		2175, 5, 197, 0, 0, 2175, 2176, 5, 281, 0, 0, 2176, 2178, 5, 148, 0, 0,
		2177, 2174, 1, 0, 0, 0, 2177, 2178, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0,
		2179, 2198, 3, 1010, 505, 0, 2180, 2181, 5, 2, 0, 0, 2181, 2186, 3, 124,
		62, 0, 2182, 2183, 5, 3, 0, 0, 2183, 2185, 3, 124, 62, 0, 2184, 2182, 1,
		0, 0, 0, 2185, 2188, 1, 0, 0, 0, 2186, 2184, 1, 0, 0, 0, 2186, 2187, 1,
		0, 0, 0, 2187, 2193, 1, 0, 0, 0, 2188, 2186, 1, 0, 0, 0, 2189, 2190, 5,
		3, 0, 0, 2190, 2192, 3, 42, 21, 0, 2191, 2189, 1, 0, 0, 0, 2192, 2195,
		1, 0, 0, 0, 2193, 2191, 1, 0, 0, 0, 2193, 2194, 1, 0, 0, 0, 2194, 2196,
		1, 0, 0, 0, 2195, 2193, 1, 0, 0, 0, 2196, 2197, 5, 4, 0, 0, 2197, 2199,
		1, 0, 0, 0, 2198, 2180, 1, 0, 0, 0, 2198, 2199, 1, 0, 0, 0, 2199, 2201,
		1, 0, 0, 0, 2200, 2202, 3, 968, 484, 0, 2201, 2200, 1, 0, 0, 0, 2201, 2202,
		1, 0, 0, 0, 2202, 2206, 1, 0, 0, 0, 2203, 2205, 3, 138, 69, 0, 2204, 2203,
		1, 0, 0, 0, 2205, 2208, 1, 0, 0, 0, 2206, 2204, 1, 0, 0, 0, 2206, 2207,
		1, 0, 0, 0, 2207, 2209, 1, 0, 0, 0, 2208, 2206, 1, 0, 0, 0, 2209, 2210,
		5, 27, 0, 0, 2210, 2211, 3, 750, 375, 0, 2211, 135, 1, 0, 0, 0, 2212, 2225,
		3, 864, 432, 0, 2213, 2214, 5, 2, 0, 0, 2214, 2219, 3, 864, 432, 0, 2215,
		2216, 5, 3, 0, 0, 2216, 2218, 3, 864, 432, 0, 2217, 2215, 1, 0, 0, 0, 2218,
		2221, 1, 0, 0, 0, 2219, 2217, 1, 0, 0, 0, 2219, 2220, 1, 0, 0, 0, 2220,
		2222, 1, 0, 0, 0, 2221, 2219, 1, 0, 0, 0, 2222, 2223, 5, 4, 0, 0, 2223,
		2225, 1, 0, 0, 0, 2224, 2212, 1, 0, 0, 0, 2224, 2213, 1, 0, 0, 0, 2225,
		137, 1, 0, 0, 0, 2226, 2227, 5, 303, 0, 0, 2227, 2228, 5, 55, 0, 0, 2228,
		2234, 3, 136, 68, 0, 2229, 2234, 3, 946, 473, 0, 2230, 2234, 3, 52, 26,
		0, 2231, 2234, 3, 948, 474, 0, 2232, 2234, 3, 952, 476, 0, 2233, 2226,
		1, 0, 0, 0, 2233, 2229, 1, 0, 0, 0, 2233, 2230, 1, 0, 0, 0, 2233, 2231,
		1, 0, 0, 0, 2233, 2232, 1, 0, 0, 0, 2234, 139, 1, 0, 0, 0, 2235, 2236,
		5, 401, 0, 0, 2236, 2237, 5, 257, 0, 0, 2237, 2240, 5, 471, 0, 0, 2238,
		2239, 7, 1, 0, 0, 2239, 2241, 3, 1010, 505, 0, 2240, 2238, 1, 0, 0, 0,
		2240, 2241, 1, 0, 0, 0, 2241, 2246, 1, 0, 0, 0, 2242, 2243, 5, 240, 0,
		0, 2243, 2247, 3, 974, 487, 0, 2244, 2245, 5, 479, 0, 0, 2245, 2247, 3,
		850, 425, 0, 2246, 2242, 1, 0, 0, 0, 2246, 2244, 1, 0, 0, 0, 2246, 2247,
		1, 0, 0, 0, 2247, 141, 1, 0, 0, 0, 2248, 2249, 5, 132, 0, 0, 2249, 2250,
		5, 257, 0, 0, 2250, 2253, 5, 470, 0, 0, 2251, 2252, 5, 197, 0, 0, 2252,
		2254, 5, 148, 0, 0, 2253, 2251, 1, 0, 0, 0, 2253, 2254, 1, 0, 0, 0, 2254,
		2255, 1, 0, 0, 0, 2255, 2256, 3, 1010, 505, 0, 2256, 143, 1, 0, 0, 0, 2257,
		2258, 5, 19, 0, 0, 2258, 2259, 5, 257, 0, 0, 2259, 2260, 5, 470, 0, 0,
		2260, 2265, 3, 1010, 505, 0, 2261, 2266, 3, 948, 474, 0, 2262, 2266, 3,
		272, 136, 0, 2263, 2266, 3, 276, 138, 0, 2264, 2266, 3, 274, 137, 0, 2265,
		2261, 1, 0, 0, 0, 2265, 2262, 1, 0, 0, 0, 2265, 2263, 1, 0, 0, 0, 2265,
		2264, 1, 0, 0, 0, 2266, 2274, 1, 0, 0, 0, 2267, 2268, 5, 19, 0, 0, 2268,
		2269, 5, 257, 0, 0, 2269, 2270, 5, 470, 0, 0, 2270, 2271, 3, 1010, 505,
		0, 2271, 2272, 3, 950, 475, 0, 2272, 2274, 1, 0, 0, 0, 2273, 2257, 1, 0,
		0, 0, 2273, 2267, 1, 0, 0, 0, 2274, 145, 1, 0, 0, 0, 2275, 2276, 5, 348,
		0, 0, 2276, 2277, 5, 257, 0, 0, 2277, 2278, 5, 470, 0, 0, 2278, 2284, 3,
		1010, 505, 0, 2279, 2282, 5, 303, 0, 0, 2280, 2283, 3, 934, 467, 0, 2281,
		2283, 3, 920, 460, 0, 2282, 2280, 1, 0, 0, 0, 2282, 2281, 1, 0, 0, 0, 2283,
		2285, 1, 0, 0, 0, 2284, 2279, 1, 0, 0, 0, 2284, 2285, 1, 0, 0, 0, 2285,
		2287, 1, 0, 0, 0, 2286, 2288, 5, 169, 0, 0, 2287, 2286, 1, 0, 0, 0, 2287,
		2288, 1, 0, 0, 0, 2288, 2292, 1, 0, 0, 0, 2289, 2290, 5, 481, 0, 0, 2290,
		2291, 7, 12, 0, 0, 2291, 2293, 5, 269, 0, 0, 2292, 2289, 1, 0, 0, 0, 2292,
		2293, 1, 0, 0, 0, 2293, 2297, 1, 0, 0, 0, 2294, 2295, 5, 481, 0, 0, 2295,
		2296, 5, 324, 0, 0, 2296, 2298, 5, 519, 0, 0, 2297, 2294, 1, 0, 0, 0, 2297,
		2298, 1, 0, 0, 0, 2298, 147, 1, 0, 0, 0, 2299, 2300, 5, 57, 0, 0, 2300,
		2301, 5, 348, 0, 0, 2301, 2302, 5, 257, 0, 0, 2302, 2303, 5, 470, 0, 0,
		2303, 2305, 3, 1010, 505, 0, 2304, 2306, 5, 169, 0, 0, 2305, 2304, 1, 0,
		0, 0, 2305, 2306, 1, 0, 0, 0, 2306, 149, 1, 0, 0, 0, 2307, 2308, 5, 14,
		0, 0, 2308, 2309, 5, 396, 0, 0, 2309, 2310, 5, 173, 0, 0, 2310, 2311, 5,
		84, 0, 0, 2311, 2312, 5, 2, 0, 0, 2312, 2313, 3, 960, 480, 0, 2313, 2316,
		5, 4, 0, 0, 2314, 2315, 5, 481, 0, 0, 2315, 2317, 5, 492, 0, 0, 2316, 2314,
		1, 0, 0, 0, 2316, 2317, 1, 0, 0, 0, 2317, 151, 1, 0, 0, 0, 2318, 2319,
		5, 14, 0, 0, 2319, 2320, 5, 396, 0, 0, 2320, 2321, 5, 358, 0, 0, 2321,
		2322, 5, 409, 0, 0, 2322, 2323, 3, 952, 476, 0, 2323, 153, 1, 0, 0, 0,
		2324, 2325, 5, 14, 0, 0, 2325, 2326, 5, 401, 0, 0, 2326, 2327, 5, 173,
		0, 0, 2327, 2330, 5, 84, 0, 0, 2328, 2329, 5, 240, 0, 0, 2329, 2331, 3,
		974, 487, 0, 2330, 2328, 1, 0, 0, 0, 2330, 2331, 1, 0, 0, 0, 2331, 155,
		1, 0, 0, 0, 2332, 2333, 5, 14, 0, 0, 2333, 2334, 5, 401, 0, 0, 2334, 2335,
		5, 358, 0, 0, 2335, 2336, 5, 130, 0, 0, 2336, 2337, 5, 172, 0, 0, 2337,
		2339, 3, 1010, 505, 0, 2338, 2340, 3, 824, 412, 0, 2339, 2338, 1, 0, 0,
		0, 2339, 2340, 1, 0, 0, 0, 2340, 157, 1, 0, 0, 0, 2341, 2342, 5, 14, 0,
		0, 2342, 2343, 5, 401, 0, 0, 2343, 2344, 5, 358, 0, 0, 2344, 2345, 5, 409,
		0, 0, 2345, 2346, 5, 172, 0, 0, 2346, 2348, 3, 1010, 505, 0, 2347, 2349,
		3, 824, 412, 0, 2348, 2347, 1, 0, 0, 0, 2348, 2349, 1, 0, 0, 0, 2349, 2352,
		1, 0, 0, 0, 2350, 2351, 5, 479, 0, 0, 2351, 2353, 3, 850, 425, 0, 2352,
		2350, 1, 0, 0, 0, 2352, 2353, 1, 0, 0, 0, 2353, 159, 1, 0, 0, 0, 2354,
		2355, 5, 14, 0, 0, 2355, 2356, 5, 354, 0, 0, 2356, 2357, 5, 423, 0, 0,
		2357, 2359, 3, 1010, 505, 0, 2358, 2360, 3, 824, 412, 0, 2359, 2358, 1,
		0, 0, 0, 2359, 2360, 1, 0, 0, 0, 2360, 161, 1, 0, 0, 0, 2361, 2362, 5,
		14, 0, 0, 2362, 2363, 5, 57, 0, 0, 2363, 2364, 5, 354, 0, 0, 2364, 2365,
		5, 423, 0, 0, 2365, 2367, 3, 1010, 505, 0, 2366, 2368, 3, 824, 412, 0,
		2367, 2366, 1, 0, 0, 0, 2367, 2368, 1, 0, 0, 0, 2368, 163, 1, 0, 0, 0,
		2369, 2370, 5, 14, 0, 0, 2370, 2371, 5, 67, 0, 0, 2371, 2372, 3, 828, 414,
		0, 2372, 2373, 5, 332, 0, 0, 2373, 2374, 5, 2, 0, 0, 2374, 2375, 3, 960,
		480, 0, 2375, 2376, 5, 4, 0, 0, 2376, 165, 1, 0, 0, 0, 2377, 2378, 5, 14,
		0, 0, 2378, 2379, 5, 396, 0, 0, 2379, 2380, 5, 423, 0, 0, 2380, 2381, 3,
		1010, 505, 0, 2381, 2382, 5, 303, 0, 0, 2382, 2385, 5, 2, 0, 0, 2383, 2386,
		3, 1024, 512, 0, 2384, 2386, 5, 519, 0, 0, 2385, 2383, 1, 0, 0, 0, 2385,
		2384, 1, 0, 0, 0, 2386, 2387, 1, 0, 0, 0, 2387, 2388, 5, 4, 0, 0, 2388,
		2389, 5, 469, 0, 0, 2389, 2390, 5, 441, 0, 0, 2390, 2391, 5, 519, 0, 0,
		2391, 167, 1, 0, 0, 0, 2392, 2397, 5, 229, 0, 0, 2393, 2395, 5, 85, 0,
		0, 2394, 2393, 1, 0, 0, 0, 2394, 2395, 1, 0, 0, 0, 2395, 2398, 1, 0, 0,
		0, 2396, 2398, 5, 338, 0, 0, 2397, 2394, 1, 0, 0, 0, 2397, 2396, 1, 0,
		0, 0, 2398, 2401, 1, 0, 0, 0, 2399, 2402, 5, 519, 0, 0, 2400, 2402, 3,
		974, 487, 0, 2401, 2399, 1, 0, 0, 0, 2401, 2400, 1, 0, 0, 0, 2402, 169,
		1, 0, 0, 0, 2403, 2404, 5, 418, 0, 0, 2404, 171, 1, 0, 0, 0, 2405, 2406,
		5, 14, 0, 0, 2406, 2407, 5, 396, 0, 0, 2407, 2408, 5, 32, 0, 0, 2408, 2409,
		5, 70, 0, 0, 2409, 2410, 5, 403, 0, 0, 2410, 2414, 5, 290, 0, 0, 2411,
		2412, 5, 411, 0, 0, 2412, 2413, 5, 472, 0, 0, 2413, 2415, 3, 1016, 508,
		0, 2414, 2411, 1, 0, 0, 0, 2414, 2415, 1, 0, 0, 0, 2415, 173, 1, 0, 0,
		0, 2416, 2417, 5, 14, 0, 0, 2417, 2418, 5, 396, 0, 0, 2418, 2419, 5, 32,
		0, 0, 2419, 2420, 5, 70, 0, 0, 2420, 2421, 5, 403, 0, 0, 2421, 2422, 5,
		288, 0, 0, 2422, 175, 1, 0, 0, 0, 2423, 2424, 5, 19, 0, 0, 2424, 2425,
		5, 419, 0, 0, 2425, 2426, 3, 232, 116, 0, 2426, 177, 1, 0, 0, 0, 2427,
		2428, 5, 57, 0, 0, 2428, 2429, 5, 116, 0, 0, 2429, 2430, 5, 35, 0, 0, 2430,
		2435, 3, 974, 487, 0, 2431, 2432, 5, 3, 0, 0, 2432, 2434, 3, 974, 487,
		0, 2433, 2431, 1, 0, 0, 0, 2434, 2437, 1, 0, 0, 0, 2435, 2433, 1, 0, 0,
		0, 2435, 2436, 1, 0, 0, 0, 2436, 179, 1, 0, 0, 0, 2437, 2435, 1, 0, 0,
		0, 2438, 2439, 5, 401, 0, 0, 2439, 2440, 5, 83, 0, 0, 2440, 2441, 5, 279,
		0, 0, 2441, 181, 1, 0, 0, 0, 2442, 2443, 5, 90, 0, 0, 2443, 2444, 5, 151,
		0, 0, 2444, 2448, 5, 60, 0, 0, 2445, 2446, 5, 197, 0, 0, 2446, 2447, 5,
		281, 0, 0, 2447, 2449, 5, 148, 0, 0, 2448, 2445, 1, 0, 0, 0, 2448, 2449,
		1, 0, 0, 0, 2449, 2450, 1, 0, 0, 0, 2450, 2452, 3, 1024, 512, 0, 2451,
		2453, 3, 968, 484, 0, 2452, 2451, 1, 0, 0, 0, 2452, 2453, 1, 0, 0, 0, 2453,
		2454, 1, 0, 0, 0, 2454, 2455, 3, 952, 476, 0, 2455, 183, 1, 0, 0, 0, 2456,
		2457, 5, 401, 0, 0, 2457, 2458, 5, 90, 0, 0, 2458, 2459, 5, 60, 0, 0, 2459,
		2460, 3, 1024, 512, 0, 2460, 185, 1, 0, 0, 0, 2461, 2462, 5, 132, 0, 0,
		2462, 2465, 5, 60, 0, 0, 2463, 2464, 5, 197, 0, 0, 2464, 2466, 5, 148,
		0, 0, 2465, 2463, 1, 0, 0, 0, 2465, 2466, 1, 0, 0, 0, 2466, 2467, 1, 0,
		0, 0, 2467, 2468, 3, 1024, 512, 0, 2468, 187, 1, 0, 0, 0, 2469, 2470, 5,
		401, 0, 0, 2470, 2473, 5, 61, 0, 0, 2471, 2472, 5, 240, 0, 0, 2472, 2474,
		3, 974, 487, 0, 2473, 2471, 1, 0, 0, 0, 2473, 2474, 1, 0, 0, 0, 2474, 189,
		1, 0, 0, 0, 2475, 2476, 5, 19, 0, 0, 2476, 2477, 5, 60, 0, 0, 2477, 2478,
		3, 1024, 512, 0, 2478, 2479, 3, 276, 138, 0, 2479, 191, 1, 0, 0, 0, 2480,
		2481, 5, 90, 0, 0, 2481, 2482, 5, 411, 0, 0, 2482, 2486, 5, 472, 0, 0,
		2483, 2484, 5, 197, 0, 0, 2484, 2485, 5, 281, 0, 0, 2485, 2487, 5, 148,
		0, 0, 2486, 2483, 1, 0, 0, 0, 2486, 2487, 1, 0, 0, 0, 2487, 2488, 1, 0,
		0, 0, 2488, 2489, 3, 1024, 512, 0, 2489, 2490, 3, 194, 97, 0, 2490, 2492,
		3, 196, 98, 0, 2491, 2493, 3, 968, 484, 0, 2492, 2491, 1, 0, 0, 0, 2492,
		2493, 1, 0, 0, 0, 2493, 2495, 1, 0, 0, 0, 2494, 2496, 3, 952, 476, 0, 2495,
		2494, 1, 0, 0, 0, 2495, 2496, 1, 0, 0, 0, 2496, 193, 1, 0, 0, 0, 2497,
		2498, 5, 447, 0, 0, 2498, 2499, 5, 493, 0, 0, 2499, 2500, 3, 1016, 508,
		0, 2500, 195, 1, 0, 0, 0, 2501, 2502, 5, 248, 0, 0, 2502, 2503, 5, 493,
		0, 0, 2503, 2504, 3, 924, 462, 0, 2504, 197, 1, 0, 0, 0, 2505, 2506, 5,
		401, 0, 0, 2506, 2507, 5, 411, 0, 0, 2507, 2510, 5, 473, 0, 0, 2508, 2509,
		5, 240, 0, 0, 2509, 2511, 3, 974, 487, 0, 2510, 2508, 1, 0, 0, 0, 2510,
		2511, 1, 0, 0, 0, 2511, 199, 1, 0, 0, 0, 2512, 2513, 5, 132, 0, 0, 2513,
		2514, 5, 411, 0, 0, 2514, 2517, 5, 472, 0, 0, 2515, 2516, 5, 197, 0, 0,
		2516, 2518, 5, 148, 0, 0, 2517, 2515, 1, 0, 0, 0, 2517, 2518, 1, 0, 0,
		0, 2518, 2519, 1, 0, 0, 0, 2519, 2520, 3, 1024, 512, 0, 2520, 201, 1, 0,
		0, 0, 2521, 2522, 5, 19, 0, 0, 2522, 2523, 5, 411, 0, 0, 2523, 2524, 5,
		472, 0, 0, 2524, 2525, 3, 1024, 512, 0, 2525, 2530, 3, 204, 102, 0, 2526,
		2527, 5, 3, 0, 0, 2527, 2529, 3, 204, 102, 0, 2528, 2526, 1, 0, 0, 0, 2529,
		2532, 1, 0, 0, 0, 2530, 2528, 1, 0, 0, 0, 2530, 2531, 1, 0, 0, 0, 2531,
		203, 1, 0, 0, 0, 2532, 2530, 1, 0, 0, 0, 2533, 2536, 3, 208, 104, 0, 2534,
		2536, 3, 206, 103, 0, 2535, 2533, 1, 0, 0, 0, 2535, 2534, 1, 0, 0, 0, 2536,
		205, 1, 0, 0, 0, 2537, 2538, 5, 396, 0, 0, 2538, 2539, 3, 956, 478, 0,
		2539, 207, 1, 0, 0, 0, 2540, 2541, 5, 78, 0, 0, 2541, 2542, 5, 493, 0,
		0, 2542, 2543, 3, 974, 487, 0, 2543, 209, 1, 0, 0, 0, 2544, 2545, 7, 8,
		0, 0, 2545, 2546, 5, 411, 0, 0, 2546, 2547, 5, 472, 0, 0, 2547, 2548, 3,
		1024, 512, 0, 2548, 211, 1, 0, 0, 0, 2549, 2550, 5, 396, 0, 0, 2550, 2551,
		3, 1024, 512, 0, 2551, 2552, 5, 27, 0, 0, 2552, 2553, 5, 117, 0, 0, 2553,
		2554, 5, 411, 0, 0, 2554, 2555, 5, 472, 0, 0, 2555, 213, 1, 0, 0, 0, 2556,
		2557, 5, 14, 0, 0, 2557, 2558, 7, 13, 0, 0, 2558, 2559, 5, 154, 0, 0, 2559,
		2567, 3, 974, 487, 0, 2560, 2565, 5, 481, 0, 0, 2561, 2562, 5, 519, 0,
		0, 2562, 2566, 5, 434, 0, 0, 2563, 2564, 5, 520, 0, 0, 2564, 2566, 5, 326,
		0, 0, 2565, 2561, 1, 0, 0, 0, 2565, 2563, 1, 0, 0, 0, 2566, 2568, 1, 0,
		0, 0, 2567, 2560, 1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2575, 1, 0,
		0, 0, 2569, 2573, 5, 290, 0, 0, 2570, 2571, 5, 35, 0, 0, 2571, 2574, 3,
		974, 487, 0, 2572, 2574, 5, 173, 0, 0, 2573, 2570, 1, 0, 0, 0, 2573, 2572,
		1, 0, 0, 0, 2574, 2576, 1, 0, 0, 0, 2575, 2569, 1, 0, 0, 0, 2575, 2576,
		1, 0, 0, 0, 2576, 215, 1, 0, 0, 0, 2577, 2578, 5, 401, 0, 0, 2578, 2581,
		5, 155, 0, 0, 2579, 2580, 5, 240, 0, 0, 2580, 2582, 3, 974, 487, 0, 2581,
		2579, 1, 0, 0, 0, 2581, 2582, 1, 0, 0, 0, 2582, 2586, 1, 0, 0, 0, 2583,
		2584, 5, 290, 0, 0, 2584, 2585, 5, 35, 0, 0, 2585, 2587, 3, 974, 487, 0,
		2586, 2583, 1, 0, 0, 0, 2586, 2587, 1, 0, 0, 0, 2587, 217, 1, 0, 0, 0,
		2588, 2589, 5, 90, 0, 0, 2589, 2590, 5, 122, 0, 0, 2590, 2591, 3, 230,
		115, 0, 2591, 2592, 5, 461, 0, 0, 2592, 2593, 3, 1010, 505, 0, 2593, 2594,
		5, 2, 0, 0, 2594, 2599, 3, 228, 114, 0, 2595, 2596, 5, 3, 0, 0, 2596, 2598,
		3, 228, 114, 0, 2597, 2595, 1, 0, 0, 0, 2598, 2601, 1, 0, 0, 0, 2599, 2597,
		1, 0, 0, 0, 2599, 2600, 1, 0, 0, 0, 2600, 2602, 1, 0, 0, 0, 2601, 2599,
		1, 0, 0, 0, 2602, 2604, 5, 4, 0, 0, 2603, 2605, 3, 952, 476, 0, 2604, 2603,
		1, 0, 0, 0, 2604, 2605, 1, 0, 0, 0, 2605, 219, 1, 0, 0, 0, 2606, 2607,
		5, 132, 0, 0, 2607, 2608, 5, 122, 0, 0, 2608, 2610, 3, 1010, 505, 0, 2609,
		2611, 5, 56, 0, 0, 2610, 2609, 1, 0, 0, 0, 2610, 2611, 1, 0, 0, 0, 2611,
		221, 1, 0, 0, 0, 2612, 2613, 5, 348, 0, 0, 2613, 2614, 5, 122, 0, 0, 2614,
		2615, 3, 1010, 505, 0, 2615, 223, 1, 0, 0, 0, 2616, 2617, 5, 401, 0, 0,
		2617, 2619, 5, 122, 0, 0, 2618, 2620, 3, 1010, 505, 0, 2619, 2618, 1, 0,
		0, 0, 2619, 2620, 1, 0, 0, 0, 2620, 225, 1, 0, 0, 0, 2621, 2622, 5, 57,
		0, 0, 2622, 2623, 5, 348, 0, 0, 2623, 2624, 5, 122, 0, 0, 2624, 2625, 3,
		1010, 505, 0, 2625, 227, 1, 0, 0, 0, 2626, 2627, 3, 1010, 505, 0, 2627,
		2628, 5, 227, 0, 0, 2628, 2633, 1, 0, 0, 0, 2629, 2630, 3, 1010, 505, 0,
		2630, 2631, 5, 462, 0, 0, 2631, 2633, 1, 0, 0, 0, 2632, 2626, 1, 0, 0,
		0, 2632, 2629, 1, 0, 0, 0, 2633, 229, 1, 0, 0, 0, 2634, 2635, 3, 1010,
		505, 0, 2635, 231, 1, 0, 0, 0, 2636, 2684, 3, 234, 117, 0, 2637, 2684,
		3, 236, 118, 0, 2638, 2684, 3, 238, 119, 0, 2639, 2684, 3, 240, 120, 0,
		2640, 2684, 3, 242, 121, 0, 2641, 2684, 3, 244, 122, 0, 2642, 2684, 3,
		246, 123, 0, 2643, 2684, 3, 248, 124, 0, 2644, 2684, 3, 250, 125, 0, 2645,
		2684, 3, 252, 126, 0, 2646, 2684, 3, 254, 127, 0, 2647, 2684, 3, 256, 128,
		0, 2648, 2684, 3, 258, 129, 0, 2649, 2684, 3, 260, 130, 0, 2650, 2684,
		3, 262, 131, 0, 2651, 2684, 3, 264, 132, 0, 2652, 2684, 3, 266, 133, 0,
		2653, 2684, 3, 268, 134, 0, 2654, 2684, 3, 270, 135, 0, 2655, 2684, 3,
		272, 136, 0, 2656, 2684, 3, 274, 137, 0, 2657, 2684, 3, 276, 138, 0, 2658,
		2684, 3, 284, 142, 0, 2659, 2684, 3, 286, 143, 0, 2660, 2684, 3, 288, 144,
		0, 2661, 2684, 3, 290, 145, 0, 2662, 2684, 3, 292, 146, 0, 2663, 2684,
		3, 294, 147, 0, 2664, 2684, 3, 296, 148, 0, 2665, 2684, 3, 298, 149, 0,
		2666, 2684, 3, 278, 139, 0, 2667, 2684, 3, 282, 141, 0, 2668, 2684, 3,
		304, 152, 0, 2669, 2684, 3, 306, 153, 0, 2670, 2684, 3, 310, 155, 0, 2671,
		2684, 3, 308, 154, 0, 2672, 2684, 3, 312, 156, 0, 2673, 2684, 3, 314, 157,
		0, 2674, 2684, 3, 316, 158, 0, 2675, 2684, 3, 336, 168, 0, 2676, 2684,
		3, 338, 169, 0, 2677, 2684, 3, 340, 170, 0, 2678, 2684, 3, 944, 472, 0,
		2679, 2684, 3, 342, 171, 0, 2680, 2684, 3, 344, 172, 0, 2681, 2684, 3,
		346, 173, 0, 2682, 2684, 3, 348, 174, 0, 2683, 2636, 1, 0, 0, 0, 2683,
		2637, 1, 0, 0, 0, 2683, 2638, 1, 0, 0, 0, 2683, 2639, 1, 0, 0, 0, 2683,
		2640, 1, 0, 0, 0, 2683, 2641, 1, 0, 0, 0, 2683, 2642, 1, 0, 0, 0, 2683,
		2643, 1, 0, 0, 0, 2683, 2644, 1, 0, 0, 0, 2683, 2645, 1, 0, 0, 0, 2683,
		2646, 1, 0, 0, 0, 2683, 2647, 1, 0, 0, 0, 2683, 2648, 1, 0, 0, 0, 2683,
		2649, 1, 0, 0, 0, 2683, 2650, 1, 0, 0, 0, 2683, 2651, 1, 0, 0, 0, 2683,
		2652, 1, 0, 0, 0, 2683, 2653, 1, 0, 0, 0, 2683, 2654, 1, 0, 0, 0, 2683,
		2655, 1, 0, 0, 0, 2683, 2656, 1, 0, 0, 0, 2683, 2657, 1, 0, 0, 0, 2683,
		2658, 1, 0, 0, 0, 2683, 2659, 1, 0, 0, 0, 2683, 2660, 1, 0, 0, 0, 2683,
		2661, 1, 0, 0, 0, 2683, 2662, 1, 0, 0, 0, 2683, 2663, 1, 0, 0, 0, 2683,
		2664, 1, 0, 0, 0, 2683, 2665, 1, 0, 0, 0, 2683, 2666, 1, 0, 0, 0, 2683,
		2667, 1, 0, 0, 0, 2683, 2668, 1, 0, 0, 0, 2683, 2669, 1, 0, 0, 0, 2683,
		2670, 1, 0, 0, 0, 2683, 2671, 1, 0, 0, 0, 2683, 2672, 1, 0, 0, 0, 2683,
		2673, 1, 0, 0, 0, 2683, 2674, 1, 0, 0, 0, 2683, 2675, 1, 0, 0, 0, 2683,
		2676, 1, 0, 0, 0, 2683, 2677, 1, 0, 0, 0, 2683, 2678, 1, 0, 0, 0, 2683,
		2679, 1, 0, 0, 0, 2683, 2680, 1, 0, 0, 0, 2683, 2681, 1, 0, 0, 0, 2683,
		2682, 1, 0, 0, 0, 2684, 233, 1, 0, 0, 0, 2685, 2686, 5, 13, 0, 0, 2686,
		2687, 7, 14, 0, 0, 2687, 2688, 3, 974, 487, 0, 2688, 235, 1, 0, 0, 0, 2689,
		2690, 5, 132, 0, 0, 2690, 2691, 7, 14, 0, 0, 2691, 2692, 3, 974, 487, 0,
		2692, 237, 1, 0, 0, 0, 2693, 2694, 5, 270, 0, 0, 2694, 2695, 5, 173, 0,
		0, 2695, 2696, 5, 192, 0, 0, 2696, 2697, 3, 974, 487, 0, 2697, 2698, 5,
		441, 0, 0, 2698, 2699, 3, 974, 487, 0, 2699, 239, 1, 0, 0, 0, 2700, 2701,
		5, 13, 0, 0, 2701, 2702, 5, 35, 0, 0, 2702, 2707, 3, 974, 487, 0, 2703,
		2704, 5, 3, 0, 0, 2704, 2706, 3, 974, 487, 0, 2705, 2703, 1, 0, 0, 0, 2706,
		2709, 1, 0, 0, 0, 2707, 2705, 1, 0, 0, 0, 2707, 2708, 1, 0, 0, 0, 2708,
		2717, 1, 0, 0, 0, 2709, 2707, 1, 0, 0, 0, 2710, 2711, 5, 218, 0, 0, 2711,
		2712, 5, 474, 0, 0, 2712, 2715, 3, 1024, 512, 0, 2713, 2714, 5, 72, 0,
		0, 2714, 2716, 3, 1024, 512, 0, 2715, 2713, 1, 0, 0, 0, 2715, 2716, 1,
		0, 0, 0, 2716, 2718, 1, 0, 0, 0, 2717, 2710, 1, 0, 0, 0, 2717, 2718, 1,
		0, 0, 0, 2718, 241, 1, 0, 0, 0, 2719, 2720, 5, 132, 0, 0, 2720, 2721, 5,
		35, 0, 0, 2721, 2726, 3, 974, 487, 0, 2722, 2723, 5, 3, 0, 0, 2723, 2725,
		3, 974, 487, 0, 2724, 2722, 1, 0, 0, 0, 2725, 2728, 1, 0, 0, 0, 2726, 2724,
		1, 0, 0, 0, 2726, 2727, 1, 0, 0, 0, 2727, 2736, 1, 0, 0, 0, 2728, 2726,
		1, 0, 0, 0, 2729, 2730, 5, 172, 0, 0, 2730, 2731, 5, 474, 0, 0, 2731, 2734,
		3, 1024, 512, 0, 2732, 2733, 5, 72, 0, 0, 2733, 2735, 3, 1024, 512, 0,
		2734, 2732, 1, 0, 0, 0, 2734, 2735, 1, 0, 0, 0, 2735, 2737, 1, 0, 0, 0,
		2736, 2729, 1, 0, 0, 0, 2736, 2737, 1, 0, 0, 0, 2737, 2739, 1, 0, 0, 0,
		2738, 2740, 5, 169, 0, 0, 2739, 2738, 1, 0, 0, 0, 2739, 2740, 1, 0, 0,
		0, 2740, 243, 1, 0, 0, 0, 2741, 2742, 5, 116, 0, 0, 2742, 2743, 5, 35,
		0, 0, 2743, 2748, 3, 974, 487, 0, 2744, 2745, 5, 3, 0, 0, 2745, 2747, 3,
		974, 487, 0, 2746, 2744, 1, 0, 0, 0, 2747, 2750, 1, 0, 0, 0, 2748, 2746,
		1, 0, 0, 0, 2748, 2749, 1, 0, 0, 0, 2749, 245, 1, 0, 0, 0, 2750, 2748,
		1, 0, 0, 0, 2751, 2752, 5, 270, 0, 0, 2752, 2753, 5, 35, 0, 0, 2753, 2754,
		5, 192, 0, 0, 2754, 2755, 3, 974, 487, 0, 2755, 2756, 5, 441, 0, 0, 2756,
		2757, 3, 974, 487, 0, 2757, 2765, 1, 0, 0, 0, 2758, 2759, 5, 270, 0, 0,
		2759, 2760, 5, 35, 0, 0, 2760, 2761, 3, 974, 487, 0, 2761, 2762, 5, 396,
		0, 0, 2762, 2763, 3, 956, 478, 0, 2763, 2765, 1, 0, 0, 0, 2764, 2751, 1,
		0, 0, 0, 2764, 2758, 1, 0, 0, 0, 2765, 247, 1, 0, 0, 0, 2766, 2767, 5,
		13, 0, 0, 2767, 2768, 5, 83, 0, 0, 2768, 2769, 5, 278, 0, 0, 2769, 2774,
		3, 974, 487, 0, 2770, 2771, 5, 3, 0, 0, 2771, 2773, 3, 974, 487, 0, 2772,
		2770, 1, 0, 0, 0, 2773, 2776, 1, 0, 0, 0, 2774, 2772, 1, 0, 0, 0, 2774,
		2775, 1, 0, 0, 0, 2775, 2784, 1, 0, 0, 0, 2776, 2774, 1, 0, 0, 0, 2777,
		2778, 5, 218, 0, 0, 2778, 2779, 5, 474, 0, 0, 2779, 2782, 3, 1024, 512,
		0, 2780, 2781, 5, 72, 0, 0, 2781, 2783, 3, 1024, 512, 0, 2782, 2780, 1,
		0, 0, 0, 2782, 2783, 1, 0, 0, 0, 2783, 2785, 1, 0, 0, 0, 2784, 2777, 1,
		0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785, 249, 1, 0, 0, 0, 2786, 2787, 5,
		132, 0, 0, 2787, 2788, 5, 83, 0, 0, 2788, 2789, 5, 278, 0, 0, 2789, 2794,
		3, 974, 487, 0, 2790, 2791, 5, 3, 0, 0, 2791, 2793, 3, 974, 487, 0, 2792,
		2790, 1, 0, 0, 0, 2793, 2796, 1, 0, 0, 0, 2794, 2792, 1, 0, 0, 0, 2794,
		2795, 1, 0, 0, 0, 2795, 2804, 1, 0, 0, 0, 2796, 2794, 1, 0, 0, 0, 2797,
		2798, 5, 172, 0, 0, 2798, 2799, 5, 474, 0, 0, 2799, 2802, 3, 1024, 512,
		0, 2800, 2801, 5, 72, 0, 0, 2801, 2803, 3, 1024, 512, 0, 2802, 2800, 1,
		0, 0, 0, 2802, 2803, 1, 0, 0, 0, 2803, 2805, 1, 0, 0, 0, 2804, 2797, 1,
		0, 0, 0, 2804, 2805, 1, 0, 0, 0, 2805, 251, 1, 0, 0, 0, 2806, 2807, 5,
		13, 0, 0, 2807, 2808, 5, 52, 0, 0, 2808, 2809, 3, 1024, 512, 0, 2809, 2814,
		3, 974, 487, 0, 2810, 2811, 5, 3, 0, 0, 2811, 2813, 3, 974, 487, 0, 2812,
		2810, 1, 0, 0, 0, 2813, 2816, 1, 0, 0, 0, 2814, 2812, 1, 0, 0, 0, 2814,
		2815, 1, 0, 0, 0, 2815, 2833, 1, 0, 0, 0, 2816, 2814, 1, 0, 0, 0, 2817,
		2818, 5, 132, 0, 0, 2818, 2819, 5, 52, 0, 0, 2819, 2820, 3, 1024, 512,
		0, 2820, 2825, 3, 974, 487, 0, 2821, 2822, 5, 3, 0, 0, 2822, 2824, 3, 974,
		487, 0, 2823, 2821, 1, 0, 0, 0, 2824, 2827, 1, 0, 0, 0, 2825, 2823, 1,
		0, 0, 0, 2825, 2826, 1, 0, 0, 0, 2826, 2833, 1, 0, 0, 0, 2827, 2825, 1,
		0, 0, 0, 2828, 2829, 5, 132, 0, 0, 2829, 2830, 5, 18, 0, 0, 2830, 2831,
		5, 52, 0, 0, 2831, 2833, 3, 1024, 512, 0, 2832, 2806, 1, 0, 0, 0, 2832,
		2817, 1, 0, 0, 0, 2832, 2828, 1, 0, 0, 0, 2833, 253, 1, 0, 0, 0, 2834,
		2835, 5, 396, 0, 0, 2835, 2836, 5, 243, 0, 0, 2836, 2837, 5, 142, 0, 0,
		2837, 2839, 5, 195, 0, 0, 2838, 2840, 3, 952, 476, 0, 2839, 2838, 1, 0,
		0, 0, 2839, 2840, 1, 0, 0, 0, 2840, 255, 1, 0, 0, 0, 2841, 2842, 5, 90,
		0, 0, 2842, 2843, 5, 201, 0, 0, 2843, 257, 1, 0, 0, 0, 2844, 2845, 5, 68,
		0, 0, 2845, 2846, 5, 425, 0, 0, 2846, 2847, 5, 386, 0, 0, 2847, 2848, 5,
		340, 0, 0, 2848, 259, 1, 0, 0, 0, 2849, 2850, 5, 116, 0, 0, 2850, 2851,
		5, 488, 0, 0, 2851, 2856, 3, 974, 487, 0, 2852, 2853, 5, 3, 0, 0, 2853,
		2855, 3, 974, 487, 0, 2854, 2852, 1, 0, 0, 0, 2855, 2858, 1, 0, 0, 0, 2856,
		2854, 1, 0, 0, 0, 2856, 2857, 1, 0, 0, 0, 2857, 2859, 1, 0, 0, 0, 2858,
		2856, 1, 0, 0, 0, 2859, 2860, 5, 290, 0, 0, 2860, 2861, 5, 35, 0, 0, 2861,
		2862, 3, 974, 487, 0, 2862, 261, 1, 0, 0, 0, 2863, 2864, 5, 57, 0, 0, 2864,
		2865, 5, 116, 0, 0, 2865, 2866, 5, 488, 0, 0, 2866, 2871, 3, 974, 487,
		0, 2867, 2868, 5, 3, 0, 0, 2868, 2870, 3, 974, 487, 0, 2869, 2867, 1, 0,
		0, 0, 2870, 2873, 1, 0, 0, 0, 2871, 2869, 1, 0, 0, 0, 2871, 2872, 1, 0,
		0, 0, 2872, 2874, 1, 0, 0, 0, 2873, 2871, 1, 0, 0, 0, 2874, 2875, 5, 290,
		0, 0, 2875, 2876, 5, 35, 0, 0, 2876, 2877, 3, 974, 487, 0, 2877, 263, 1,
		0, 0, 0, 2878, 2879, 5, 127, 0, 0, 2879, 2880, 5, 488, 0, 0, 2880, 2885,
		3, 974, 487, 0, 2881, 2882, 5, 3, 0, 0, 2882, 2884, 3, 974, 487, 0, 2883,
		2881, 1, 0, 0, 0, 2884, 2887, 1, 0, 0, 0, 2885, 2883, 1, 0, 0, 0, 2885,
		2886, 1, 0, 0, 0, 2886, 2888, 1, 0, 0, 0, 2887, 2885, 1, 0, 0, 0, 2888,
		2889, 5, 290, 0, 0, 2889, 2890, 5, 35, 0, 0, 2890, 2891, 3, 974, 487, 0,
		2891, 265, 1, 0, 0, 0, 2892, 2893, 5, 57, 0, 0, 2893, 2894, 5, 127, 0,
		0, 2894, 2895, 5, 488, 0, 0, 2895, 2900, 3, 974, 487, 0, 2896, 2897, 5,
		3, 0, 0, 2897, 2899, 3, 974, 487, 0, 2898, 2896, 1, 0, 0, 0, 2899, 2902,
		1, 0, 0, 0, 2900, 2898, 1, 0, 0, 0, 2900, 2901, 1, 0, 0, 0, 2901, 2903,
		1, 0, 0, 0, 2902, 2900, 1, 0, 0, 0, 2903, 2904, 5, 290, 0, 0, 2904, 2905,
		5, 35, 0, 0, 2905, 2906, 3, 974, 487, 0, 2906, 267, 1, 0, 0, 0, 2907, 2908,
		5, 13, 0, 0, 2908, 2909, 5, 205, 0, 0, 2909, 2910, 3, 1016, 508, 0, 2910,
		2915, 3, 1022, 511, 0, 2911, 2913, 3, 86, 43, 0, 2912, 2914, 3, 956, 478,
		0, 2913, 2912, 1, 0, 0, 0, 2913, 2914, 1, 0, 0, 0, 2914, 2916, 1, 0, 0,
		0, 2915, 2911, 1, 0, 0, 0, 2915, 2916, 1, 0, 0, 0, 2916, 2918, 1, 0, 0,
		0, 2917, 2919, 3, 968, 484, 0, 2918, 2917, 1, 0, 0, 0, 2918, 2919, 1, 0,
		0, 0, 2919, 269, 1, 0, 0, 0, 2920, 2921, 5, 132, 0, 0, 2921, 2922, 5, 205,
		0, 0, 2922, 2923, 3, 1016, 508, 0, 2923, 271, 1, 0, 0, 0, 2924, 2925, 5,
		353, 0, 0, 2925, 2926, 3, 1016, 508, 0, 2926, 273, 1, 0, 0, 0, 2927, 2928,
		5, 421, 0, 0, 2928, 2929, 5, 481, 0, 0, 2929, 2930, 3, 1016, 508, 0, 2930,
		275, 1, 0, 0, 0, 2931, 2932, 5, 396, 0, 0, 2932, 2933, 3, 956, 478, 0,
		2933, 277, 1, 0, 0, 0, 2934, 2935, 5, 78, 0, 0, 2935, 2936, 5, 493, 0,
		0, 2936, 2937, 3, 974, 487, 0, 2937, 279, 1, 0, 0, 0, 2938, 2939, 5, 41,
		0, 0, 2939, 2940, 3, 974, 487, 0, 2940, 2941, 5, 21, 0, 0, 2941, 2942,
		3, 974, 487, 0, 2942, 281, 1, 0, 0, 0, 2943, 2945, 3, 824, 412, 0, 2944,
		2943, 1, 0, 0, 0, 2944, 2945, 1, 0, 0, 0, 2945, 2947, 1, 0, 0, 0, 2946,
		2948, 3, 50, 25, 0, 2947, 2946, 1, 0, 0, 0, 2947, 2948, 1, 0, 0, 0, 2948,
		2950, 1, 0, 0, 0, 2949, 2951, 3, 908, 454, 0, 2950, 2949, 1, 0, 0, 0, 2950,
		2951, 1, 0, 0, 0, 2951, 2953, 1, 0, 0, 0, 2952, 2954, 3, 52, 26, 0, 2953,
		2952, 1, 0, 0, 0, 2953, 2954, 1, 0, 0, 0, 2954, 2956, 1, 0, 0, 0, 2955,
		2957, 3, 946, 473, 0, 2956, 2955, 1, 0, 0, 0, 2956, 2957, 1, 0, 0, 0, 2957,
		2959, 1, 0, 0, 0, 2958, 2960, 3, 280, 140, 0, 2959, 2958, 1, 0, 0, 0, 2959,
		2960, 1, 0, 0, 0, 2960, 283, 1, 0, 0, 0, 2961, 2962, 5, 13, 0, 0, 2962,
		2963, 5, 76, 0, 0, 2963, 2967, 3, 34, 17, 0, 2964, 2968, 5, 161, 0, 0,
		2965, 2966, 5, 16, 0, 0, 2966, 2968, 3, 1016, 508, 0, 2967, 2964, 1, 0,
		0, 0, 2967, 2965, 1, 0, 0, 0, 2967, 2968, 1, 0, 0, 0, 2968, 2971, 1, 0,
		0, 0, 2969, 2970, 7, 15, 0, 0, 2970, 2972, 3, 1016, 508, 0, 2971, 2969,
		1, 0, 0, 0, 2971, 2972, 1, 0, 0, 0, 2972, 2974, 1, 0, 0, 0, 2973, 2975,
		3, 952, 476, 0, 2974, 2973, 1, 0, 0, 0, 2974, 2975, 1, 0, 0, 0, 2975, 285,
		1, 0, 0, 0, 2976, 2977, 5, 13, 0, 0, 2977, 2978, 5, 76, 0, 0, 2978, 2979,
		5, 2, 0, 0, 2979, 2984, 3, 34, 17, 0, 2980, 2981, 5, 3, 0, 0, 2981, 2983,
		3, 34, 17, 0, 2982, 2980, 1, 0, 0, 0, 2983, 2986, 1, 0, 0, 0, 2984, 2982,
		1, 0, 0, 0, 2984, 2985, 1, 0, 0, 0, 2985, 2987, 1, 0, 0, 0, 2986, 2984,
		1, 0, 0, 0, 2987, 2990, 5, 4, 0, 0, 2988, 2989, 7, 15, 0, 0, 2989, 2991,
		3, 1016, 508, 0, 2990, 2988, 1, 0, 0, 0, 2990, 2991, 1, 0, 0, 0, 2991,
		2993, 1, 0, 0, 0, 2992, 2994, 3, 952, 476, 0, 2993, 2992, 1, 0, 0, 0, 2993,
		2994, 1, 0, 0, 0, 2994, 287, 1, 0, 0, 0, 2995, 2996, 5, 132, 0, 0, 2996,
		2997, 5, 76, 0, 0, 2997, 3000, 3, 1016, 508, 0, 2998, 2999, 5, 172, 0,
		0, 2999, 3001, 3, 1016, 508, 0, 3000, 2998, 1, 0, 0, 0, 3000, 3001, 1,
		0, 0, 0, 3001, 3003, 1, 0, 0, 0, 3002, 3004, 3, 952, 476, 0, 3003, 3002,
		1, 0, 0, 0, 3003, 3004, 1, 0, 0, 0, 3004, 289, 1, 0, 0, 0, 3005, 3006,
		5, 270, 0, 0, 3006, 3007, 5, 76, 0, 0, 3007, 3011, 3, 34, 17, 0, 3008,
		3012, 5, 161, 0, 0, 3009, 3010, 5, 16, 0, 0, 3010, 3012, 3, 1016, 508,
		0, 3011, 3008, 1, 0, 0, 0, 3011, 3009, 1, 0, 0, 0, 3011, 3012, 1, 0, 0,
		0, 3012, 3015, 1, 0, 0, 0, 3013, 3014, 5, 172, 0, 0, 3014, 3016, 3, 1016,
		508, 0, 3015, 3013, 1, 0, 0, 0, 3015, 3016, 1, 0, 0, 0, 3016, 3018, 1,
		0, 0, 0, 3017, 3019, 3, 952, 476, 0, 3018, 3017, 1, 0, 0, 0, 3018, 3019,
		1, 0, 0, 0, 3019, 291, 1, 0, 0, 0, 3020, 3021, 5, 353, 0, 0, 3021, 3022,
		5, 76, 0, 0, 3022, 3023, 3, 1016, 508, 0, 3023, 3024, 5, 441, 0, 0, 3024,
		3025, 3, 1016, 508, 0, 3025, 293, 1, 0, 0, 0, 3026, 3027, 5, 298, 0, 0,
		3027, 3028, 5, 55, 0, 0, 3028, 3031, 3, 1022, 511, 0, 3029, 3030, 5, 172,
		0, 0, 3030, 3032, 3, 1016, 508, 0, 3031, 3029, 1, 0, 0, 0, 3031, 3032,
		1, 0, 0, 0, 3032, 3034, 1, 0, 0, 0, 3033, 3035, 3, 952, 476, 0, 3034, 3033,
		1, 0, 0, 0, 3034, 3035, 1, 0, 0, 0, 3035, 295, 1, 0, 0, 0, 3036, 3037,
		5, 353, 0, 0, 3037, 3038, 5, 376, 0, 0, 3038, 3039, 3, 1016, 508, 0, 3039,
		3040, 3, 1016, 508, 0, 3040, 297, 1, 0, 0, 0, 3041, 3043, 7, 16, 0, 0,
		3042, 3041, 1, 0, 0, 0, 3042, 3043, 1, 0, 0, 0, 3043, 3044, 1, 0, 0, 0,
		3044, 3047, 5, 81, 0, 0, 3045, 3048, 3, 1016, 508, 0, 3046, 3048, 3, 1022,
		511, 0, 3047, 3045, 1, 0, 0, 0, 3047, 3046, 1, 0, 0, 0, 3047, 3048, 1,
		0, 0, 0, 3048, 299, 1, 0, 0, 0, 3049, 3052, 3, 1016, 508, 0, 3050, 3052,
		5, 500, 0, 0, 3051, 3049, 1, 0, 0, 0, 3051, 3050, 1, 0, 0, 0, 3052, 301,
		1, 0, 0, 0, 3053, 3059, 3, 300, 150, 0, 3054, 3058, 5, 529, 0, 0, 3055,
		3056, 5, 1, 0, 0, 3056, 3058, 3, 300, 150, 0, 3057, 3054, 1, 0, 0, 0, 3057,
		3055, 1, 0, 0, 0, 3058, 3061, 1, 0, 0, 0, 3059, 3057, 1, 0, 0, 0, 3059,
		3060, 1, 0, 0, 0, 3060, 303, 1, 0, 0, 0, 3061, 3059, 1, 0, 0, 0, 3062,
		3063, 5, 270, 0, 0, 3063, 3064, 5, 76, 0, 0, 3064, 3065, 3, 1016, 508,
		0, 3065, 3066, 5, 13, 0, 0, 3066, 3067, 5, 491, 0, 0, 3067, 3071, 3, 998,
		499, 0, 3068, 3072, 5, 161, 0, 0, 3069, 3070, 5, 16, 0, 0, 3070, 3072,
		3, 1016, 508, 0, 3071, 3068, 1, 0, 0, 0, 3071, 3069, 1, 0, 0, 0, 3071,
		3072, 1, 0, 0, 0, 3072, 3074, 1, 0, 0, 0, 3073, 3075, 3, 952, 476, 0, 3074,
		3073, 1, 0, 0, 0, 3074, 3075, 1, 0, 0, 0, 3075, 305, 1, 0, 0, 0, 3076,
		3077, 5, 270, 0, 0, 3077, 3078, 5, 76, 0, 0, 3078, 3079, 3, 1016, 508,
		0, 3079, 3080, 5, 132, 0, 0, 3080, 3081, 5, 491, 0, 0, 3081, 3083, 3, 302,
		151, 0, 3082, 3084, 3, 952, 476, 0, 3083, 3082, 1, 0, 0, 0, 3083, 3084,
		1, 0, 0, 0, 3084, 307, 1, 0, 0, 0, 3085, 3086, 5, 90, 0, 0, 3086, 3088,
		5, 297, 0, 0, 3087, 3085, 1, 0, 0, 0, 3087, 3088, 1, 0, 0, 0, 3088, 3089,
		1, 0, 0, 0, 3089, 3090, 5, 356, 0, 0, 3090, 3091, 5, 427, 0, 0, 3091, 3092,
		3, 1016, 508, 0, 3092, 3093, 3, 318, 159, 0, 3093, 3105, 1, 0, 0, 0, 3094,
		3095, 5, 90, 0, 0, 3095, 3099, 5, 427, 0, 0, 3096, 3097, 5, 197, 0, 0,
		3097, 3098, 5, 281, 0, 0, 3098, 3100, 5, 148, 0, 0, 3099, 3096, 1, 0, 0,
		0, 3099, 3100, 1, 0, 0, 0, 3100, 3101, 1, 0, 0, 0, 3101, 3102, 3, 1016,
		508, 0, 3102, 3103, 3, 318, 159, 0, 3103, 3105, 1, 0, 0, 0, 3104, 3087,
		1, 0, 0, 0, 3104, 3094, 1, 0, 0, 0, 3105, 309, 1, 0, 0, 0, 3106, 3107,
		5, 90, 0, 0, 3107, 3109, 5, 297, 0, 0, 3108, 3106, 1, 0, 0, 0, 3108, 3109,
		1, 0, 0, 0, 3109, 3110, 1, 0, 0, 0, 3110, 3111, 5, 356, 0, 0, 3111, 3112,
		5, 51, 0, 0, 3112, 3113, 3, 1016, 508, 0, 3113, 3114, 3, 320, 160, 0, 3114,
		3126, 1, 0, 0, 0, 3115, 3116, 5, 90, 0, 0, 3116, 3120, 5, 51, 0, 0, 3117,
		3118, 5, 197, 0, 0, 3118, 3119, 5, 281, 0, 0, 3119, 3121, 5, 148, 0, 0,
		3120, 3117, 1, 0, 0, 0, 3120, 3121, 1, 0, 0, 0, 3121, 3122, 1, 0, 0, 0,
		3122, 3123, 3, 1016, 508, 0, 3123, 3124, 3, 320, 160, 0, 3124, 3126, 1,
		0, 0, 0, 3125, 3108, 1, 0, 0, 0, 3125, 3115, 1, 0, 0, 0, 3126, 311, 1,
		0, 0, 0, 3127, 3128, 5, 132, 0, 0, 3128, 3131, 5, 51, 0, 0, 3129, 3130,
		5, 197, 0, 0, 3130, 3132, 5, 148, 0, 0, 3131, 3129, 1, 0, 0, 0, 3131, 3132,
		1, 0, 0, 0, 3132, 3133, 1, 0, 0, 0, 3133, 3134, 3, 1016, 508, 0, 3134,
		313, 1, 0, 0, 0, 3135, 3136, 5, 132, 0, 0, 3136, 3139, 5, 427, 0, 0, 3137,
		3138, 5, 197, 0, 0, 3138, 3140, 5, 148, 0, 0, 3139, 3137, 1, 0, 0, 0, 3139,
		3140, 1, 0, 0, 0, 3140, 3141, 1, 0, 0, 0, 3141, 3142, 3, 1016, 508, 0,
		3142, 315, 1, 0, 0, 0, 3143, 3144, 5, 147, 0, 0, 3144, 3145, 3, 868, 434,
		0, 3145, 317, 1, 0, 0, 0, 3146, 3147, 5, 27, 0, 0, 3147, 3148, 5, 287,
		0, 0, 3148, 3149, 5, 469, 0, 0, 3149, 3151, 3, 330, 165, 0, 3150, 3146,
		1, 0, 0, 0, 3150, 3151, 1, 0, 0, 0, 3151, 3153, 1, 0, 0, 0, 3152, 3154,
		3, 324, 162, 0, 3153, 3152, 1, 0, 0, 0, 3153, 3154, 1, 0, 0, 0, 3154, 319,
		1, 0, 0, 0, 3155, 3156, 5, 27, 0, 0, 3156, 3157, 5, 287, 0, 0, 3157, 3158,
		5, 469, 0, 0, 3158, 3160, 3, 330, 165, 0, 3159, 3155, 1, 0, 0, 0, 3159,
		3160, 1, 0, 0, 0, 3160, 3162, 1, 0, 0, 0, 3161, 3163, 3, 324, 162, 0, 3162,
		3161, 1, 0, 0, 0, 3162, 3163, 1, 0, 0, 0, 3163, 3165, 1, 0, 0, 0, 3164,
		3166, 3, 322, 161, 0, 3165, 3164, 1, 0, 0, 0, 3165, 3166, 1, 0, 0, 0, 3166,
		321, 1, 0, 0, 0, 3167, 3168, 5, 481, 0, 0, 3168, 3169, 5, 403, 0, 0, 3169,
		3170, 5, 366, 0, 0, 3170, 3182, 3, 328, 164, 0, 3171, 3172, 5, 481, 0,
		0, 3172, 3173, 5, 403, 0, 0, 3173, 3174, 5, 366, 0, 0, 3174, 3182, 3, 326,
		163, 0, 3175, 3176, 5, 481, 0, 0, 3176, 3177, 5, 403, 0, 0, 3177, 3178,
		5, 366, 0, 0, 3178, 3179, 3, 328, 164, 0, 3179, 3180, 3, 326, 163, 0, 3180,
		3182, 1, 0, 0, 0, 3181, 3167, 1, 0, 0, 0, 3181, 3171, 1, 0, 0, 0, 3181,
		3175, 1, 0, 0, 0, 3182, 323, 1, 0, 0, 0, 3183, 3184, 5, 365, 0, 0, 3184,
		3185, 3, 1036, 518, 0, 3185, 3186, 3, 332, 166, 0, 3186, 325, 1, 0, 0,
		0, 3187, 3188, 3, 1036, 518, 0, 3188, 3189, 3, 332, 166, 0, 3189, 327,
		1, 0, 0, 0, 3190, 3191, 3, 1036, 518, 0, 3191, 3192, 5, 404, 0, 0, 3192,
		329, 1, 0, 0, 0, 3193, 3194, 3, 1036, 518, 0, 3194, 331, 1, 0, 0, 0, 3195,
		3196, 7, 17, 0, 0, 3196, 333, 1, 0, 0, 0, 3197, 3198, 5, 2, 0, 0, 3198,
		3203, 5, 519, 0, 0, 3199, 3200, 5, 3, 0, 0, 3200, 3202, 5, 519, 0, 0, 3201,
		3199, 1, 0, 0, 0, 3202, 3205, 1, 0, 0, 0, 3203, 3201, 1, 0, 0, 0, 3203,
		3204, 1, 0, 0, 0, 3204, 3206, 1, 0, 0, 0, 3205, 3203, 1, 0, 0, 0, 3206,
		3207, 5, 4, 0, 0, 3207, 335, 1, 0, 0, 0, 3208, 3209, 5, 132, 0, 0, 3209,
		3210, 5, 492, 0, 0, 3210, 3211, 5, 205, 0, 0, 3211, 3212, 5, 290, 0, 0,
		3212, 3213, 5, 426, 0, 0, 3213, 3214, 3, 334, 167, 0, 3214, 337, 1, 0,
		0, 0, 3215, 3217, 5, 13, 0, 0, 3216, 3218, 5, 429, 0, 0, 3217, 3216, 1,
		0, 0, 0, 3217, 3218, 1, 0, 0, 0, 3218, 3222, 1, 0, 0, 0, 3219, 3223, 3,
		930, 465, 0, 3220, 3221, 5, 304, 0, 0, 3221, 3223, 3, 932, 466, 0, 3222,
		3219, 1, 0, 0, 0, 3222, 3220, 1, 0, 0, 0, 3223, 3225, 1, 0, 0, 0, 3224,
		3226, 3, 946, 473, 0, 3225, 3224, 1, 0, 0, 0, 3225, 3226, 1, 0, 0, 0, 3226,
		3228, 1, 0, 0, 0, 3227, 3229, 3, 952, 476, 0, 3228, 3227, 1, 0, 0, 0, 3228,
		3229, 1, 0, 0, 0, 3229, 3245, 1, 0, 0, 0, 3230, 3232, 5, 13, 0, 0, 3231,
		3233, 5, 429, 0, 0, 3232, 3231, 1, 0, 0, 0, 3232, 3233, 1, 0, 0, 0, 3233,
		3236, 1, 0, 0, 0, 3234, 3237, 3, 912, 456, 0, 3235, 3237, 3, 914, 457,
		0, 3236, 3234, 1, 0, 0, 0, 3236, 3235, 1, 0, 0, 0, 3237, 3239, 1, 0, 0,
		0, 3238, 3240, 3, 946, 473, 0, 3239, 3238, 1, 0, 0, 0, 3239, 3240, 1, 0,
		0, 0, 3240, 3242, 1, 0, 0, 0, 3241, 3243, 3, 952, 476, 0, 3242, 3241, 1,
		0, 0, 0, 3242, 3243, 1, 0, 0, 0, 3243, 3245, 1, 0, 0, 0, 3244, 3215, 1,
		0, 0, 0, 3244, 3230, 1, 0, 0, 0, 3245, 339, 1, 0, 0, 0, 3246, 3248, 5,
		132, 0, 0, 3247, 3249, 5, 429, 0, 0, 3248, 3247, 1, 0, 0, 0, 3248, 3249,
		1, 0, 0, 0, 3249, 3262, 1, 0, 0, 0, 3250, 3253, 5, 303, 0, 0, 3251, 3252,
		5, 197, 0, 0, 3252, 3254, 5, 148, 0, 0, 3253, 3251, 1, 0, 0, 0, 3253, 3254,
		1, 0, 0, 0, 3254, 3255, 1, 0, 0, 0, 3255, 3263, 3, 1016, 508, 0, 3256,
		3259, 5, 304, 0, 0, 3257, 3258, 5, 197, 0, 0, 3258, 3260, 5, 148, 0, 0,
		3259, 3257, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3261, 1, 0, 0, 0,
		3261, 3263, 3, 1022, 511, 0, 3262, 3250, 1, 0, 0, 0, 3262, 3256, 1, 0,
		0, 0, 3263, 3265, 1, 0, 0, 0, 3264, 3266, 5, 169, 0, 0, 3265, 3264, 1,
		0, 0, 0, 3265, 3266, 1, 0, 0, 0, 3266, 3302, 1, 0, 0, 0, 3267, 3269, 5,
		132, 0, 0, 3268, 3270, 5, 429, 0, 0, 3269, 3268, 1, 0, 0, 0, 3269, 3270,
		1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 3271, 3274, 5, 304, 0, 0, 3272, 3273,
		5, 197, 0, 0, 3273, 3275, 5, 148, 0, 0, 3274, 3272, 1, 0, 0, 0, 3274, 3275,
		1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3278, 3, 932, 466, 0, 3277, 3279,
		5, 169, 0, 0, 3278, 3277, 1, 0, 0, 0, 3278, 3279, 1, 0, 0, 0, 3279, 3302,
		1, 0, 0, 0, 3280, 3282, 5, 132, 0, 0, 3281, 3283, 5, 429, 0, 0, 3282, 3281,
		1, 0, 0, 0, 3282, 3283, 1, 0, 0, 0, 3283, 3284, 1, 0, 0, 0, 3284, 3287,
		5, 304, 0, 0, 3285, 3286, 5, 197, 0, 0, 3286, 3288, 5, 148, 0, 0, 3287,
		3285, 1, 0, 0, 0, 3287, 3288, 1, 0, 0, 0, 3288, 3289, 1, 0, 0, 0, 3289,
		3290, 5, 479, 0, 0, 3290, 3292, 3, 850, 425, 0, 3291, 3293, 5, 169, 0,
		0, 3292, 3291, 1, 0, 0, 0, 3292, 3293, 1, 0, 0, 0, 3293, 3302, 1, 0, 0,
		0, 3294, 3295, 5, 132, 0, 0, 3295, 3296, 5, 18, 0, 0, 3296, 3297, 5, 429,
		0, 0, 3297, 3299, 5, 304, 0, 0, 3298, 3300, 5, 169, 0, 0, 3299, 3298, 1,
		0, 0, 0, 3299, 3300, 1, 0, 0, 0, 3300, 3302, 1, 0, 0, 0, 3301, 3246, 1,
		0, 0, 0, 3301, 3267, 1, 0, 0, 0, 3301, 3280, 1, 0, 0, 0, 3301, 3294, 1,
		0, 0, 0, 3302, 341, 1, 0, 0, 0, 3303, 3304, 5, 446, 0, 0, 3304, 3305, 3,
		824, 412, 0, 3305, 343, 1, 0, 0, 0, 3306, 3307, 5, 270, 0, 0, 3307, 3313,
		5, 303, 0, 0, 3308, 3314, 3, 1016, 508, 0, 3309, 3314, 3, 1022, 511, 0,
		3310, 3311, 5, 2, 0, 0, 3311, 3312, 5, 503, 0, 0, 3312, 3314, 5, 4, 0,
		0, 3313, 3308, 1, 0, 0, 0, 3313, 3309, 1, 0, 0, 0, 3313, 3310, 1, 0, 0,
		0, 3314, 3315, 1, 0, 0, 0, 3315, 3316, 5, 396, 0, 0, 3316, 3321, 3, 956,
		478, 0, 3317, 3318, 5, 270, 0, 0, 3318, 3319, 5, 303, 0, 0, 3319, 3321,
		3, 946, 473, 0, 3320, 3306, 1, 0, 0, 0, 3320, 3317, 1, 0, 0, 0, 3321, 345,
		1, 0, 0, 0, 3322, 3323, 5, 356, 0, 0, 3323, 3324, 3, 824, 412, 0, 3324,
		3325, 5, 481, 0, 0, 3325, 3327, 3, 824, 412, 0, 3326, 3328, 3, 952, 476,
		0, 3327, 3326, 1, 0, 0, 0, 3327, 3328, 1, 0, 0, 0, 3328, 347, 1, 0, 0,
		0, 3329, 3330, 5, 353, 0, 0, 3330, 3331, 5, 303, 0, 0, 3331, 3332, 3, 1016,
		508, 0, 3332, 3333, 3, 1016, 508, 0, 3333, 349, 1, 0, 0, 0, 3334, 3336,
		3, 902, 451, 0, 3335, 3334, 1, 0, 0, 0, 3335, 3336, 1, 0, 0, 0, 3336, 3337,
		1, 0, 0, 0, 3337, 3338, 5, 210, 0, 0, 3338, 3351, 7, 18, 0, 0, 3339, 3341,
		3, 1010, 505, 0, 3340, 3342, 3, 1014, 507, 0, 3341, 3340, 1, 0, 0, 0, 3341,
		3342, 1, 0, 0, 0, 3342, 3344, 1, 0, 0, 0, 3343, 3345, 3, 824, 412, 0, 3344,
		3343, 1, 0, 0, 0, 3344, 3345, 1, 0, 0, 0, 3345, 3352, 1, 0, 0, 0, 3346,
		3347, 5, 159, 0, 0, 3347, 3352, 3, 956, 478, 0, 3348, 3349, 5, 46, 0, 0,
		3349, 3350, 5, 2, 0, 0, 3350, 3352, 5, 4, 0, 0, 3351, 3339, 1, 0, 0, 0,
		3351, 3346, 1, 0, 0, 0, 3351, 3348, 1, 0, 0, 0, 3352, 3356, 1, 0, 0, 0,
		3353, 3355, 3, 352, 176, 0, 3354, 3353, 1, 0, 0, 0, 3355, 3358, 1, 0, 0,
		0, 3356, 3354, 1, 0, 0, 0, 3356, 3357, 1, 0, 0, 0, 3357, 3360, 1, 0, 0,
		0, 3358, 3356, 1, 0, 0, 0, 3359, 3361, 3, 952, 476, 0, 3360, 3359, 1, 0,
		0, 0, 3360, 3361, 1, 0, 0, 0, 3361, 3372, 1, 0, 0, 0, 3362, 3373, 3, 750,
		375, 0, 3363, 3364, 5, 463, 0, 0, 3364, 3369, 3, 840, 420, 0, 3365, 3366,
		5, 3, 0, 0, 3366, 3368, 3, 840, 420, 0, 3367, 3365, 1, 0, 0, 0, 3368, 3371,
		1, 0, 0, 0, 3369, 3367, 1, 0, 0, 0, 3369, 3370, 1, 0, 0, 0, 3370, 3373,
		1, 0, 0, 0, 3371, 3369, 1, 0, 0, 0, 3372, 3362, 1, 0, 0, 0, 3372, 3363,
		1, 0, 0, 0, 3373, 351, 1, 0, 0, 0, 3374, 3379, 3, 354, 177, 0, 3375, 3376,
		5, 481, 0, 0, 3376, 3377, 5, 230, 0, 0, 3377, 3379, 3, 1016, 508, 0, 3378,
		3374, 1, 0, 0, 0, 3378, 3375, 1, 0, 0, 0, 3379, 353, 1, 0, 0, 0, 3380,
		3384, 3, 822, 411, 0, 3381, 3382, 5, 55, 0, 0, 3382, 3384, 5, 273, 0, 0,
		3383, 3380, 1, 0, 0, 0, 3383, 3381, 1, 0, 0, 0, 3384, 355, 1, 0, 0, 0,
		3385, 3387, 3, 902, 451, 0, 3386, 3385, 1, 0, 0, 0, 3386, 3387, 1, 0, 0,
		0, 3387, 3389, 1, 0, 0, 0, 3388, 3390, 3, 754, 377, 0, 3389, 3388, 1, 0,
		0, 0, 3389, 3390, 1, 0, 0, 0, 3390, 3391, 1, 0, 0, 0, 3391, 3392, 5, 456,
		0, 0, 3392, 3393, 3, 1010, 505, 0, 3393, 3394, 5, 396, 0, 0, 3394, 3395,
		3, 1034, 517, 0, 3395, 3398, 3, 776, 388, 0, 3396, 3397, 5, 479, 0, 0,
		3397, 3399, 3, 850, 425, 0, 3398, 3396, 1, 0, 0, 0, 3398, 3399, 1, 0, 0,
		0, 3399, 357, 1, 0, 0, 0, 3400, 3402, 3, 902, 451, 0, 3401, 3400, 1, 0,
		0, 0, 3401, 3402, 1, 0, 0, 0, 3402, 3404, 1, 0, 0, 0, 3403, 3405, 3, 754,
		377, 0, 3404, 3403, 1, 0, 0, 0, 3404, 3405, 1, 0, 0, 0, 3405, 3406, 1,
		0, 0, 0, 3406, 3407, 5, 118, 0, 0, 3407, 3408, 5, 172, 0, 0, 3408, 3410,
		3, 1010, 505, 0, 3409, 3411, 3, 824, 412, 0, 3410, 3409, 1, 0, 0, 0, 3410,
		3411, 1, 0, 0, 0, 3411, 3414, 1, 0, 0, 0, 3412, 3413, 5, 461, 0, 0, 3413,
		3415, 3, 790, 395, 0, 3414, 3412, 1, 0, 0, 0, 3414, 3415, 1, 0, 0, 0, 3415,
		3418, 1, 0, 0, 0, 3416, 3417, 5, 479, 0, 0, 3417, 3419, 3, 850, 425, 0,
		3418, 3416, 1, 0, 0, 0, 3418, 3419, 1, 0, 0, 0, 3419, 359, 1, 0, 0, 0,
		3420, 3421, 5, 90, 0, 0, 3421, 3422, 5, 377, 0, 0, 3422, 3426, 5, 243,
		0, 0, 3423, 3424, 3, 1010, 505, 0, 3424, 3425, 5, 1, 0, 0, 3425, 3427,
		1, 0, 0, 0, 3426, 3423, 1, 0, 0, 0, 3426, 3427, 1, 0, 0, 0, 3427, 3428,
		1, 0, 0, 0, 3428, 3429, 3, 1016, 508, 0, 3429, 3430, 5, 290, 0, 0, 3430,
		3439, 3, 1010, 505, 0, 3431, 3436, 3, 366, 183, 0, 3432, 3433, 5, 3, 0,
		0, 3433, 3435, 3, 366, 183, 0, 3434, 3432, 1, 0, 0, 0, 3435, 3438, 1, 0,
		0, 0, 3436, 3434, 1, 0, 0, 0, 3436, 3437, 1, 0, 0, 0, 3437, 3440, 1, 0,
		0, 0, 3438, 3436, 1, 0, 0, 0, 3439, 3431, 1, 0, 0, 0, 3439, 3440, 1, 0,
		0, 0, 3440, 3442, 1, 0, 0, 0, 3441, 3443, 3, 376, 188, 0, 3442, 3441, 1,
		0, 0, 0, 3442, 3443, 1, 0, 0, 0, 3443, 3444, 1, 0, 0, 0, 3444, 3445, 5,
		172, 0, 0, 3445, 3447, 3, 1016, 508, 0, 3446, 3448, 3, 378, 189, 0, 3447,
		3446, 1, 0, 0, 0, 3447, 3448, 1, 0, 0, 0, 3448, 361, 1, 0, 0, 0, 3449,
		3450, 5, 19, 0, 0, 3450, 3451, 5, 377, 0, 0, 3451, 3452, 5, 243, 0, 0,
		3452, 3456, 5, 168, 0, 0, 3453, 3454, 3, 1010, 505, 0, 3454, 3455, 5, 1,
		0, 0, 3455, 3457, 1, 0, 0, 0, 3456, 3453, 1, 0, 0, 0, 3456, 3457, 1, 0,
		0, 0, 3457, 3458, 1, 0, 0, 0, 3458, 3467, 3, 1016, 508, 0, 3459, 3464,
		3, 366, 183, 0, 3460, 3461, 5, 3, 0, 0, 3461, 3463, 3, 366, 183, 0, 3462,
		3460, 1, 0, 0, 0, 3463, 3466, 1, 0, 0, 0, 3464, 3462, 1, 0, 0, 0, 3464,
		3465, 1, 0, 0, 0, 3465, 3468, 1, 0, 0, 0, 3466, 3464, 1, 0, 0, 0, 3467,
		3459, 1, 0, 0, 0, 3467, 3468, 1, 0, 0, 0, 3468, 3470, 1, 0, 0, 0, 3469,
		3471, 3, 376, 188, 0, 3470, 3469, 1, 0, 0, 0, 3470, 3471, 1, 0, 0, 0, 3471,
		3473, 1, 0, 0, 0, 3472, 3474, 3, 364, 182, 0, 3473, 3472, 1, 0, 0, 0, 3473,
		3474, 1, 0, 0, 0, 3474, 363, 1, 0, 0, 0, 3475, 3476, 5, 172, 0, 0, 3476,
		3477, 3, 1016, 508, 0, 3477, 3478, 3, 378, 189, 0, 3478, 365, 1, 0, 0,
		0, 3479, 3486, 3, 368, 184, 0, 3480, 3486, 3, 370, 185, 0, 3481, 3486,
		3, 372, 186, 0, 3482, 3483, 5, 479, 0, 0, 3483, 3486, 3, 850, 425, 0, 3484,
		3486, 3, 824, 412, 0, 3485, 3479, 1, 0, 0, 0, 3485, 3480, 1, 0, 0, 0, 3485,
		3481, 1, 0, 0, 0, 3485, 3482, 1, 0, 0, 0, 3485, 3484, 1, 0, 0, 0, 3486,
		367, 1, 0, 0, 0, 3487, 3488, 5, 77, 0, 0, 3488, 3489, 5, 430, 0, 0, 3489,
		3490, 5, 55, 0, 0, 3490, 3491, 3, 974, 487, 0, 3491, 369, 1, 0, 0, 0, 3492,
		3493, 5, 379, 0, 0, 3493, 3494, 5, 430, 0, 0, 3494, 3495, 5, 55, 0, 0,
		3495, 3496, 3, 974, 487, 0, 3496, 371, 1, 0, 0, 0, 3497, 3498, 5, 77, 0,
		0, 3498, 3499, 3, 374, 187, 0, 3499, 373, 1, 0, 0, 0, 3500, 3503, 5, 2,
		0, 0, 3501, 3504, 3, 1010, 505, 0, 3502, 3504, 3, 1032, 516, 0, 3503, 3501,
		1, 0, 0, 0, 3503, 3502, 1, 0, 0, 0, 3504, 3512, 1, 0, 0, 0, 3505, 3508,
		5, 3, 0, 0, 3506, 3509, 3, 1010, 505, 0, 3507, 3509, 3, 1032, 516, 0, 3508,
		3506, 1, 0, 0, 0, 3508, 3507, 1, 0, 0, 0, 3509, 3511, 1, 0, 0, 0, 3510,
		3505, 1, 0, 0, 0, 3511, 3514, 1, 0, 0, 0, 3512, 3510, 1, 0, 0, 0, 3512,
		3513, 1, 0, 0, 0, 3513, 3515, 1, 0, 0, 0, 3514, 3512, 1, 0, 0, 0, 3515,
		3516, 5, 4, 0, 0, 3516, 375, 1, 0, 0, 0, 3517, 3518, 3, 952, 476, 0, 3518,
		377, 1, 0, 0, 0, 3519, 3520, 3, 956, 478, 0, 3520, 379, 1, 0, 0, 0, 3521,
		3522, 5, 410, 0, 0, 3522, 3523, 5, 377, 0, 0, 3523, 3524, 5, 243, 0, 0,
		3524, 3528, 5, 168, 0, 0, 3525, 3526, 3, 1010, 505, 0, 3526, 3527, 5, 1,
		0, 0, 3527, 3529, 1, 0, 0, 0, 3528, 3525, 1, 0, 0, 0, 3528, 3529, 1, 0,
		0, 0, 3529, 3530, 1, 0, 0, 0, 3530, 3531, 3, 1016, 508, 0, 3531, 381, 1,
		0, 0, 0, 3532, 3533, 5, 364, 0, 0, 3533, 3534, 5, 377, 0, 0, 3534, 3535,
		5, 243, 0, 0, 3535, 3539, 5, 168, 0, 0, 3536, 3537, 3, 1010, 505, 0, 3537,
		3538, 5, 1, 0, 0, 3538, 3540, 1, 0, 0, 0, 3539, 3536, 1, 0, 0, 0, 3539,
		3540, 1, 0, 0, 0, 3540, 3541, 1, 0, 0, 0, 3541, 3542, 3, 1016, 508, 0,
		3542, 383, 1, 0, 0, 0, 3543, 3544, 5, 307, 0, 0, 3544, 3545, 5, 377, 0,
		0, 3545, 3546, 5, 243, 0, 0, 3546, 3550, 5, 168, 0, 0, 3547, 3548, 3, 1010,
		505, 0, 3548, 3549, 5, 1, 0, 0, 3549, 3551, 1, 0, 0, 0, 3550, 3547, 1,
		0, 0, 0, 3550, 3551, 1, 0, 0, 0, 3551, 3552, 1, 0, 0, 0, 3552, 3553, 3,
		1016, 508, 0, 3553, 385, 1, 0, 0, 0, 3554, 3556, 5, 401, 0, 0, 3555, 3557,
		5, 18, 0, 0, 3556, 3555, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557, 3558,
		1, 0, 0, 0, 3558, 3559, 5, 377, 0, 0, 3559, 3567, 5, 243, 0, 0, 3560, 3564,
		5, 168, 0, 0, 3561, 3562, 3, 1010, 505, 0, 3562, 3563, 5, 1, 0, 0, 3563,
		3565, 1, 0, 0, 0, 3564, 3561, 1, 0, 0, 0, 3564, 3565, 1, 0, 0, 0, 3565,
		3566, 1, 0, 0, 0, 3566, 3568, 3, 1016, 508, 0, 3567, 3560, 1, 0, 0, 0,
		3567, 3568, 1, 0, 0, 0, 3568, 3571, 1, 0, 0, 0, 3569, 3570, 5, 172, 0,
		0, 3570, 3572, 3, 1010, 505, 0, 3571, 3569, 1, 0, 0, 0, 3571, 3572, 1,
		0, 0, 0, 3572, 3575, 1, 0, 0, 0, 3573, 3574, 5, 479, 0, 0, 3574, 3576,
		3, 850, 425, 0, 3575, 3573, 1, 0, 0, 0, 3575, 3576, 1, 0, 0, 0, 3576, 3587,
		1, 0, 0, 0, 3577, 3578, 5, 298, 0, 0, 3578, 3579, 5, 55, 0, 0, 3579, 3584,
		3, 768, 384, 0, 3580, 3581, 5, 3, 0, 0, 3581, 3583, 3, 768, 384, 0, 3582,
		3580, 1, 0, 0, 0, 3583, 3586, 1, 0, 0, 0, 3584, 3582, 1, 0, 0, 0, 3584,
		3585, 1, 0, 0, 0, 3585, 3588, 1, 0, 0, 0, 3586, 3584, 1, 0, 0, 0, 3587,
		3577, 1, 0, 0, 0, 3587, 3588, 1, 0, 0, 0, 3588, 3590, 1, 0, 0, 0, 3589,
		3591, 3, 772, 386, 0, 3590, 3589, 1, 0, 0, 0, 3590, 3591, 1, 0, 0, 0, 3591,
		387, 1, 0, 0, 0, 3592, 3593, 5, 401, 0, 0, 3593, 3594, 5, 377, 0, 0, 3594,
		3595, 5, 243, 0, 0, 3595, 3598, 5, 428, 0, 0, 3596, 3597, 5, 172, 0, 0,
		3597, 3599, 3, 1010, 505, 0, 3598, 3596, 1, 0, 0, 0, 3598, 3599, 1, 0,
		0, 0, 3599, 3600, 1, 0, 0, 0, 3600, 3601, 5, 479, 0, 0, 3601, 3602, 3,
		850, 425, 0, 3602, 389, 1, 0, 0, 0, 3603, 3604, 5, 401, 0, 0, 3604, 3605,
		5, 90, 0, 0, 3605, 3606, 5, 377, 0, 0, 3606, 3610, 5, 243, 0, 0, 3607,
		3608, 3, 1010, 505, 0, 3608, 3609, 5, 1, 0, 0, 3609, 3611, 1, 0, 0, 0,
		3610, 3607, 1, 0, 0, 0, 3610, 3611, 1, 0, 0, 0, 3611, 3612, 1, 0, 0, 0,
		3612, 3613, 3, 1016, 508, 0, 3613, 391, 1, 0, 0, 0, 3614, 3616, 5, 401,
		0, 0, 3615, 3617, 5, 18, 0, 0, 3616, 3615, 1, 0, 0, 0, 3616, 3617, 1, 0,
		0, 0, 3617, 3618, 1, 0, 0, 0, 3618, 3619, 5, 412, 0, 0, 3619, 3627, 5,
		243, 0, 0, 3620, 3624, 5, 168, 0, 0, 3621, 3622, 3, 1010, 505, 0, 3622,
		3623, 5, 1, 0, 0, 3623, 3625, 1, 0, 0, 0, 3624, 3621, 1, 0, 0, 0, 3624,
		3625, 1, 0, 0, 0, 3625, 3626, 1, 0, 0, 0, 3626, 3628, 3, 1016, 508, 0,
		3627, 3620, 1, 0, 0, 0, 3627, 3628, 1, 0, 0, 0, 3628, 3631, 1, 0, 0, 0,
		3629, 3630, 5, 172, 0, 0, 3630, 3632, 3, 1010, 505, 0, 3631, 3629, 1, 0,
		0, 0, 3631, 3632, 1, 0, 0, 0, 3632, 3635, 1, 0, 0, 0, 3633, 3634, 5, 479,
		0, 0, 3634, 3636, 3, 850, 425, 0, 3635, 3633, 1, 0, 0, 0, 3635, 3636, 1,
		0, 0, 0, 3636, 3647, 1, 0, 0, 0, 3637, 3638, 5, 298, 0, 0, 3638, 3639,
		5, 55, 0, 0, 3639, 3644, 3, 768, 384, 0, 3640, 3641, 5, 3, 0, 0, 3641,
		3643, 3, 768, 384, 0, 3642, 3640, 1, 0, 0, 0, 3643, 3646, 1, 0, 0, 0, 3644,
		3642, 1, 0, 0, 0, 3644, 3645, 1, 0, 0, 0, 3645, 3648, 1, 0, 0, 0, 3646,
		3644, 1, 0, 0, 0, 3647, 3637, 1, 0, 0, 0, 3647, 3648, 1, 0, 0, 0, 3648,
		3650, 1, 0, 0, 0, 3649, 3651, 3, 772, 386, 0, 3650, 3649, 1, 0, 0, 0, 3650,
		3651, 1, 0, 0, 0, 3651, 393, 1, 0, 0, 0, 3652, 3654, 5, 20, 0, 0, 3653,
		3655, 7, 19, 0, 0, 3654, 3653, 1, 0, 0, 0, 3654, 3655, 1, 0, 0, 0, 3655,
		3656, 1, 0, 0, 0, 3656, 3657, 5, 423, 0, 0, 3657, 3659, 3, 1012, 506, 0,
		3658, 3660, 3, 396, 198, 0, 3659, 3658, 1, 0, 0, 0, 3659, 3660, 1, 0, 0,
		0, 3660, 3662, 1, 0, 0, 0, 3661, 3663, 3, 824, 412, 0, 3662, 3661, 1, 0,
		0, 0, 3662, 3663, 1, 0, 0, 0, 3663, 3667, 1, 0, 0, 0, 3664, 3665, 5, 481,
		0, 0, 3665, 3666, 7, 12, 0, 0, 3666, 3668, 5, 269, 0, 0, 3667, 3664, 1,
		0, 0, 0, 3667, 3668, 1, 0, 0, 0, 3668, 3670, 1, 0, 0, 0, 3669, 3671, 3,
		952, 476, 0, 3670, 3669, 1, 0, 0, 0, 3670, 3671, 1, 0, 0, 0, 3671, 395,
		1, 0, 0, 0, 3672, 3673, 5, 2, 0, 0, 3673, 3678, 3, 1010, 505, 0, 3674,
		3675, 5, 3, 0, 0, 3675, 3677, 3, 1010, 505, 0, 3676, 3674, 1, 0, 0, 0,
		3677, 3680, 1, 0, 0, 0, 3678, 3676, 1, 0, 0, 0, 3678, 3679, 1, 0, 0, 0,
		3679, 3681, 1, 0, 0, 0, 3680, 3678, 1, 0, 0, 0, 3681, 3682, 5, 4, 0, 0,
		3682, 3709, 1, 0, 0, 0, 3683, 3688, 3, 1010, 505, 0, 3684, 3685, 5, 3,
		0, 0, 3685, 3687, 3, 1010, 505, 0, 3686, 3684, 1, 0, 0, 0, 3687, 3690,
		1, 0, 0, 0, 3688, 3686, 1, 0, 0, 0, 3688, 3689, 1, 0, 0, 0, 3689, 3709,
		1, 0, 0, 0, 3690, 3688, 1, 0, 0, 0, 3691, 3692, 5, 18, 0, 0, 3692, 3709,
		5, 77, 0, 0, 3693, 3694, 5, 321, 0, 0, 3694, 3709, 5, 77, 0, 0, 3695, 3696,
		5, 272, 0, 0, 3696, 3697, 5, 77, 0, 0, 3697, 3698, 5, 2, 0, 0, 3698, 3703,
		3, 1010, 505, 0, 3699, 3700, 5, 3, 0, 0, 3700, 3702, 3, 1010, 505, 0, 3701,
		3699, 1, 0, 0, 0, 3702, 3705, 1, 0, 0, 0, 3703, 3701, 1, 0, 0, 0, 3703,
		3704, 1, 0, 0, 0, 3704, 3706, 1, 0, 0, 0, 3705, 3703, 1, 0, 0, 0, 3706,
		3707, 5, 4, 0, 0, 3707, 3709, 1, 0, 0, 0, 3708, 3672, 1, 0, 0, 0, 3708,
		3683, 1, 0, 0, 0, 3708, 3691, 1, 0, 0, 0, 3708, 3693, 1, 0, 0, 0, 3708,
		3695, 1, 0, 0, 0, 3709, 397, 1, 0, 0, 0, 3710, 3713, 5, 132, 0, 0, 3711,
		3712, 5, 272, 0, 0, 3712, 3714, 5, 77, 0, 0, 3713, 3711, 1, 0, 0, 0, 3713,
		3714, 1, 0, 0, 0, 3714, 3715, 1, 0, 0, 0, 3715, 3716, 5, 408, 0, 0, 3716,
		3717, 3, 1010, 505, 0, 3717, 399, 1, 0, 0, 0, 3718, 3719, 5, 20, 0, 0,
		3719, 3720, 5, 423, 0, 0, 3720, 3721, 3, 1012, 506, 0, 3721, 3722, 5, 456,
		0, 0, 3722, 3723, 5, 189, 0, 0, 3723, 3724, 5, 290, 0, 0, 3724, 3728, 3,
		396, 198, 0, 3725, 3726, 5, 481, 0, 0, 3726, 3727, 5, 519, 0, 0, 3727,
		3729, 5, 53, 0, 0, 3728, 3725, 1, 0, 0, 0, 3728, 3729, 1, 0, 0, 0, 3729,
		3731, 1, 0, 0, 0, 3730, 3732, 3, 952, 476, 0, 3731, 3730, 1, 0, 0, 0, 3731,
		3732, 1, 0, 0, 0, 3732, 401, 1, 0, 0, 0, 3733, 3737, 3, 400, 200, 0, 3734,
		3735, 5, 481, 0, 0, 3735, 3736, 7, 12, 0, 0, 3736, 3738, 5, 269, 0, 0,
		3737, 3734, 1, 0, 0, 0, 3737, 3738, 1, 0, 0, 0, 3738, 403, 1, 0, 0, 0,
		3739, 3740, 5, 20, 0, 0, 3740, 3741, 5, 423, 0, 0, 3741, 3742, 3, 1010,
		505, 0, 3742, 3743, 5, 132, 0, 0, 3743, 3744, 5, 189, 0, 0, 3744, 3745,
		5, 290, 0, 0, 3745, 3750, 3, 1010, 505, 0, 3746, 3747, 5, 3, 0, 0, 3747,
		3749, 3, 1010, 505, 0, 3748, 3746, 1, 0, 0, 0, 3749, 3752, 1, 0, 0, 0,
		3750, 3748, 1, 0, 0, 0, 3750, 3751, 1, 0, 0, 0, 3751, 405, 1, 0, 0, 0,
		3752, 3750, 1, 0, 0, 0, 3753, 3754, 5, 90, 0, 0, 3754, 3756, 5, 20, 0,
		0, 3755, 3757, 7, 19, 0, 0, 3756, 3755, 1, 0, 0, 0, 3756, 3757, 1, 0, 0,
		0, 3757, 3758, 1, 0, 0, 0, 3758, 3760, 5, 18, 0, 0, 3759, 3761, 3, 952,
		476, 0, 3760, 3759, 1, 0, 0, 0, 3760, 3761, 1, 0, 0, 0, 3761, 3798, 1,
		0, 0, 0, 3762, 3763, 5, 90, 0, 0, 3763, 3765, 5, 20, 0, 0, 3764, 3766,
		7, 19, 0, 0, 3765, 3764, 1, 0, 0, 0, 3765, 3766, 1, 0, 0, 0, 3766, 3767,
		1, 0, 0, 0, 3767, 3768, 5, 104, 0, 0, 3768, 3770, 3, 1016, 508, 0, 3769,
		3771, 3, 952, 476, 0, 3770, 3769, 1, 0, 0, 0, 3770, 3771, 1, 0, 0, 0, 3771,
		3798, 1, 0, 0, 0, 3772, 3773, 5, 90, 0, 0, 3773, 3775, 5, 20, 0, 0, 3774,
		3776, 7, 19, 0, 0, 3775, 3774, 1, 0, 0, 0, 3775, 3776, 1, 0, 0, 0, 3776,
		3777, 1, 0, 0, 0, 3777, 3778, 5, 423, 0, 0, 3778, 3790, 3, 1010, 505, 0,
		3779, 3780, 5, 2, 0, 0, 3780, 3785, 3, 1010, 505, 0, 3781, 3782, 5, 3,
		0, 0, 3782, 3784, 3, 1010, 505, 0, 3783, 3781, 1, 0, 0, 0, 3784, 3787,
		1, 0, 0, 0, 3785, 3783, 1, 0, 0, 0, 3785, 3786, 1, 0, 0, 0, 3786, 3788,
		1, 0, 0, 0, 3787, 3785, 1, 0, 0, 0, 3788, 3789, 5, 4, 0, 0, 3789, 3791,
		1, 0, 0, 0, 3790, 3779, 1, 0, 0, 0, 3790, 3791, 1, 0, 0, 0, 3791, 3793,
		1, 0, 0, 0, 3792, 3794, 3, 952, 476, 0, 3793, 3792, 1, 0, 0, 0, 3793, 3794,
		1, 0, 0, 0, 3794, 3798, 1, 0, 0, 0, 3795, 3796, 5, 90, 0, 0, 3796, 3798,
		3, 400, 200, 0, 3797, 3753, 1, 0, 0, 0, 3797, 3762, 1, 0, 0, 0, 3797, 3772,
		1, 0, 0, 0, 3797, 3795, 1, 0, 0, 0, 3798, 407, 1, 0, 0, 0, 3799, 3800,
		5, 132, 0, 0, 3800, 3801, 5, 20, 0, 0, 3801, 3807, 5, 519, 0, 0, 3802,
		3803, 5, 132, 0, 0, 3803, 3804, 5, 18, 0, 0, 3804, 3805, 5, 20, 0, 0, 3805,
		3807, 5, 224, 0, 0, 3806, 3799, 1, 0, 0, 0, 3806, 3802, 1, 0, 0, 0, 3807,
		409, 1, 0, 0, 0, 3808, 3809, 5, 401, 0, 0, 3809, 3811, 5, 20, 0, 0, 3810,
		3812, 7, 20, 0, 0, 3811, 3810, 1, 0, 0, 0, 3811, 3812, 1, 0, 0, 0, 3812,
		3815, 1, 0, 0, 0, 3813, 3814, 5, 479, 0, 0, 3814, 3816, 3, 850, 425, 0,
		3815, 3813, 1, 0, 0, 0, 3815, 3816, 1, 0, 0, 0, 3816, 3827, 1, 0, 0, 0,
		3817, 3818, 5, 298, 0, 0, 3818, 3819, 5, 55, 0, 0, 3819, 3824, 3, 768,
		384, 0, 3820, 3821, 5, 3, 0, 0, 3821, 3823, 3, 768, 384, 0, 3822, 3820,
		1, 0, 0, 0, 3823, 3826, 1, 0, 0, 0, 3824, 3822, 1, 0, 0, 0, 3824, 3825,
		1, 0, 0, 0, 3825, 3828, 1, 0, 0, 0, 3826, 3824, 1, 0, 0, 0, 3827, 3817,
		1, 0, 0, 0, 3827, 3828, 1, 0, 0, 0, 3828, 3830, 1, 0, 0, 0, 3829, 3831,
		3, 772, 386, 0, 3830, 3829, 1, 0, 0, 0, 3830, 3831, 1, 0, 0, 0, 3831, 411,
		1, 0, 0, 0, 3832, 3835, 5, 401, 0, 0, 3833, 3834, 5, 272, 0, 0, 3834, 3836,
		5, 77, 0, 0, 3835, 3833, 1, 0, 0, 0, 3835, 3836, 1, 0, 0, 0, 3836, 3837,
		1, 0, 0, 0, 3837, 3838, 5, 408, 0, 0, 3838, 3841, 5, 267, 0, 0, 3839, 3840,
		5, 479, 0, 0, 3840, 3842, 3, 850, 425, 0, 3841, 3839, 1, 0, 0, 0, 3841,
		3842, 1, 0, 0, 0, 3842, 3853, 1, 0, 0, 0, 3843, 3844, 5, 298, 0, 0, 3844,
		3845, 5, 55, 0, 0, 3845, 3850, 3, 768, 384, 0, 3846, 3847, 5, 3, 0, 0,
		3847, 3849, 3, 768, 384, 0, 3848, 3846, 1, 0, 0, 0, 3849, 3852, 1, 0, 0,
		0, 3850, 3848, 1, 0, 0, 0, 3850, 3851, 1, 0, 0, 0, 3851, 3854, 1, 0, 0,
		0, 3852, 3850, 1, 0, 0, 0, 3853, 3843, 1, 0, 0, 0, 3853, 3854, 1, 0, 0,
		0, 3854, 3856, 1, 0, 0, 0, 3855, 3857, 3, 772, 386, 0, 3856, 3855, 1, 0,
		0, 0, 3856, 3857, 1, 0, 0, 0, 3857, 413, 1, 0, 0, 0, 3858, 3859, 5, 401,
		0, 0, 3859, 3860, 5, 189, 0, 0, 3860, 3863, 5, 267, 0, 0, 3861, 3862, 5,
		479, 0, 0, 3862, 3864, 3, 850, 425, 0, 3863, 3861, 1, 0, 0, 0, 3863, 3864,
		1, 0, 0, 0, 3864, 3875, 1, 0, 0, 0, 3865, 3866, 5, 298, 0, 0, 3866, 3867,
		5, 55, 0, 0, 3867, 3872, 3, 768, 384, 0, 3868, 3869, 5, 3, 0, 0, 3869,
		3871, 3, 768, 384, 0, 3870, 3868, 1, 0, 0, 0, 3871, 3874, 1, 0, 0, 0, 3872,
		3870, 1, 0, 0, 0, 3872, 3873, 1, 0, 0, 0, 3873, 3876, 1, 0, 0, 0, 3874,
		3872, 1, 0, 0, 0, 3875, 3865, 1, 0, 0, 0, 3875, 3876, 1, 0, 0, 0, 3876,
		3878, 1, 0, 0, 0, 3877, 3879, 3, 772, 386, 0, 3878, 3877, 1, 0, 0, 0, 3878,
		3879, 1, 0, 0, 0, 3879, 415, 1, 0, 0, 0, 3880, 3881, 5, 229, 0, 0, 3881,
		3882, 5, 20, 0, 0, 3882, 3883, 5, 519, 0, 0, 3883, 417, 1, 0, 0, 0, 3884,
		3885, 5, 20, 0, 0, 3885, 3886, 5, 330, 0, 0, 3886, 3887, 5, 172, 0, 0,
		3887, 3902, 3, 974, 487, 0, 3888, 3889, 5, 20, 0, 0, 3889, 3890, 5, 330,
		0, 0, 3890, 3891, 5, 172, 0, 0, 3891, 3892, 3, 974, 487, 0, 3892, 3893,
		5, 3, 0, 0, 3893, 3898, 5, 519, 0, 0, 3894, 3895, 5, 3, 0, 0, 3895, 3897,
		5, 519, 0, 0, 3896, 3894, 1, 0, 0, 0, 3897, 3900, 1, 0, 0, 0, 3898, 3896,
		1, 0, 0, 0, 3898, 3899, 1, 0, 0, 0, 3899, 3902, 1, 0, 0, 0, 3900, 3898,
		1, 0, 0, 0, 3901, 3884, 1, 0, 0, 0, 3901, 3888, 1, 0, 0, 0, 3902, 419,
		1, 0, 0, 0, 3903, 3905, 5, 90, 0, 0, 3904, 3906, 5, 178, 0, 0, 3905, 3904,
		1, 0, 0, 0, 3905, 3906, 1, 0, 0, 0, 3906, 3907, 1, 0, 0, 0, 3907, 3910,
		5, 39, 0, 0, 3908, 3909, 5, 290, 0, 0, 3909, 3911, 3, 752, 376, 0, 3910,
		3908, 1, 0, 0, 0, 3910, 3911, 1, 0, 0, 0, 3911, 3912, 1, 0, 0, 0, 3912,
		3913, 5, 461, 0, 0, 3913, 3915, 3, 752, 376, 0, 3914, 3916, 3, 952, 476,
		0, 3915, 3914, 1, 0, 0, 0, 3915, 3916, 1, 0, 0, 0, 3916, 421, 1, 0, 0,
		0, 3917, 3918, 5, 132, 0, 0, 3918, 3919, 5, 39, 0, 0, 3919, 3920, 5, 519,
		0, 0, 3920, 423, 1, 0, 0, 0, 3921, 3922, 5, 401, 0, 0, 3922, 3923, 5, 39,
		0, 0, 3923, 425, 1, 0, 0, 0, 3924, 3925, 5, 90, 0, 0, 3925, 3926, 5, 361,
		0, 0, 3926, 3930, 5, 181, 0, 0, 3927, 3928, 5, 197, 0, 0, 3928, 3929, 5,
		281, 0, 0, 3929, 3931, 5, 148, 0, 0, 3930, 3927, 1, 0, 0, 0, 3930, 3931,
		1, 0, 0, 0, 3931, 3934, 1, 0, 0, 0, 3932, 3933, 5, 297, 0, 0, 3933, 3935,
		5, 356, 0, 0, 3934, 3932, 1, 0, 0, 0, 3934, 3935, 1, 0, 0, 0, 3935, 3936,
		1, 0, 0, 0, 3936, 3946, 3, 1016, 508, 0, 3937, 3938, 5, 441, 0, 0, 3938,
		3943, 3, 444, 222, 0, 3939, 3940, 5, 3, 0, 0, 3940, 3942, 3, 444, 222,
		0, 3941, 3939, 1, 0, 0, 0, 3942, 3945, 1, 0, 0, 0, 3943, 3941, 1, 0, 0,
		0, 3943, 3944, 1, 0, 0, 0, 3944, 3947, 1, 0, 0, 0, 3945, 3943, 1, 0, 0,
		0, 3946, 3937, 1, 0, 0, 0, 3946, 3947, 1, 0, 0, 0, 3947, 3948, 1, 0, 0,
		0, 3948, 3949, 5, 481, 0, 0, 3949, 3950, 5, 2, 0, 0, 3950, 3955, 3, 960,
		480, 0, 3951, 3952, 5, 3, 0, 0, 3952, 3954, 3, 960, 480, 0, 3953, 3951,
		1, 0, 0, 0, 3954, 3957, 1, 0, 0, 0, 3955, 3953, 1, 0, 0, 0, 3955, 3956,
		1, 0, 0, 0, 3956, 3958, 1, 0, 0, 0, 3957, 3955, 1, 0, 0, 0, 3958, 3959,
		5, 4, 0, 0, 3959, 427, 1, 0, 0, 0, 3960, 3961, 5, 132, 0, 0, 3961, 3962,
		5, 361, 0, 0, 3962, 3963, 5, 181, 0, 0, 3963, 3964, 3, 1016, 508, 0, 3964,
		429, 1, 0, 0, 0, 3965, 3966, 5, 19, 0, 0, 3966, 3967, 5, 361, 0, 0, 3967,
		3968, 5, 181, 0, 0, 3968, 3969, 3, 1016, 508, 0, 3969, 3970, 5, 13, 0,
		0, 3970, 3975, 3, 444, 222, 0, 3971, 3972, 5, 3, 0, 0, 3972, 3974, 3, 444,
		222, 0, 3973, 3971, 1, 0, 0, 0, 3974, 3977, 1, 0, 0, 0, 3975, 3973, 1,
		0, 0, 0, 3975, 3976, 1, 0, 0, 0, 3976, 4018, 1, 0, 0, 0, 3977, 3975, 1,
		0, 0, 0, 3978, 3979, 5, 19, 0, 0, 3979, 3980, 5, 361, 0, 0, 3980, 3981,
		5, 181, 0, 0, 3981, 3982, 3, 1016, 508, 0, 3982, 3983, 5, 132, 0, 0, 3983,
		3984, 5, 2, 0, 0, 3984, 3989, 5, 519, 0, 0, 3985, 3986, 5, 3, 0, 0, 3986,
		3988, 5, 519, 0, 0, 3987, 3985, 1, 0, 0, 0, 3988, 3991, 1, 0, 0, 0, 3989,
		3987, 1, 0, 0, 0, 3989, 3990, 1, 0, 0, 0, 3990, 3992, 1, 0, 0, 0, 3991,
		3989, 1, 0, 0, 0, 3992, 3993, 5, 4, 0, 0, 3993, 4018, 1, 0, 0, 0, 3994,
		3995, 5, 19, 0, 0, 3995, 3996, 5, 361, 0, 0, 3996, 3997, 5, 181, 0, 0,
		3997, 3998, 3, 1016, 508, 0, 3998, 3999, 5, 132, 0, 0, 3999, 4000, 5, 18,
		0, 0, 4000, 4018, 1, 0, 0, 0, 4001, 4002, 5, 19, 0, 0, 4002, 4003, 5, 361,
		0, 0, 4003, 4004, 5, 181, 0, 0, 4004, 4005, 3, 1016, 508, 0, 4005, 4006,
		5, 481, 0, 0, 4006, 4007, 5, 2, 0, 0, 4007, 4012, 3, 960, 480, 0, 4008,
		4009, 5, 3, 0, 0, 4009, 4011, 3, 960, 480, 0, 4010, 4008, 1, 0, 0, 0, 4011,
		4014, 1, 0, 0, 0, 4012, 4010, 1, 0, 0, 0, 4012, 4013, 1, 0, 0, 0, 4013,
		4015, 1, 0, 0, 0, 4014, 4012, 1, 0, 0, 0, 4015, 4016, 5, 4, 0, 0, 4016,
		4018, 1, 0, 0, 0, 4017, 3965, 1, 0, 0, 0, 4017, 3978, 1, 0, 0, 0, 4017,
		3994, 1, 0, 0, 0, 4017, 4001, 1, 0, 0, 0, 4018, 431, 1, 0, 0, 0, 4019,
		4021, 5, 401, 0, 0, 4020, 4022, 5, 468, 0, 0, 4021, 4020, 1, 0, 0, 0, 4021,
		4022, 1, 0, 0, 0, 4022, 4023, 1, 0, 0, 0, 4023, 4024, 5, 361, 0, 0, 4024,
		4025, 5, 181, 0, 0, 4025, 4036, 3, 1016, 508, 0, 4026, 4028, 5, 401, 0,
		0, 4027, 4029, 5, 468, 0, 0, 4028, 4027, 1, 0, 0, 0, 4028, 4029, 1, 0,
		0, 0, 4029, 4030, 1, 0, 0, 0, 4030, 4031, 5, 361, 0, 0, 4031, 4033, 5,
		182, 0, 0, 4032, 4034, 5, 18, 0, 0, 4033, 4032, 1, 0, 0, 0, 4033, 4034,
		1, 0, 0, 0, 4034, 4036, 1, 0, 0, 0, 4035, 4019, 1, 0, 0, 0, 4035, 4026,
		1, 0, 0, 0, 4036, 433, 1, 0, 0, 0, 4037, 4038, 5, 401, 0, 0, 4038, 4039,
		5, 457, 0, 0, 4039, 4040, 5, 361, 0, 0, 4040, 4041, 5, 181, 0, 0, 4041,
		4047, 3, 1016, 508, 0, 4042, 4043, 5, 401, 0, 0, 4043, 4044, 5, 457, 0,
		0, 4044, 4045, 5, 361, 0, 0, 4045, 4047, 5, 182, 0, 0, 4046, 4037, 1, 0,
		0, 0, 4046, 4042, 1, 0, 0, 0, 4047, 435, 1, 0, 0, 0, 4048, 4050, 5, 90,
		0, 0, 4049, 4051, 5, 151, 0, 0, 4050, 4049, 1, 0, 0, 0, 4050, 4051, 1,
		0, 0, 0, 4051, 4052, 1, 0, 0, 0, 4052, 4053, 5, 361, 0, 0, 4053, 4055,
		3, 1024, 512, 0, 4054, 4056, 3, 952, 476, 0, 4055, 4054, 1, 0, 0, 0, 4055,
		4056, 1, 0, 0, 0, 4056, 437, 1, 0, 0, 0, 4057, 4058, 5, 19, 0, 0, 4058,
		4059, 5, 361, 0, 0, 4059, 4060, 3, 1024, 512, 0, 4060, 4061, 5, 396, 0,
		0, 4061, 4062, 3, 952, 476, 0, 4062, 439, 1, 0, 0, 0, 4063, 4064, 5, 132,
		0, 0, 4064, 4065, 5, 361, 0, 0, 4065, 4066, 3, 1024, 512, 0, 4066, 441,
		1, 0, 0, 0, 4067, 4068, 5, 401, 0, 0, 4068, 4069, 5, 362, 0, 0, 4069, 443,
		1, 0, 0, 0, 4070, 4071, 5, 2, 0, 0, 4071, 4072, 3, 852, 426, 0, 4072, 4073,
		5, 4, 0, 0, 4073, 445, 1, 0, 0, 0, 4074, 4076, 5, 401, 0, 0, 4075, 4077,
		5, 175, 0, 0, 4076, 4075, 1, 0, 0, 0, 4076, 4077, 1, 0, 0, 0, 4077, 4079,
		1, 0, 0, 0, 4078, 4080, 7, 21, 0, 0, 4079, 4078, 1, 0, 0, 0, 4079, 4080,
		1, 0, 0, 0, 4080, 4081, 1, 0, 0, 0, 4081, 4084, 5, 177, 0, 0, 4082, 4083,
		7, 1, 0, 0, 4083, 4085, 3, 1010, 505, 0, 4084, 4082, 1, 0, 0, 0, 4084,
		4085, 1, 0, 0, 0, 4085, 4090, 1, 0, 0, 0, 4086, 4087, 5, 240, 0, 0, 4087,
		4091, 3, 974, 487, 0, 4088, 4089, 5, 479, 0, 0, 4089, 4091, 3, 850, 425,
		0, 4090, 4086, 1, 0, 0, 0, 4090, 4088, 1, 0, 0, 0, 4090, 4091, 1, 0, 0,
		0, 4091, 447, 1, 0, 0, 0, 4092, 4094, 5, 132, 0, 0, 4093, 4095, 5, 178,
		0, 0, 4094, 4093, 1, 0, 0, 0, 4094, 4095, 1, 0, 0, 0, 4095, 4096, 1, 0,
		0, 0, 4096, 4099, 5, 176, 0, 0, 4097, 4098, 5, 197, 0, 0, 4098, 4100, 5,
		148, 0, 0, 4099, 4097, 1, 0, 0, 0, 4099, 4100, 1, 0, 0, 0, 4100, 4101,
		1, 0, 0, 0, 4101, 4102, 3, 1010, 505, 0, 4102, 4103, 5, 2, 0, 0, 4103,
		4104, 3, 454, 227, 0, 4104, 4105, 5, 4, 0, 0, 4105, 449, 1, 0, 0, 0, 4106,
		4107, 5, 90, 0, 0, 4107, 4109, 3, 70, 35, 0, 4108, 4110, 5, 178, 0, 0,
		4109, 4108, 1, 0, 0, 0, 4109, 4110, 1, 0, 0, 0, 4110, 4112, 1, 0, 0, 0,
		4111, 4113, 7, 22, 0, 0, 4112, 4111, 1, 0, 0, 0, 4112, 4113, 1, 0, 0, 0,
		4113, 4114, 1, 0, 0, 0, 4114, 4115, 5, 176, 0, 0, 4115, 4116, 3, 72, 36,
		0, 4116, 4117, 3, 1010, 505, 0, 4117, 4118, 5, 2, 0, 0, 4118, 4119, 3,
		454, 227, 0, 4119, 4120, 5, 4, 0, 0, 4120, 4121, 5, 367, 0, 0, 4121, 4124,
		3, 992, 496, 0, 4122, 4125, 3, 952, 476, 0, 4123, 4125, 3, 962, 481, 0,
		4124, 4125, 1, 0, 0, 0, 4124, 4122, 1, 0, 0, 0, 4124, 4123, 1, 0, 0, 0,
		4125, 4127, 1, 0, 0, 0, 4126, 4128, 3, 452, 226, 0, 4127, 4126, 1, 0, 0,
		0, 4127, 4128, 1, 0, 0, 0, 4128, 451, 1, 0, 0, 0, 4129, 4130, 5, 27, 0,
		0, 4130, 4131, 5, 536, 0, 0, 4131, 453, 1, 0, 0, 0, 4132, 4134, 3, 992,
		496, 0, 4133, 4132, 1, 0, 0, 0, 4133, 4134, 1, 0, 0, 0, 4134, 4139, 1,
		0, 0, 0, 4135, 4136, 5, 3, 0, 0, 4136, 4138, 3, 992, 496, 0, 4137, 4135,
		1, 0, 0, 0, 4138, 4141, 1, 0, 0, 0, 4139, 4137, 1, 0, 0, 0, 4139, 4140,
		1, 0, 0, 0, 4140, 4144, 1, 0, 0, 0, 4141, 4139, 1, 0, 0, 0, 4142, 4143,
		5, 3, 0, 0, 4143, 4145, 5, 534, 0, 0, 4144, 4142, 1, 0, 0, 0, 4144, 4145,
		1, 0, 0, 0, 4145, 455, 1, 0, 0, 0, 4146, 4147, 5, 243, 0, 0, 4147, 4148,
		5, 230, 0, 0, 4148, 4150, 3, 458, 229, 0, 4149, 4151, 3, 460, 230, 0, 4150,
		4149, 1, 0, 0, 0, 4150, 4151, 1, 0, 0, 0, 4151, 4153, 1, 0, 0, 0, 4152,
		4154, 3, 466, 233, 0, 4153, 4152, 1, 0, 0, 0, 4153, 4154, 1, 0, 0, 0, 4154,
		4157, 1, 0, 0, 0, 4155, 4156, 5, 55, 0, 0, 4156, 4158, 3, 1024, 512, 0,
		4157, 4155, 1, 0, 0, 0, 4157, 4158, 1, 0, 0, 0, 4158, 4161, 1, 0, 0, 0,
		4159, 4160, 5, 332, 0, 0, 4160, 4162, 3, 956, 478, 0, 4161, 4159, 1, 0,
		0, 0, 4161, 4162, 1, 0, 0, 0, 4162, 4175, 1, 0, 0, 0, 4163, 4164, 5, 243,
		0, 0, 4164, 4165, 5, 230, 0, 0, 4165, 4167, 3, 458, 229, 0, 4166, 4168,
		3, 460, 230, 0, 4167, 4166, 1, 0, 0, 0, 4167, 4168, 1, 0, 0, 0, 4168, 4169,
		1, 0, 0, 0, 4169, 4172, 3, 468, 234, 0, 4170, 4171, 5, 332, 0, 0, 4171,
		4173, 3, 956, 478, 0, 4172, 4170, 1, 0, 0, 0, 4172, 4173, 1, 0, 0, 0, 4173,
		4175, 1, 0, 0, 0, 4174, 4146, 1, 0, 0, 0, 4174, 4163, 1, 0, 0, 0, 4175,
		457, 1, 0, 0, 0, 4176, 4177, 3, 1016, 508, 0, 4177, 4178, 5, 1, 0, 0, 4178,
		4180, 1, 0, 0, 0, 4179, 4176, 1, 0, 0, 0, 4179, 4180, 1, 0, 0, 0, 4180,
		4181, 1, 0, 0, 0, 4181, 4182, 3, 1016, 508, 0, 4182, 459, 1, 0, 0, 0, 4183,
		4184, 5, 2, 0, 0, 4184, 4189, 3, 462, 231, 0, 4185, 4186, 5, 3, 0, 0, 4186,
		4188, 3, 462, 231, 0, 4187, 4185, 1, 0, 0, 0, 4188, 4191, 1, 0, 0, 0, 4189,
		4187, 1, 0, 0, 0, 4189, 4190, 1, 0, 0, 0, 4190, 4192, 1, 0, 0, 0, 4191,
		4189, 1, 0, 0, 0, 4192, 4193, 5, 4, 0, 0, 4193, 461, 1, 0, 0, 0, 4194,
		4195, 5, 102, 0, 0, 4195, 4196, 5, 207, 0, 0, 4196, 4198, 3, 924, 462,
		0, 4197, 4199, 5, 275, 0, 0, 4198, 4197, 1, 0, 0, 0, 4198, 4199, 1, 0,
		0, 0, 4199, 4200, 1, 0, 0, 0, 4200, 4201, 5, 218, 0, 0, 4201, 4202, 5,
		423, 0, 0, 4202, 4204, 3, 1016, 508, 0, 4203, 4205, 3, 824, 412, 0, 4204,
		4203, 1, 0, 0, 0, 4204, 4205, 1, 0, 0, 0, 4205, 4210, 1, 0, 0, 0, 4206,
		4207, 5, 77, 0, 0, 4207, 4208, 5, 430, 0, 0, 4208, 4209, 5, 55, 0, 0, 4209,
		4211, 3, 974, 487, 0, 4210, 4206, 1, 0, 0, 0, 4210, 4211, 1, 0, 0, 0, 4211,
		4216, 1, 0, 0, 0, 4212, 4213, 5, 379, 0, 0, 4213, 4214, 5, 430, 0, 0, 4214,
		4215, 5, 55, 0, 0, 4215, 4217, 3, 974, 487, 0, 4216, 4212, 1, 0, 0, 0,
		4216, 4217, 1, 0, 0, 0, 4217, 4219, 1, 0, 0, 0, 4218, 4220, 3, 972, 486,
		0, 4219, 4218, 1, 0, 0, 0, 4219, 4220, 1, 0, 0, 0, 4220, 4222, 1, 0, 0,
		0, 4221, 4223, 3, 464, 232, 0, 4222, 4221, 1, 0, 0, 0, 4222, 4223, 1, 0,
		0, 0, 4223, 4225, 1, 0, 0, 0, 4224, 4226, 3, 822, 411, 0, 4225, 4224, 1,
		0, 0, 0, 4225, 4226, 1, 0, 0, 0, 4226, 4232, 1, 0, 0, 0, 4227, 4228, 5,
		77, 0, 0, 4228, 4229, 5, 172, 0, 0, 4229, 4230, 5, 306, 0, 0, 4230, 4231,
		5, 27, 0, 0, 4231, 4233, 3, 1022, 511, 0, 4232, 4227, 1, 0, 0, 0, 4232,
		4233, 1, 0, 0, 0, 4233, 4236, 1, 0, 0, 0, 4234, 4235, 5, 396, 0, 0, 4235,
		4237, 3, 444, 222, 0, 4236, 4234, 1, 0, 0, 0, 4236, 4237, 1, 0, 0, 0, 4237,
		4240, 1, 0, 0, 0, 4238, 4239, 5, 479, 0, 0, 4239, 4241, 3, 850, 425, 0,
		4240, 4238, 1, 0, 0, 0, 4240, 4241, 1, 0, 0, 0, 4241, 4264, 1, 0, 0, 0,
		4242, 4243, 5, 102, 0, 0, 4243, 4244, 5, 172, 0, 0, 4244, 4245, 5, 423,
		0, 0, 4245, 4247, 3, 1016, 508, 0, 4246, 4248, 5, 275, 0, 0, 4247, 4246,
		1, 0, 0, 0, 4247, 4248, 1, 0, 0, 0, 4248, 4249, 1, 0, 0, 0, 4249, 4250,
		5, 218, 0, 0, 4250, 4251, 5, 423, 0, 0, 4251, 4253, 3, 1016, 508, 0, 4252,
		4254, 3, 824, 412, 0, 4253, 4252, 1, 0, 0, 0, 4253, 4254, 1, 0, 0, 0, 4254,
		4257, 1, 0, 0, 0, 4255, 4256, 5, 396, 0, 0, 4256, 4258, 3, 444, 222, 0,
		4257, 4255, 1, 0, 0, 0, 4257, 4258, 1, 0, 0, 0, 4258, 4261, 1, 0, 0, 0,
		4259, 4260, 5, 479, 0, 0, 4260, 4262, 3, 850, 425, 0, 4261, 4259, 1, 0,
		0, 0, 4261, 4262, 1, 0, 0, 0, 4262, 4264, 1, 0, 0, 0, 4263, 4194, 1, 0,
		0, 0, 4263, 4242, 1, 0, 0, 0, 4264, 463, 1, 0, 0, 0, 4265, 4269, 5, 2,
		0, 0, 4266, 4267, 5, 400, 0, 0, 4267, 4268, 5, 493, 0, 0, 4268, 4270, 5,
		519, 0, 0, 4269, 4266, 1, 0, 0, 0, 4269, 4270, 1, 0, 0, 0, 4270, 4274,
		1, 0, 0, 0, 4271, 4272, 5, 444, 0, 0, 4272, 4273, 5, 493, 0, 0, 4273, 4275,
		3, 980, 490, 0, 4274, 4271, 1, 0, 0, 0, 4274, 4275, 1, 0, 0, 0, 4275, 4279,
		1, 0, 0, 0, 4276, 4277, 5, 138, 0, 0, 4277, 4278, 5, 493, 0, 0, 4278, 4280,
		3, 974, 487, 0, 4279, 4276, 1, 0, 0, 0, 4279, 4280, 1, 0, 0, 0, 4280, 4284,
		1, 0, 0, 0, 4281, 4282, 5, 143, 0, 0, 4282, 4283, 5, 493, 0, 0, 4283, 4285,
		3, 974, 487, 0, 4284, 4281, 1, 0, 0, 0, 4284, 4285, 1, 0, 0, 0, 4285, 4286,
		1, 0, 0, 0, 4286, 4287, 5, 4, 0, 0, 4287, 465, 1, 0, 0, 0, 4288, 4289,
		5, 481, 0, 0, 4289, 4291, 5, 52, 0, 0, 4290, 4292, 3, 956, 478, 0, 4291,
		4290, 1, 0, 0, 0, 4291, 4292, 1, 0, 0, 0, 4292, 4300, 1, 0, 0, 0, 4293,
		4294, 5, 481, 0, 0, 4294, 4295, 5, 52, 0, 0, 4295, 4297, 3, 1024, 512,
		0, 4296, 4298, 3, 956, 478, 0, 4297, 4296, 1, 0, 0, 0, 4297, 4298, 1, 0,
		0, 0, 4298, 4300, 1, 0, 0, 0, 4299, 4288, 1, 0, 0, 0, 4299, 4293, 1, 0,
		0, 0, 4300, 467, 1, 0, 0, 0, 4301, 4302, 5, 481, 0, 0, 4302, 4303, 5, 361,
		0, 0, 4303, 4305, 3, 1024, 512, 0, 4304, 4306, 3, 956, 478, 0, 4305, 4304,
		1, 0, 0, 0, 4305, 4306, 1, 0, 0, 0, 4306, 469, 1, 0, 0, 0, 4307, 4308,
		5, 401, 0, 0, 4308, 4310, 5, 243, 0, 0, 4309, 4311, 5, 18, 0, 0, 4310,
		4309, 1, 0, 0, 0, 4310, 4311, 1, 0, 0, 0, 4311, 4314, 1, 0, 0, 0, 4312,
		4313, 5, 172, 0, 0, 4313, 4315, 3, 1016, 508, 0, 4314, 4312, 1, 0, 0, 0,
		4314, 4315, 1, 0, 0, 0, 4315, 4318, 1, 0, 0, 0, 4316, 4317, 5, 479, 0,
		0, 4317, 4319, 3, 850, 425, 0, 4318, 4316, 1, 0, 0, 0, 4318, 4319, 1, 0,
		0, 0, 4319, 4330, 1, 0, 0, 0, 4320, 4321, 5, 298, 0, 0, 4321, 4322, 5,
		55, 0, 0, 4322, 4327, 3, 768, 384, 0, 4323, 4324, 5, 3, 0, 0, 4324, 4326,
		3, 768, 384, 0, 4325, 4323, 1, 0, 0, 0, 4326, 4329, 1, 0, 0, 0, 4327, 4325,
		1, 0, 0, 0, 4327, 4328, 1, 0, 0, 0, 4328, 4331, 1, 0, 0, 0, 4329, 4327,
		1, 0, 0, 0, 4330, 4320, 1, 0, 0, 0, 4330, 4331, 1, 0, 0, 0, 4331, 4333,
		1, 0, 0, 0, 4332, 4334, 3, 772, 386, 0, 4333, 4332, 1, 0, 0, 0, 4333, 4334,
		1, 0, 0, 0, 4334, 471, 1, 0, 0, 0, 4335, 4336, 5, 401, 0, 0, 4336, 4337,
		5, 243, 0, 0, 4337, 4340, 5, 476, 0, 0, 4338, 4339, 5, 172, 0, 0, 4339,
		4341, 3, 1016, 508, 0, 4340, 4338, 1, 0, 0, 0, 4340, 4341, 1, 0, 0, 0,
		4341, 4344, 1, 0, 0, 0, 4342, 4343, 5, 479, 0, 0, 4343, 4345, 3, 850, 425,
		0, 4344, 4342, 1, 0, 0, 0, 4344, 4345, 1, 0, 0, 0, 4345, 4347, 1, 0, 0,
		0, 4346, 4348, 3, 772, 386, 0, 4347, 4346, 1, 0, 0, 0, 4347, 4348, 1, 0,
		0, 0, 4348, 4355, 1, 0, 0, 0, 4349, 4350, 5, 401, 0, 0, 4350, 4351, 5,
		243, 0, 0, 4351, 4352, 5, 476, 0, 0, 4352, 4353, 5, 290, 0, 0, 4353, 4355,
		3, 974, 487, 0, 4354, 4335, 1, 0, 0, 0, 4354, 4349, 1, 0, 0, 0, 4355, 473,
		1, 0, 0, 0, 4356, 4357, 5, 57, 0, 0, 4357, 4360, 5, 243, 0, 0, 4358, 4359,
		5, 172, 0, 0, 4359, 4361, 3, 1016, 508, 0, 4360, 4358, 1, 0, 0, 0, 4360,
		4361, 1, 0, 0, 0, 4361, 4364, 1, 0, 0, 0, 4362, 4363, 5, 479, 0, 0, 4363,
		4365, 3, 850, 425, 0, 4364, 4362, 1, 0, 0, 0, 4364, 4365, 1, 0, 0, 0, 4365,
		475, 1, 0, 0, 0, 4366, 4367, 5, 19, 0, 0, 4367, 4368, 5, 243, 0, 0, 4368,
		4372, 5, 168, 0, 0, 4369, 4370, 3, 1010, 505, 0, 4370, 4371, 5, 1, 0, 0,
		4371, 4373, 1, 0, 0, 0, 4372, 4369, 1, 0, 0, 0, 4372, 4373, 1, 0, 0, 0,
		4373, 4374, 1, 0, 0, 0, 4374, 4376, 3, 1016, 508, 0, 4375, 4377, 3, 376,
		188, 0, 4376, 4375, 1, 0, 0, 0, 4376, 4377, 1, 0, 0, 0, 4377, 477, 1, 0,
		0, 0, 4378, 4379, 5, 57, 0, 0, 4379, 4380, 5, 82, 0, 0, 4380, 4381, 5,
		479, 0, 0, 4381, 4382, 3, 850, 425, 0, 4382, 479, 1, 0, 0, 0, 4383, 4384,
		5, 401, 0, 0, 4384, 4385, 5, 30, 0, 0, 4385, 481, 1, 0, 0, 0, 4386, 4387,
		5, 401, 0, 0, 4387, 4388, 5, 36, 0, 0, 4388, 483, 1, 0, 0, 0, 4389, 4390,
		5, 401, 0, 0, 4390, 4391, 5, 52, 0, 0, 4391, 485, 1, 0, 0, 0, 4392, 4398,
		5, 401, 0, 0, 4393, 4394, 5, 64, 0, 0, 4394, 4399, 5, 396, 0, 0, 4395,
		4399, 5, 66, 0, 0, 4396, 4397, 5, 65, 0, 0, 4397, 4399, 5, 396, 0, 0, 4398,
		4393, 1, 0, 0, 0, 4398, 4395, 1, 0, 0, 0, 4398, 4396, 1, 0, 0, 0, 4399,
		4404, 1, 0, 0, 0, 4400, 4401, 5, 240, 0, 0, 4401, 4405, 3, 974, 487, 0,
		4402, 4403, 5, 479, 0, 0, 4403, 4405, 3, 850, 425, 0, 4404, 4400, 1, 0,
		0, 0, 4404, 4402, 1, 0, 0, 0, 4404, 4405, 1, 0, 0, 0, 4405, 487, 1, 0,
		0, 0, 4406, 4407, 5, 401, 0, 0, 4407, 4412, 5, 75, 0, 0, 4408, 4409, 5,
		240, 0, 0, 4409, 4413, 3, 974, 487, 0, 4410, 4411, 5, 479, 0, 0, 4411,
		4413, 3, 850, 425, 0, 4412, 4408, 1, 0, 0, 0, 4412, 4410, 1, 0, 0, 0, 4412,
		4413, 1, 0, 0, 0, 4413, 489, 1, 0, 0, 0, 4414, 4415, 5, 401, 0, 0, 4415,
		4418, 5, 118, 0, 0, 4416, 4417, 7, 1, 0, 0, 4417, 4419, 3, 1010, 505, 0,
		4418, 4416, 1, 0, 0, 0, 4418, 4419, 1, 0, 0, 0, 4419, 491, 1, 0, 0, 0,
		4420, 4421, 5, 401, 0, 0, 4421, 4422, 5, 135, 0, 0, 4422, 4423, 5, 303,
		0, 0, 4423, 4426, 5, 424, 0, 0, 4424, 4425, 7, 1, 0, 0, 4425, 4427, 3,
		1010, 505, 0, 4426, 4424, 1, 0, 0, 0, 4426, 4427, 1, 0, 0, 0, 4427, 493,
		1, 0, 0, 0, 4428, 4429, 5, 401, 0, 0, 4429, 4432, 5, 144, 0, 0, 4430, 4431,
		7, 1, 0, 0, 4431, 4433, 3, 1010, 505, 0, 4432, 4430, 1, 0, 0, 0, 4432,
		4433, 1, 0, 0, 0, 4433, 4438, 1, 0, 0, 0, 4434, 4435, 5, 240, 0, 0, 4435,
		4439, 3, 974, 487, 0, 4436, 4437, 5, 479, 0, 0, 4437, 4439, 3, 850, 425,
		0, 4438, 4434, 1, 0, 0, 0, 4438, 4436, 1, 0, 0, 0, 4438, 4439, 1, 0, 0,
		0, 4439, 495, 1, 0, 0, 0, 4440, 4441, 5, 401, 0, 0, 4441, 4442, 5, 141,
		0, 0, 4442, 497, 1, 0, 0, 0, 4443, 4444, 5, 401, 0, 0, 4444, 4445, 5, 174,
		0, 0, 4445, 499, 1, 0, 0, 0, 4446, 4447, 5, 401, 0, 0, 4447, 4448, 5, 314,
		0, 0, 4448, 501, 1, 0, 0, 0, 4449, 4450, 5, 401, 0, 0, 4450, 4451, 5, 360,
		0, 0, 4451, 503, 1, 0, 0, 0, 4452, 4453, 5, 401, 0, 0, 4453, 4454, 5, 292,
		0, 0, 4454, 4455, 5, 424, 0, 0, 4455, 505, 1, 0, 0, 0, 4456, 4457, 5, 401,
		0, 0, 4457, 4458, 5, 325, 0, 0, 4458, 507, 1, 0, 0, 0, 4459, 4460, 5, 401,
		0, 0, 4460, 4461, 7, 23, 0, 0, 4461, 4466, 5, 409, 0, 0, 4462, 4463, 5,
		240, 0, 0, 4463, 4467, 3, 974, 487, 0, 4464, 4465, 5, 479, 0, 0, 4465,
		4467, 3, 850, 425, 0, 4466, 4462, 1, 0, 0, 0, 4466, 4464, 1, 0, 0, 0, 4466,
		4467, 1, 0, 0, 0, 4467, 509, 1, 0, 0, 0, 4468, 4469, 5, 401, 0, 0, 4469,
		4470, 5, 327, 0, 0, 4470, 4471, 3, 974, 487, 0, 4471, 511, 1, 0, 0, 0,
		4472, 4474, 5, 401, 0, 0, 4473, 4475, 5, 175, 0, 0, 4474, 4473, 1, 0, 0,
		0, 4474, 4475, 1, 0, 0, 0, 4475, 4476, 1, 0, 0, 0, 4476, 4479, 5, 329,
		0, 0, 4477, 4478, 5, 168, 0, 0, 4478, 4480, 3, 974, 487, 0, 4479, 4477,
		1, 0, 0, 0, 4479, 4480, 1, 0, 0, 0, 4480, 513, 1, 0, 0, 0, 4481, 4482,
		5, 401, 0, 0, 4482, 4485, 5, 331, 0, 0, 4483, 4484, 5, 241, 0, 0, 4484,
		4486, 5, 519, 0, 0, 4485, 4483, 1, 0, 0, 0, 4485, 4486, 1, 0, 0, 0, 4486,
		515, 1, 0, 0, 0, 4487, 4488, 5, 401, 0, 0, 4488, 4489, 5, 383, 0, 0, 4489,
		4492, 5, 339, 0, 0, 4490, 4491, 5, 241, 0, 0, 4491, 4493, 5, 519, 0, 0,
		4492, 4490, 1, 0, 0, 0, 4492, 4493, 1, 0, 0, 0, 4493, 517, 1, 0, 0, 0,
		4494, 4496, 5, 401, 0, 0, 4495, 4497, 3, 966, 483, 0, 4496, 4495, 1, 0,
		0, 0, 4496, 4497, 1, 0, 0, 0, 4497, 4498, 1, 0, 0, 0, 4498, 4503, 5, 409,
		0, 0, 4499, 4500, 5, 240, 0, 0, 4500, 4504, 3, 974, 487, 0, 4501, 4502,
		5, 479, 0, 0, 4502, 4504, 3, 850, 425, 0, 4503, 4499, 1, 0, 0, 0, 4503,
		4501, 1, 0, 0, 0, 4503, 4504, 1, 0, 0, 0, 4504, 519, 1, 0, 0, 0, 4505,
		4506, 5, 401, 0, 0, 4506, 4507, 5, 425, 0, 0, 4507, 4535, 5, 519, 0, 0,
		4508, 4509, 5, 401, 0, 0, 4509, 4510, 7, 24, 0, 0, 4510, 4511, 5, 172,
		0, 0, 4511, 4513, 3, 1010, 505, 0, 4512, 4514, 3, 824, 412, 0, 4513, 4512,
		1, 0, 0, 0, 4513, 4514, 1, 0, 0, 0, 4514, 4517, 1, 0, 0, 0, 4515, 4516,
		5, 479, 0, 0, 4516, 4518, 3, 850, 425, 0, 4517, 4515, 1, 0, 0, 0, 4517,
		4518, 1, 0, 0, 0, 4518, 4529, 1, 0, 0, 0, 4519, 4520, 5, 298, 0, 0, 4520,
		4521, 5, 55, 0, 0, 4521, 4526, 3, 768, 384, 0, 4522, 4523, 5, 3, 0, 0,
		4523, 4525, 3, 768, 384, 0, 4524, 4522, 1, 0, 0, 0, 4525, 4528, 1, 0, 0,
		0, 4526, 4524, 1, 0, 0, 0, 4526, 4527, 1, 0, 0, 0, 4527, 4530, 1, 0, 0,
		0, 4528, 4526, 1, 0, 0, 0, 4529, 4519, 1, 0, 0, 0, 4529, 4530, 1, 0, 0,
		0, 4530, 4532, 1, 0, 0, 0, 4531, 4533, 3, 772, 386, 0, 4532, 4531, 1, 0,
		0, 0, 4532, 4533, 1, 0, 0, 0, 4533, 4535, 1, 0, 0, 0, 4534, 4505, 1, 0,
		0, 0, 4534, 4508, 1, 0, 0, 0, 4535, 521, 1, 0, 0, 0, 4536, 4537, 5, 401,
		0, 0, 4537, 4540, 5, 439, 0, 0, 4538, 4539, 7, 1, 0, 0, 4539, 4541, 3,
		1010, 505, 0, 4540, 4538, 1, 0, 0, 0, 4540, 4541, 1, 0, 0, 0, 4541, 4544,
		1, 0, 0, 0, 4542, 4543, 5, 479, 0, 0, 4543, 4545, 3, 850, 425, 0, 4544,
		4542, 1, 0, 0, 0, 4544, 4545, 1, 0, 0, 0, 4545, 523, 1, 0, 0, 0, 4546,
		4548, 5, 401, 0, 0, 4547, 4549, 5, 175, 0, 0, 4548, 4547, 1, 0, 0, 0, 4548,
		4549, 1, 0, 0, 0, 4549, 4550, 1, 0, 0, 0, 4550, 4553, 5, 443, 0, 0, 4551,
		4552, 7, 1, 0, 0, 4552, 4554, 3, 1010, 505, 0, 4553, 4551, 1, 0, 0, 0,
		4553, 4554, 1, 0, 0, 0, 4554, 4559, 1, 0, 0, 0, 4555, 4556, 5, 240, 0,
		0, 4556, 4560, 3, 974, 487, 0, 4557, 4558, 5, 479, 0, 0, 4558, 4560, 3,
		850, 425, 0, 4559, 4555, 1, 0, 0, 0, 4559, 4557, 1, 0, 0, 0, 4559, 4560,
		1, 0, 0, 0, 4560, 525, 1, 0, 0, 0, 4561, 4562, 5, 401, 0, 0, 4562, 4565,
		5, 333, 0, 0, 4563, 4564, 5, 168, 0, 0, 4564, 4566, 3, 974, 487, 0, 4565,
		4563, 1, 0, 0, 0, 4565, 4566, 1, 0, 0, 0, 4566, 4569, 1, 0, 0, 0, 4567,
		4568, 5, 240, 0, 0, 4568, 4570, 3, 974, 487, 0, 4569, 4567, 1, 0, 0, 0,
		4569, 4570, 1, 0, 0, 0, 4570, 4582, 1, 0, 0, 0, 4571, 4572, 5, 401, 0,
		0, 4572, 4575, 5, 332, 0, 0, 4573, 4574, 5, 168, 0, 0, 4574, 4576, 3, 974,
		487, 0, 4575, 4573, 1, 0, 0, 0, 4575, 4576, 1, 0, 0, 0, 4576, 4579, 1,
		0, 0, 0, 4577, 4578, 5, 240, 0, 0, 4578, 4580, 3, 974, 487, 0, 4579, 4577,
		1, 0, 0, 0, 4579, 4580, 1, 0, 0, 0, 4580, 4582, 1, 0, 0, 0, 4581, 4561,
		1, 0, 0, 0, 4581, 4571, 1, 0, 0, 0, 4582, 527, 1, 0, 0, 0, 4583, 4585,
		5, 401, 0, 0, 4584, 4586, 3, 966, 483, 0, 4585, 4584, 1, 0, 0, 0, 4585,
		4586, 1, 0, 0, 0, 4586, 4587, 1, 0, 0, 0, 4587, 4592, 5, 466, 0, 0, 4588,
		4589, 5, 240, 0, 0, 4589, 4593, 3, 974, 487, 0, 4590, 4591, 5, 479, 0,
		0, 4591, 4593, 3, 850, 425, 0, 4592, 4588, 1, 0, 0, 0, 4592, 4590, 1, 0,
		0, 0, 4592, 4593, 1, 0, 0, 0, 4593, 529, 1, 0, 0, 0, 4594, 4595, 5, 401,
		0, 0, 4595, 4597, 7, 25, 0, 0, 4596, 4598, 3, 772, 386, 0, 4597, 4596,
		1, 0, 0, 0, 4597, 4598, 1, 0, 0, 0, 4598, 531, 1, 0, 0, 0, 4599, 4600,
		5, 188, 0, 0, 4600, 4601, 3, 1024, 512, 0, 4601, 533, 1, 0, 0, 0, 4602,
		4603, 5, 90, 0, 0, 4603, 4607, 5, 459, 0, 0, 4604, 4605, 5, 197, 0, 0,
		4605, 4606, 5, 281, 0, 0, 4606, 4608, 5, 148, 0, 0, 4607, 4604, 1, 0, 0,
		0, 4607, 4608, 1, 0, 0, 0, 4608, 4609, 1, 0, 0, 0, 4609, 4611, 3, 1030,
		515, 0, 4610, 4612, 3, 570, 285, 0, 4611, 4610, 1, 0, 0, 0, 4611, 4612,
		1, 0, 0, 0, 4612, 4616, 1, 0, 0, 0, 4613, 4614, 5, 117, 0, 0, 4614, 4615,
		5, 373, 0, 0, 4615, 4617, 3, 692, 346, 0, 4616, 4613, 1, 0, 0, 0, 4616,
		4617, 1, 0, 0, 0, 4617, 4619, 1, 0, 0, 0, 4618, 4620, 3, 952, 476, 0, 4619,
		4618, 1, 0, 0, 0, 4619, 4620, 1, 0, 0, 0, 4620, 535, 1, 0, 0, 0, 4621,
		4622, 5, 132, 0, 0, 4622, 4625, 5, 459, 0, 0, 4623, 4624, 5, 197, 0, 0,
		4624, 4626, 5, 148, 0, 0, 4625, 4623, 1, 0, 0, 0, 4625, 4626, 1, 0, 0,
		0, 4626, 4627, 1, 0, 0, 0, 4627, 4628, 3, 1030, 515, 0, 4628, 537, 1, 0,
		0, 0, 4629, 4630, 5, 19, 0, 0, 4630, 4633, 5, 459, 0, 0, 4631, 4632, 5,
		197, 0, 0, 4632, 4634, 5, 148, 0, 0, 4633, 4631, 1, 0, 0, 0, 4633, 4634,
		1, 0, 0, 0, 4634, 4635, 1, 0, 0, 0, 4635, 4636, 3, 1030, 515, 0, 4636,
		4637, 3, 570, 285, 0, 4637, 4663, 1, 0, 0, 0, 4638, 4639, 5, 19, 0, 0,
		4639, 4642, 5, 459, 0, 0, 4640, 4641, 5, 197, 0, 0, 4641, 4643, 5, 148,
		0, 0, 4642, 4640, 1, 0, 0, 0, 4642, 4643, 1, 0, 0, 0, 4643, 4644, 1, 0,
		0, 0, 4644, 4645, 3, 1030, 515, 0, 4645, 4646, 5, 117, 0, 0, 4646, 4650,
		5, 373, 0, 0, 4647, 4651, 5, 280, 0, 0, 4648, 4651, 5, 18, 0, 0, 4649,
		4651, 3, 692, 346, 0, 4650, 4647, 1, 0, 0, 0, 4650, 4648, 1, 0, 0, 0, 4650,
		4649, 1, 0, 0, 0, 4651, 4663, 1, 0, 0, 0, 4652, 4653, 5, 19, 0, 0, 4653,
		4656, 5, 459, 0, 0, 4654, 4655, 5, 197, 0, 0, 4655, 4657, 5, 148, 0, 0,
		4656, 4654, 1, 0, 0, 0, 4656, 4657, 1, 0, 0, 0, 4657, 4658, 1, 0, 0, 0,
		4658, 4659, 3, 1030, 515, 0, 4659, 4660, 5, 396, 0, 0, 4660, 4661, 3, 952,
		476, 0, 4661, 4663, 1, 0, 0, 0, 4662, 4629, 1, 0, 0, 0, 4662, 4638, 1,
		0, 0, 0, 4662, 4652, 1, 0, 0, 0, 4663, 539, 1, 0, 0, 0, 4664, 4665, 5,
		401, 0, 0, 4665, 4666, 7, 26, 0, 0, 4666, 541, 1, 0, 0, 0, 4667, 4668,
		5, 401, 0, 0, 4668, 4669, 5, 18, 0, 0, 4669, 4677, 5, 31, 0, 0, 4670, 4671,
		5, 401, 0, 0, 4671, 4674, 5, 31, 0, 0, 4672, 4673, 5, 168, 0, 0, 4673,
		4675, 3, 1030, 515, 0, 4674, 4672, 1, 0, 0, 0, 4674, 4675, 1, 0, 0, 0,
		4675, 4677, 1, 0, 0, 0, 4676, 4667, 1, 0, 0, 0, 4676, 4670, 1, 0, 0, 0,
		4677, 543, 1, 0, 0, 0, 4678, 4679, 5, 147, 0, 0, 4679, 4680, 5, 27, 0,
		0, 4680, 4684, 3, 1030, 515, 0, 4681, 4682, 5, 481, 0, 0, 4682, 4683, 5,
		277, 0, 0, 4683, 4685, 5, 370, 0, 0, 4684, 4681, 1, 0, 0, 0, 4684, 4685,
		1, 0, 0, 0, 4685, 545, 1, 0, 0, 0, 4686, 4687, 5, 90, 0, 0, 4687, 4691,
		5, 373, 0, 0, 4688, 4689, 5, 197, 0, 0, 4689, 4690, 5, 281, 0, 0, 4690,
		4692, 5, 148, 0, 0, 4691, 4688, 1, 0, 0, 0, 4691, 4692, 1, 0, 0, 0, 4692,
		4693, 1, 0, 0, 0, 4693, 4695, 3, 692, 346, 0, 4694, 4696, 3, 968, 484,
		0, 4695, 4694, 1, 0, 0, 0, 4695, 4696, 1, 0, 0, 0, 4696, 547, 1, 0, 0,
		0, 4697, 4698, 5, 19, 0, 0, 4698, 4701, 5, 373, 0, 0, 4699, 4700, 5, 197,
		0, 0, 4700, 4702, 5, 148, 0, 0, 4701, 4699, 1, 0, 0, 0, 4701, 4702, 1,
		0, 0, 0, 4702, 4703, 1, 0, 0, 0, 4703, 4704, 3, 692, 346, 0, 4704, 4705,
		5, 396, 0, 0, 4705, 4706, 5, 78, 0, 0, 4706, 4707, 5, 493, 0, 0, 4707,
		4708, 3, 974, 487, 0, 4708, 549, 1, 0, 0, 0, 4709, 4710, 5, 132, 0, 0,
		4710, 4713, 5, 373, 0, 0, 4711, 4712, 5, 197, 0, 0, 4712, 4714, 5, 148,
		0, 0, 4713, 4711, 1, 0, 0, 0, 4713, 4714, 1, 0, 0, 0, 4714, 4715, 1, 0,
		0, 0, 4715, 4716, 3, 692, 346, 0, 4716, 551, 1, 0, 0, 0, 4717, 4718, 5,
		401, 0, 0, 4718, 4719, 5, 374, 0, 0, 4719, 553, 1, 0, 0, 0, 4720, 4721,
		5, 179, 0, 0, 4721, 4722, 3, 1026, 513, 0, 4722, 4724, 5, 441, 0, 0, 4723,
		4725, 5, 459, 0, 0, 4724, 4723, 1, 0, 0, 0, 4724, 4725, 1, 0, 0, 0, 4725,
		4726, 1, 0, 0, 0, 4726, 4727, 3, 1030, 515, 0, 4727, 4735, 1, 0, 0, 0,
		4728, 4729, 5, 179, 0, 0, 4729, 4730, 3, 1026, 513, 0, 4730, 4731, 5, 441,
		0, 0, 4731, 4732, 5, 373, 0, 0, 4732, 4733, 3, 1024, 512, 0, 4733, 4735,
		1, 0, 0, 0, 4734, 4720, 1, 0, 0, 0, 4734, 4728, 1, 0, 0, 0, 4735, 555,
		1, 0, 0, 0, 4736, 4737, 5, 369, 0, 0, 4737, 4738, 3, 1026, 513, 0, 4738,
		4740, 5, 172, 0, 0, 4739, 4741, 5, 459, 0, 0, 4740, 4739, 1, 0, 0, 0, 4740,
		4741, 1, 0, 0, 0, 4741, 4742, 1, 0, 0, 0, 4742, 4743, 3, 1030, 515, 0,
		4743, 4751, 1, 0, 0, 0, 4744, 4745, 5, 369, 0, 0, 4745, 4746, 3, 1026,
		513, 0, 4746, 4747, 5, 172, 0, 0, 4747, 4748, 5, 373, 0, 0, 4748, 4749,
		3, 1024, 512, 0, 4749, 4751, 1, 0, 0, 0, 4750, 4736, 1, 0, 0, 0, 4750,
		4744, 1, 0, 0, 0, 4751, 557, 1, 0, 0, 0, 4752, 4753, 5, 396, 0, 0, 4753,
		4754, 5, 373, 0, 0, 4754, 4769, 5, 117, 0, 0, 4755, 4756, 5, 396, 0, 0,
		4756, 4757, 5, 373, 0, 0, 4757, 4769, 5, 280, 0, 0, 4758, 4759, 5, 396,
		0, 0, 4759, 4760, 5, 373, 0, 0, 4760, 4763, 5, 18, 0, 0, 4761, 4762, 5,
		145, 0, 0, 4762, 4764, 3, 692, 346, 0, 4763, 4761, 1, 0, 0, 0, 4763, 4764,
		1, 0, 0, 0, 4764, 4769, 1, 0, 0, 0, 4765, 4766, 5, 396, 0, 0, 4766, 4767,
		5, 373, 0, 0, 4767, 4769, 3, 692, 346, 0, 4768, 4752, 1, 0, 0, 0, 4768,
		4755, 1, 0, 0, 0, 4768, 4758, 1, 0, 0, 0, 4768, 4765, 1, 0, 0, 0, 4769,
		559, 1, 0, 0, 0, 4770, 4771, 5, 396, 0, 0, 4771, 4772, 5, 117, 0, 0, 4772,
		4776, 5, 373, 0, 0, 4773, 4777, 5, 280, 0, 0, 4774, 4777, 5, 18, 0, 0,
		4775, 4777, 3, 692, 346, 0, 4776, 4773, 1, 0, 0, 0, 4776, 4774, 1, 0, 0,
		0, 4776, 4775, 1, 0, 0, 0, 4777, 4778, 1, 0, 0, 0, 4778, 4779, 5, 441,
		0, 0, 4779, 4780, 3, 1030, 515, 0, 4780, 561, 1, 0, 0, 0, 4781, 4783, 5,
		459, 0, 0, 4782, 4781, 1, 0, 0, 0, 4782, 4783, 1, 0, 0, 0, 4783, 4784,
		1, 0, 0, 0, 4784, 4788, 3, 1030, 515, 0, 4785, 4786, 5, 373, 0, 0, 4786,
		4788, 3, 1024, 512, 0, 4787, 4782, 1, 0, 0, 0, 4787, 4785, 1, 0, 0, 0,
		4788, 563, 1, 0, 0, 0, 4789, 4790, 5, 179, 0, 0, 4790, 4791, 5, 198, 0,
		0, 4791, 4792, 5, 290, 0, 0, 4792, 4793, 5, 459, 0, 0, 4793, 4798, 3, 1030,
		515, 0, 4794, 4795, 5, 3, 0, 0, 4795, 4797, 3, 1030, 515, 0, 4796, 4794,
		1, 0, 0, 0, 4797, 4800, 1, 0, 0, 0, 4798, 4796, 1, 0, 0, 0, 4798, 4799,
		1, 0, 0, 0, 4799, 4801, 1, 0, 0, 0, 4800, 4798, 1, 0, 0, 0, 4801, 4802,
		5, 441, 0, 0, 4802, 4806, 3, 562, 281, 0, 4803, 4804, 5, 481, 0, 0, 4804,
		4805, 5, 179, 0, 0, 4805, 4807, 5, 296, 0, 0, 4806, 4803, 1, 0, 0, 0, 4806,
		4807, 1, 0, 0, 0, 4807, 4878, 1, 0, 0, 0, 4808, 4809, 5, 179, 0, 0, 4809,
		4810, 3, 578, 289, 0, 4810, 4811, 5, 290, 0, 0, 4811, 4812, 3, 574, 287,
		0, 4812, 4813, 5, 441, 0, 0, 4813, 4817, 3, 562, 281, 0, 4814, 4815, 5,
		481, 0, 0, 4815, 4816, 5, 179, 0, 0, 4816, 4818, 5, 296, 0, 0, 4817, 4814,
		1, 0, 0, 0, 4817, 4818, 1, 0, 0, 0, 4818, 4878, 1, 0, 0, 0, 4819, 4820,
		5, 179, 0, 0, 4820, 4821, 3, 578, 289, 0, 4821, 4823, 5, 290, 0, 0, 4822,
		4824, 5, 178, 0, 0, 4823, 4822, 1, 0, 0, 0, 4823, 4824, 1, 0, 0, 0, 4824,
		4825, 1, 0, 0, 0, 4825, 4826, 5, 176, 0, 0, 4826, 4827, 3, 576, 288, 0,
		4827, 4828, 5, 441, 0, 0, 4828, 4832, 3, 562, 281, 0, 4829, 4830, 5, 481,
		0, 0, 4830, 4831, 5, 179, 0, 0, 4831, 4833, 5, 296, 0, 0, 4832, 4829, 1,
		0, 0, 0, 4832, 4833, 1, 0, 0, 0, 4833, 4878, 1, 0, 0, 0, 4834, 4835, 5,
		179, 0, 0, 4835, 4836, 3, 578, 289, 0, 4836, 4837, 5, 290, 0, 0, 4837,
		4838, 5, 419, 0, 0, 4838, 4839, 5, 441, 0, 0, 4839, 4843, 3, 562, 281,
		0, 4840, 4841, 5, 481, 0, 0, 4841, 4842, 5, 179, 0, 0, 4842, 4844, 5, 296,
		0, 0, 4843, 4840, 1, 0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 4878, 1, 0,
		0, 0, 4845, 4846, 5, 179, 0, 0, 4846, 4847, 3, 578, 289, 0, 4847, 4848,
		5, 290, 0, 0, 4848, 4849, 3, 582, 291, 0, 4849, 4850, 3, 574, 287, 0, 4850,
		4851, 5, 441, 0, 0, 4851, 4855, 3, 562, 281, 0, 4852, 4853, 5, 481, 0,
		0, 4853, 4854, 5, 179, 0, 0, 4854, 4856, 5, 296, 0, 0, 4855, 4852, 1, 0,
		0, 0, 4855, 4856, 1, 0, 0, 0, 4856, 4878, 1, 0, 0, 0, 4857, 4858, 5, 179,
		0, 0, 4858, 4859, 3, 578, 289, 0, 4859, 4860, 5, 290, 0, 0, 4860, 4861,
		5, 18, 0, 0, 4861, 4868, 3, 584, 292, 0, 4862, 4863, 5, 202, 0, 0, 4863,
		4864, 5, 18, 0, 0, 4864, 4869, 5, 105, 0, 0, 4865, 4866, 5, 202, 0, 0,
		4866, 4867, 5, 104, 0, 0, 4867, 4869, 3, 1024, 512, 0, 4868, 4862, 1, 0,
		0, 0, 4868, 4865, 1, 0, 0, 0, 4868, 4869, 1, 0, 0, 0, 4869, 4870, 1, 0,
		0, 0, 4870, 4871, 5, 441, 0, 0, 4871, 4875, 3, 562, 281, 0, 4872, 4873,
		5, 481, 0, 0, 4873, 4874, 5, 179, 0, 0, 4874, 4876, 5, 296, 0, 0, 4875,
		4872, 1, 0, 0, 0, 4875, 4876, 1, 0, 0, 0, 4876, 4878, 1, 0, 0, 0, 4877,
		4789, 1, 0, 0, 0, 4877, 4808, 1, 0, 0, 0, 4877, 4819, 1, 0, 0, 0, 4877,
		4834, 1, 0, 0, 0, 4877, 4845, 1, 0, 0, 0, 4877, 4857, 1, 0, 0, 0, 4878,
		565, 1, 0, 0, 0, 4879, 4880, 5, 369, 0, 0, 4880, 4881, 5, 198, 0, 0, 4881,
		4882, 5, 290, 0, 0, 4882, 4883, 5, 459, 0, 0, 4883, 4888, 3, 1030, 515,
		0, 4884, 4885, 5, 3, 0, 0, 4885, 4887, 3, 1030, 515, 0, 4886, 4884, 1,
		0, 0, 0, 4887, 4890, 1, 0, 0, 0, 4888, 4886, 1, 0, 0, 0, 4888, 4889, 1,
		0, 0, 0, 4889, 4891, 1, 0, 0, 0, 4890, 4888, 1, 0, 0, 0, 4891, 4892, 5,
		172, 0, 0, 4892, 4893, 3, 562, 281, 0, 4893, 4944, 1, 0, 0, 0, 4894, 4895,
		5, 369, 0, 0, 4895, 4896, 3, 578, 289, 0, 4896, 4897, 5, 290, 0, 0, 4897,
		4898, 3, 574, 287, 0, 4898, 4899, 5, 172, 0, 0, 4899, 4900, 3, 562, 281,
		0, 4900, 4944, 1, 0, 0, 0, 4901, 4902, 5, 369, 0, 0, 4902, 4903, 3, 578,
		289, 0, 4903, 4905, 5, 290, 0, 0, 4904, 4906, 5, 178, 0, 0, 4905, 4904,
		1, 0, 0, 0, 4905, 4906, 1, 0, 0, 0, 4906, 4907, 1, 0, 0, 0, 4907, 4908,
		5, 176, 0, 0, 4908, 4909, 3, 576, 288, 0, 4909, 4910, 5, 172, 0, 0, 4910,
		4911, 3, 562, 281, 0, 4911, 4944, 1, 0, 0, 0, 4912, 4913, 5, 369, 0, 0,
		4913, 4914, 3, 578, 289, 0, 4914, 4915, 5, 290, 0, 0, 4915, 4916, 5, 419,
		0, 0, 4916, 4917, 5, 172, 0, 0, 4917, 4918, 3, 562, 281, 0, 4918, 4944,
		1, 0, 0, 0, 4919, 4920, 5, 369, 0, 0, 4920, 4921, 3, 578, 289, 0, 4921,
		4922, 5, 290, 0, 0, 4922, 4923, 3, 582, 291, 0, 4923, 4924, 3, 574, 287,
		0, 4924, 4925, 5, 172, 0, 0, 4925, 4926, 3, 562, 281, 0, 4926, 4944, 1,
		0, 0, 0, 4927, 4928, 5, 369, 0, 0, 4928, 4929, 3, 578, 289, 0, 4929, 4930,
		5, 290, 0, 0, 4930, 4931, 5, 18, 0, 0, 4931, 4938, 3, 584, 292, 0, 4932,
		4933, 5, 202, 0, 0, 4933, 4934, 5, 18, 0, 0, 4934, 4939, 5, 105, 0, 0,
		4935, 4936, 5, 202, 0, 0, 4936, 4937, 5, 104, 0, 0, 4937, 4939, 3, 1024,
		512, 0, 4938, 4932, 1, 0, 0, 0, 4938, 4935, 1, 0, 0, 0, 4938, 4939, 1,
		0, 0, 0, 4939, 4940, 1, 0, 0, 0, 4940, 4941, 5, 172, 0, 0, 4941, 4942,
		3, 562, 281, 0, 4942, 4944, 1, 0, 0, 0, 4943, 4879, 1, 0, 0, 0, 4943, 4894,
		1, 0, 0, 0, 4943, 4901, 1, 0, 0, 0, 4943, 4912, 1, 0, 0, 0, 4943, 4919,
		1, 0, 0, 0, 4943, 4927, 1, 0, 0, 0, 4944, 567, 1, 0, 0, 0, 4945, 4946,
		5, 401, 0, 0, 4946, 4960, 5, 180, 0, 0, 4947, 4948, 5, 401, 0, 0, 4948,
		4949, 5, 180, 0, 0, 4949, 4951, 5, 168, 0, 0, 4950, 4952, 5, 459, 0, 0,
		4951, 4950, 1, 0, 0, 0, 4951, 4952, 1, 0, 0, 0, 4952, 4953, 1, 0, 0, 0,
		4953, 4960, 3, 1030, 515, 0, 4954, 4955, 5, 401, 0, 0, 4955, 4956, 5, 180,
		0, 0, 4956, 4957, 5, 168, 0, 0, 4957, 4958, 5, 373, 0, 0, 4958, 4960, 3,
		1024, 512, 0, 4959, 4945, 1, 0, 0, 0, 4959, 4947, 1, 0, 0, 0, 4959, 4954,
		1, 0, 0, 0, 4960, 569, 1, 0, 0, 0, 4961, 4962, 5, 196, 0, 0, 4962, 4964,
		5, 55, 0, 0, 4963, 4965, 5, 305, 0, 0, 4964, 4963, 1, 0, 0, 0, 4964, 4965,
		1, 0, 0, 0, 4965, 4966, 1, 0, 0, 0, 4966, 4975, 3, 974, 487, 0, 4967, 4968,
		5, 196, 0, 0, 4968, 4969, 5, 481, 0, 0, 4969, 4972, 3, 1024, 512, 0, 4970,
		4971, 7, 27, 0, 0, 4971, 4973, 3, 974, 487, 0, 4972, 4970, 1, 0, 0, 0,
		4972, 4973, 1, 0, 0, 0, 4973, 4975, 1, 0, 0, 0, 4974, 4961, 1, 0, 0, 0,
		4974, 4967, 1, 0, 0, 0, 4975, 571, 1, 0, 0, 0, 4976, 4979, 3, 1028, 514,
		0, 4977, 4978, 5, 1, 0, 0, 4978, 4980, 3, 1028, 514, 0, 4979, 4977, 1,
		0, 0, 0, 4979, 4980, 1, 0, 0, 0, 4980, 573, 1, 0, 0, 0, 4981, 4986, 3,
		572, 286, 0, 4982, 4983, 5, 3, 0, 0, 4983, 4985, 3, 572, 286, 0, 4984,
		4982, 1, 0, 0, 0, 4985, 4988, 1, 0, 0, 0, 4986, 4984, 1, 0, 0, 0, 4986,
		4987, 1, 0, 0, 0, 4987, 575, 1, 0, 0, 0, 4988, 4986, 1, 0, 0, 0, 4989,
		4990, 3, 1010, 505, 0, 4990, 4991, 5, 2, 0, 0, 4991, 4992, 3, 454, 227,
		0, 4992, 5001, 5, 4, 0, 0, 4993, 4994, 5, 3, 0, 0, 4994, 4995, 3, 1010,
		505, 0, 4995, 4996, 5, 2, 0, 0, 4996, 4997, 3, 454, 227, 0, 4997, 4998,
		5, 4, 0, 0, 4998, 5000, 1, 0, 0, 0, 4999, 4993, 1, 0, 0, 0, 5000, 5003,
		1, 0, 0, 0, 5001, 4999, 1, 0, 0, 0, 5001, 5002, 1, 0, 0, 0, 5002, 577,
		1, 0, 0, 0, 5003, 5001, 1, 0, 0, 0, 5004, 5009, 3, 580, 290, 0, 5005, 5006,
		5, 3, 0, 0, 5006, 5008, 3, 580, 290, 0, 5007, 5005, 1, 0, 0, 0, 5008, 5011,
		1, 0, 0, 0, 5009, 5007, 1, 0, 0, 0, 5009, 5010, 1, 0, 0, 0, 5010, 579,
		1, 0, 0, 0, 5011, 5009, 1, 0, 0, 0, 5012, 5014, 5, 18, 0, 0, 5013, 5015,
		5, 325, 0, 0, 5014, 5013, 1, 0, 0, 0, 5014, 5015, 1, 0, 0, 0, 5015, 5056,
		1, 0, 0, 0, 5016, 5056, 5, 19, 0, 0, 5017, 5056, 5, 23, 0, 0, 5018, 5056,
		5, 47, 0, 0, 5019, 5038, 5, 90, 0, 0, 5020, 5039, 5, 104, 0, 0, 5021, 5039,
		5, 423, 0, 0, 5022, 5039, 5, 470, 0, 0, 5023, 5039, 5, 176, 0, 0, 5024,
		5025, 5, 178, 0, 0, 5025, 5039, 5, 176, 0, 0, 5026, 5027, 5, 257, 0, 0,
		5027, 5039, 5, 470, 0, 0, 5028, 5039, 5, 361, 0, 0, 5029, 5030, 5, 361,
		0, 0, 5030, 5039, 5, 181, 0, 0, 5031, 5032, 5, 151, 0, 0, 5032, 5039, 5,
		60, 0, 0, 5033, 5034, 5, 411, 0, 0, 5034, 5039, 5, 472, 0, 0, 5035, 5039,
		5, 474, 0, 0, 5036, 5039, 5, 72, 0, 0, 5037, 5039, 5, 315, 0, 0, 5038,
		5020, 1, 0, 0, 0, 5038, 5021, 1, 0, 0, 0, 5038, 5022, 1, 0, 0, 0, 5038,
		5023, 1, 0, 0, 0, 5038, 5024, 1, 0, 0, 0, 5038, 5026, 1, 0, 0, 0, 5038,
		5028, 1, 0, 0, 0, 5038, 5029, 1, 0, 0, 0, 5038, 5031, 1, 0, 0, 0, 5038,
		5033, 1, 0, 0, 0, 5038, 5035, 1, 0, 0, 0, 5038, 5036, 1, 0, 0, 0, 5038,
		5037, 1, 0, 0, 0, 5039, 5056, 1, 0, 0, 0, 5040, 5056, 5, 118, 0, 0, 5041,
		5056, 5, 132, 0, 0, 5042, 5056, 5, 150, 0, 0, 5043, 5056, 5, 158, 0, 0,
		5044, 5056, 5, 198, 0, 0, 5045, 5056, 5, 210, 0, 0, 5046, 5056, 5, 179,
		0, 0, 5047, 5056, 5, 278, 0, 0, 5048, 5056, 5, 293, 0, 0, 5049, 5056, 5,
		313, 0, 0, 5050, 5056, 5, 359, 0, 0, 5051, 5056, 5, 348, 0, 0, 5052, 5056,
		5, 391, 0, 0, 5053, 5056, 5, 456, 0, 0, 5054, 5056, 5, 457, 0, 0, 5055,
		5012, 1, 0, 0, 0, 5055, 5016, 1, 0, 0, 0, 5055, 5017, 1, 0, 0, 0, 5055,
		5018, 1, 0, 0, 0, 5055, 5019, 1, 0, 0, 0, 5055, 5040, 1, 0, 0, 0, 5055,
		5041, 1, 0, 0, 0, 5055, 5042, 1, 0, 0, 0, 5055, 5043, 1, 0, 0, 0, 5055,
		5044, 1, 0, 0, 0, 5055, 5045, 1, 0, 0, 0, 5055, 5046, 1, 0, 0, 0, 5055,
		5047, 1, 0, 0, 0, 5055, 5048, 1, 0, 0, 0, 5055, 5049, 1, 0, 0, 0, 5055,
		5050, 1, 0, 0, 0, 5055, 5051, 1, 0, 0, 0, 5055, 5052, 1, 0, 0, 0, 5055,
		5053, 1, 0, 0, 0, 5055, 5054, 1, 0, 0, 0, 5056, 581, 1, 0, 0, 0, 5057,
		5072, 5, 60, 0, 0, 5058, 5072, 5, 104, 0, 0, 5059, 5060, 5, 257, 0, 0,
		5060, 5072, 5, 470, 0, 0, 5061, 5072, 5, 361, 0, 0, 5062, 5063, 5, 361,
		0, 0, 5063, 5072, 5, 181, 0, 0, 5064, 5065, 5, 411, 0, 0, 5065, 5072, 5,
		472, 0, 0, 5066, 5072, 5, 419, 0, 0, 5067, 5072, 5, 423, 0, 0, 5068, 5072,
		5, 470, 0, 0, 5069, 5072, 5, 474, 0, 0, 5070, 5072, 5, 315, 0, 0, 5071,
		5057, 1, 0, 0, 0, 5071, 5058, 1, 0, 0, 0, 5071, 5059, 1, 0, 0, 0, 5071,
		5061, 1, 0, 0, 0, 5071, 5062, 1, 0, 0, 0, 5071, 5064, 1, 0, 0, 0, 5071,
		5066, 1, 0, 0, 0, 5071, 5067, 1, 0, 0, 0, 5071, 5068, 1, 0, 0, 0, 5071,
		5069, 1, 0, 0, 0, 5071, 5070, 1, 0, 0, 0, 5072, 583, 1, 0, 0, 0, 5073,
		5092, 5, 61, 0, 0, 5074, 5092, 5, 105, 0, 0, 5075, 5092, 5, 177, 0, 0,
		5076, 5077, 5, 178, 0, 0, 5077, 5092, 5, 177, 0, 0, 5078, 5079, 5, 257,
		0, 0, 5079, 5092, 5, 471, 0, 0, 5080, 5092, 5, 319, 0, 0, 5081, 5092, 5,
		362, 0, 0, 5082, 5083, 5, 361, 0, 0, 5083, 5092, 5, 182, 0, 0, 5084, 5085,
		5, 411, 0, 0, 5085, 5092, 5, 473, 0, 0, 5086, 5092, 5, 424, 0, 0, 5087,
		5092, 5, 460, 0, 0, 5088, 5092, 5, 471, 0, 0, 5089, 5092, 5, 475, 0, 0,
		5090, 5092, 5, 316, 0, 0, 5091, 5073, 1, 0, 0, 0, 5091, 5074, 1, 0, 0,
		0, 5091, 5075, 1, 0, 0, 0, 5091, 5076, 1, 0, 0, 0, 5091, 5078, 1, 0, 0,
		0, 5091, 5080, 1, 0, 0, 0, 5091, 5081, 1, 0, 0, 0, 5091, 5082, 1, 0, 0,
		0, 5091, 5084, 1, 0, 0, 0, 5091, 5086, 1, 0, 0, 0, 5091, 5087, 1, 0, 0,
		0, 5091, 5088, 1, 0, 0, 0, 5091, 5089, 1, 0, 0, 0, 5091, 5090, 1, 0, 0,
		0, 5092, 585, 1, 0, 0, 0, 5093, 5094, 5, 90, 0, 0, 5094, 5095, 5, 390,
		0, 0, 5095, 5096, 5, 213, 0, 0, 5096, 5097, 3, 1016, 508, 0, 5097, 5098,
		3, 952, 476, 0, 5098, 587, 1, 0, 0, 0, 5099, 5100, 5, 19, 0, 0, 5100, 5101,
		5, 390, 0, 0, 5101, 5102, 5, 213, 0, 0, 5102, 5103, 3, 1016, 508, 0, 5103,
		5104, 5, 396, 0, 0, 5104, 5105, 3, 956, 478, 0, 5105, 589, 1, 0, 0, 0,
		5106, 5107, 5, 132, 0, 0, 5107, 5108, 5, 390, 0, 0, 5108, 5109, 5, 213,
		0, 0, 5109, 5110, 3, 1016, 508, 0, 5110, 591, 1, 0, 0, 0, 5111, 5112, 5,
		401, 0, 0, 5112, 5113, 5, 390, 0, 0, 5113, 5114, 5, 214, 0, 0, 5114, 593,
		1, 0, 0, 0, 5115, 5116, 5, 401, 0, 0, 5116, 5117, 5, 90, 0, 0, 5117, 5118,
		5, 390, 0, 0, 5118, 5119, 5, 213, 0, 0, 5119, 5120, 3, 1016, 508, 0, 5120,
		595, 1, 0, 0, 0, 5121, 5122, 5, 90, 0, 0, 5122, 5123, 5, 181, 0, 0, 5123,
		5124, 5, 334, 0, 0, 5124, 5125, 3, 1016, 508, 0, 5125, 5126, 3, 952, 476,
		0, 5126, 597, 1, 0, 0, 0, 5127, 5128, 5, 132, 0, 0, 5128, 5129, 5, 181,
		0, 0, 5129, 5130, 5, 334, 0, 0, 5130, 5131, 3, 1016, 508, 0, 5131, 599,
		1, 0, 0, 0, 5132, 5133, 5, 401, 0, 0, 5133, 5134, 5, 181, 0, 0, 5134, 5135,
		5, 335, 0, 0, 5135, 601, 1, 0, 0, 0, 5136, 5137, 5, 401, 0, 0, 5137, 5138,
		5, 90, 0, 0, 5138, 5139, 5, 181, 0, 0, 5139, 5140, 5, 334, 0, 0, 5140,
		5141, 3, 1016, 508, 0, 5141, 603, 1, 0, 0, 0, 5142, 5149, 5, 37, 0, 0,
		5143, 5144, 5, 18, 0, 0, 5144, 5145, 5, 151, 0, 0, 5145, 5150, 5, 61, 0,
		0, 5146, 5147, 5, 151, 0, 0, 5147, 5148, 7, 28, 0, 0, 5148, 5150, 3, 1022,
		511, 0, 5149, 5143, 1, 0, 0, 0, 5149, 5146, 1, 0, 0, 0, 5149, 5150, 1,
		0, 0, 0, 5150, 5153, 1, 0, 0, 0, 5151, 5152, 5, 104, 0, 0, 5152, 5154,
		3, 1016, 508, 0, 5153, 5151, 1, 0, 0, 0, 5153, 5154, 1, 0, 0, 0, 5154,
		5155, 1, 0, 0, 0, 5155, 5156, 5, 403, 0, 0, 5156, 5157, 3, 1010, 505, 0,
		5157, 5158, 5, 441, 0, 0, 5158, 5171, 3, 1016, 508, 0, 5159, 5160, 5, 290,
		0, 0, 5160, 5161, 5, 2, 0, 0, 5161, 5166, 3, 896, 448, 0, 5162, 5163, 5,
		3, 0, 0, 5163, 5165, 3, 896, 448, 0, 5164, 5162, 1, 0, 0, 0, 5165, 5168,
		1, 0, 0, 0, 5166, 5164, 1, 0, 0, 0, 5166, 5167, 1, 0, 0, 0, 5167, 5169,
		1, 0, 0, 0, 5168, 5166, 1, 0, 0, 0, 5169, 5170, 5, 4, 0, 0, 5170, 5172,
		1, 0, 0, 0, 5171, 5159, 1, 0, 0, 0, 5171, 5172, 1, 0, 0, 0, 5172, 5175,
		1, 0, 0, 0, 5173, 5174, 5, 332, 0, 0, 5174, 5176, 3, 956, 478, 0, 5175,
		5173, 1, 0, 0, 0, 5175, 5176, 1, 0, 0, 0, 5176, 605, 1, 0, 0, 0, 5177,
		5178, 5, 57, 0, 0, 5178, 5184, 5, 37, 0, 0, 5179, 5180, 7, 1, 0, 0, 5180,
		5185, 3, 1016, 508, 0, 5181, 5182, 5, 168, 0, 0, 5182, 5183, 5, 151, 0,
		0, 5183, 5185, 5, 60, 0, 0, 5184, 5179, 1, 0, 0, 0, 5184, 5181, 1, 0, 0,
		0, 5184, 5185, 1, 0, 0, 0, 5185, 607, 1, 0, 0, 0, 5186, 5187, 5, 401, 0,
		0, 5187, 5190, 5, 37, 0, 0, 5188, 5189, 7, 1, 0, 0, 5189, 5191, 3, 1016,
		508, 0, 5190, 5188, 1, 0, 0, 0, 5190, 5191, 1, 0, 0, 0, 5191, 609, 1, 0,
		0, 0, 5192, 5193, 5, 363, 0, 0, 5193, 5194, 5, 403, 0, 0, 5194, 5195, 3,
		1010, 505, 0, 5195, 5196, 5, 172, 0, 0, 5196, 5203, 3, 1016, 508, 0, 5197,
		5198, 5, 18, 0, 0, 5198, 5199, 5, 151, 0, 0, 5199, 5204, 5, 61, 0, 0, 5200,
		5201, 5, 151, 0, 0, 5201, 5202, 7, 28, 0, 0, 5202, 5204, 3, 1020, 510,
		0, 5203, 5197, 1, 0, 0, 0, 5203, 5200, 1, 0, 0, 0, 5203, 5204, 1, 0, 0,
		0, 5204, 5211, 1, 0, 0, 0, 5205, 5206, 5, 104, 0, 0, 5206, 5209, 3, 1016,
		508, 0, 5207, 5208, 5, 27, 0, 0, 5208, 5210, 3, 1016, 508, 0, 5209, 5207,
		1, 0, 0, 0, 5209, 5210, 1, 0, 0, 0, 5210, 5212, 1, 0, 0, 0, 5211, 5205,
		1, 0, 0, 0, 5211, 5212, 1, 0, 0, 0, 5212, 5225, 1, 0, 0, 0, 5213, 5214,
		5, 290, 0, 0, 5214, 5215, 5, 2, 0, 0, 5215, 5220, 3, 896, 448, 0, 5216,
		5217, 5, 3, 0, 0, 5217, 5219, 3, 896, 448, 0, 5218, 5216, 1, 0, 0, 0, 5219,
		5222, 1, 0, 0, 0, 5220, 5218, 1, 0, 0, 0, 5220, 5221, 1, 0, 0, 0, 5221,
		5223, 1, 0, 0, 0, 5222, 5220, 1, 0, 0, 0, 5223, 5224, 5, 4, 0, 0, 5224,
		5226, 1, 0, 0, 0, 5225, 5213, 1, 0, 0, 0, 5225, 5226, 1, 0, 0, 0, 5226,
		5229, 1, 0, 0, 0, 5227, 5228, 5, 332, 0, 0, 5228, 5230, 3, 956, 478, 0,
		5229, 5227, 1, 0, 0, 0, 5229, 5230, 1, 0, 0, 0, 5230, 611, 1, 0, 0, 0,
		5231, 5232, 5, 57, 0, 0, 5232, 5238, 5, 363, 0, 0, 5233, 5234, 7, 1, 0,
		0, 5234, 5239, 3, 1016, 508, 0, 5235, 5236, 5, 168, 0, 0, 5236, 5237, 5,
		151, 0, 0, 5237, 5239, 5, 60, 0, 0, 5238, 5233, 1, 0, 0, 0, 5238, 5235,
		1, 0, 0, 0, 5238, 5239, 1, 0, 0, 0, 5239, 613, 1, 0, 0, 0, 5240, 5241,
		5, 401, 0, 0, 5241, 5244, 5, 363, 0, 0, 5242, 5243, 7, 1, 0, 0, 5243, 5245,
		3, 1016, 508, 0, 5244, 5242, 1, 0, 0, 0, 5244, 5245, 1, 0, 0, 0, 5245,
		5248, 1, 0, 0, 0, 5246, 5247, 5, 479, 0, 0, 5247, 5249, 3, 850, 425, 0,
		5248, 5246, 1, 0, 0, 0, 5248, 5249, 1, 0, 0, 0, 5249, 615, 1, 0, 0, 0,
		5250, 5251, 5, 401, 0, 0, 5251, 5252, 5, 403, 0, 0, 5252, 5253, 5, 290,
		0, 0, 5253, 5256, 3, 1016, 508, 0, 5254, 5255, 5, 479, 0, 0, 5255, 5257,
		3, 850, 425, 0, 5256, 5254, 1, 0, 0, 0, 5256, 5257, 1, 0, 0, 0, 5257, 617,
		1, 0, 0, 0, 5258, 5261, 5, 90, 0, 0, 5259, 5260, 5, 345, 0, 0, 5260, 5262,
		5, 291, 0, 0, 5261, 5259, 1, 0, 0, 0, 5261, 5262, 1, 0, 0, 0, 5262, 5263,
		1, 0, 0, 0, 5263, 5264, 5, 359, 0, 0, 5264, 5265, 3, 1016, 508, 0, 5265,
		5266, 5, 481, 0, 0, 5266, 5268, 5, 52, 0, 0, 5267, 5269, 3, 1024, 512,
		0, 5268, 5267, 1, 0, 0, 0, 5268, 5269, 1, 0, 0, 0, 5269, 5270, 1, 0, 0,
		0, 5270, 5271, 5, 290, 0, 0, 5271, 5272, 5, 247, 0, 0, 5272, 5275, 3, 974,
		487, 0, 5273, 5274, 5, 332, 0, 0, 5274, 5276, 3, 956, 478, 0, 5275, 5273,
		1, 0, 0, 0, 5275, 5276, 1, 0, 0, 0, 5276, 619, 1, 0, 0, 0, 5277, 5278,
		5, 132, 0, 0, 5278, 5279, 5, 359, 0, 0, 5279, 5280, 3, 1016, 508, 0, 5280,
		621, 1, 0, 0, 0, 5281, 5282, 5, 13, 0, 0, 5282, 5283, 5, 405, 0, 0, 5283,
		5284, 3, 974, 487, 0, 5284, 623, 1, 0, 0, 0, 5285, 5286, 5, 118, 0, 0,
		5286, 5287, 5, 405, 0, 0, 5287, 5292, 5, 519, 0, 0, 5288, 5289, 5, 3, 0,
		0, 5289, 5291, 5, 519, 0, 0, 5290, 5288, 1, 0, 0, 0, 5291, 5294, 1, 0,
		0, 0, 5292, 5290, 1, 0, 0, 0, 5292, 5293, 1, 0, 0, 0, 5293, 625, 1, 0,
		0, 0, 5294, 5292, 1, 0, 0, 0, 5295, 5296, 5, 401, 0, 0, 5296, 5297, 5,
		405, 0, 0, 5297, 627, 1, 0, 0, 0, 5298, 5299, 5, 401, 0, 0, 5299, 5300,
		5, 480, 0, 0, 5300, 629, 1, 0, 0, 0, 5301, 5302, 5, 13, 0, 0, 5302, 5303,
		5, 35, 0, 0, 5303, 5304, 5, 47, 0, 0, 5304, 5309, 5, 519, 0, 0, 5305, 5306,
		5, 3, 0, 0, 5306, 5308, 5, 519, 0, 0, 5307, 5305, 1, 0, 0, 0, 5308, 5311,
		1, 0, 0, 0, 5309, 5307, 1, 0, 0, 0, 5309, 5310, 1, 0, 0, 0, 5310, 631,
		1, 0, 0, 0, 5311, 5309, 1, 0, 0, 0, 5312, 5313, 5, 118, 0, 0, 5313, 5314,
		5, 35, 0, 0, 5314, 5315, 5, 47, 0, 0, 5315, 5320, 5, 519, 0, 0, 5316, 5317,
		5, 3, 0, 0, 5317, 5319, 5, 519, 0, 0, 5318, 5316, 1, 0, 0, 0, 5319, 5322,
		1, 0, 0, 0, 5320, 5318, 1, 0, 0, 0, 5320, 5321, 1, 0, 0, 0, 5321, 633,
		1, 0, 0, 0, 5322, 5320, 1, 0, 0, 0, 5323, 5324, 5, 401, 0, 0, 5324, 5325,
		5, 35, 0, 0, 5325, 5326, 5, 47, 0, 0, 5326, 635, 1, 0, 0, 0, 5327, 5328,
		3, 1028, 514, 0, 5328, 5329, 5, 1, 0, 0, 5329, 5330, 3, 1028, 514, 0, 5330,
		5331, 5, 1, 0, 0, 5331, 5332, 3, 1028, 514, 0, 5332, 637, 1, 0, 0, 0, 5333,
		5334, 5, 90, 0, 0, 5334, 5335, 5, 103, 0, 0, 5335, 5336, 5, 381, 0, 0,
		5336, 5339, 3, 636, 318, 0, 5337, 5338, 5, 479, 0, 0, 5338, 5340, 3, 850,
		425, 0, 5339, 5337, 1, 0, 0, 0, 5339, 5340, 1, 0, 0, 0, 5340, 5341, 1,
		0, 0, 0, 5341, 5342, 5, 324, 0, 0, 5342, 5344, 5, 493, 0, 0, 5343, 5345,
		5, 502, 0, 0, 5344, 5343, 1, 0, 0, 0, 5344, 5345, 1, 0, 0, 0, 5345, 5346,
		1, 0, 0, 0, 5346, 5348, 5, 519, 0, 0, 5347, 5349, 3, 952, 476, 0, 5348,
		5347, 1, 0, 0, 0, 5348, 5349, 1, 0, 0, 0, 5349, 639, 1, 0, 0, 0, 5350,
		5351, 5, 401, 0, 0, 5351, 5352, 5, 103, 0, 0, 5352, 5353, 5, 382, 0, 0,
		5353, 641, 1, 0, 0, 0, 5354, 5355, 5, 132, 0, 0, 5355, 5356, 5, 103, 0,
		0, 5356, 5357, 5, 381, 0, 0, 5357, 5358, 5, 519, 0, 0, 5358, 643, 1, 0,
		0, 0, 5359, 5360, 5, 69, 0, 0, 5360, 5361, 5, 103, 0, 0, 5361, 5362, 5,
		382, 0, 0, 5362, 645, 1, 0, 0, 0, 5363, 5364, 5, 56, 0, 0, 5364, 5365,
		5, 391, 0, 0, 5365, 5370, 3, 786, 393, 0, 5366, 5367, 5, 3, 0, 0, 5367,
		5369, 3, 786, 393, 0, 5368, 5366, 1, 0, 0, 0, 5369, 5372, 1, 0, 0, 0, 5370,
		5368, 1, 0, 0, 0, 5370, 5371, 1, 0, 0, 0, 5371, 5373, 1, 0, 0, 0, 5372,
		5370, 1, 0, 0, 0, 5373, 5374, 5, 172, 0, 0, 5374, 5377, 3, 1010, 505, 0,
		5375, 5376, 5, 479, 0, 0, 5376, 5378, 3, 850, 425, 0, 5377, 5375, 1, 0,
		0, 0, 5377, 5378, 1, 0, 0, 0, 5378, 5380, 1, 0, 0, 0, 5379, 5381, 3, 952,
		476, 0, 5380, 5379, 1, 0, 0, 0, 5380, 5381, 1, 0, 0, 0, 5381, 647, 1, 0,
		0, 0, 5382, 5383, 5, 150, 0, 0, 5383, 5384, 5, 423, 0, 0, 5384, 5386, 3,
		898, 449, 0, 5385, 5387, 3, 822, 411, 0, 5386, 5385, 1, 0, 0, 0, 5386,
		5387, 1, 0, 0, 0, 5387, 5388, 1, 0, 0, 0, 5388, 5389, 5, 441, 0, 0, 5389,
		5393, 3, 974, 487, 0, 5390, 5391, 5, 481, 0, 0, 5391, 5392, 7, 12, 0, 0,
		5392, 5394, 5, 269, 0, 0, 5393, 5390, 1, 0, 0, 0, 5393, 5394, 1, 0, 0,
		0, 5394, 5396, 1, 0, 0, 0, 5395, 5397, 3, 952, 476, 0, 5396, 5395, 1, 0,
		0, 0, 5396, 5397, 1, 0, 0, 0, 5397, 5399, 1, 0, 0, 0, 5398, 5400, 3, 466,
		233, 0, 5399, 5398, 1, 0, 0, 0, 5399, 5400, 1, 0, 0, 0, 5400, 649, 1, 0,
		0, 0, 5401, 5402, 5, 57, 0, 0, 5402, 5405, 5, 150, 0, 0, 5403, 5404, 7,
		1, 0, 0, 5404, 5406, 3, 1010, 505, 0, 5405, 5403, 1, 0, 0, 0, 5405, 5406,
		1, 0, 0, 0, 5406, 5411, 1, 0, 0, 0, 5407, 5408, 5, 240, 0, 0, 5408, 5412,
		3, 974, 487, 0, 5409, 5410, 5, 479, 0, 0, 5410, 5412, 3, 850, 425, 0, 5411,
		5407, 1, 0, 0, 0, 5411, 5409, 1, 0, 0, 0, 5411, 5412, 1, 0, 0, 0, 5412,
		651, 1, 0, 0, 0, 5413, 5414, 5, 401, 0, 0, 5414, 5417, 5, 150, 0, 0, 5415,
		5416, 7, 1, 0, 0, 5416, 5418, 3, 1010, 505, 0, 5417, 5415, 1, 0, 0, 0,
		5417, 5418, 1, 0, 0, 0, 5418, 5423, 1, 0, 0, 0, 5419, 5420, 5, 240, 0,
		0, 5420, 5424, 3, 974, 487, 0, 5421, 5422, 5, 479, 0, 0, 5422, 5424, 3,
		850, 425, 0, 5423, 5419, 1, 0, 0, 0, 5423, 5421, 1, 0, 0, 0, 5423, 5424,
		1, 0, 0, 0, 5424, 5435, 1, 0, 0, 0, 5425, 5426, 5, 298, 0, 0, 5426, 5427,
		5, 55, 0, 0, 5427, 5432, 3, 768, 384, 0, 5428, 5429, 5, 3, 0, 0, 5429,
		5431, 3, 768, 384, 0, 5430, 5428, 1, 0, 0, 0, 5431, 5434, 1, 0, 0, 0, 5432,
		5430, 1, 0, 0, 0, 5432, 5433, 1, 0, 0, 0, 5433, 5436, 1, 0, 0, 0, 5434,
		5432, 1, 0, 0, 0, 5435, 5425, 1, 0, 0, 0, 5435, 5436, 1, 0, 0, 0, 5436,
		5438, 1, 0, 0, 0, 5437, 5439, 3, 772, 386, 0, 5438, 5437, 1, 0, 0, 0, 5438,
		5439, 1, 0, 0, 0, 5439, 653, 1, 0, 0, 0, 5440, 5441, 5, 209, 0, 0, 5441,
		5442, 5, 313, 0, 0, 5442, 5443, 5, 172, 0, 0, 5443, 5445, 3, 1024, 512,
		0, 5444, 5446, 3, 952, 476, 0, 5445, 5444, 1, 0, 0, 0, 5445, 5446, 1, 0,
		0, 0, 5446, 655, 1, 0, 0, 0, 5447, 5448, 5, 453, 0, 0, 5448, 5449, 5, 313,
		0, 0, 5449, 5450, 3, 1024, 512, 0, 5450, 657, 1, 0, 0, 0, 5451, 5452, 5,
		90, 0, 0, 5452, 5453, 5, 158, 0, 0, 5453, 5456, 3, 974, 487, 0, 5454, 5455,
		7, 1, 0, 0, 5455, 5457, 3, 1010, 505, 0, 5456, 5454, 1, 0, 0, 0, 5456,
		5457, 1, 0, 0, 0, 5457, 5458, 1, 0, 0, 0, 5458, 5459, 3, 952, 476, 0, 5459,
		659, 1, 0, 0, 0, 5460, 5461, 5, 132, 0, 0, 5461, 5462, 5, 158, 0, 0, 5462,
		5465, 3, 974, 487, 0, 5463, 5464, 7, 1, 0, 0, 5464, 5466, 3, 1010, 505,
		0, 5465, 5463, 1, 0, 0, 0, 5465, 5466, 1, 0, 0, 0, 5466, 5467, 1, 0, 0,
		0, 5467, 5468, 3, 952, 476, 0, 5468, 661, 1, 0, 0, 0, 5469, 5470, 5, 401,
		0, 0, 5470, 5473, 5, 158, 0, 0, 5471, 5472, 7, 1, 0, 0, 5472, 5474, 3,
		1010, 505, 0, 5473, 5471, 1, 0, 0, 0, 5473, 5474, 1, 0, 0, 0, 5474, 663,
		1, 0, 0, 0, 5475, 5476, 5, 90, 0, 0, 5476, 5477, 3, 70, 35, 0, 5477, 5478,
		5, 315, 0, 0, 5478, 5479, 3, 72, 36, 0, 5479, 5481, 3, 1010, 505, 0, 5480,
		5482, 3, 952, 476, 0, 5481, 5480, 1, 0, 0, 0, 5481, 5482, 1, 0, 0, 0, 5482,
		5483, 1, 0, 0, 0, 5483, 5484, 5, 27, 0, 0, 5484, 5485, 3, 350, 175, 0,
		5485, 665, 1, 0, 0, 0, 5486, 5487, 5, 132, 0, 0, 5487, 5490, 5, 315, 0,
		0, 5488, 5489, 5, 197, 0, 0, 5489, 5491, 5, 148, 0, 0, 5490, 5488, 1, 0,
		0, 0, 5490, 5491, 1, 0, 0, 0, 5491, 5492, 1, 0, 0, 0, 5492, 5493, 3, 1010,
		505, 0, 5493, 667, 1, 0, 0, 0, 5494, 5504, 5, 417, 0, 0, 5495, 5504, 5,
		364, 0, 0, 5496, 5497, 5, 368, 0, 0, 5497, 5504, 5, 18, 0, 0, 5498, 5499,
		5, 368, 0, 0, 5499, 5500, 5, 158, 0, 0, 5500, 5504, 3, 974, 487, 0, 5501,
		5502, 5, 396, 0, 0, 5502, 5504, 3, 956, 478, 0, 5503, 5494, 1, 0, 0, 0,
		5503, 5495, 1, 0, 0, 0, 5503, 5496, 1, 0, 0, 0, 5503, 5498, 1, 0, 0, 0,
		5503, 5501, 1, 0, 0, 0, 5504, 669, 1, 0, 0, 0, 5505, 5506, 5, 19, 0, 0,
		5506, 5507, 5, 315, 0, 0, 5507, 5508, 3, 1010, 505, 0, 5508, 5509, 3, 668,
		334, 0, 5509, 671, 1, 0, 0, 0, 5510, 5511, 7, 8, 0, 0, 5511, 5512, 5, 315,
		0, 0, 5512, 5513, 3, 1010, 505, 0, 5513, 673, 1, 0, 0, 0, 5514, 5515, 5,
		401, 0, 0, 5515, 5522, 5, 316, 0, 0, 5516, 5517, 5, 240, 0, 0, 5517, 5523,
		3, 974, 487, 0, 5518, 5519, 5, 479, 0, 0, 5519, 5523, 3, 850, 425, 0, 5520,
		5521, 5, 172, 0, 0, 5521, 5523, 3, 1010, 505, 0, 5522, 5516, 1, 0, 0, 0,
		5522, 5518, 1, 0, 0, 0, 5522, 5520, 1, 0, 0, 0, 5522, 5523, 1, 0, 0, 0,
		5523, 5534, 1, 0, 0, 0, 5524, 5525, 5, 298, 0, 0, 5525, 5526, 5, 55, 0,
		0, 5526, 5531, 3, 768, 384, 0, 5527, 5528, 5, 3, 0, 0, 5528, 5530, 3, 768,
		384, 0, 5529, 5527, 1, 0, 0, 0, 5530, 5533, 1, 0, 0, 0, 5531, 5529, 1,
		0, 0, 0, 5531, 5532, 1, 0, 0, 0, 5532, 5535, 1, 0, 0, 0, 5533, 5531, 1,
		0, 0, 0, 5534, 5524, 1, 0, 0, 0, 5534, 5535, 1, 0, 0, 0, 5535, 5537, 1,
		0, 0, 0, 5536, 5538, 3, 772, 386, 0, 5537, 5536, 1, 0, 0, 0, 5537, 5538,
		1, 0, 0, 0, 5538, 675, 1, 0, 0, 0, 5539, 5540, 5, 396, 0, 0, 5540, 5545,
		3, 678, 339, 0, 5541, 5542, 5, 3, 0, 0, 5542, 5544, 3, 678, 339, 0, 5543,
		5541, 1, 0, 0, 0, 5544, 5547, 1, 0, 0, 0, 5545, 5543, 1, 0, 0, 0, 5545,
		5546, 1, 0, 0, 0, 5546, 677, 1, 0, 0, 0, 5547, 5545, 1, 0, 0, 0, 5548,
		5549, 5, 64, 0, 0, 5549, 5554, 5, 396, 0, 0, 5550, 5554, 5, 66, 0, 0, 5551,
		5552, 5, 65, 0, 0, 5552, 5554, 5, 396, 0, 0, 5553, 5548, 1, 0, 0, 0, 5553,
		5550, 1, 0, 0, 0, 5553, 5551, 1, 0, 0, 0, 5554, 5557, 1, 0, 0, 0, 5555,
		5558, 3, 1024, 512, 0, 5556, 5558, 5, 117, 0, 0, 5557, 5555, 1, 0, 0, 0,
		5557, 5556, 1, 0, 0, 0, 5558, 5614, 1, 0, 0, 0, 5559, 5562, 5, 274, 0,
		0, 5560, 5563, 3, 1024, 512, 0, 5561, 5563, 5, 117, 0, 0, 5562, 5560, 1,
		0, 0, 0, 5562, 5561, 1, 0, 0, 0, 5563, 5569, 1, 0, 0, 0, 5564, 5567, 5,
		74, 0, 0, 5565, 5568, 3, 1024, 512, 0, 5566, 5568, 5, 117, 0, 0, 5567,
		5565, 1, 0, 0, 0, 5567, 5566, 1, 0, 0, 0, 5568, 5570, 1, 0, 0, 0, 5569,
		5564, 1, 0, 0, 0, 5569, 5570, 1, 0, 0, 0, 5570, 5614, 1, 0, 0, 0, 5571,
		5572, 5, 305, 0, 0, 5572, 5579, 5, 493, 0, 0, 5573, 5580, 3, 974, 487,
		0, 5574, 5575, 5, 305, 0, 0, 5575, 5576, 5, 2, 0, 0, 5576, 5577, 3, 974,
		487, 0, 5577, 5578, 5, 4, 0, 0, 5578, 5580, 1, 0, 0, 0, 5579, 5573, 1,
		0, 0, 0, 5579, 5574, 1, 0, 0, 0, 5580, 5614, 1, 0, 0, 0, 5581, 5582, 5,
		305, 0, 0, 5582, 5583, 5, 168, 0, 0, 5583, 5584, 3, 1030, 515, 0, 5584,
		5591, 5, 493, 0, 0, 5585, 5592, 3, 974, 487, 0, 5586, 5587, 5, 305, 0,
		0, 5587, 5588, 5, 2, 0, 0, 5588, 5589, 3, 974, 487, 0, 5589, 5590, 5, 4,
		0, 0, 5590, 5592, 1, 0, 0, 0, 5591, 5585, 1, 0, 0, 0, 5591, 5586, 1, 0,
		0, 0, 5592, 5614, 1, 0, 0, 0, 5593, 5594, 3, 872, 436, 0, 5594, 5595, 5,
		493, 0, 0, 5595, 5596, 3, 850, 425, 0, 5596, 5614, 1, 0, 0, 0, 5597, 5599,
		3, 966, 483, 0, 5598, 5597, 1, 0, 0, 0, 5598, 5599, 1, 0, 0, 0, 5599, 5600,
		1, 0, 0, 0, 5600, 5601, 3, 1016, 508, 0, 5601, 5602, 5, 493, 0, 0, 5602,
		5603, 3, 688, 344, 0, 5603, 5614, 1, 0, 0, 0, 5604, 5605, 3, 874, 437,
		0, 5605, 5606, 5, 493, 0, 0, 5606, 5607, 3, 688, 344, 0, 5607, 5614, 1,
		0, 0, 0, 5608, 5610, 3, 966, 483, 0, 5609, 5608, 1, 0, 0, 0, 5609, 5610,
		1, 0, 0, 0, 5610, 5611, 1, 0, 0, 0, 5611, 5612, 5, 439, 0, 0, 5612, 5614,
		3, 680, 340, 0, 5613, 5553, 1, 0, 0, 0, 5613, 5559, 1, 0, 0, 0, 5613, 5571,
		1, 0, 0, 0, 5613, 5581, 1, 0, 0, 0, 5613, 5593, 1, 0, 0, 0, 5613, 5598,
		1, 0, 0, 0, 5613, 5604, 1, 0, 0, 0, 5613, 5609, 1, 0, 0, 0, 5614, 679,
		1, 0, 0, 0, 5615, 5626, 3, 682, 341, 0, 5616, 5626, 3, 684, 342, 0, 5617,
		5618, 3, 682, 341, 0, 5618, 5619, 5, 3, 0, 0, 5619, 5620, 3, 684, 342,
		0, 5620, 5626, 1, 0, 0, 0, 5621, 5622, 3, 684, 342, 0, 5622, 5623, 5, 3,
		0, 0, 5623, 5624, 3, 682, 341, 0, 5624, 5626, 1, 0, 0, 0, 5625, 5615, 1,
		0, 0, 0, 5625, 5616, 1, 0, 0, 0, 5625, 5617, 1, 0, 0, 0, 5625, 5621, 1,
		0, 0, 0, 5626, 681, 1, 0, 0, 0, 5627, 5628, 5, 345, 0, 0, 5628, 5632, 5,
		291, 0, 0, 5629, 5630, 5, 345, 0, 0, 5630, 5632, 5, 483, 0, 0, 5631, 5627,
		1, 0, 0, 0, 5631, 5629, 1, 0, 0, 0, 5632, 683, 1, 0, 0, 0, 5633, 5634,
		5, 223, 0, 0, 5634, 5635, 5, 239, 0, 0, 5635, 5636, 3, 686, 343, 0, 5636,
		685, 1, 0, 0, 0, 5637, 5638, 5, 345, 0, 0, 5638, 5645, 5, 450, 0, 0, 5639,
		5640, 5, 345, 0, 0, 5640, 5645, 5, 80, 0, 0, 5641, 5642, 5, 355, 0, 0,
		5642, 5645, 5, 345, 0, 0, 5643, 5645, 5, 394, 0, 0, 5644, 5637, 1, 0, 0,
		0, 5644, 5639, 1, 0, 0, 0, 5644, 5641, 1, 0, 0, 0, 5644, 5643, 1, 0, 0,
		0, 5645, 687, 1, 0, 0, 0, 5646, 5651, 5, 117, 0, 0, 5647, 5651, 5, 290,
		0, 0, 5648, 5651, 5, 18, 0, 0, 5649, 5651, 3, 850, 425, 0, 5650, 5646,
		1, 0, 0, 0, 5650, 5647, 1, 0, 0, 0, 5650, 5648, 1, 0, 0, 0, 5650, 5649,
		1, 0, 0, 0, 5651, 689, 1, 0, 0, 0, 5652, 5653, 5, 396, 0, 0, 5653, 5656,
		5, 333, 0, 0, 5654, 5655, 5, 168, 0, 0, 5655, 5657, 3, 974, 487, 0, 5656,
		5654, 1, 0, 0, 0, 5656, 5657, 1, 0, 0, 0, 5657, 5658, 1, 0, 0, 0, 5658,
		5659, 3, 958, 479, 0, 5659, 691, 1, 0, 0, 0, 5660, 5665, 3, 1024, 512,
		0, 5661, 5662, 5, 3, 0, 0, 5662, 5664, 3, 1024, 512, 0, 5663, 5661, 1,
		0, 0, 0, 5664, 5667, 1, 0, 0, 0, 5665, 5663, 1, 0, 0, 0, 5665, 5666, 1,
		0, 0, 0, 5666, 693, 1, 0, 0, 0, 5667, 5665, 1, 0, 0, 0, 5668, 5669, 5,
		14, 0, 0, 5669, 5670, 5, 147, 0, 0, 5670, 5671, 5, 290, 0, 0, 5671, 5672,
		7, 29, 0, 0, 5672, 5673, 3, 974, 487, 0, 5673, 695, 1, 0, 0, 0, 5674, 5675,
		5, 485, 0, 0, 5675, 5676, 5, 424, 0, 0, 5676, 5681, 3, 698, 349, 0, 5677,
		5678, 5, 3, 0, 0, 5678, 5680, 3, 698, 349, 0, 5679, 5677, 1, 0, 0, 0, 5680,
		5683, 1, 0, 0, 0, 5681, 5679, 1, 0, 0, 0, 5681, 5682, 1, 0, 0, 0, 5682,
		5687, 1, 0, 0, 0, 5683, 5681, 1, 0, 0, 0, 5684, 5685, 5, 486, 0, 0, 5685,
		5687, 5, 424, 0, 0, 5686, 5674, 1, 0, 0, 0, 5686, 5684, 1, 0, 0, 0, 5687,
		697, 1, 0, 0, 0, 5688, 5693, 3, 1016, 508, 0, 5689, 5691, 5, 27, 0, 0,
		5690, 5689, 1, 0, 0, 0, 5690, 5691, 1, 0, 0, 0, 5691, 5692, 1, 0, 0, 0,
		5692, 5694, 3, 1016, 508, 0, 5693, 5690, 1, 0, 0, 0, 5693, 5694, 1, 0,
		0, 0, 5694, 5695, 1, 0, 0, 0, 5695, 5696, 3, 700, 350, 0, 5696, 699, 1,
		0, 0, 0, 5697, 5699, 5, 345, 0, 0, 5698, 5700, 5, 244, 0, 0, 5699, 5698,
		1, 0, 0, 0, 5699, 5700, 1, 0, 0, 0, 5700, 5706, 1, 0, 0, 0, 5701, 5703,
		5, 487, 0, 0, 5702, 5701, 1, 0, 0, 0, 5702, 5703, 1, 0, 0, 0, 5703, 5704,
		1, 0, 0, 0, 5704, 5706, 5, 483, 0, 0, 5705, 5697, 1, 0, 0, 0, 5705, 5702,
		1, 0, 0, 0, 5706, 701, 1, 0, 0, 0, 5707, 5708, 5, 19, 0, 0, 5708, 5709,
		5, 312, 0, 0, 5709, 5710, 5, 15, 0, 0, 5710, 5711, 5, 13, 0, 0, 5711, 5712,
		3, 750, 375, 0, 5712, 703, 1, 0, 0, 0, 5713, 5714, 5, 446, 0, 0, 5714,
		5715, 5, 312, 0, 0, 5715, 5716, 5, 15, 0, 0, 5716, 705, 1, 0, 0, 0, 5717,
		5718, 5, 19, 0, 0, 5718, 5719, 5, 312, 0, 0, 5719, 5720, 5, 15, 0, 0, 5720,
		5721, 5, 132, 0, 0, 5721, 5722, 3, 974, 487, 0, 5722, 707, 1, 0, 0, 0,
		5723, 5724, 5, 401, 0, 0, 5724, 5725, 5, 312, 0, 0, 5725, 5726, 5, 15,
		0, 0, 5726, 709, 1, 0, 0, 0, 5727, 5728, 5, 90, 0, 0, 5728, 5732, 5, 474,
		0, 0, 5729, 5730, 5, 197, 0, 0, 5730, 5731, 5, 281, 0, 0, 5731, 5733, 5,
		148, 0, 0, 5732, 5729, 1, 0, 0, 0, 5732, 5733, 1, 0, 0, 0, 5733, 5734,
		1, 0, 0, 0, 5734, 5736, 3, 1024, 512, 0, 5735, 5737, 3, 968, 484, 0, 5736,
		5735, 1, 0, 0, 0, 5736, 5737, 1, 0, 0, 0, 5737, 5739, 1, 0, 0, 0, 5738,
		5740, 3, 952, 476, 0, 5739, 5738, 1, 0, 0, 0, 5739, 5740, 1, 0, 0, 0, 5740,
		711, 1, 0, 0, 0, 5741, 5742, 5, 132, 0, 0, 5742, 5745, 5, 474, 0, 0, 5743,
		5744, 5, 197, 0, 0, 5744, 5746, 5, 148, 0, 0, 5745, 5743, 1, 0, 0, 0, 5745,
		5746, 1, 0, 0, 0, 5746, 5747, 1, 0, 0, 0, 5747, 5748, 3, 1024, 512, 0,
		5748, 713, 1, 0, 0, 0, 5749, 5750, 5, 417, 0, 0, 5750, 5753, 5, 474, 0,
		0, 5751, 5752, 5, 197, 0, 0, 5752, 5754, 5, 148, 0, 0, 5753, 5751, 1, 0,
		0, 0, 5753, 5754, 1, 0, 0, 0, 5754, 5755, 1, 0, 0, 0, 5755, 5756, 3, 1016,
		508, 0, 5756, 715, 1, 0, 0, 0, 5757, 5758, 5, 364, 0, 0, 5758, 5761, 5,
		474, 0, 0, 5759, 5760, 5, 197, 0, 0, 5760, 5762, 5, 148, 0, 0, 5761, 5759,
		1, 0, 0, 0, 5761, 5762, 1, 0, 0, 0, 5762, 5763, 1, 0, 0, 0, 5763, 5764,
		3, 1016, 508, 0, 5764, 717, 1, 0, 0, 0, 5765, 5767, 5, 396, 0, 0, 5766,
		5768, 5, 395, 0, 0, 5767, 5766, 1, 0, 0, 0, 5767, 5768, 1, 0, 0, 0, 5768,
		5769, 1, 0, 0, 0, 5769, 5771, 5, 474, 0, 0, 5770, 5772, 5, 493, 0, 0, 5771,
		5770, 1, 0, 0, 0, 5771, 5772, 1, 0, 0, 0, 5772, 5773, 1, 0, 0, 0, 5773,
		5774, 3, 1024, 512, 0, 5774, 719, 1, 0, 0, 0, 5775, 5776, 5, 401, 0, 0,
		5776, 5779, 5, 475, 0, 0, 5777, 5778, 5, 240, 0, 0, 5778, 5780, 3, 974,
		487, 0, 5779, 5777, 1, 0, 0, 0, 5779, 5780, 1, 0, 0, 0, 5780, 721, 1, 0,
		0, 0, 5781, 5782, 5, 401, 0, 0, 5782, 5783, 7, 30, 0, 0, 5783, 5784, 5,
		172, 0, 0, 5784, 5785, 5, 474, 0, 0, 5785, 5786, 3, 1016, 508, 0, 5786,
		723, 1, 0, 0, 0, 5787, 5788, 5, 401, 0, 0, 5788, 5789, 5, 279, 0, 0, 5789,
		5790, 5, 172, 0, 0, 5790, 5793, 5, 475, 0, 0, 5791, 5792, 5, 240, 0, 0,
		5792, 5794, 3, 974, 487, 0, 5793, 5791, 1, 0, 0, 0, 5793, 5794, 1, 0, 0,
		0, 5794, 5805, 1, 0, 0, 0, 5795, 5796, 5, 401, 0, 0, 5796, 5797, 5, 279,
		0, 0, 5797, 5798, 5, 172, 0, 0, 5798, 5799, 5, 474, 0, 0, 5799, 5802, 3,
		1016, 508, 0, 5800, 5801, 5, 72, 0, 0, 5801, 5803, 3, 1024, 512, 0, 5802,
		5800, 1, 0, 0, 0, 5802, 5803, 1, 0, 0, 0, 5803, 5805, 1, 0, 0, 0, 5804,
		5787, 1, 0, 0, 0, 5804, 5795, 1, 0, 0, 0, 5805, 725, 1, 0, 0, 0, 5806,
		5807, 5, 19, 0, 0, 5807, 5808, 5, 474, 0, 0, 5808, 5809, 3, 1024, 512,
		0, 5809, 5810, 3, 276, 138, 0, 5810, 727, 1, 0, 0, 0, 5811, 5812, 5, 19,
		0, 0, 5812, 5813, 5, 474, 0, 0, 5813, 5814, 3, 1024, 512, 0, 5814, 5815,
		5, 13, 0, 0, 5815, 5819, 5, 72, 0, 0, 5816, 5817, 5, 197, 0, 0, 5817, 5818,
		5, 281, 0, 0, 5818, 5820, 5, 148, 0, 0, 5819, 5816, 1, 0, 0, 0, 5819, 5820,
		1, 0, 0, 0, 5820, 5821, 1, 0, 0, 0, 5821, 5823, 3, 1024, 512, 0, 5822,
		5824, 3, 968, 484, 0, 5823, 5822, 1, 0, 0, 0, 5823, 5824, 1, 0, 0, 0, 5824,
		5826, 1, 0, 0, 0, 5825, 5827, 3, 952, 476, 0, 5826, 5825, 1, 0, 0, 0, 5826,
		5827, 1, 0, 0, 0, 5827, 729, 1, 0, 0, 0, 5828, 5829, 5, 19, 0, 0, 5829,
		5830, 5, 474, 0, 0, 5830, 5831, 3, 1024, 512, 0, 5831, 5832, 5, 132, 0,
		0, 5832, 5835, 5, 72, 0, 0, 5833, 5834, 5, 197, 0, 0, 5834, 5836, 5, 148,
		0, 0, 5835, 5833, 1, 0, 0, 0, 5835, 5836, 1, 0, 0, 0, 5836, 5837, 1, 0,
		0, 0, 5837, 5839, 3, 1024, 512, 0, 5838, 5840, 5, 169, 0, 0, 5839, 5838,
		1, 0, 0, 0, 5839, 5840, 1, 0, 0, 0, 5840, 731, 1, 0, 0, 0, 5841, 5842,
		5, 19, 0, 0, 5842, 5843, 5, 474, 0, 0, 5843, 5844, 3, 1024, 512, 0, 5844,
		5845, 5, 137, 0, 0, 5845, 5846, 5, 72, 0, 0, 5846, 5847, 3, 1024, 512,
		0, 5847, 733, 1, 0, 0, 0, 5848, 5849, 5, 19, 0, 0, 5849, 5850, 5, 474,
		0, 0, 5850, 5851, 3, 1024, 512, 0, 5851, 5852, 5, 127, 0, 0, 5852, 5853,
		5, 72, 0, 0, 5853, 5854, 3, 1024, 512, 0, 5854, 735, 1, 0, 0, 0, 5855,
		5856, 5, 19, 0, 0, 5856, 5857, 5, 474, 0, 0, 5857, 5858, 3, 1024, 512,
		0, 5858, 5859, 5, 270, 0, 0, 5859, 5860, 5, 72, 0, 0, 5860, 5861, 3, 1024,
		512, 0, 5861, 5862, 3, 276, 138, 0, 5862, 737, 1, 0, 0, 0, 5863, 5864,
		5, 407, 0, 0, 5864, 5868, 5, 439, 0, 0, 5865, 5866, 5, 481, 0, 0, 5866,
		5867, 5, 86, 0, 0, 5867, 5869, 5, 403, 0, 0, 5868, 5865, 1, 0, 0, 0, 5868,
		5869, 1, 0, 0, 0, 5869, 5875, 1, 0, 0, 0, 5870, 5872, 5, 40, 0, 0, 5871,
		5873, 5, 482, 0, 0, 5872, 5871, 1, 0, 0, 0, 5872, 5873, 1, 0, 0, 0, 5873,
		5875, 1, 0, 0, 0, 5874, 5863, 1, 0, 0, 0, 5874, 5870, 1, 0, 0, 0, 5875,
		739, 1, 0, 0, 0, 5876, 5878, 5, 79, 0, 0, 5877, 5879, 5, 482, 0, 0, 5878,
		5877, 1, 0, 0, 0, 5878, 5879, 1, 0, 0, 0, 5879, 5885, 1, 0, 0, 0, 5880,
		5882, 5, 21, 0, 0, 5881, 5883, 5, 277, 0, 0, 5882, 5881, 1, 0, 0, 0, 5882,
		5883, 1, 0, 0, 0, 5883, 5884, 1, 0, 0, 0, 5884, 5886, 5, 63, 0, 0, 5885,
		5880, 1, 0, 0, 0, 5885, 5886, 1, 0, 0, 0, 5886, 5891, 1, 0, 0, 0, 5887,
		5889, 5, 277, 0, 0, 5888, 5887, 1, 0, 0, 0, 5888, 5889, 1, 0, 0, 0, 5889,
		5890, 1, 0, 0, 0, 5890, 5892, 5, 351, 0, 0, 5891, 5888, 1, 0, 0, 0, 5891,
		5892, 1, 0, 0, 0, 5892, 741, 1, 0, 0, 0, 5893, 5895, 5, 375, 0, 0, 5894,
		5896, 5, 482, 0, 0, 5895, 5894, 1, 0, 0, 0, 5895, 5896, 1, 0, 0, 0, 5896,
		5902, 1, 0, 0, 0, 5897, 5899, 5, 21, 0, 0, 5898, 5900, 5, 277, 0, 0, 5899,
		5898, 1, 0, 0, 0, 5899, 5900, 1, 0, 0, 0, 5900, 5901, 1, 0, 0, 0, 5901,
		5903, 5, 63, 0, 0, 5902, 5897, 1, 0, 0, 0, 5902, 5903, 1, 0, 0, 0, 5903,
		5908, 1, 0, 0, 0, 5904, 5906, 5, 277, 0, 0, 5905, 5904, 1, 0, 0, 0, 5905,
		5906, 1, 0, 0, 0, 5906, 5907, 1, 0, 0, 0, 5907, 5909, 5, 351, 0, 0, 5908,
		5905, 1, 0, 0, 0, 5908, 5909, 1, 0, 0, 0, 5909, 743, 1, 0, 0, 0, 5910,
		5911, 5, 440, 0, 0, 5911, 5912, 3, 746, 373, 0, 5912, 5913, 3, 748, 374,
		0, 5913, 745, 1, 0, 0, 0, 5914, 5915, 3, 1016, 508, 0, 5915, 747, 1, 0,
		0, 0, 5916, 5918, 9, 0, 0, 0, 5917, 5916, 1, 0, 0, 0, 5918, 5919, 1, 0,
		0, 0, 5919, 5917, 1, 0, 0, 0, 5919, 5920, 1, 0, 0, 0, 5920, 749, 1, 0,
		0, 0, 5921, 5924, 3, 902, 451, 0, 5922, 5924, 3, 904, 452, 0, 5923, 5921,
		1, 0, 0, 0, 5923, 5922, 1, 0, 0, 0, 5923, 5924, 1, 0, 0, 0, 5924, 5925,
		1, 0, 0, 0, 5925, 5927, 3, 752, 376, 0, 5926, 5928, 3, 970, 485, 0, 5927,
		5926, 1, 0, 0, 0, 5927, 5928, 1, 0, 0, 0, 5928, 751, 1, 0, 0, 0, 5929,
		5931, 3, 754, 377, 0, 5930, 5929, 1, 0, 0, 0, 5930, 5931, 1, 0, 0, 0, 5931,
		5932, 1, 0, 0, 0, 5932, 5933, 3, 756, 378, 0, 5933, 753, 1, 0, 0, 0, 5934,
		5935, 5, 481, 0, 0, 5935, 5940, 3, 782, 391, 0, 5936, 5937, 5, 3, 0, 0,
		5937, 5939, 3, 782, 391, 0, 5938, 5936, 1, 0, 0, 0, 5939, 5942, 1, 0, 0,
		0, 5940, 5938, 1, 0, 0, 0, 5940, 5941, 1, 0, 0, 0, 5941, 755, 1, 0, 0,
		0, 5942, 5940, 1, 0, 0, 0, 5943, 5954, 3, 762, 381, 0, 5944, 5945, 5, 298,
		0, 0, 5945, 5946, 5, 55, 0, 0, 5946, 5951, 3, 768, 384, 0, 5947, 5948,
		5, 3, 0, 0, 5948, 5950, 3, 768, 384, 0, 5949, 5947, 1, 0, 0, 0, 5950, 5953,
		1, 0, 0, 0, 5951, 5949, 1, 0, 0, 0, 5951, 5952, 1, 0, 0, 0, 5952, 5955,
		1, 0, 0, 0, 5953, 5951, 1, 0, 0, 0, 5954, 5944, 1, 0, 0, 0, 5954, 5955,
		1, 0, 0, 0, 5955, 5957, 1, 0, 0, 0, 5956, 5958, 3, 772, 386, 0, 5957, 5956,
		1, 0, 0, 0, 5957, 5958, 1, 0, 0, 0, 5958, 757, 1, 0, 0, 0, 5959, 5961,
		5, 168, 0, 0, 5960, 5959, 1, 0, 0, 0, 5960, 5961, 1, 0, 0, 0, 5961, 5962,
		1, 0, 0, 0, 5962, 5963, 3, 760, 380, 0, 5963, 5964, 5, 41, 0, 0, 5964,
		5965, 3, 850, 425, 0, 5965, 5966, 5, 21, 0, 0, 5966, 5967, 3, 850, 425,
		0, 5967, 5992, 1, 0, 0, 0, 5968, 5970, 5, 168, 0, 0, 5969, 5968, 1, 0,
		0, 0, 5969, 5970, 1, 0, 0, 0, 5970, 5971, 1, 0, 0, 0, 5971, 5972, 3, 760,
		380, 0, 5972, 5973, 5, 172, 0, 0, 5973, 5974, 3, 850, 425, 0, 5974, 5975,
		5, 441, 0, 0, 5975, 5976, 3, 850, 425, 0, 5976, 5992, 1, 0, 0, 0, 5977,
		5979, 5, 168, 0, 0, 5978, 5977, 1, 0, 0, 0, 5978, 5979, 1, 0, 0, 0, 5979,
		5980, 1, 0, 0, 0, 5980, 5981, 3, 760, 380, 0, 5981, 5982, 5, 18, 0, 0,
		5982, 5992, 1, 0, 0, 0, 5983, 5985, 5, 168, 0, 0, 5984, 5983, 1, 0, 0,
		0, 5984, 5985, 1, 0, 0, 0, 5985, 5986, 1, 0, 0, 0, 5986, 5987, 3, 760,
		380, 0, 5987, 5988, 5, 27, 0, 0, 5988, 5989, 5, 287, 0, 0, 5989, 5990,
		3, 850, 425, 0, 5990, 5992, 1, 0, 0, 0, 5991, 5960, 1, 0, 0, 0, 5991, 5969,
		1, 0, 0, 0, 5991, 5978, 1, 0, 0, 0, 5991, 5984, 1, 0, 0, 0, 5992, 759,
		1, 0, 0, 0, 5993, 5994, 7, 31, 0, 0, 5994, 761, 1, 0, 0, 0, 5995, 5996,
		6, 381, -1, 0, 5996, 5999, 3, 774, 387, 0, 5997, 5999, 3, 764, 382, 0,
		5998, 5995, 1, 0, 0, 0, 5998, 5997, 1, 0, 0, 0, 5999, 6014, 1, 0, 0, 0,
		6000, 6001, 10, 2, 0, 0, 6001, 6003, 5, 216, 0, 0, 6002, 6004, 3, 784,
		392, 0, 6003, 6002, 1, 0, 0, 0, 6003, 6004, 1, 0, 0, 0, 6004, 6005, 1,
		0, 0, 0, 6005, 6013, 3, 762, 381, 3, 6006, 6007, 10, 1, 0, 0, 6007, 6009,
		7, 32, 0, 0, 6008, 6010, 3, 784, 392, 0, 6009, 6008, 1, 0, 0, 0, 6009,
		6010, 1, 0, 0, 0, 6010, 6011, 1, 0, 0, 0, 6011, 6013, 3, 762, 381, 2, 6012,
		6000, 1, 0, 0, 0, 6012, 6006, 1, 0, 0, 0, 6013, 6016, 1, 0, 0, 0, 6014,
		6012, 1, 0, 0, 0, 6014, 6015, 1, 0, 0, 0, 6015, 763, 1, 0, 0, 0, 6016,
		6014, 1, 0, 0, 0, 6017, 6018, 5, 2, 0, 0, 6018, 6019, 3, 752, 376, 0, 6019,
		6020, 5, 4, 0, 0, 6020, 765, 1, 0, 0, 0, 6021, 6022, 5, 2, 0, 0, 6022,
		6023, 3, 852, 426, 0, 6023, 6024, 5, 4, 0, 0, 6024, 767, 1, 0, 0, 0, 6025,
		6027, 3, 850, 425, 0, 6026, 6028, 7, 33, 0, 0, 6027, 6026, 1, 0, 0, 0,
		6027, 6028, 1, 0, 0, 0, 6028, 6031, 1, 0, 0, 0, 6029, 6030, 5, 283, 0,
		0, 6030, 6032, 7, 34, 0, 0, 6031, 6029, 1, 0, 0, 0, 6031, 6032, 1, 0, 0,
		0, 6032, 769, 1, 0, 0, 0, 6033, 6037, 5, 519, 0, 0, 6034, 6037, 5, 302,
		0, 0, 6035, 6037, 3, 872, 436, 0, 6036, 6033, 1, 0, 0, 0, 6036, 6034, 1,
		0, 0, 0, 6036, 6035, 1, 0, 0, 0, 6037, 771, 1, 0, 0, 0, 6038, 6039, 5,
		241, 0, 0, 6039, 6042, 3, 770, 385, 0, 6040, 6041, 5, 289, 0, 0, 6041,
		6043, 3, 770, 385, 0, 6042, 6040, 1, 0, 0, 0, 6042, 6043, 1, 0, 0, 0, 6043,
		6050, 1, 0, 0, 0, 6044, 6045, 5, 241, 0, 0, 6045, 6046, 3, 770, 385, 0,
		6046, 6047, 5, 3, 0, 0, 6047, 6048, 3, 770, 385, 0, 6048, 6050, 1, 0, 0,
		0, 6049, 6038, 1, 0, 0, 0, 6049, 6044, 1, 0, 0, 0, 6050, 773, 1, 0, 0,
		0, 6051, 6053, 5, 391, 0, 0, 6052, 6054, 3, 784, 392, 0, 6053, 6052, 1,
		0, 0, 0, 6053, 6054, 1, 0, 0, 0, 6054, 6055, 1, 0, 0, 0, 6055, 6060, 3,
		786, 393, 0, 6056, 6057, 5, 3, 0, 0, 6057, 6059, 3, 786, 393, 0, 6058,
		6056, 1, 0, 0, 0, 6059, 6062, 1, 0, 0, 0, 6060, 6058, 1, 0, 0, 0, 6060,
		6061, 1, 0, 0, 0, 6061, 6063, 1, 0, 0, 0, 6062, 6060, 1, 0, 0, 0, 6063,
		6066, 3, 776, 388, 0, 6064, 6065, 5, 479, 0, 0, 6065, 6067, 3, 850, 425,
		0, 6066, 6064, 1, 0, 0, 0, 6066, 6067, 1, 0, 0, 0, 6067, 6071, 1, 0, 0,
		0, 6068, 6069, 5, 181, 0, 0, 6069, 6070, 5, 55, 0, 0, 6070, 6072, 3, 778,
		389, 0, 6071, 6068, 1, 0, 0, 0, 6071, 6072, 1, 0, 0, 0, 6072, 6075, 1,
		0, 0, 0, 6073, 6074, 5, 187, 0, 0, 6074, 6076, 3, 850, 425, 0, 6075, 6073,
		1, 0, 0, 0, 6075, 6076, 1, 0, 0, 0, 6076, 6082, 1, 0, 0, 0, 6077, 6078,
		5, 336, 0, 0, 6078, 6079, 3, 786, 393, 0, 6079, 6080, 3, 978, 489, 0, 6080,
		6081, 5, 519, 0, 0, 6081, 6083, 1, 0, 0, 0, 6082, 6077, 1, 0, 0, 0, 6082,
		6083, 1, 0, 0, 0, 6083, 775, 1, 0, 0, 0, 6084, 6085, 5, 172, 0, 0, 6085,
		6087, 3, 790, 395, 0, 6086, 6088, 3, 796, 398, 0, 6087, 6086, 1, 0, 0,
		0, 6087, 6088, 1, 0, 0, 0, 6088, 6090, 1, 0, 0, 0, 6089, 6084, 1, 0, 0,
		0, 6089, 6090, 1, 0, 0, 0, 6090, 6094, 1, 0, 0, 0, 6091, 6092, 5, 172,
		0, 0, 6092, 6094, 5, 133, 0, 0, 6093, 6089, 1, 0, 0, 0, 6093, 6091, 1,
		0, 0, 0, 6094, 777, 1, 0, 0, 0, 6095, 6096, 5, 376, 0, 0, 6096, 6098, 5,
		2, 0, 0, 6097, 6099, 3, 852, 426, 0, 6098, 6097, 1, 0, 0, 0, 6098, 6099,
		1, 0, 0, 0, 6099, 6100, 1, 0, 0, 0, 6100, 6122, 5, 4, 0, 0, 6101, 6102,
		5, 92, 0, 0, 6102, 6104, 5, 2, 0, 0, 6103, 6105, 3, 852, 426, 0, 6104,
		6103, 1, 0, 0, 0, 6104, 6105, 1, 0, 0, 0, 6105, 6106, 1, 0, 0, 0, 6106,
		6122, 5, 4, 0, 0, 6107, 6108, 5, 183, 0, 0, 6108, 6109, 5, 397, 0, 0, 6109,
		6110, 5, 2, 0, 0, 6110, 6115, 3, 780, 390, 0, 6111, 6112, 5, 3, 0, 0, 6112,
		6114, 3, 780, 390, 0, 6113, 6111, 1, 0, 0, 0, 6114, 6117, 1, 0, 0, 0, 6115,
		6113, 1, 0, 0, 0, 6115, 6116, 1, 0, 0, 0, 6116, 6118, 1, 0, 0, 0, 6117,
		6115, 1, 0, 0, 0, 6118, 6119, 5, 4, 0, 0, 6119, 6122, 1, 0, 0, 0, 6120,
		6122, 3, 852, 426, 0, 6121, 6095, 1, 0, 0, 0, 6121, 6101, 1, 0, 0, 0, 6121,
		6107, 1, 0, 0, 0, 6121, 6120, 1, 0, 0, 0, 6122, 779, 1, 0, 0, 0, 6123,
		6125, 5, 2, 0, 0, 6124, 6126, 3, 850, 425, 0, 6125, 6124, 1, 0, 0, 0, 6125,
		6126, 1, 0, 0, 0, 6126, 6131, 1, 0, 0, 0, 6127, 6128, 5, 3, 0, 0, 6128,
		6130, 3, 850, 425, 0, 6129, 6127, 1, 0, 0, 0, 6130, 6133, 1, 0, 0, 0, 6131,
		6129, 1, 0, 0, 0, 6131, 6132, 1, 0, 0, 0, 6132, 6134, 1, 0, 0, 0, 6133,
		6131, 1, 0, 0, 0, 6134, 6135, 5, 4, 0, 0, 6135, 781, 1, 0, 0, 0, 6136,
		6138, 3, 1016, 508, 0, 6137, 6139, 3, 822, 411, 0, 6138, 6137, 1, 0, 0,
		0, 6138, 6139, 1, 0, 0, 0, 6139, 6140, 1, 0, 0, 0, 6140, 6141, 5, 27, 0,
		0, 6141, 6142, 5, 2, 0, 0, 6142, 6143, 3, 752, 376, 0, 6143, 6144, 5, 4,
		0, 0, 6144, 783, 1, 0, 0, 0, 6145, 6146, 7, 35, 0, 0, 6146, 785, 1, 0,
		0, 0, 6147, 6155, 3, 850, 425, 0, 6148, 6150, 5, 27, 0, 0, 6149, 6148,
		1, 0, 0, 0, 6149, 6150, 1, 0, 0, 0, 6150, 6153, 1, 0, 0, 0, 6151, 6154,
		3, 1016, 508, 0, 6152, 6154, 3, 974, 487, 0, 6153, 6151, 1, 0, 0, 0, 6153,
		6152, 1, 0, 0, 0, 6154, 6156, 1, 0, 0, 0, 6155, 6149, 1, 0, 0, 0, 6155,
		6156, 1, 0, 0, 0, 6156, 6168, 1, 0, 0, 0, 6157, 6158, 3, 1010, 505, 0,
		6158, 6159, 5, 1, 0, 0, 6159, 6161, 5, 503, 0, 0, 6160, 6162, 3, 788, 394,
		0, 6161, 6160, 1, 0, 0, 0, 6161, 6162, 1, 0, 0, 0, 6162, 6168, 1, 0, 0,
		0, 6163, 6165, 5, 503, 0, 0, 6164, 6166, 3, 788, 394, 0, 6165, 6164, 1,
		0, 0, 0, 6165, 6166, 1, 0, 0, 0, 6166, 6168, 1, 0, 0, 0, 6167, 6147, 1,
		0, 0, 0, 6167, 6157, 1, 0, 0, 0, 6167, 6163, 1, 0, 0, 0, 6168, 787, 1,
		0, 0, 0, 6169, 6170, 7, 36, 0, 0, 6170, 6171, 5, 2, 0, 0, 6171, 6176, 3,
		1016, 508, 0, 6172, 6173, 5, 3, 0, 0, 6173, 6175, 3, 1016, 508, 0, 6174,
		6172, 1, 0, 0, 0, 6175, 6178, 1, 0, 0, 0, 6176, 6174, 1, 0, 0, 0, 6176,
		6177, 1, 0, 0, 0, 6177, 6179, 1, 0, 0, 0, 6178, 6176, 1, 0, 0, 0, 6179,
		6180, 5, 4, 0, 0, 6180, 789, 1, 0, 0, 0, 6181, 6189, 3, 792, 396, 0, 6182,
		6184, 5, 3, 0, 0, 6183, 6185, 5, 235, 0, 0, 6184, 6183, 1, 0, 0, 0, 6184,
		6185, 1, 0, 0, 0, 6185, 6186, 1, 0, 0, 0, 6186, 6188, 3, 792, 396, 0, 6187,
		6182, 1, 0, 0, 0, 6188, 6191, 1, 0, 0, 0, 6189, 6187, 1, 0, 0, 0, 6189,
		6190, 1, 0, 0, 0, 6190, 791, 1, 0, 0, 0, 6191, 6189, 1, 0, 0, 0, 6192,
		6196, 3, 794, 397, 0, 6193, 6195, 3, 810, 405, 0, 6194, 6193, 1, 0, 0,
		0, 6195, 6198, 1, 0, 0, 0, 6196, 6194, 1, 0, 0, 0, 6196, 6197, 1, 0, 0,
		0, 6197, 6210, 1, 0, 0, 0, 6198, 6196, 1, 0, 0, 0, 6199, 6200, 5, 2, 0,
		0, 6200, 6204, 3, 794, 397, 0, 6201, 6203, 3, 810, 405, 0, 6202, 6201,
		1, 0, 0, 0, 6203, 6206, 1, 0, 0, 0, 6204, 6202, 1, 0, 0, 0, 6204, 6205,
		1, 0, 0, 0, 6205, 6207, 1, 0, 0, 0, 6206, 6204, 1, 0, 0, 0, 6207, 6208,
		5, 4, 0, 0, 6208, 6210, 1, 0, 0, 0, 6209, 6192, 1, 0, 0, 0, 6209, 6199,
		1, 0, 0, 0, 6210, 793, 1, 0, 0, 0, 6211, 6213, 3, 1010, 505, 0, 6212, 6214,
		3, 758, 379, 0, 6213, 6212, 1, 0, 0, 0, 6213, 6214, 1, 0, 0, 0, 6214, 6216,
		1, 0, 0, 0, 6215, 6217, 3, 824, 412, 0, 6216, 6215, 1, 0, 0, 0, 6216, 6217,
		1, 0, 0, 0, 6217, 6219, 1, 0, 0, 0, 6218, 6220, 3, 828, 414, 0, 6219, 6218,
		1, 0, 0, 0, 6219, 6220, 1, 0, 0, 0, 6220, 6222, 1, 0, 0, 0, 6221, 6223,
		3, 838, 419, 0, 6222, 6221, 1, 0, 0, 0, 6222, 6223, 1, 0, 0, 0, 6223, 6225,
		1, 0, 0, 0, 6224, 6226, 3, 802, 401, 0, 6225, 6224, 1, 0, 0, 0, 6225, 6226,
		1, 0, 0, 0, 6226, 6231, 1, 0, 0, 0, 6227, 6229, 5, 27, 0, 0, 6228, 6227,
		1, 0, 0, 0, 6228, 6229, 1, 0, 0, 0, 6229, 6230, 1, 0, 0, 0, 6230, 6232,
		3, 1016, 508, 0, 6231, 6228, 1, 0, 0, 0, 6231, 6232, 1, 0, 0, 0, 6232,
		6234, 1, 0, 0, 0, 6233, 6235, 3, 816, 408, 0, 6234, 6233, 1, 0, 0, 0, 6234,
		6235, 1, 0, 0, 0, 6235, 6238, 1, 0, 0, 0, 6236, 6237, 5, 489, 0, 0, 6237,
		6239, 3, 974, 487, 0, 6238, 6236, 1, 0, 0, 0, 6238, 6239, 1, 0, 0, 0, 6239,
		6315, 1, 0, 0, 0, 6240, 6241, 5, 2, 0, 0, 6241, 6242, 5, 463, 0, 0, 6242,
		6247, 3, 766, 383, 0, 6243, 6244, 5, 3, 0, 0, 6244, 6246, 3, 766, 383,
		0, 6245, 6243, 1, 0, 0, 0, 6246, 6249, 1, 0, 0, 0, 6247, 6245, 1, 0, 0,
		0, 6247, 6248, 1, 0, 0, 0, 6248, 6250, 1, 0, 0, 0, 6249, 6247, 1, 0, 0,
		0, 6250, 6258, 5, 4, 0, 0, 6251, 6253, 5, 27, 0, 0, 6252, 6251, 1, 0, 0,
		0, 6252, 6253, 1, 0, 0, 0, 6253, 6254, 1, 0, 0, 0, 6254, 6256, 3, 1016,
		508, 0, 6255, 6257, 3, 822, 411, 0, 6256, 6255, 1, 0, 0, 0, 6256, 6257,
		1, 0, 0, 0, 6257, 6259, 1, 0, 0, 0, 6258, 6252, 1, 0, 0, 0, 6258, 6259,
		1, 0, 0, 0, 6259, 6315, 1, 0, 0, 0, 6260, 6268, 3, 764, 382, 0, 6261, 6263,
		5, 27, 0, 0, 6262, 6261, 1, 0, 0, 0, 6262, 6263, 1, 0, 0, 0, 6263, 6264,
		1, 0, 0, 0, 6264, 6266, 3, 1016, 508, 0, 6265, 6267, 3, 822, 411, 0, 6266,
		6265, 1, 0, 0, 0, 6266, 6267, 1, 0, 0, 0, 6267, 6269, 1, 0, 0, 0, 6268,
		6262, 1, 0, 0, 0, 6268, 6269, 1, 0, 0, 0, 6269, 6315, 1, 0, 0, 0, 6270,
		6271, 3, 1010, 505, 0, 6271, 6272, 5, 2, 0, 0, 6272, 6273, 3, 852, 426,
		0, 6273, 6281, 5, 4, 0, 0, 6274, 6276, 5, 27, 0, 0, 6275, 6274, 1, 0, 0,
		0, 6275, 6276, 1, 0, 0, 0, 6276, 6277, 1, 0, 0, 0, 6277, 6279, 3, 1016,
		508, 0, 6278, 6280, 3, 822, 411, 0, 6279, 6278, 1, 0, 0, 0, 6279, 6280,
		1, 0, 0, 0, 6280, 6282, 1, 0, 0, 0, 6281, 6275, 1, 0, 0, 0, 6281, 6282,
		1, 0, 0, 0, 6282, 6315, 1, 0, 0, 0, 6283, 6284, 5, 423, 0, 0, 6284, 6285,
		5, 2, 0, 0, 6285, 6286, 3, 1010, 505, 0, 6286, 6287, 5, 2, 0, 0, 6287,
		6288, 3, 804, 402, 0, 6288, 6289, 5, 4, 0, 0, 6289, 6297, 5, 4, 0, 0, 6290,
		6292, 5, 27, 0, 0, 6291, 6290, 1, 0, 0, 0, 6291, 6292, 1, 0, 0, 0, 6292,
		6293, 1, 0, 0, 0, 6293, 6295, 3, 1016, 508, 0, 6294, 6296, 3, 822, 411,
		0, 6295, 6294, 1, 0, 0, 0, 6295, 6296, 1, 0, 0, 0, 6296, 6298, 1, 0, 0,
		0, 6297, 6291, 1, 0, 0, 0, 6297, 6298, 1, 0, 0, 0, 6298, 6315, 1, 0, 0,
		0, 6299, 6300, 5, 159, 0, 0, 6300, 6308, 3, 956, 478, 0, 6301, 6303, 5,
		27, 0, 0, 6302, 6301, 1, 0, 0, 0, 6302, 6303, 1, 0, 0, 0, 6303, 6304, 1,
		0, 0, 0, 6304, 6306, 3, 1016, 508, 0, 6305, 6307, 3, 822, 411, 0, 6306,
		6305, 1, 0, 0, 0, 6306, 6307, 1, 0, 0, 0, 6307, 6309, 1, 0, 0, 0, 6308,
		6302, 1, 0, 0, 0, 6308, 6309, 1, 0, 0, 0, 6309, 6315, 1, 0, 0, 0, 6310,
		6311, 5, 2, 0, 0, 6311, 6312, 3, 790, 395, 0, 6312, 6313, 5, 4, 0, 0, 6313,
		6315, 1, 0, 0, 0, 6314, 6211, 1, 0, 0, 0, 6314, 6240, 1, 0, 0, 0, 6314,
		6260, 1, 0, 0, 0, 6314, 6270, 1, 0, 0, 0, 6314, 6283, 1, 0, 0, 0, 6314,
		6299, 1, 0, 0, 0, 6314, 6310, 1, 0, 0, 0, 6315, 795, 1, 0, 0, 0, 6316,
		6317, 5, 317, 0, 0, 6317, 6318, 5, 2, 0, 0, 6318, 6323, 3, 798, 399, 0,
		6319, 6320, 5, 3, 0, 0, 6320, 6322, 3, 798, 399, 0, 6321, 6319, 1, 0, 0,
		0, 6322, 6325, 1, 0, 0, 0, 6323, 6321, 1, 0, 0, 0, 6323, 6324, 1, 0, 0,
		0, 6324, 6326, 1, 0, 0, 0, 6325, 6323, 1, 0, 0, 0, 6326, 6329, 5, 168,
		0, 0, 6327, 6330, 3, 1016, 508, 0, 6328, 6330, 3, 1022, 511, 0, 6329, 6327,
		1, 0, 0, 0, 6329, 6328, 1, 0, 0, 0, 6330, 6331, 1, 0, 0, 0, 6331, 6332,
		5, 202, 0, 0, 6332, 6333, 5, 2, 0, 0, 6333, 6338, 3, 800, 400, 0, 6334,
		6335, 5, 3, 0, 0, 6335, 6337, 3, 800, 400, 0, 6336, 6334, 1, 0, 0, 0, 6337,
		6340, 1, 0, 0, 0, 6338, 6336, 1, 0, 0, 0, 6338, 6339, 1, 0, 0, 0, 6339,
		6341, 1, 0, 0, 0, 6340, 6338, 1, 0, 0, 0, 6341, 6342, 5, 4, 0, 0, 6342,
		6343, 5, 4, 0, 0, 6343, 797, 1, 0, 0, 0, 6344, 6352, 3, 868, 434, 0, 6345,
		6347, 5, 27, 0, 0, 6346, 6345, 1, 0, 0, 0, 6346, 6347, 1, 0, 0, 0, 6347,
		6350, 1, 0, 0, 0, 6348, 6351, 3, 1016, 508, 0, 6349, 6351, 3, 974, 487,
		0, 6350, 6348, 1, 0, 0, 0, 6350, 6349, 1, 0, 0, 0, 6351, 6353, 1, 0, 0,
		0, 6352, 6346, 1, 0, 0, 0, 6352, 6353, 1, 0, 0, 0, 6353, 799, 1, 0, 0,
		0, 6354, 6357, 3, 866, 433, 0, 6355, 6357, 3, 926, 463, 0, 6356, 6354,
		1, 0, 0, 0, 6356, 6355, 1, 0, 0, 0, 6357, 6365, 1, 0, 0, 0, 6358, 6360,
		5, 27, 0, 0, 6359, 6358, 1, 0, 0, 0, 6359, 6360, 1, 0, 0, 0, 6360, 6363,
		1, 0, 0, 0, 6361, 6364, 3, 1016, 508, 0, 6362, 6364, 3, 974, 487, 0, 6363,
		6361, 1, 0, 0, 0, 6363, 6362, 1, 0, 0, 0, 6364, 6366, 1, 0, 0, 0, 6365,
		6359, 1, 0, 0, 0, 6365, 6366, 1, 0, 0, 0, 6366, 801, 1, 0, 0, 0, 6367,
		6369, 5, 384, 0, 0, 6368, 6370, 3, 956, 478, 0, 6369, 6368, 1, 0, 0, 0,
		6369, 6370, 1, 0, 0, 0, 6370, 803, 1, 0, 0, 0, 6371, 6374, 3, 852, 426,
		0, 6372, 6374, 3, 806, 403, 0, 6373, 6371, 1, 0, 0, 0, 6373, 6372, 1, 0,
		0, 0, 6374, 805, 1, 0, 0, 0, 6375, 6380, 3, 808, 404, 0, 6376, 6377, 5,
		3, 0, 0, 6377, 6379, 3, 808, 404, 0, 6378, 6376, 1, 0, 0, 0, 6379, 6382,
		1, 0, 0, 0, 6380, 6378, 1, 0, 0, 0, 6380, 6381, 1, 0, 0, 0, 6381, 807,
		1, 0, 0, 0, 6382, 6380, 1, 0, 0, 0, 6383, 6384, 3, 1016, 508, 0, 6384,
		6385, 5, 5, 0, 0, 6385, 6386, 3, 850, 425, 0, 6386, 809, 1, 0, 0, 0, 6387,
		6389, 3, 812, 406, 0, 6388, 6390, 3, 816, 408, 0, 6389, 6388, 1, 0, 0,
		0, 6389, 6390, 1, 0, 0, 0, 6390, 6392, 1, 0, 0, 0, 6391, 6393, 5, 235,
		0, 0, 6392, 6391, 1, 0, 0, 0, 6392, 6393, 1, 0, 0, 0, 6393, 6394, 1, 0,
		0, 0, 6394, 6396, 3, 794, 397, 0, 6395, 6397, 3, 820, 410, 0, 6396, 6395,
		1, 0, 0, 0, 6396, 6397, 1, 0, 0, 0, 6397, 6409, 1, 0, 0, 0, 6398, 6400,
		3, 814, 407, 0, 6399, 6401, 3, 816, 408, 0, 6400, 6399, 1, 0, 0, 0, 6400,
		6401, 1, 0, 0, 0, 6401, 6403, 1, 0, 0, 0, 6402, 6404, 5, 235, 0, 0, 6403,
		6402, 1, 0, 0, 0, 6403, 6404, 1, 0, 0, 0, 6404, 6405, 1, 0, 0, 0, 6405,
		6406, 3, 794, 397, 0, 6406, 6407, 3, 820, 410, 0, 6407, 6409, 1, 0, 0,
		0, 6408, 6387, 1, 0, 0, 0, 6408, 6398, 1, 0, 0, 0, 6409, 811, 1, 0, 0,
		0, 6410, 6417, 5, 225, 0, 0, 6411, 6412, 5, 208, 0, 0, 6412, 6417, 5, 225,
		0, 0, 6413, 6417, 5, 91, 0, 0, 6414, 6415, 5, 91, 0, 0, 6415, 6417, 5,
		225, 0, 0, 6416, 6410, 1, 0, 0, 0, 6416, 6411, 1, 0, 0, 0, 6416, 6413,
		1, 0, 0, 0, 6416, 6414, 1, 0, 0, 0, 6417, 813, 1, 0, 0, 0, 6418, 6419,
		5, 237, 0, 0, 6419, 6446, 5, 225, 0, 0, 6420, 6421, 5, 371, 0, 0, 6421,
		6446, 5, 225, 0, 0, 6422, 6423, 5, 175, 0, 0, 6423, 6446, 5, 225, 0, 0,
		6424, 6425, 5, 237, 0, 0, 6425, 6426, 5, 299, 0, 0, 6426, 6446, 5, 225,
		0, 0, 6427, 6428, 5, 371, 0, 0, 6428, 6429, 5, 299, 0, 0, 6429, 6446, 5,
		225, 0, 0, 6430, 6431, 5, 175, 0, 0, 6431, 6432, 5, 299, 0, 0, 6432, 6446,
		5, 225, 0, 0, 6433, 6434, 5, 237, 0, 0, 6434, 6435, 5, 392, 0, 0, 6435,
		6446, 5, 225, 0, 0, 6436, 6437, 5, 371, 0, 0, 6437, 6438, 5, 392, 0, 0,
		6438, 6446, 5, 225, 0, 0, 6439, 6440, 5, 237, 0, 0, 6440, 6441, 5, 22,
		0, 0, 6441, 6446, 5, 225, 0, 0, 6442, 6443, 5, 371, 0, 0, 6443, 6444, 5,
		22, 0, 0, 6444, 6446, 5, 225, 0, 0, 6445, 6418, 1, 0, 0, 0, 6445, 6420,
		1, 0, 0, 0, 6445, 6422, 1, 0, 0, 0, 6445, 6424, 1, 0, 0, 0, 6445, 6427,
		1, 0, 0, 0, 6445, 6430, 1, 0, 0, 0, 6445, 6433, 1, 0, 0, 0, 6445, 6436,
		1, 0, 0, 0, 6445, 6439, 1, 0, 0, 0, 6445, 6442, 1, 0, 0, 0, 6446, 815,
		1, 0, 0, 0, 6447, 6448, 5, 6, 0, 0, 6448, 6453, 3, 1016, 508, 0, 6449,
		6450, 5, 3, 0, 0, 6450, 6452, 3, 1016, 508, 0, 6451, 6449, 1, 0, 0, 0,
		6452, 6455, 1, 0, 0, 0, 6453, 6451, 1, 0, 0, 0, 6453, 6454, 1, 0, 0, 0,
		6454, 6456, 1, 0, 0, 0, 6455, 6453, 1, 0, 0, 0, 6456, 6457, 5, 7, 0, 0,
		6457, 6466, 1, 0, 0, 0, 6458, 6459, 5, 6, 0, 0, 6459, 6460, 3, 1016, 508,
		0, 6460, 6461, 5, 511, 0, 0, 6461, 6462, 3, 864, 432, 0, 6462, 6463, 3,
		926, 463, 0, 6463, 6464, 5, 7, 0, 0, 6464, 6466, 1, 0, 0, 0, 6465, 6447,
		1, 0, 0, 0, 6465, 6458, 1, 0, 0, 0, 6466, 817, 1, 0, 0, 0, 6467, 6468,
		3, 1024, 512, 0, 6468, 6469, 5, 493, 0, 0, 6469, 6470, 3, 866, 433, 0,
		6470, 819, 1, 0, 0, 0, 6471, 6472, 5, 290, 0, 0, 6472, 6486, 3, 850, 425,
		0, 6473, 6474, 5, 461, 0, 0, 6474, 6475, 5, 2, 0, 0, 6475, 6480, 3, 1016,
		508, 0, 6476, 6477, 5, 3, 0, 0, 6477, 6479, 3, 1016, 508, 0, 6478, 6476,
		1, 0, 0, 0, 6479, 6482, 1, 0, 0, 0, 6480, 6478, 1, 0, 0, 0, 6480, 6481,
		1, 0, 0, 0, 6481, 6483, 1, 0, 0, 0, 6482, 6480, 1, 0, 0, 0, 6483, 6484,
		5, 4, 0, 0, 6484, 6486, 1, 0, 0, 0, 6485, 6471, 1, 0, 0, 0, 6485, 6473,
		1, 0, 0, 0, 6486, 821, 1, 0, 0, 0, 6487, 6488, 5, 2, 0, 0, 6488, 6493,
		3, 1016, 508, 0, 6489, 6490, 5, 3, 0, 0, 6490, 6492, 3, 1016, 508, 0, 6491,
		6489, 1, 0, 0, 0, 6492, 6495, 1, 0, 0, 0, 6493, 6491, 1, 0, 0, 0, 6493,
		6494, 1, 0, 0, 0, 6494, 6496, 1, 0, 0, 0, 6495, 6493, 1, 0, 0, 0, 6496,
		6497, 5, 4, 0, 0, 6497, 823, 1, 0, 0, 0, 6498, 6500, 5, 429, 0, 0, 6499,
		6498, 1, 0, 0, 0, 6499, 6500, 1, 0, 0, 0, 6500, 6501, 1, 0, 0, 0, 6501,
		6502, 7, 37, 0, 0, 6502, 6503, 5, 2, 0, 0, 6503, 6508, 3, 1024, 512, 0,
		6504, 6505, 5, 3, 0, 0, 6505, 6507, 3, 1024, 512, 0, 6506, 6504, 1, 0,
		0, 0, 6507, 6510, 1, 0, 0, 0, 6508, 6506, 1, 0, 0, 0, 6508, 6509, 1, 0,
		0, 0, 6509, 6511, 1, 0, 0, 0, 6510, 6508, 1, 0, 0, 0, 6511, 6512, 5, 4,
		0, 0, 6512, 6520, 1, 0, 0, 0, 6513, 6515, 5, 429, 0, 0, 6514, 6513, 1,
		0, 0, 0, 6514, 6515, 1, 0, 0, 0, 6515, 6516, 1, 0, 0, 0, 6516, 6517, 7,
		37, 0, 0, 6517, 6520, 3, 1024, 512, 0, 6518, 6520, 3, 826, 413, 0, 6519,
		6499, 1, 0, 0, 0, 6519, 6514, 1, 0, 0, 0, 6519, 6518, 1, 0, 0, 0, 6520,
		825, 1, 0, 0, 0, 6521, 6522, 5, 303, 0, 0, 6522, 6523, 5, 2, 0, 0, 6523,
		6528, 3, 940, 470, 0, 6524, 6525, 5, 3, 0, 0, 6525, 6527, 3, 940, 470,
		0, 6526, 6524, 1, 0, 0, 0, 6527, 6530, 1, 0, 0, 0, 6528, 6526, 1, 0, 0,
		0, 6528, 6529, 1, 0, 0, 0, 6529, 6531, 1, 0, 0, 0, 6530, 6528, 1, 0, 0,
		0, 6531, 6532, 5, 4, 0, 0, 6532, 827, 1, 0, 0, 0, 6533, 6534, 5, 425, 0,
		0, 6534, 6535, 5, 2, 0, 0, 6535, 6540, 5, 519, 0, 0, 6536, 6537, 5, 3,
		0, 0, 6537, 6539, 5, 519, 0, 0, 6538, 6536, 1, 0, 0, 0, 6539, 6542, 1,
		0, 0, 0, 6540, 6538, 1, 0, 0, 0, 6540, 6541, 1, 0, 0, 0, 6541, 6543, 1,
		0, 0, 0, 6542, 6540, 1, 0, 0, 0, 6543, 6544, 5, 4, 0, 0, 6544, 829, 1,
		0, 0, 0, 6545, 6546, 5, 322, 0, 0, 6546, 6547, 3, 1016, 508, 0, 6547, 6548,
		5, 172, 0, 0, 6548, 6549, 3, 832, 416, 0, 6549, 831, 1, 0, 0, 0, 6550,
		6553, 3, 6, 3, 0, 6551, 6553, 5, 522, 0, 0, 6552, 6550, 1, 0, 0, 0, 6552,
		6551, 1, 0, 0, 0, 6553, 833, 1, 0, 0, 0, 6554, 6555, 5, 147, 0, 0, 6555,
		6567, 3, 1016, 508, 0, 6556, 6557, 5, 461, 0, 0, 6557, 6558, 5, 518, 0,
		0, 6558, 6564, 3, 1024, 512, 0, 6559, 6560, 5, 3, 0, 0, 6560, 6561, 5,
		518, 0, 0, 6561, 6563, 3, 1024, 512, 0, 6562, 6559, 1, 0, 0, 0, 6563, 6566,
		1, 0, 0, 0, 6564, 6562, 1, 0, 0, 0, 6564, 6565, 1, 0, 0, 0, 6565, 6568,
		1, 0, 0, 0, 6566, 6564, 1, 0, 0, 0, 6567, 6556, 1, 0, 0, 0, 6567, 6568,
		1, 0, 0, 0, 6568, 835, 1, 0, 0, 0, 6569, 6570, 7, 38, 0, 0, 6570, 6571,
		5, 322, 0, 0, 6571, 6572, 3, 1016, 508, 0, 6572, 837, 1, 0, 0, 0, 6573,
		6574, 5, 358, 0, 0, 6574, 6575, 5, 2, 0, 0, 6575, 6580, 5, 519, 0, 0, 6576,
		6577, 5, 3, 0, 0, 6577, 6579, 5, 519, 0, 0, 6578, 6576, 1, 0, 0, 0, 6579,
		6582, 1, 0, 0, 0, 6580, 6578, 1, 0, 0, 0, 6580, 6581, 1, 0, 0, 0, 6581,
		6583, 1, 0, 0, 0, 6582, 6580, 1, 0, 0, 0, 6583, 6584, 5, 4, 0, 0, 6584,
		839, 1, 0, 0, 0, 6585, 6586, 5, 2, 0, 0, 6586, 6591, 3, 842, 421, 0, 6587,
		6588, 5, 3, 0, 0, 6588, 6590, 3, 842, 421, 0, 6589, 6587, 1, 0, 0, 0, 6590,
		6593, 1, 0, 0, 0, 6591, 6589, 1, 0, 0, 0, 6591, 6592, 1, 0, 0, 0, 6592,
		6594, 1, 0, 0, 0, 6593, 6591, 1, 0, 0, 0, 6594, 6595, 5, 4, 0, 0, 6595,
		841, 1, 0, 0, 0, 6596, 6599, 3, 850, 425, 0, 6597, 6599, 5, 117, 0, 0,
		6598, 6596, 1, 0, 0, 0, 6598, 6597, 1, 0, 0, 0, 6599, 843, 1, 0, 0, 0,
		6600, 6605, 3, 846, 423, 0, 6601, 6602, 5, 3, 0, 0, 6602, 6604, 3, 846,
		423, 0, 6603, 6601, 1, 0, 0, 0, 6604, 6607, 1, 0, 0, 0, 6605, 6603, 1,
		0, 0, 0, 6605, 6606, 1, 0, 0, 0, 6606, 845, 1, 0, 0, 0, 6607, 6605, 1,
		0, 0, 0, 6608, 6609, 3, 850, 425, 0, 6609, 6610, 5, 8, 0, 0, 6610, 6611,
		3, 850, 425, 0, 6611, 847, 1, 0, 0, 0, 6612, 6613, 3, 850, 425, 0, 6613,
		6614, 5, 0, 0, 1, 6614, 849, 1, 0, 0, 0, 6615, 6617, 6, 425, -1, 0, 6616,
		6618, 5, 43, 0, 0, 6617, 6616, 1, 0, 0, 0, 6617, 6618, 1, 0, 0, 0, 6618,
		6619, 1, 0, 0, 0, 6619, 6623, 3, 854, 427, 0, 6620, 6621, 5, 281, 0, 0,
		6621, 6623, 3, 850, 425, 3, 6622, 6615, 1, 0, 0, 0, 6622, 6620, 1, 0, 0,
		0, 6623, 6632, 1, 0, 0, 0, 6624, 6625, 10, 2, 0, 0, 6625, 6626, 7, 39,
		0, 0, 6626, 6631, 3, 850, 425, 3, 6627, 6628, 10, 1, 0, 0, 6628, 6629,
		7, 40, 0, 0, 6629, 6631, 3, 850, 425, 2, 6630, 6624, 1, 0, 0, 0, 6630,
		6627, 1, 0, 0, 0, 6631, 6634, 1, 0, 0, 0, 6632, 6630, 1, 0, 0, 0, 6632,
		6633, 1, 0, 0, 0, 6633, 851, 1, 0, 0, 0, 6634, 6632, 1, 0, 0, 0, 6635,
		6640, 3, 850, 425, 0, 6636, 6637, 5, 3, 0, 0, 6637, 6639, 3, 850, 425,
		0, 6638, 6636, 1, 0, 0, 0, 6639, 6642, 1, 0, 0, 0, 6640, 6638, 1, 0, 0,
		0, 6640, 6641, 1, 0, 0, 0, 6641, 853, 1, 0, 0, 0, 6642, 6640, 1, 0, 0,
		0, 6643, 6644, 6, 427, -1, 0, 6644, 6645, 3, 856, 428, 0, 6645, 6664, 1,
		0, 0, 0, 6646, 6647, 10, 3, 0, 0, 6647, 6649, 5, 222, 0, 0, 6648, 6650,
		5, 281, 0, 0, 6649, 6648, 1, 0, 0, 0, 6649, 6650, 1, 0, 0, 0, 6650, 6651,
		1, 0, 0, 0, 6651, 6663, 5, 282, 0, 0, 6652, 6653, 10, 2, 0, 0, 6653, 6654,
		3, 978, 489, 0, 6654, 6655, 3, 856, 428, 0, 6655, 6663, 1, 0, 0, 0, 6656,
		6657, 10, 1, 0, 0, 6657, 6658, 3, 978, 489, 0, 6658, 6659, 5, 2, 0, 0,
		6659, 6660, 3, 752, 376, 0, 6660, 6661, 5, 4, 0, 0, 6661, 6663, 1, 0, 0,
		0, 6662, 6646, 1, 0, 0, 0, 6662, 6652, 1, 0, 0, 0, 6662, 6656, 1, 0, 0,
		0, 6663, 6666, 1, 0, 0, 0, 6664, 6662, 1, 0, 0, 0, 6664, 6665, 1, 0, 0,
		0, 6665, 855, 1, 0, 0, 0, 6666, 6664, 1, 0, 0, 0, 6667, 6669, 3, 862, 431,
		0, 6668, 6670, 3, 860, 430, 0, 6669, 6668, 1, 0, 0, 0, 6669, 6670, 1, 0,
		0, 0, 6670, 6673, 1, 0, 0, 0, 6671, 6673, 3, 858, 429, 0, 6672, 6667, 1,
		0, 0, 0, 6672, 6671, 1, 0, 0, 0, 6673, 857, 1, 0, 0, 0, 6674, 6675, 5,
		2, 0, 0, 6675, 6678, 3, 850, 425, 0, 6676, 6677, 5, 3, 0, 0, 6677, 6679,
		3, 850, 425, 0, 6678, 6676, 1, 0, 0, 0, 6679, 6680, 1, 0, 0, 0, 6680, 6678,
		1, 0, 0, 0, 6680, 6681, 1, 0, 0, 0, 6681, 6682, 1, 0, 0, 0, 6682, 6684,
		5, 4, 0, 0, 6683, 6685, 5, 281, 0, 0, 6684, 6683, 1, 0, 0, 0, 6684, 6685,
		1, 0, 0, 0, 6685, 6686, 1, 0, 0, 0, 6686, 6687, 5, 202, 0, 0, 6687, 6688,
		5, 2, 0, 0, 6688, 6689, 3, 752, 376, 0, 6689, 6690, 5, 4, 0, 0, 6690, 859,
		1, 0, 0, 0, 6691, 6693, 5, 281, 0, 0, 6692, 6691, 1, 0, 0, 0, 6692, 6693,
		1, 0, 0, 0, 6693, 6694, 1, 0, 0, 0, 6694, 6695, 5, 202, 0, 0, 6695, 6696,
		5, 2, 0, 0, 6696, 6697, 3, 752, 376, 0, 6697, 6698, 5, 4, 0, 0, 6698, 6721,
		1, 0, 0, 0, 6699, 6701, 5, 281, 0, 0, 6700, 6699, 1, 0, 0, 0, 6700, 6701,
		1, 0, 0, 0, 6701, 6702, 1, 0, 0, 0, 6702, 6703, 5, 202, 0, 0, 6703, 6704,
		5, 2, 0, 0, 6704, 6705, 3, 852, 426, 0, 6705, 6706, 5, 4, 0, 0, 6706, 6721,
		1, 0, 0, 0, 6707, 6709, 5, 281, 0, 0, 6708, 6707, 1, 0, 0, 0, 6708, 6709,
		1, 0, 0, 0, 6709, 6710, 1, 0, 0, 0, 6710, 6711, 5, 41, 0, 0, 6711, 6712,
		3, 862, 431, 0, 6712, 6713, 5, 21, 0, 0, 6713, 6714, 3, 856, 428, 0, 6714,
		6721, 1, 0, 0, 0, 6715, 6717, 5, 281, 0, 0, 6716, 6715, 1, 0, 0, 0, 6716,
		6717, 1, 0, 0, 0, 6717, 6718, 1, 0, 0, 0, 6718, 6719, 7, 41, 0, 0, 6719,
		6721, 3, 862, 431, 0, 6720, 6692, 1, 0, 0, 0, 6720, 6700, 1, 0, 0, 0, 6720,
		6708, 1, 0, 0, 0, 6720, 6716, 1, 0, 0, 0, 6721, 861, 1, 0, 0, 0, 6722,
		6723, 6, 431, -1, 0, 6723, 6724, 3, 864, 432, 0, 6724, 6751, 1, 0, 0, 0,
		6725, 6726, 10, 8, 0, 0, 6726, 6727, 5, 512, 0, 0, 6727, 6750, 3, 862,
		431, 9, 6728, 6729, 10, 7, 0, 0, 6729, 6730, 7, 42, 0, 0, 6730, 6750, 3,
		862, 431, 8, 6731, 6732, 10, 6, 0, 0, 6732, 6733, 7, 43, 0, 0, 6733, 6750,
		3, 862, 431, 7, 6734, 6735, 10, 5, 0, 0, 6735, 6736, 5, 510, 0, 0, 6736,
		6750, 3, 862, 431, 6, 6737, 6738, 10, 4, 0, 0, 6738, 6739, 5, 511, 0, 0,
		6739, 6750, 3, 862, 431, 5, 6740, 6741, 10, 3, 0, 0, 6741, 6742, 5, 514,
		0, 0, 6742, 6750, 3, 862, 431, 4, 6743, 6744, 10, 2, 0, 0, 6744, 6745,
		5, 515, 0, 0, 6745, 6750, 3, 862, 431, 3, 6746, 6747, 10, 1, 0, 0, 6747,
		6748, 5, 516, 0, 0, 6748, 6750, 3, 862, 431, 2, 6749, 6725, 1, 0, 0, 0,
		6749, 6728, 1, 0, 0, 0, 6749, 6731, 1, 0, 0, 0, 6749, 6734, 1, 0, 0, 0,
		6749, 6737, 1, 0, 0, 0, 6749, 6740, 1, 0, 0, 0, 6749, 6743, 1, 0, 0, 0,
		6749, 6746, 1, 0, 0, 0, 6750, 6753, 1, 0, 0, 0, 6751, 6749, 1, 0, 0, 0,
		6751, 6752, 1, 0, 0, 0, 6752, 863, 1, 0, 0, 0, 6753, 6751, 1, 0, 0, 0,
		6754, 6755, 6, 432, -1, 0, 6755, 6860, 3, 872, 436, 0, 6756, 6860, 3, 874,
		437, 0, 6757, 6758, 5, 123, 0, 0, 6758, 6759, 5, 2, 0, 0, 6759, 6760, 3,
		852, 426, 0, 6760, 6761, 5, 4, 0, 0, 6761, 6860, 1, 0, 0, 0, 6762, 6860,
		3, 868, 434, 0, 6763, 6764, 5, 9, 0, 0, 6764, 6765, 5, 165, 0, 0, 6765,
		6766, 3, 868, 434, 0, 6766, 6767, 5, 10, 0, 0, 6767, 6860, 1, 0, 0, 0,
		6768, 6860, 3, 866, 433, 0, 6769, 6860, 3, 876, 438, 0, 6770, 6771, 7,
		44, 0, 0, 6771, 6860, 3, 864, 432, 18, 6772, 6773, 5, 508, 0, 0, 6773,
		6860, 3, 864, 432, 17, 6774, 6775, 5, 2, 0, 0, 6775, 6776, 3, 850, 425,
		0, 6776, 6777, 5, 4, 0, 0, 6777, 6860, 1, 0, 0, 0, 6778, 6779, 5, 148,
		0, 0, 6779, 6780, 5, 2, 0, 0, 6780, 6781, 3, 752, 376, 0, 6781, 6782, 5,
		4, 0, 0, 6782, 6860, 1, 0, 0, 0, 6783, 6860, 3, 764, 382, 0, 6784, 6785,
		5, 59, 0, 0, 6785, 6786, 5, 2, 0, 0, 6786, 6787, 3, 850, 425, 0, 6787,
		6788, 5, 27, 0, 0, 6788, 6789, 3, 992, 496, 0, 6789, 6790, 5, 4, 0, 0,
		6790, 6860, 1, 0, 0, 0, 6791, 6792, 5, 87, 0, 0, 6792, 6793, 5, 2, 0, 0,
		6793, 6794, 3, 850, 425, 0, 6794, 6795, 5, 3, 0, 0, 6795, 6796, 3, 992,
		496, 0, 6796, 6797, 5, 4, 0, 0, 6797, 6860, 1, 0, 0, 0, 6798, 6799, 5,
		58, 0, 0, 6799, 6801, 3, 850, 425, 0, 6800, 6802, 3, 886, 443, 0, 6801,
		6800, 1, 0, 0, 0, 6802, 6803, 1, 0, 0, 0, 6803, 6801, 1, 0, 0, 0, 6803,
		6804, 1, 0, 0, 0, 6804, 6807, 1, 0, 0, 0, 6805, 6806, 5, 136, 0, 0, 6806,
		6808, 3, 850, 425, 0, 6807, 6805, 1, 0, 0, 0, 6807, 6808, 1, 0, 0, 0, 6808,
		6809, 1, 0, 0, 0, 6809, 6810, 5, 139, 0, 0, 6810, 6860, 1, 0, 0, 0, 6811,
		6813, 5, 58, 0, 0, 6812, 6814, 3, 886, 443, 0, 6813, 6812, 1, 0, 0, 0,
		6814, 6815, 1, 0, 0, 0, 6815, 6813, 1, 0, 0, 0, 6815, 6816, 1, 0, 0, 0,
		6816, 6819, 1, 0, 0, 0, 6817, 6818, 5, 136, 0, 0, 6818, 6820, 3, 850, 425,
		0, 6819, 6817, 1, 0, 0, 0, 6819, 6820, 1, 0, 0, 0, 6820, 6821, 1, 0, 0,
		0, 6821, 6822, 5, 139, 0, 0, 6822, 6860, 1, 0, 0, 0, 6823, 6825, 3, 994,
		497, 0, 6824, 6823, 1, 0, 0, 0, 6824, 6825, 1, 0, 0, 0, 6825, 6826, 1,
		0, 0, 0, 6826, 6828, 5, 6, 0, 0, 6827, 6829, 3, 852, 426, 0, 6828, 6827,
		1, 0, 0, 0, 6828, 6829, 1, 0, 0, 0, 6829, 6830, 1, 0, 0, 0, 6830, 6860,
		5, 7, 0, 0, 6831, 6832, 3, 996, 498, 0, 6832, 6834, 5, 9, 0, 0, 6833, 6835,
		3, 844, 422, 0, 6834, 6833, 1, 0, 0, 0, 6834, 6835, 1, 0, 0, 0, 6835, 6836,
		1, 0, 0, 0, 6836, 6837, 5, 10, 0, 0, 6837, 6860, 1, 0, 0, 0, 6838, 6839,
		5, 252, 0, 0, 6839, 6841, 5, 9, 0, 0, 6840, 6842, 3, 844, 422, 0, 6841,
		6840, 1, 0, 0, 0, 6841, 6842, 1, 0, 0, 0, 6842, 6843, 1, 0, 0, 0, 6843,
		6860, 5, 10, 0, 0, 6844, 6847, 3, 1016, 508, 0, 6845, 6847, 3, 1022, 511,
		0, 6846, 6844, 1, 0, 0, 0, 6846, 6845, 1, 0, 0, 0, 6847, 6848, 1, 0, 0,
		0, 6848, 6849, 5, 517, 0, 0, 6849, 6850, 3, 850, 425, 0, 6850, 6860, 1,
		0, 0, 0, 6851, 6852, 3, 1022, 511, 0, 6852, 6853, 5, 517, 0, 0, 6853, 6855,
		5, 2, 0, 0, 6854, 6856, 3, 852, 426, 0, 6855, 6854, 1, 0, 0, 0, 6855, 6856,
		1, 0, 0, 0, 6856, 6857, 1, 0, 0, 0, 6857, 6858, 5, 4, 0, 0, 6858, 6860,
		1, 0, 0, 0, 6859, 6754, 1, 0, 0, 0, 6859, 6756, 1, 0, 0, 0, 6859, 6757,
		1, 0, 0, 0, 6859, 6762, 1, 0, 0, 0, 6859, 6763, 1, 0, 0, 0, 6859, 6768,
		1, 0, 0, 0, 6859, 6769, 1, 0, 0, 0, 6859, 6770, 1, 0, 0, 0, 6859, 6772,
		1, 0, 0, 0, 6859, 6774, 1, 0, 0, 0, 6859, 6778, 1, 0, 0, 0, 6859, 6783,
		1, 0, 0, 0, 6859, 6784, 1, 0, 0, 0, 6859, 6791, 1, 0, 0, 0, 6859, 6798,
		1, 0, 0, 0, 6859, 6811, 1, 0, 0, 0, 6859, 6824, 1, 0, 0, 0, 6859, 6831,
		1, 0, 0, 0, 6859, 6838, 1, 0, 0, 0, 6859, 6846, 1, 0, 0, 0, 6859, 6851,
		1, 0, 0, 0, 6860, 6902, 1, 0, 0, 0, 6861, 6862, 10, 19, 0, 0, 6862, 6863,
		5, 537, 0, 0, 6863, 6901, 3, 864, 432, 20, 6864, 6866, 10, 1, 0, 0, 6865,
		6867, 5, 281, 0, 0, 6866, 6865, 1, 0, 0, 0, 6866, 6867, 1, 0, 0, 0, 6867,
		6868, 1, 0, 0, 0, 6868, 6869, 5, 256, 0, 0, 6869, 6901, 3, 864, 432, 2,
		6870, 6871, 10, 23, 0, 0, 6871, 6874, 5, 74, 0, 0, 6872, 6875, 3, 1016,
		508, 0, 6873, 6875, 3, 974, 487, 0, 6874, 6872, 1, 0, 0, 0, 6874, 6873,
		1, 0, 0, 0, 6875, 6901, 1, 0, 0, 0, 6876, 6880, 10, 20, 0, 0, 6877, 6881,
		5, 529, 0, 0, 6878, 6879, 5, 1, 0, 0, 6879, 6881, 3, 1016, 508, 0, 6880,
		6877, 1, 0, 0, 0, 6880, 6878, 1, 0, 0, 0, 6881, 6901, 1, 0, 0, 0, 6882,
		6883, 10, 6, 0, 0, 6883, 6884, 5, 6, 0, 0, 6884, 6885, 3, 862, 431, 0,
		6885, 6886, 5, 7, 0, 0, 6886, 6901, 1, 0, 0, 0, 6887, 6888, 10, 5, 0, 0,
		6888, 6890, 5, 6, 0, 0, 6889, 6891, 5, 519, 0, 0, 6890, 6889, 1, 0, 0,
		0, 6890, 6891, 1, 0, 0, 0, 6891, 6892, 1, 0, 0, 0, 6892, 6894, 5, 8, 0,
		0, 6893, 6895, 5, 519, 0, 0, 6894, 6893, 1, 0, 0, 0, 6894, 6895, 1, 0,
		0, 0, 6895, 6896, 1, 0, 0, 0, 6896, 6901, 5, 7, 0, 0, 6897, 6898, 10, 4,
		0, 0, 6898, 6899, 5, 517, 0, 0, 6899, 6901, 3, 974, 487, 0, 6900, 6861,
		1, 0, 0, 0, 6900, 6864, 1, 0, 0, 0, 6900, 6870, 1, 0, 0, 0, 6900, 6876,
		1, 0, 0, 0, 6900, 6882, 1, 0, 0, 0, 6900, 6887, 1, 0, 0, 0, 6900, 6897,
		1, 0, 0, 0, 6901, 6904, 1, 0, 0, 0, 6902, 6900, 1, 0, 0, 0, 6902, 6903,
		1, 0, 0, 0, 6903, 865, 1, 0, 0, 0, 6904, 6902, 1, 0, 0, 0, 6905, 6916,
		5, 282, 0, 0, 6906, 6916, 3, 980, 490, 0, 6907, 6916, 3, 1036, 518, 0,
		6908, 6909, 7, 45, 0, 0, 6909, 6916, 3, 974, 487, 0, 6910, 6916, 3, 974,
		487, 0, 6911, 6916, 3, 982, 491, 0, 6912, 6916, 3, 990, 495, 0, 6913, 6916,
		3, 976, 488, 0, 6914, 6916, 5, 302, 0, 0, 6915, 6905, 1, 0, 0, 0, 6915,
		6906, 1, 0, 0, 0, 6915, 6907, 1, 0, 0, 0, 6915, 6908, 1, 0, 0, 0, 6915,
		6910, 1, 0, 0, 0, 6915, 6911, 1, 0, 0, 0, 6915, 6912, 1, 0, 0, 0, 6915,
		6913, 1, 0, 0, 0, 6915, 6914, 1, 0, 0, 0, 6916, 867, 1, 0, 0, 0, 6917,
		6918, 5, 152, 0, 0, 6918, 6919, 5, 2, 0, 0, 6919, 6920, 3, 1016, 508, 0,
		6920, 6921, 5, 172, 0, 0, 6921, 6922, 3, 862, 431, 0, 6922, 6923, 5, 4,
		0, 0, 6923, 6990, 1, 0, 0, 0, 6924, 6925, 5, 183, 0, 0, 6925, 6934, 5,
		2, 0, 0, 6926, 6931, 3, 850, 425, 0, 6927, 6928, 5, 3, 0, 0, 6928, 6930,
		3, 850, 425, 0, 6929, 6927, 1, 0, 0, 0, 6930, 6933, 1, 0, 0, 0, 6931, 6929,
		1, 0, 0, 0, 6931, 6932, 1, 0, 0, 0, 6932, 6935, 1, 0, 0, 0, 6933, 6931,
		1, 0, 0, 0, 6934, 6926, 1, 0, 0, 0, 6934, 6935, 1, 0, 0, 0, 6935, 6936,
		1, 0, 0, 0, 6936, 6990, 5, 4, 0, 0, 6937, 6938, 5, 184, 0, 0, 6938, 6947,
		5, 2, 0, 0, 6939, 6944, 3, 850, 425, 0, 6940, 6941, 5, 3, 0, 0, 6941, 6943,
		3, 850, 425, 0, 6942, 6940, 1, 0, 0, 0, 6943, 6946, 1, 0, 0, 0, 6944, 6942,
		1, 0, 0, 0, 6944, 6945, 1, 0, 0, 0, 6945, 6948, 1, 0, 0, 0, 6946, 6944,
		1, 0, 0, 0, 6947, 6939, 1, 0, 0, 0, 6947, 6948, 1, 0, 0, 0, 6948, 6949,
		1, 0, 0, 0, 6949, 6990, 5, 4, 0, 0, 6950, 6990, 3, 878, 439, 0, 6951, 6990,
		3, 880, 440, 0, 6952, 6990, 3, 882, 441, 0, 6953, 6955, 3, 870, 435, 0,
		6954, 6956, 3, 888, 444, 0, 6955, 6954, 1, 0, 0, 0, 6955, 6956, 1, 0, 0,
		0, 6956, 6990, 1, 0, 0, 0, 6957, 6958, 3, 884, 442, 0, 6958, 6959, 3, 888,
		444, 0, 6959, 6990, 1, 0, 0, 0, 6960, 6961, 5, 440, 0, 0, 6961, 6970, 5,
		2, 0, 0, 6962, 6967, 3, 850, 425, 0, 6963, 6964, 5, 3, 0, 0, 6964, 6966,
		3, 850, 425, 0, 6965, 6963, 1, 0, 0, 0, 6966, 6969, 1, 0, 0, 0, 6967, 6965,
		1, 0, 0, 0, 6967, 6968, 1, 0, 0, 0, 6968, 6971, 1, 0, 0, 0, 6969, 6967,
		1, 0, 0, 0, 6970, 6962, 1, 0, 0, 0, 6970, 6971, 1, 0, 0, 0, 6971, 6972,
		1, 0, 0, 0, 6972, 6990, 5, 4, 0, 0, 6973, 6974, 3, 1010, 505, 0, 6974,
		6983, 5, 2, 0, 0, 6975, 6980, 3, 850, 425, 0, 6976, 6977, 5, 3, 0, 0, 6977,
		6979, 3, 850, 425, 0, 6978, 6976, 1, 0, 0, 0, 6979, 6982, 1, 0, 0, 0, 6980,
		6978, 1, 0, 0, 0, 6980, 6981, 1, 0, 0, 0, 6981, 6984, 1, 0, 0, 0, 6982,
		6980, 1, 0, 0, 0, 6983, 6975, 1, 0, 0, 0, 6983, 6984, 1, 0, 0, 0, 6984,
		6985, 1, 0, 0, 0, 6985, 6987, 5, 4, 0, 0, 6986, 6988, 3, 888, 444, 0, 6987,
		6986, 1, 0, 0, 0, 6987, 6988, 1, 0, 0, 0, 6988, 6990, 1, 0, 0, 0, 6989,
		6917, 1, 0, 0, 0, 6989, 6924, 1, 0, 0, 0, 6989, 6937, 1, 0, 0, 0, 6989,
		6950, 1, 0, 0, 0, 6989, 6951, 1, 0, 0, 0, 6989, 6952, 1, 0, 0, 0, 6989,
		6953, 1, 0, 0, 0, 6989, 6957, 1, 0, 0, 0, 6989, 6960, 1, 0, 0, 0, 6989,
		6973, 1, 0, 0, 0, 6990, 869, 1, 0, 0, 0, 6991, 6992, 5, 34, 0, 0, 6992,
		6994, 5, 2, 0, 0, 6993, 6995, 3, 784, 392, 0, 6994, 6993, 1, 0, 0, 0, 6994,
		6995, 1, 0, 0, 0, 6995, 6996, 1, 0, 0, 0, 6996, 6997, 3, 850, 425, 0, 6997,
		6998, 5, 4, 0, 0, 6998, 7117, 1, 0, 0, 0, 6999, 7000, 5, 89, 0, 0, 7000,
		7002, 5, 2, 0, 0, 7001, 7003, 5, 503, 0, 0, 7002, 7001, 1, 0, 0, 0, 7002,
		7003, 1, 0, 0, 0, 7003, 7004, 1, 0, 0, 0, 7004, 7117, 5, 4, 0, 0, 7005,
		7006, 5, 89, 0, 0, 7006, 7011, 5, 2, 0, 0, 7007, 7009, 3, 784, 392, 0,
		7008, 7010, 3, 816, 408, 0, 7009, 7008, 1, 0, 0, 0, 7009, 7010, 1, 0, 0,
		0, 7010, 7012, 1, 0, 0, 0, 7011, 7007, 1, 0, 0, 0, 7011, 7012, 1, 0, 0,
		0, 7012, 7021, 1, 0, 0, 0, 7013, 7018, 3, 850, 425, 0, 7014, 7015, 5, 3,
		0, 0, 7015, 7017, 3, 850, 425, 0, 7016, 7014, 1, 0, 0, 0, 7017, 7020, 1,
		0, 0, 0, 7018, 7016, 1, 0, 0, 0, 7018, 7019, 1, 0, 0, 0, 7019, 7022, 1,
		0, 0, 0, 7020, 7018, 1, 0, 0, 0, 7021, 7013, 1, 0, 0, 0, 7021, 7022, 1,
		0, 0, 0, 7022, 7023, 1, 0, 0, 0, 7023, 7117, 5, 4, 0, 0, 7024, 7025, 5,
		258, 0, 0, 7025, 7027, 5, 2, 0, 0, 7026, 7028, 3, 784, 392, 0, 7027, 7026,
		1, 0, 0, 0, 7027, 7028, 1, 0, 0, 0, 7028, 7029, 1, 0, 0, 0, 7029, 7030,
		3, 850, 425, 0, 7030, 7031, 5, 4, 0, 0, 7031, 7117, 1, 0, 0, 0, 7032, 7033,
		5, 263, 0, 0, 7033, 7035, 5, 2, 0, 0, 7034, 7036, 3, 784, 392, 0, 7035,
		7034, 1, 0, 0, 0, 7035, 7036, 1, 0, 0, 0, 7036, 7037, 1, 0, 0, 0, 7037,
		7038, 3, 850, 425, 0, 7038, 7039, 5, 4, 0, 0, 7039, 7117, 1, 0, 0, 0, 7040,
		7041, 5, 416, 0, 0, 7041, 7043, 5, 2, 0, 0, 7042, 7044, 3, 784, 392, 0,
		7043, 7042, 1, 0, 0, 0, 7043, 7044, 1, 0, 0, 0, 7044, 7045, 1, 0, 0, 0,
		7045, 7046, 3, 850, 425, 0, 7046, 7047, 5, 4, 0, 0, 7047, 7117, 1, 0, 0,
		0, 7048, 7049, 5, 25, 0, 0, 7049, 7051, 5, 2, 0, 0, 7050, 7052, 3, 784,
		392, 0, 7051, 7050, 1, 0, 0, 0, 7051, 7052, 1, 0, 0, 0, 7052, 7053, 1,
		0, 0, 0, 7053, 7064, 3, 850, 425, 0, 7054, 7055, 5, 298, 0, 0, 7055, 7056,
		5, 55, 0, 0, 7056, 7061, 3, 768, 384, 0, 7057, 7058, 5, 3, 0, 0, 7058,
		7060, 3, 768, 384, 0, 7059, 7057, 1, 0, 0, 0, 7060, 7063, 1, 0, 0, 0, 7061,
		7059, 1, 0, 0, 0, 7061, 7062, 1, 0, 0, 0, 7062, 7065, 1, 0, 0, 0, 7063,
		7061, 1, 0, 0, 0, 7064, 7054, 1, 0, 0, 0, 7064, 7065, 1, 0, 0, 0, 7065,
		7066, 1, 0, 0, 0, 7066, 7067, 5, 4, 0, 0, 7067, 7117, 1, 0, 0, 0, 7068,
		7069, 5, 26, 0, 0, 7069, 7070, 5, 2, 0, 0, 7070, 7081, 3, 850, 425, 0,
		7071, 7072, 5, 298, 0, 0, 7072, 7073, 5, 55, 0, 0, 7073, 7078, 3, 768,
		384, 0, 7074, 7075, 5, 3, 0, 0, 7075, 7077, 3, 768, 384, 0, 7076, 7074,
		1, 0, 0, 0, 7077, 7080, 1, 0, 0, 0, 7078, 7076, 1, 0, 0, 0, 7078, 7079,
		1, 0, 0, 0, 7079, 7082, 1, 0, 0, 0, 7080, 7078, 1, 0, 0, 0, 7081, 7071,
		1, 0, 0, 0, 7081, 7082, 1, 0, 0, 0, 7082, 7083, 1, 0, 0, 0, 7083, 7084,
		5, 4, 0, 0, 7084, 7117, 1, 0, 0, 0, 7085, 7086, 5, 185, 0, 0, 7086, 7088,
		5, 2, 0, 0, 7087, 7089, 3, 784, 392, 0, 7088, 7087, 1, 0, 0, 0, 7088, 7089,
		1, 0, 0, 0, 7089, 7090, 1, 0, 0, 0, 7090, 7095, 3, 850, 425, 0, 7091, 7092,
		5, 3, 0, 0, 7092, 7094, 3, 850, 425, 0, 7093, 7091, 1, 0, 0, 0, 7094, 7097,
		1, 0, 0, 0, 7095, 7093, 1, 0, 0, 0, 7095, 7096, 1, 0, 0, 0, 7096, 7108,
		1, 0, 0, 0, 7097, 7095, 1, 0, 0, 0, 7098, 7099, 5, 298, 0, 0, 7099, 7100,
		5, 55, 0, 0, 7100, 7105, 3, 768, 384, 0, 7101, 7102, 5, 3, 0, 0, 7102,
		7104, 3, 768, 384, 0, 7103, 7101, 1, 0, 0, 0, 7104, 7107, 1, 0, 0, 0, 7105,
		7103, 1, 0, 0, 0, 7105, 7106, 1, 0, 0, 0, 7106, 7109, 1, 0, 0, 0, 7107,
		7105, 1, 0, 0, 0, 7108, 7098, 1, 0, 0, 0, 7108, 7109, 1, 0, 0, 0, 7109,
		7112, 1, 0, 0, 0, 7110, 7111, 5, 393, 0, 0, 7111, 7113, 3, 850, 425, 0,
		7112, 7110, 1, 0, 0, 0, 7112, 7113, 1, 0, 0, 0, 7113, 7114, 1, 0, 0, 0,
		7114, 7115, 5, 4, 0, 0, 7115, 7117, 1, 0, 0, 0, 7116, 6991, 1, 0, 0, 0,
		7116, 6999, 1, 0, 0, 0, 7116, 7005, 1, 0, 0, 0, 7116, 7024, 1, 0, 0, 0,
		7116, 7032, 1, 0, 0, 0, 7116, 7040, 1, 0, 0, 0, 7116, 7048, 1, 0, 0, 0,
		7116, 7068, 1, 0, 0, 0, 7116, 7085, 1, 0, 0, 0, 7117, 871, 1, 0, 0, 0,
		7118, 7119, 5, 518, 0, 0, 7119, 7120, 3, 1024, 512, 0, 7120, 873, 1, 0,
		0, 0, 7121, 7122, 5, 518, 0, 0, 7122, 7126, 5, 518, 0, 0, 7123, 7124, 3,
		966, 483, 0, 7124, 7125, 5, 1, 0, 0, 7125, 7127, 1, 0, 0, 0, 7126, 7123,
		1, 0, 0, 0, 7126, 7127, 1, 0, 0, 0, 7127, 7128, 1, 0, 0, 0, 7128, 7129,
		3, 1016, 508, 0, 7129, 875, 1, 0, 0, 0, 7130, 7131, 3, 1016, 508, 0, 7131,
		877, 1, 0, 0, 0, 7132, 7133, 5, 60, 0, 0, 7133, 7134, 5, 2, 0, 0, 7134,
		7160, 5, 4, 0, 0, 7135, 7136, 5, 104, 0, 0, 7136, 7137, 5, 2, 0, 0, 7137,
		7160, 5, 4, 0, 0, 7138, 7139, 5, 387, 0, 0, 7139, 7140, 5, 2, 0, 0, 7140,
		7160, 5, 4, 0, 0, 7141, 7142, 5, 459, 0, 0, 7142, 7143, 5, 2, 0, 0, 7143,
		7160, 5, 4, 0, 0, 7144, 7147, 5, 101, 0, 0, 7145, 7146, 5, 2, 0, 0, 7146,
		7148, 5, 4, 0, 0, 7147, 7145, 1, 0, 0, 0, 7147, 7148, 1, 0, 0, 0, 7148,
		7160, 1, 0, 0, 0, 7149, 7152, 5, 98, 0, 0, 7150, 7151, 5, 2, 0, 0, 7151,
		7153, 5, 4, 0, 0, 7152, 7150, 1, 0, 0, 0, 7152, 7153, 1, 0, 0, 0, 7153,
		7160, 1, 0, 0, 0, 7154, 7157, 5, 97, 0, 0, 7155, 7156, 5, 2, 0, 0, 7156,
		7158, 5, 4, 0, 0, 7157, 7155, 1, 0, 0, 0, 7157, 7158, 1, 0, 0, 0, 7158,
		7160, 1, 0, 0, 0, 7159, 7132, 1, 0, 0, 0, 7159, 7135, 1, 0, 0, 0, 7159,
		7138, 1, 0, 0, 0, 7159, 7141, 1, 0, 0, 0, 7159, 7144, 1, 0, 0, 0, 7159,
		7149, 1, 0, 0, 0, 7159, 7154, 1, 0, 0, 0, 7160, 879, 1, 0, 0, 0, 7161,
		7164, 5, 96, 0, 0, 7162, 7163, 5, 2, 0, 0, 7163, 7165, 5, 4, 0, 0, 7164,
		7162, 1, 0, 0, 0, 7164, 7165, 1, 0, 0, 0, 7165, 7190, 1, 0, 0, 0, 7166,
		7169, 5, 99, 0, 0, 7167, 7168, 5, 2, 0, 0, 7168, 7170, 5, 4, 0, 0, 7169,
		7167, 1, 0, 0, 0, 7169, 7170, 1, 0, 0, 0, 7170, 7190, 1, 0, 0, 0, 7171,
		7177, 5, 100, 0, 0, 7172, 7174, 5, 2, 0, 0, 7173, 7175, 5, 519, 0, 0, 7174,
		7173, 1, 0, 0, 0, 7174, 7175, 1, 0, 0, 0, 7175, 7176, 1, 0, 0, 0, 7176,
		7178, 5, 4, 0, 0, 7177, 7172, 1, 0, 0, 0, 7177, 7178, 1, 0, 0, 0, 7178,
		7190, 1, 0, 0, 0, 7179, 7182, 5, 245, 0, 0, 7180, 7181, 5, 2, 0, 0, 7181,
		7183, 5, 4, 0, 0, 7182, 7180, 1, 0, 0, 0, 7182, 7183, 1, 0, 0, 0, 7183,
		7190, 1, 0, 0, 0, 7184, 7187, 5, 246, 0, 0, 7185, 7186, 5, 2, 0, 0, 7186,
		7188, 5, 4, 0, 0, 7187, 7185, 1, 0, 0, 0, 7187, 7188, 1, 0, 0, 0, 7188,
		7190, 1, 0, 0, 0, 7189, 7161, 1, 0, 0, 0, 7189, 7166, 1, 0, 0, 0, 7189,
		7171, 1, 0, 0, 0, 7189, 7179, 1, 0, 0, 0, 7189, 7184, 1, 0, 0, 0, 7190,
		881, 1, 0, 0, 0, 7191, 7192, 5, 64, 0, 0, 7192, 7193, 5, 2, 0, 0, 7193,
		7194, 3, 850, 425, 0, 7194, 7195, 5, 4, 0, 0, 7195, 7333, 1, 0, 0, 0, 7196,
		7197, 5, 108, 0, 0, 7197, 7198, 5, 2, 0, 0, 7198, 7199, 3, 850, 425, 0,
		7199, 7200, 5, 4, 0, 0, 7200, 7333, 1, 0, 0, 0, 7201, 7202, 5, 193, 0,
		0, 7202, 7203, 5, 2, 0, 0, 7203, 7204, 3, 850, 425, 0, 7204, 7205, 5, 4,
		0, 0, 7205, 7333, 1, 0, 0, 0, 7206, 7207, 5, 197, 0, 0, 7207, 7216, 5,
		2, 0, 0, 7208, 7213, 3, 850, 425, 0, 7209, 7210, 5, 3, 0, 0, 7210, 7212,
		3, 850, 425, 0, 7211, 7209, 1, 0, 0, 0, 7212, 7215, 1, 0, 0, 0, 7213, 7211,
		1, 0, 0, 0, 7213, 7214, 1, 0, 0, 0, 7214, 7217, 1, 0, 0, 0, 7215, 7213,
		1, 0, 0, 0, 7216, 7208, 1, 0, 0, 0, 7216, 7217, 1, 0, 0, 0, 7217, 7218,
		1, 0, 0, 0, 7218, 7333, 5, 4, 0, 0, 7219, 7220, 5, 237, 0, 0, 7220, 7221,
		5, 2, 0, 0, 7221, 7222, 3, 850, 425, 0, 7222, 7223, 5, 3, 0, 0, 7223, 7224,
		3, 850, 425, 0, 7224, 7225, 5, 4, 0, 0, 7225, 7333, 1, 0, 0, 0, 7226, 7227,
		5, 240, 0, 0, 7227, 7228, 5, 2, 0, 0, 7228, 7229, 3, 850, 425, 0, 7229,
		7230, 5, 3, 0, 0, 7230, 7231, 3, 850, 425, 0, 7231, 7232, 5, 4, 0, 0, 7232,
		7333, 1, 0, 0, 0, 7233, 7234, 5, 264, 0, 0, 7234, 7235, 5, 2, 0, 0, 7235,
		7236, 3, 850, 425, 0, 7236, 7237, 5, 4, 0, 0, 7237, 7333, 1, 0, 0, 0, 7238,
		7239, 5, 268, 0, 0, 7239, 7240, 5, 2, 0, 0, 7240, 7241, 3, 850, 425, 0,
		7241, 7242, 5, 3, 0, 0, 7242, 7243, 3, 850, 425, 0, 7243, 7244, 5, 4, 0,
		0, 7244, 7333, 1, 0, 0, 0, 7245, 7246, 5, 271, 0, 0, 7246, 7247, 5, 2,
		0, 0, 7247, 7248, 3, 850, 425, 0, 7248, 7249, 5, 4, 0, 0, 7249, 7333, 1,
		0, 0, 0, 7250, 7251, 5, 337, 0, 0, 7251, 7252, 5, 2, 0, 0, 7252, 7253,
		3, 850, 425, 0, 7253, 7254, 5, 4, 0, 0, 7254, 7333, 1, 0, 0, 0, 7255, 7256,
		5, 350, 0, 0, 7256, 7257, 5, 2, 0, 0, 7257, 7258, 3, 850, 425, 0, 7258,
		7259, 5, 3, 0, 0, 7259, 7260, 3, 850, 425, 0, 7260, 7261, 5, 4, 0, 0, 7261,
		7333, 1, 0, 0, 0, 7262, 7263, 5, 356, 0, 0, 7263, 7272, 5, 2, 0, 0, 7264,
		7269, 3, 850, 425, 0, 7265, 7266, 5, 3, 0, 0, 7266, 7268, 3, 850, 425,
		0, 7267, 7265, 1, 0, 0, 0, 7268, 7271, 1, 0, 0, 0, 7269, 7267, 1, 0, 0,
		0, 7269, 7270, 1, 0, 0, 0, 7270, 7273, 1, 0, 0, 0, 7271, 7269, 1, 0, 0,
		0, 7272, 7264, 1, 0, 0, 0, 7272, 7273, 1, 0, 0, 0, 7273, 7274, 1, 0, 0,
		0, 7274, 7333, 5, 4, 0, 0, 7275, 7276, 5, 371, 0, 0, 7276, 7277, 5, 2,
		0, 0, 7277, 7278, 3, 850, 425, 0, 7278, 7279, 5, 3, 0, 0, 7279, 7280, 3,
		850, 425, 0, 7280, 7281, 5, 4, 0, 0, 7281, 7333, 1, 0, 0, 0, 7282, 7283,
		5, 372, 0, 0, 7283, 7284, 5, 2, 0, 0, 7284, 7285, 3, 850, 425, 0, 7285,
		7286, 5, 3, 0, 0, 7286, 7287, 3, 850, 425, 0, 7287, 7288, 5, 4, 0, 0, 7288,
		7333, 1, 0, 0, 0, 7289, 7290, 5, 389, 0, 0, 7290, 7291, 5, 2, 0, 0, 7291,
		7292, 3, 850, 425, 0, 7292, 7293, 5, 4, 0, 0, 7293, 7333, 1, 0, 0, 0, 7294,
		7295, 5, 436, 0, 0, 7295, 7296, 5, 2, 0, 0, 7296, 7297, 3, 988, 494, 0,
		7297, 7298, 5, 3, 0, 0, 7298, 7299, 3, 850, 425, 0, 7299, 7300, 5, 3, 0,
		0, 7300, 7301, 3, 850, 425, 0, 7301, 7302, 5, 4, 0, 0, 7302, 7333, 1, 0,
		0, 0, 7303, 7304, 5, 437, 0, 0, 7304, 7305, 5, 2, 0, 0, 7305, 7306, 3,
		988, 494, 0, 7306, 7307, 5, 3, 0, 0, 7307, 7308, 3, 850, 425, 0, 7308,
		7309, 5, 3, 0, 0, 7309, 7310, 3, 850, 425, 0, 7310, 7311, 5, 4, 0, 0, 7311,
		7333, 1, 0, 0, 0, 7312, 7313, 5, 484, 0, 0, 7313, 7314, 5, 2, 0, 0, 7314,
		7315, 3, 850, 425, 0, 7315, 7316, 5, 4, 0, 0, 7316, 7333, 1, 0, 0, 0, 7317,
		7318, 5, 305, 0, 0, 7318, 7319, 5, 2, 0, 0, 7319, 7320, 3, 974, 487, 0,
		7320, 7321, 5, 4, 0, 0, 7321, 7333, 1, 0, 0, 0, 7322, 7323, 5, 164, 0,
		0, 7323, 7324, 5, 2, 0, 0, 7324, 7325, 3, 850, 425, 0, 7325, 7326, 5, 4,
		0, 0, 7326, 7333, 1, 0, 0, 0, 7327, 7328, 5, 62, 0, 0, 7328, 7329, 5, 2,
		0, 0, 7329, 7330, 3, 850, 425, 0, 7330, 7331, 5, 4, 0, 0, 7331, 7333, 1,
		0, 0, 0, 7332, 7191, 1, 0, 0, 0, 7332, 7196, 1, 0, 0, 0, 7332, 7201, 1,
		0, 0, 0, 7332, 7206, 1, 0, 0, 0, 7332, 7219, 1, 0, 0, 0, 7332, 7226, 1,
		0, 0, 0, 7332, 7233, 1, 0, 0, 0, 7332, 7238, 1, 0, 0, 0, 7332, 7245, 1,
		0, 0, 0, 7332, 7250, 1, 0, 0, 0, 7332, 7255, 1, 0, 0, 0, 7332, 7262, 1,
		0, 0, 0, 7332, 7275, 1, 0, 0, 0, 7332, 7282, 1, 0, 0, 0, 7332, 7289, 1,
		0, 0, 0, 7332, 7294, 1, 0, 0, 0, 7332, 7303, 1, 0, 0, 0, 7332, 7312, 1,
		0, 0, 0, 7332, 7317, 1, 0, 0, 0, 7332, 7322, 1, 0, 0, 0, 7332, 7327, 1,
		0, 0, 0, 7333, 883, 1, 0, 0, 0, 7334, 7335, 5, 380, 0, 0, 7335, 7336, 5,
		2, 0, 0, 7336, 7432, 5, 4, 0, 0, 7337, 7338, 5, 344, 0, 0, 7338, 7339,
		5, 2, 0, 0, 7339, 7432, 5, 4, 0, 0, 7340, 7341, 5, 119, 0, 0, 7341, 7342,
		5, 2, 0, 0, 7342, 7432, 5, 4, 0, 0, 7343, 7344, 5, 93, 0, 0, 7344, 7345,
		5, 2, 0, 0, 7345, 7432, 5, 4, 0, 0, 7346, 7347, 5, 309, 0, 0, 7347, 7348,
		5, 2, 0, 0, 7348, 7432, 5, 4, 0, 0, 7349, 7350, 5, 124, 0, 0, 7350, 7352,
		5, 2, 0, 0, 7351, 7353, 3, 850, 425, 0, 7352, 7351, 1, 0, 0, 0, 7352, 7353,
		1, 0, 0, 0, 7353, 7354, 1, 0, 0, 0, 7354, 7432, 5, 4, 0, 0, 7355, 7356,
		5, 236, 0, 0, 7356, 7368, 5, 2, 0, 0, 7357, 7359, 3, 850, 425, 0, 7358,
		7360, 3, 890, 445, 0, 7359, 7358, 1, 0, 0, 0, 7359, 7360, 1, 0, 0, 0, 7360,
		7365, 1, 0, 0, 0, 7361, 7362, 5, 3, 0, 0, 7362, 7364, 3, 850, 425, 0, 7363,
		7361, 1, 0, 0, 0, 7364, 7367, 1, 0, 0, 0, 7365, 7363, 1, 0, 0, 0, 7365,
		7366, 1, 0, 0, 0, 7366, 7369, 1, 0, 0, 0, 7367, 7365, 1, 0, 0, 0, 7368,
		7357, 1, 0, 0, 0, 7368, 7369, 1, 0, 0, 0, 7369, 7370, 1, 0, 0, 0, 7370,
		7372, 5, 4, 0, 0, 7371, 7373, 3, 890, 445, 0, 7372, 7371, 1, 0, 0, 0, 7372,
		7373, 1, 0, 0, 0, 7373, 7432, 1, 0, 0, 0, 7374, 7375, 5, 231, 0, 0, 7375,
		7387, 5, 2, 0, 0, 7376, 7378, 3, 850, 425, 0, 7377, 7379, 3, 890, 445,
		0, 7378, 7377, 1, 0, 0, 0, 7378, 7379, 1, 0, 0, 0, 7379, 7384, 1, 0, 0,
		0, 7380, 7381, 5, 3, 0, 0, 7381, 7383, 3, 850, 425, 0, 7382, 7380, 1, 0,
		0, 0, 7383, 7386, 1, 0, 0, 0, 7384, 7382, 1, 0, 0, 0, 7384, 7385, 1, 0,
		0, 0, 7385, 7388, 1, 0, 0, 0, 7386, 7384, 1, 0, 0, 0, 7387, 7376, 1, 0,
		0, 0, 7387, 7388, 1, 0, 0, 0, 7388, 7389, 1, 0, 0, 0, 7389, 7391, 5, 4,
		0, 0, 7390, 7392, 3, 890, 445, 0, 7391, 7390, 1, 0, 0, 0, 7391, 7392, 1,
		0, 0, 0, 7392, 7432, 1, 0, 0, 0, 7393, 7394, 5, 162, 0, 0, 7394, 7406,
		5, 2, 0, 0, 7395, 7397, 3, 850, 425, 0, 7396, 7398, 3, 890, 445, 0, 7397,
		7396, 1, 0, 0, 0, 7397, 7398, 1, 0, 0, 0, 7398, 7403, 1, 0, 0, 0, 7399,
		7400, 5, 3, 0, 0, 7400, 7402, 3, 850, 425, 0, 7401, 7399, 1, 0, 0, 0, 7402,
		7405, 1, 0, 0, 0, 7403, 7401, 1, 0, 0, 0, 7403, 7404, 1, 0, 0, 0, 7404,
		7407, 1, 0, 0, 0, 7405, 7403, 1, 0, 0, 0, 7406, 7395, 1, 0, 0, 0, 7406,
		7407, 1, 0, 0, 0, 7407, 7408, 1, 0, 0, 0, 7408, 7410, 5, 4, 0, 0, 7409,
		7411, 3, 890, 445, 0, 7410, 7409, 1, 0, 0, 0, 7410, 7411, 1, 0, 0, 0, 7411,
		7432, 1, 0, 0, 0, 7412, 7413, 5, 234, 0, 0, 7413, 7425, 5, 2, 0, 0, 7414,
		7416, 3, 850, 425, 0, 7415, 7417, 3, 890, 445, 0, 7416, 7415, 1, 0, 0,
		0, 7416, 7417, 1, 0, 0, 0, 7417, 7422, 1, 0, 0, 0, 7418, 7419, 5, 3, 0,
		0, 7419, 7421, 3, 850, 425, 0, 7420, 7418, 1, 0, 0, 0, 7421, 7424, 1, 0,
		0, 0, 7422, 7420, 1, 0, 0, 0, 7422, 7423, 1, 0, 0, 0, 7423, 7426, 1, 0,
		0, 0, 7424, 7422, 1, 0, 0, 0, 7425, 7414, 1, 0, 0, 0, 7425, 7426, 1, 0,
		0, 0, 7426, 7427, 1, 0, 0, 0, 7427, 7429, 5, 4, 0, 0, 7428, 7430, 3, 890,
		445, 0, 7429, 7428, 1, 0, 0, 0, 7429, 7430, 1, 0, 0, 0, 7430, 7432, 1,
		0, 0, 0, 7431, 7334, 1, 0, 0, 0, 7431, 7337, 1, 0, 0, 0, 7431, 7340, 1,
		0, 0, 0, 7431, 7343, 1, 0, 0, 0, 7431, 7346, 1, 0, 0, 0, 7431, 7349, 1,
		0, 0, 0, 7431, 7355, 1, 0, 0, 0, 7431, 7374, 1, 0, 0, 0, 7431, 7393, 1,
		0, 0, 0, 7431, 7412, 1, 0, 0, 0, 7432, 885, 1, 0, 0, 0, 7433, 7434, 5,
		478, 0, 0, 7434, 7435, 3, 850, 425, 0, 7435, 7436, 5, 432, 0, 0, 7436,
		7437, 3, 850, 425, 0, 7437, 887, 1, 0, 0, 0, 7438, 7439, 5, 301, 0, 0,
		7439, 7453, 5, 2, 0, 0, 7440, 7442, 3, 816, 408, 0, 7441, 7440, 1, 0, 0,
		0, 7441, 7442, 1, 0, 0, 0, 7442, 7443, 1, 0, 0, 0, 7443, 7444, 5, 303,
		0, 0, 7444, 7445, 5, 55, 0, 0, 7445, 7450, 3, 850, 425, 0, 7446, 7447,
		5, 3, 0, 0, 7447, 7449, 3, 850, 425, 0, 7448, 7446, 1, 0, 0, 0, 7449, 7452,
		1, 0, 0, 0, 7450, 7448, 1, 0, 0, 0, 7450, 7451, 1, 0, 0, 0, 7451, 7454,
		1, 0, 0, 0, 7452, 7450, 1, 0, 0, 0, 7453, 7441, 1, 0, 0, 0, 7453, 7454,
		1, 0, 0, 0, 7454, 7465, 1, 0, 0, 0, 7455, 7456, 5, 298, 0, 0, 7456, 7457,
		5, 55, 0, 0, 7457, 7462, 3, 768, 384, 0, 7458, 7459, 5, 3, 0, 0, 7459,
		7461, 3, 768, 384, 0, 7460, 7458, 1, 0, 0, 0, 7461, 7464, 1, 0, 0, 0, 7462,
		7460, 1, 0, 0, 0, 7462, 7463, 1, 0, 0, 0, 7463, 7466, 1, 0, 0, 0, 7464,
		7462, 1, 0, 0, 0, 7465, 7455, 1, 0, 0, 0, 7465, 7466, 1, 0, 0, 0, 7466,
		7468, 1, 0, 0, 0, 7467, 7469, 3, 892, 446, 0, 7468, 7467, 1, 0, 0, 0, 7468,
		7469, 1, 0, 0, 0, 7469, 7470, 1, 0, 0, 0, 7470, 7471, 5, 4, 0, 0, 7471,
		889, 1, 0, 0, 0, 7472, 7473, 5, 200, 0, 0, 7473, 7474, 5, 283, 0, 0, 7474,
		891, 1, 0, 0, 0, 7475, 7476, 5, 343, 0, 0, 7476, 7492, 3, 894, 447, 0,
		7477, 7478, 5, 379, 0, 0, 7478, 7492, 3, 894, 447, 0, 7479, 7480, 5, 343,
		0, 0, 7480, 7481, 5, 41, 0, 0, 7481, 7482, 3, 894, 447, 0, 7482, 7483,
		5, 21, 0, 0, 7483, 7484, 3, 894, 447, 0, 7484, 7492, 1, 0, 0, 0, 7485,
		7486, 5, 379, 0, 0, 7486, 7487, 5, 41, 0, 0, 7487, 7488, 3, 894, 447, 0,
		7488, 7489, 5, 21, 0, 0, 7489, 7490, 3, 894, 447, 0, 7490, 7492, 1, 0,
		0, 0, 7491, 7475, 1, 0, 0, 0, 7491, 7477, 1, 0, 0, 0, 7491, 7479, 1, 0,
		0, 0, 7491, 7485, 1, 0, 0, 0, 7492, 893, 1, 0, 0, 0, 7493, 7494, 5, 449,
		0, 0, 7494, 7503, 5, 320, 0, 0, 7495, 7496, 5, 449, 0, 0, 7496, 7503, 5,
		166, 0, 0, 7497, 7498, 5, 95, 0, 0, 7498, 7503, 5, 378, 0, 0, 7499, 7500,
		3, 850, 425, 0, 7500, 7501, 7, 46, 0, 0, 7501, 7503, 1, 0, 0, 0, 7502,
		7493, 1, 0, 0, 0, 7502, 7495, 1, 0, 0, 0, 7502, 7497, 1, 0, 0, 0, 7502,
		7499, 1, 0, 0, 0, 7503, 895, 1, 0, 0, 0, 7504, 7544, 3, 900, 450, 0, 7505,
		7506, 5, 18, 0, 0, 7506, 7514, 7, 47, 0, 0, 7507, 7508, 7, 47, 0, 0, 7508,
		7511, 3, 1010, 505, 0, 7509, 7510, 5, 27, 0, 0, 7510, 7512, 3, 1016, 508,
		0, 7511, 7509, 1, 0, 0, 0, 7511, 7512, 1, 0, 0, 0, 7512, 7514, 1, 0, 0,
		0, 7513, 7505, 1, 0, 0, 0, 7513, 7507, 1, 0, 0, 0, 7514, 7544, 1, 0, 0,
		0, 7515, 7516, 5, 18, 0, 0, 7516, 7520, 7, 48, 0, 0, 7517, 7518, 7, 48,
		0, 0, 7518, 7520, 3, 900, 450, 0, 7519, 7515, 1, 0, 0, 0, 7519, 7517, 1,
		0, 0, 0, 7520, 7544, 1, 0, 0, 0, 7521, 7522, 5, 18, 0, 0, 7522, 7523, 5,
		257, 0, 0, 7523, 7532, 7, 49, 0, 0, 7524, 7525, 5, 257, 0, 0, 7525, 7526,
		7, 49, 0, 0, 7526, 7529, 3, 1010, 505, 0, 7527, 7528, 5, 27, 0, 0, 7528,
		7530, 3, 1016, 508, 0, 7529, 7527, 1, 0, 0, 0, 7529, 7530, 1, 0, 0, 0,
		7530, 7532, 1, 0, 0, 0, 7531, 7521, 1, 0, 0, 0, 7531, 7524, 1, 0, 0, 0,
		7532, 7544, 1, 0, 0, 0, 7533, 7534, 5, 18, 0, 0, 7534, 7542, 7, 49, 0,
		0, 7535, 7536, 7, 49, 0, 0, 7536, 7539, 3, 1010, 505, 0, 7537, 7538, 5,
		27, 0, 0, 7538, 7540, 3, 1016, 508, 0, 7539, 7537, 1, 0, 0, 0, 7539, 7540,
		1, 0, 0, 0, 7540, 7542, 1, 0, 0, 0, 7541, 7533, 1, 0, 0, 0, 7541, 7535,
		1, 0, 0, 0, 7542, 7544, 1, 0, 0, 0, 7543, 7504, 1, 0, 0, 0, 7543, 7513,
		1, 0, 0, 0, 7543, 7519, 1, 0, 0, 0, 7543, 7531, 1, 0, 0, 0, 7543, 7541,
		1, 0, 0, 0, 7544, 897, 1, 0, 0, 0, 7545, 7547, 3, 1010, 505, 0, 7546, 7548,
		3, 824, 412, 0, 7547, 7546, 1, 0, 0, 0, 7547, 7548, 1, 0, 0, 0, 7548, 899,
		1, 0, 0, 0, 7549, 7551, 3, 1010, 505, 0, 7550, 7552, 3, 824, 412, 0, 7551,
		7550, 1, 0, 0, 0, 7551, 7552, 1, 0, 0, 0, 7552, 7555, 1, 0, 0, 0, 7553,
		7554, 5, 27, 0, 0, 7554, 7556, 3, 1016, 508, 0, 7555, 7553, 1, 0, 0, 0,
		7555, 7556, 1, 0, 0, 0, 7556, 901, 1, 0, 0, 0, 7557, 7559, 7, 50, 0, 0,
		7558, 7560, 7, 51, 0, 0, 7559, 7558, 1, 0, 0, 0, 7559, 7560, 1, 0, 0, 0,
		7560, 903, 1, 0, 0, 0, 7561, 7562, 5, 442, 0, 0, 7562, 7564, 7, 52, 0,
		0, 7563, 7565, 3, 1016, 508, 0, 7564, 7563, 1, 0, 0, 0, 7564, 7565, 1,
		0, 0, 0, 7565, 905, 1, 0, 0, 0, 7566, 7569, 3, 1016, 508, 0, 7567, 7569,
		3, 868, 434, 0, 7568, 7566, 1, 0, 0, 0, 7568, 7567, 1, 0, 0, 0, 7569, 907,
		1, 0, 0, 0, 7570, 7571, 5, 303, 0, 0, 7571, 7572, 5, 55, 0, 0, 7572, 7573,
		5, 343, 0, 0, 7573, 7574, 3, 1022, 511, 0, 7574, 7583, 5, 2, 0, 0, 7575,
		7580, 3, 928, 464, 0, 7576, 7577, 5, 3, 0, 0, 7577, 7579, 3, 928, 464,
		0, 7578, 7576, 1, 0, 0, 0, 7579, 7582, 1, 0, 0, 0, 7580, 7578, 1, 0, 0,
		0, 7580, 7581, 1, 0, 0, 0, 7581, 7584, 1, 0, 0, 0, 7582, 7580, 1, 0, 0,
		0, 7583, 7575, 1, 0, 0, 0, 7583, 7584, 1, 0, 0, 0, 7584, 7585, 1, 0, 0,
		0, 7585, 7586, 5, 4, 0, 0, 7586, 7659, 1, 0, 0, 0, 7587, 7588, 5, 303,
		0, 0, 7588, 7589, 5, 55, 0, 0, 7589, 7590, 5, 343, 0, 0, 7590, 7591, 3,
		864, 432, 0, 7591, 7600, 5, 2, 0, 0, 7592, 7597, 3, 928, 464, 0, 7593,
		7594, 5, 3, 0, 0, 7594, 7596, 3, 928, 464, 0, 7595, 7593, 1, 0, 0, 0, 7596,
		7599, 1, 0, 0, 0, 7597, 7595, 1, 0, 0, 0, 7597, 7598, 1, 0, 0, 0, 7598,
		7601, 1, 0, 0, 0, 7599, 7597, 1, 0, 0, 0, 7600, 7592, 1, 0, 0, 0, 7600,
		7601, 1, 0, 0, 0, 7601, 7602, 1, 0, 0, 0, 7602, 7603, 5, 4, 0, 0, 7603,
		7659, 1, 0, 0, 0, 7604, 7605, 5, 303, 0, 0, 7605, 7607, 5, 55, 0, 0, 7606,
		7608, 5, 242, 0, 0, 7607, 7606, 1, 0, 0, 0, 7607, 7608, 1, 0, 0, 0, 7608,
		7609, 1, 0, 0, 0, 7609, 7610, 3, 1022, 511, 0, 7610, 7619, 5, 2, 0, 0,
		7611, 7616, 3, 910, 455, 0, 7612, 7613, 5, 3, 0, 0, 7613, 7615, 3, 910,
		455, 0, 7614, 7612, 1, 0, 0, 0, 7615, 7618, 1, 0, 0, 0, 7616, 7614, 1,
		0, 0, 0, 7616, 7617, 1, 0, 0, 0, 7617, 7620, 1, 0, 0, 0, 7618, 7616, 1,
		0, 0, 0, 7619, 7611, 1, 0, 0, 0, 7619, 7620, 1, 0, 0, 0, 7620, 7621, 1,
		0, 0, 0, 7621, 7622, 5, 4, 0, 0, 7622, 7659, 1, 0, 0, 0, 7623, 7624, 5,
		303, 0, 0, 7624, 7626, 5, 55, 0, 0, 7625, 7627, 5, 242, 0, 0, 7626, 7625,
		1, 0, 0, 0, 7626, 7627, 1, 0, 0, 0, 7627, 7628, 1, 0, 0, 0, 7628, 7659,
		3, 1022, 511, 0, 7629, 7630, 5, 303, 0, 0, 7630, 7631, 5, 55, 0, 0, 7631,
		7632, 3, 868, 434, 0, 7632, 7641, 5, 2, 0, 0, 7633, 7638, 3, 928, 464,
		0, 7634, 7635, 5, 3, 0, 0, 7635, 7637, 3, 928, 464, 0, 7636, 7634, 1, 0,
		0, 0, 7637, 7640, 1, 0, 0, 0, 7638, 7636, 1, 0, 0, 0, 7638, 7639, 1, 0,
		0, 0, 7639, 7642, 1, 0, 0, 0, 7640, 7638, 1, 0, 0, 0, 7641, 7633, 1, 0,
		0, 0, 7641, 7642, 1, 0, 0, 0, 7642, 7643, 1, 0, 0, 0, 7643, 7644, 5, 4,
		0, 0, 7644, 7659, 1, 0, 0, 0, 7645, 7646, 5, 303, 0, 0, 7646, 7647, 5,
		55, 0, 0, 7647, 7659, 3, 868, 434, 0, 7648, 7649, 5, 303, 0, 0, 7649, 7650,
		5, 55, 0, 0, 7650, 7655, 3, 906, 453, 0, 7651, 7652, 5, 3, 0, 0, 7652,
		7654, 3, 906, 453, 0, 7653, 7651, 1, 0, 0, 0, 7654, 7657, 1, 0, 0, 0, 7655,
		7653, 1, 0, 0, 0, 7655, 7656, 1, 0, 0, 0, 7656, 7659, 1, 0, 0, 0, 7657,
		7655, 1, 0, 0, 0, 7658, 7570, 1, 0, 0, 0, 7658, 7587, 1, 0, 0, 0, 7658,
		7604, 1, 0, 0, 0, 7658, 7623, 1, 0, 0, 0, 7658, 7629, 1, 0, 0, 0, 7658,
		7645, 1, 0, 0, 0, 7658, 7648, 1, 0, 0, 0, 7659, 909, 1, 0, 0, 0, 7660,
		7663, 3, 912, 456, 0, 7661, 7663, 3, 914, 457, 0, 7662, 7660, 1, 0, 0,
		0, 7662, 7661, 1, 0, 0, 0, 7663, 911, 1, 0, 0, 0, 7664, 7668, 5, 303, 0,
		0, 7665, 7666, 5, 197, 0, 0, 7666, 7667, 5, 281, 0, 0, 7667, 7669, 5, 148,
		0, 0, 7668, 7665, 1, 0, 0, 0, 7668, 7669, 1, 0, 0, 0, 7669, 7670, 1, 0,
		0, 0, 7670, 7671, 3, 1016, 508, 0, 7671, 7672, 5, 463, 0, 0, 7672, 7673,
		5, 202, 0, 0, 7673, 7675, 3, 918, 459, 0, 7674, 7676, 3, 956, 478, 0, 7675,
		7674, 1, 0, 0, 0, 7675, 7676, 1, 0, 0, 0, 7676, 913, 1, 0, 0, 0, 7677,
		7681, 5, 303, 0, 0, 7678, 7679, 5, 197, 0, 0, 7679, 7680, 5, 281, 0, 0,
		7680, 7682, 5, 148, 0, 0, 7681, 7678, 1, 0, 0, 0, 7681, 7682, 1, 0, 0,
		0, 7682, 7683, 1, 0, 0, 0, 7683, 7684, 3, 1016, 508, 0, 7684, 7685, 5,
		463, 0, 0, 7685, 7686, 5, 202, 0, 0, 7686, 7688, 3, 916, 458, 0, 7687,
		7689, 3, 956, 478, 0, 7688, 7687, 1, 0, 0, 0, 7688, 7689, 1, 0, 0, 0, 7689,
		915, 1, 0, 0, 0, 7690, 7691, 5, 2, 0, 0, 7691, 7696, 3, 918, 459, 0, 7692,
		7693, 5, 3, 0, 0, 7693, 7695, 3, 918, 459, 0, 7694, 7692, 1, 0, 0, 0, 7695,
		7698, 1, 0, 0, 0, 7696, 7694, 1, 0, 0, 0, 7696, 7697, 1, 0, 0, 0, 7697,
		7699, 1, 0, 0, 0, 7698, 7696, 1, 0, 0, 0, 7699, 7700, 5, 4, 0, 0, 7700,
		917, 1, 0, 0, 0, 7701, 7702, 5, 2, 0, 0, 7702, 7707, 3, 922, 461, 0, 7703,
		7704, 5, 3, 0, 0, 7704, 7706, 3, 922, 461, 0, 7705, 7703, 1, 0, 0, 0, 7706,
		7709, 1, 0, 0, 0, 7707, 7705, 1, 0, 0, 0, 7707, 7708, 1, 0, 0, 0, 7708,
		7710, 1, 0, 0, 0, 7709, 7707, 1, 0, 0, 0, 7710, 7711, 5, 4, 0, 0, 7711,
		919, 1, 0, 0, 0, 7712, 7715, 3, 918, 459, 0, 7713, 7715, 3, 916, 458, 0,
		7714, 7712, 1, 0, 0, 0, 7714, 7713, 1, 0, 0, 0, 7715, 921, 1, 0, 0, 0,
		7716, 7719, 5, 282, 0, 0, 7717, 7719, 3, 974, 487, 0, 7718, 7716, 1, 0,
		0, 0, 7718, 7717, 1, 0, 0, 0, 7719, 923, 1, 0, 0, 0, 7720, 7721, 5, 2,
		0, 0, 7721, 7726, 3, 974, 487, 0, 7722, 7723, 5, 3, 0, 0, 7723, 7725, 3,
		974, 487, 0, 7724, 7722, 1, 0, 0, 0, 7725, 7728, 1, 0, 0, 0, 7726, 7724,
		1, 0, 0, 0, 7726, 7727, 1, 0, 0, 0, 7727, 7729, 1, 0, 0, 0, 7728, 7726,
		1, 0, 0, 0, 7729, 7730, 5, 4, 0, 0, 7730, 925, 1, 0, 0, 0, 7731, 7732,
		5, 2, 0, 0, 7732, 7737, 3, 866, 433, 0, 7733, 7734, 5, 3, 0, 0, 7734, 7736,
		3, 866, 433, 0, 7735, 7733, 1, 0, 0, 0, 7736, 7739, 1, 0, 0, 0, 7737, 7735,
		1, 0, 0, 0, 7737, 7738, 1, 0, 0, 0, 7738, 7740, 1, 0, 0, 0, 7739, 7737,
		1, 0, 0, 0, 7740, 7741, 5, 4, 0, 0, 7741, 927, 1, 0, 0, 0, 7742, 7745,
		3, 930, 465, 0, 7743, 7745, 3, 932, 466, 0, 7744, 7742, 1, 0, 0, 0, 7744,
		7743, 1, 0, 0, 0, 7745, 929, 1, 0, 0, 0, 7746, 7750, 5, 303, 0, 0, 7747,
		7748, 5, 197, 0, 0, 7748, 7749, 5, 281, 0, 0, 7749, 7751, 5, 148, 0, 0,
		7750, 7747, 1, 0, 0, 0, 7750, 7751, 1, 0, 0, 0, 7751, 7752, 1, 0, 0, 0,
		7752, 7753, 3, 1016, 508, 0, 7753, 7754, 5, 463, 0, 0, 7754, 7756, 3, 936,
		468, 0, 7755, 7757, 3, 956, 478, 0, 7756, 7755, 1, 0, 0, 0, 7756, 7757,
		1, 0, 0, 0, 7757, 931, 1, 0, 0, 0, 7758, 7759, 5, 407, 0, 0, 7759, 7760,
		5, 2, 0, 0, 7760, 7761, 3, 974, 487, 0, 7761, 7762, 5, 4, 0, 0, 7762, 7763,
		5, 139, 0, 0, 7763, 7764, 5, 2, 0, 0, 7764, 7765, 3, 974, 487, 0, 7765,
		7766, 5, 4, 0, 0, 7766, 7767, 5, 153, 0, 0, 7767, 7768, 5, 2, 0, 0, 7768,
		7769, 3, 982, 491, 0, 7769, 7770, 5, 4, 0, 0, 7770, 7785, 1, 0, 0, 0, 7771,
		7772, 5, 407, 0, 0, 7772, 7773, 5, 2, 0, 0, 7773, 7774, 3, 974, 487, 0,
		7774, 7775, 5, 4, 0, 0, 7775, 7776, 5, 139, 0, 0, 7776, 7777, 5, 2, 0,
		0, 7777, 7778, 3, 974, 487, 0, 7778, 7779, 5, 4, 0, 0, 7779, 7780, 5, 153,
		0, 0, 7780, 7781, 5, 2, 0, 0, 7781, 7782, 5, 519, 0, 0, 7782, 7783, 5,
		4, 0, 0, 7783, 7785, 1, 0, 0, 0, 7784, 7758, 1, 0, 0, 0, 7784, 7771, 1,
		0, 0, 0, 7785, 933, 1, 0, 0, 0, 7786, 7787, 5, 407, 0, 0, 7787, 7788, 5,
		2, 0, 0, 7788, 7789, 3, 974, 487, 0, 7789, 7790, 5, 4, 0, 0, 7790, 7791,
		5, 139, 0, 0, 7791, 7792, 5, 2, 0, 0, 7792, 7793, 3, 974, 487, 0, 7793,
		7794, 5, 4, 0, 0, 7794, 935, 1, 0, 0, 0, 7795, 7796, 5, 238, 0, 0, 7796,
		7799, 5, 431, 0, 0, 7797, 7800, 5, 259, 0, 0, 7798, 7800, 3, 938, 469,
		0, 7799, 7797, 1, 0, 0, 0, 7799, 7798, 1, 0, 0, 0, 7800, 7808, 1, 0, 0,
		0, 7801, 7802, 5, 6, 0, 0, 7802, 7803, 3, 938, 469, 0, 7803, 7804, 5, 3,
		0, 0, 7804, 7805, 3, 938, 469, 0, 7805, 7806, 5, 4, 0, 0, 7806, 7808, 1,
		0, 0, 0, 7807, 7795, 1, 0, 0, 0, 7807, 7801, 1, 0, 0, 0, 7808, 937, 1,
		0, 0, 0, 7809, 7810, 5, 2, 0, 0, 7810, 7815, 3, 942, 471, 0, 7811, 7812,
		5, 3, 0, 0, 7812, 7814, 3, 942, 471, 0, 7813, 7811, 1, 0, 0, 0, 7814, 7817,
		1, 0, 0, 0, 7815, 7813, 1, 0, 0, 0, 7815, 7816, 1, 0, 0, 0, 7816, 7818,
		1, 0, 0, 0, 7817, 7815, 1, 0, 0, 0, 7818, 7819, 5, 4, 0, 0, 7819, 939,
		1, 0, 0, 0, 7820, 7821, 3, 1016, 508, 0, 7821, 7822, 5, 493, 0, 0, 7822,
		7823, 3, 866, 433, 0, 7823, 941, 1, 0, 0, 0, 7824, 7827, 5, 259, 0, 0,
		7825, 7827, 3, 974, 487, 0, 7826, 7824, 1, 0, 0, 0, 7826, 7825, 1, 0, 0,
		0, 7827, 943, 1, 0, 0, 0, 7828, 7829, 5, 129, 0, 0, 7829, 7830, 5, 55,
		0, 0, 7830, 7831, 5, 186, 0, 0, 7831, 7834, 3, 1022, 511, 0, 7832, 7833,
		5, 53, 0, 0, 7833, 7835, 5, 519, 0, 0, 7834, 7832, 1, 0, 0, 0, 7834, 7835,
		1, 0, 0, 0, 7835, 7841, 1, 0, 0, 0, 7836, 7837, 5, 129, 0, 0, 7837, 7838,
		5, 55, 0, 0, 7838, 7839, 5, 186, 0, 0, 7839, 7841, 3, 1022, 511, 0, 7840,
		7828, 1, 0, 0, 0, 7840, 7836, 1, 0, 0, 0, 7841, 945, 1, 0, 0, 0, 7842,
		7843, 5, 129, 0, 0, 7843, 7844, 5, 55, 0, 0, 7844, 7845, 5, 186, 0, 0,
		7845, 7848, 3, 1022, 511, 0, 7846, 7847, 5, 53, 0, 0, 7847, 7849, 5, 519,
		0, 0, 7848, 7846, 1, 0, 0, 0, 7848, 7849, 1, 0, 0, 0, 7849, 7862, 1, 0,
		0, 0, 7850, 7851, 5, 129, 0, 0, 7851, 7852, 5, 55, 0, 0, 7852, 7853, 5,
		186, 0, 0, 7853, 7862, 3, 1022, 511, 0, 7854, 7855, 5, 129, 0, 0, 7855,
		7856, 5, 55, 0, 0, 7856, 7859, 5, 342, 0, 0, 7857, 7858, 5, 53, 0, 0, 7858,
		7860, 5, 519, 0, 0, 7859, 7857, 1, 0, 0, 0, 7859, 7860, 1, 0, 0, 0, 7860,
		7862, 1, 0, 0, 0, 7861, 7842, 1, 0, 0, 0, 7861, 7850, 1, 0, 0, 0, 7861,
		7854, 1, 0, 0, 0, 7862, 947, 1, 0, 0, 0, 7863, 7865, 5, 348, 0, 0, 7864,
		7866, 7, 53, 0, 0, 7865, 7864, 1, 0, 0, 0, 7865, 7866, 1, 0, 0, 0, 7866,
		7883, 1, 0, 0, 0, 7867, 7884, 5, 29, 0, 0, 7868, 7874, 5, 29, 0, 0, 7869,
		7870, 5, 407, 0, 0, 7870, 7871, 5, 2, 0, 0, 7871, 7872, 3, 974, 487, 0,
		7872, 7873, 5, 4, 0, 0, 7873, 7875, 1, 0, 0, 0, 7874, 7869, 1, 0, 0, 0,
		7874, 7875, 1, 0, 0, 0, 7875, 7876, 1, 0, 0, 0, 7876, 7877, 5, 153, 0,
		0, 7877, 7878, 5, 2, 0, 0, 7878, 7879, 3, 982, 491, 0, 7879, 7880, 5, 4,
		0, 0, 7880, 7884, 1, 0, 0, 0, 7881, 7884, 5, 204, 0, 0, 7882, 7884, 5,
		251, 0, 0, 7883, 7867, 1, 0, 0, 0, 7883, 7868, 1, 0, 0, 0, 7883, 7881,
		1, 0, 0, 0, 7883, 7882, 1, 0, 0, 0, 7884, 949, 1, 0, 0, 0, 7885, 7886,
		7, 54, 0, 0, 7886, 951, 1, 0, 0, 0, 7887, 7888, 5, 332, 0, 0, 7888, 7889,
		5, 2, 0, 0, 7889, 7894, 3, 960, 480, 0, 7890, 7891, 5, 3, 0, 0, 7891, 7893,
		3, 960, 480, 0, 7892, 7890, 1, 0, 0, 0, 7893, 7896, 1, 0, 0, 0, 7894, 7892,
		1, 0, 0, 0, 7894, 7895, 1, 0, 0, 0, 7895, 7897, 1, 0, 0, 0, 7896, 7894,
		1, 0, 0, 0, 7897, 7898, 5, 4, 0, 0, 7898, 953, 1, 0, 0, 0, 7899, 7900,
		5, 52, 0, 0, 7900, 7901, 3, 952, 476, 0, 7901, 955, 1, 0, 0, 0, 7902, 7903,
		5, 2, 0, 0, 7903, 7908, 3, 960, 480, 0, 7904, 7905, 5, 3, 0, 0, 7905, 7907,
		3, 960, 480, 0, 7906, 7904, 1, 0, 0, 0, 7907, 7910, 1, 0, 0, 0, 7908, 7906,
		1, 0, 0, 0, 7908, 7909, 1, 0, 0, 0, 7909, 7911, 1, 0, 0, 0, 7910, 7908,
		1, 0, 0, 0, 7911, 7912, 5, 4, 0, 0, 7912, 957, 1, 0, 0, 0, 7913, 7918,
		3, 960, 480, 0, 7914, 7915, 5, 3, 0, 0, 7915, 7917, 3, 960, 480, 0, 7916,
		7914, 1, 0, 0, 0, 7917, 7920, 1, 0, 0, 0, 7918, 7916, 1, 0, 0, 0, 7918,
		7919, 1, 0, 0, 0, 7919, 959, 1, 0, 0, 0, 7920, 7918, 1, 0, 0, 0, 7921,
		7922, 3, 974, 487, 0, 7922, 7923, 5, 493, 0, 0, 7923, 7924, 3, 974, 487,
		0, 7924, 961, 1, 0, 0, 0, 7925, 7929, 3, 964, 482, 0, 7926, 7928, 3, 964,
		482, 0, 7927, 7926, 1, 0, 0, 0, 7928, 7931, 1, 0, 0, 0, 7929, 7927, 1,
		0, 0, 0, 7929, 7930, 1, 0, 0, 0, 7930, 963, 1, 0, 0, 0, 7931, 7929, 1,
		0, 0, 0, 7932, 7933, 3, 1016, 508, 0, 7933, 7934, 5, 493, 0, 0, 7934, 7935,
		3, 974, 487, 0, 7935, 965, 1, 0, 0, 0, 7936, 7937, 7, 55, 0, 0, 7937, 967,
		1, 0, 0, 0, 7938, 7939, 5, 78, 0, 0, 7939, 7940, 3, 974, 487, 0, 7940,
		969, 1, 0, 0, 0, 7941, 7942, 5, 218, 0, 0, 7942, 7943, 5, 300, 0, 0, 7943,
		7945, 3, 974, 487, 0, 7944, 7946, 3, 972, 486, 0, 7945, 7944, 1, 0, 0,
		0, 7945, 7946, 1, 0, 0, 0, 7946, 7948, 1, 0, 0, 0, 7947, 7949, 3, 952,
		476, 0, 7948, 7947, 1, 0, 0, 0, 7948, 7949, 1, 0, 0, 0, 7949, 971, 1, 0,
		0, 0, 7950, 7951, 5, 170, 0, 0, 7951, 7954, 5, 27, 0, 0, 7952, 7955, 3,
		1016, 508, 0, 7953, 7955, 3, 974, 487, 0, 7954, 7952, 1, 0, 0, 0, 7954,
		7953, 1, 0, 0, 0, 7955, 973, 1, 0, 0, 0, 7956, 7957, 7, 56, 0, 0, 7957,
		975, 1, 0, 0, 0, 7958, 7959, 7, 57, 0, 0, 7959, 977, 1, 0, 0, 0, 7960,
		7961, 7, 58, 0, 0, 7961, 979, 1, 0, 0, 0, 7962, 7963, 7, 59, 0, 0, 7963,
		981, 1, 0, 0, 0, 7964, 7965, 5, 217, 0, 0, 7965, 7966, 3, 850, 425, 0,
		7966, 7967, 3, 988, 494, 0, 7967, 983, 1, 0, 0, 0, 7968, 7969, 5, 217,
		0, 0, 7969, 7970, 3, 850, 425, 0, 7970, 7971, 3, 986, 493, 0, 7971, 985,
		1, 0, 0, 0, 7972, 7973, 7, 60, 0, 0, 7973, 987, 1, 0, 0, 0, 7974, 7975,
		7, 61, 0, 0, 7975, 989, 1, 0, 0, 0, 7976, 7977, 7, 62, 0, 0, 7977, 991,
		1, 0, 0, 0, 7978, 7984, 3, 1006, 503, 0, 7979, 7984, 3, 1008, 504, 0, 7980,
		7984, 3, 994, 497, 0, 7981, 7984, 3, 1002, 501, 0, 7982, 7984, 3, 996,
		498, 0, 7983, 7978, 1, 0, 0, 0, 7983, 7979, 1, 0, 0, 0, 7983, 7980, 1,
		0, 0, 0, 7983, 7981, 1, 0, 0, 0, 7983, 7982, 1, 0, 0, 0, 7984, 993, 1,
		0, 0, 0, 7985, 7986, 5, 24, 0, 0, 7986, 7987, 5, 495, 0, 0, 7987, 7988,
		3, 992, 496, 0, 7988, 7989, 5, 497, 0, 0, 7989, 995, 1, 0, 0, 0, 7990,
		7991, 5, 252, 0, 0, 7991, 7992, 5, 495, 0, 0, 7992, 7993, 3, 992, 496,
		0, 7993, 7994, 5, 3, 0, 0, 7994, 7995, 3, 992, 496, 0, 7995, 7996, 5, 497,
		0, 0, 7996, 997, 1, 0, 0, 0, 7997, 8000, 3, 1016, 508, 0, 7998, 8000, 3,
		302, 151, 0, 7999, 7997, 1, 0, 0, 0, 7999, 7998, 1, 0, 0, 0, 8000, 8001,
		1, 0, 0, 0, 8001, 8002, 3, 992, 496, 0, 8002, 999, 1, 0, 0, 0, 8003, 8008,
		3, 998, 499, 0, 8004, 8005, 5, 3, 0, 0, 8005, 8007, 3, 998, 499, 0, 8006,
		8004, 1, 0, 0, 0, 8007, 8010, 1, 0, 0, 0, 8008, 8006, 1, 0, 0, 0, 8008,
		8009, 1, 0, 0, 0, 8009, 1001, 1, 0, 0, 0, 8010, 8008, 1, 0, 0, 0, 8011,
		8012, 5, 422, 0, 0, 8012, 8013, 5, 495, 0, 0, 8013, 8014, 3, 1000, 500,
		0, 8014, 8015, 5, 497, 0, 0, 8015, 1003, 1, 0, 0, 0, 8016, 8017, 5, 2,
		0, 0, 8017, 8018, 5, 519, 0, 0, 8018, 8019, 5, 4, 0, 0, 8019, 1005, 1,
		0, 0, 0, 8020, 8089, 5, 49, 0, 0, 8021, 8023, 5, 438, 0, 0, 8022, 8024,
		3, 1004, 502, 0, 8023, 8022, 1, 0, 0, 0, 8023, 8024, 1, 0, 0, 0, 8024,
		8089, 1, 0, 0, 0, 8025, 8027, 5, 402, 0, 0, 8026, 8028, 3, 1004, 502, 0,
		8027, 8026, 1, 0, 0, 0, 8027, 8028, 1, 0, 0, 0, 8028, 8089, 1, 0, 0, 0,
		8029, 8031, 5, 399, 0, 0, 8030, 8032, 5, 211, 0, 0, 8031, 8030, 1, 0, 0,
		0, 8031, 8032, 1, 0, 0, 0, 8032, 8089, 1, 0, 0, 0, 8033, 8035, 5, 399,
		0, 0, 8034, 8036, 5, 212, 0, 0, 8035, 8034, 1, 0, 0, 0, 8035, 8036, 1,
		0, 0, 0, 8036, 8089, 1, 0, 0, 0, 8037, 8039, 5, 455, 0, 0, 8038, 8040,
		5, 211, 0, 0, 8039, 8038, 1, 0, 0, 0, 8039, 8040, 1, 0, 0, 0, 8040, 8089,
		1, 0, 0, 0, 8041, 8043, 5, 455, 0, 0, 8042, 8044, 5, 212, 0, 0, 8043, 8042,
		1, 0, 0, 0, 8043, 8044, 1, 0, 0, 0, 8044, 8089, 1, 0, 0, 0, 8045, 8047,
		5, 211, 0, 0, 8046, 8048, 3, 1004, 502, 0, 8047, 8046, 1, 0, 0, 0, 8047,
		8048, 1, 0, 0, 0, 8048, 8089, 1, 0, 0, 0, 8049, 8051, 5, 212, 0, 0, 8050,
		8052, 3, 1004, 502, 0, 8051, 8050, 1, 0, 0, 0, 8051, 8052, 1, 0, 0, 0,
		8052, 8089, 1, 0, 0, 0, 8053, 8055, 5, 42, 0, 0, 8054, 8056, 3, 1004, 502,
		0, 8055, 8054, 1, 0, 0, 0, 8055, 8056, 1, 0, 0, 0, 8056, 8089, 1, 0, 0,
		0, 8057, 8059, 5, 232, 0, 0, 8058, 8060, 3, 1004, 502, 0, 8059, 8058, 1,
		0, 0, 0, 8059, 8060, 1, 0, 0, 0, 8060, 8089, 1, 0, 0, 0, 8061, 8089, 5,
		163, 0, 0, 8062, 8089, 5, 131, 0, 0, 8063, 8089, 5, 106, 0, 0, 8064, 8089,
		5, 107, 0, 0, 8065, 8089, 5, 433, 0, 0, 8066, 8068, 5, 64, 0, 0, 8067,
		8069, 3, 1004, 502, 0, 8068, 8067, 1, 0, 0, 0, 8068, 8069, 1, 0, 0, 0,
		8069, 8089, 1, 0, 0, 0, 8070, 8072, 5, 465, 0, 0, 8071, 8073, 3, 1004,
		502, 0, 8072, 8071, 1, 0, 0, 0, 8072, 8073, 1, 0, 0, 0, 8073, 8089, 1,
		0, 0, 0, 8074, 8089, 5, 413, 0, 0, 8075, 8089, 5, 414, 0, 0, 8076, 8089,
		5, 44, 0, 0, 8077, 8089, 5, 190, 0, 0, 8078, 8089, 5, 310, 0, 0, 8079,
		8089, 5, 226, 0, 0, 8080, 8082, 5, 464, 0, 0, 8081, 8083, 3, 1004, 502,
		0, 8082, 8081, 1, 0, 0, 0, 8082, 8083, 1, 0, 0, 0, 8083, 8089, 1, 0, 0,
		0, 8084, 8086, 5, 43, 0, 0, 8085, 8087, 3, 1004, 502, 0, 8086, 8085, 1,
		0, 0, 0, 8086, 8087, 1, 0, 0, 0, 8087, 8089, 1, 0, 0, 0, 8088, 8020, 1,
		0, 0, 0, 8088, 8021, 1, 0, 0, 0, 8088, 8025, 1, 0, 0, 0, 8088, 8029, 1,
		0, 0, 0, 8088, 8033, 1, 0, 0, 0, 8088, 8037, 1, 0, 0, 0, 8088, 8041, 1,
		0, 0, 0, 8088, 8045, 1, 0, 0, 0, 8088, 8049, 1, 0, 0, 0, 8088, 8053, 1,
		0, 0, 0, 8088, 8057, 1, 0, 0, 0, 8088, 8061, 1, 0, 0, 0, 8088, 8062, 1,
		0, 0, 0, 8088, 8063, 1, 0, 0, 0, 8088, 8064, 1, 0, 0, 0, 8088, 8065, 1,
		0, 0, 0, 8088, 8066, 1, 0, 0, 0, 8088, 8070, 1, 0, 0, 0, 8088, 8074, 1,
		0, 0, 0, 8088, 8075, 1, 0, 0, 0, 8088, 8076, 1, 0, 0, 0, 8088, 8077, 1,
		0, 0, 0, 8088, 8078, 1, 0, 0, 0, 8088, 8079, 1, 0, 0, 0, 8088, 8080, 1,
		0, 0, 0, 8088, 8084, 1, 0, 0, 0, 8089, 1007, 1, 0, 0, 0, 8090, 8098, 7,
		63, 0, 0, 8091, 8092, 5, 2, 0, 0, 8092, 8095, 5, 519, 0, 0, 8093, 8094,
		5, 3, 0, 0, 8094, 8096, 5, 519, 0, 0, 8095, 8093, 1, 0, 0, 0, 8095, 8096,
		1, 0, 0, 0, 8096, 8097, 1, 0, 0, 0, 8097, 8099, 5, 4, 0, 0, 8098, 8091,
		1, 0, 0, 0, 8098, 8099, 1, 0, 0, 0, 8099, 1009, 1, 0, 0, 0, 8100, 8106,
		3, 1016, 508, 0, 8101, 8105, 5, 529, 0, 0, 8102, 8103, 5, 1, 0, 0, 8103,
		8105, 3, 1016, 508, 0, 8104, 8101, 1, 0, 0, 0, 8104, 8102, 1, 0, 0, 0,
		8105, 8108, 1, 0, 0, 0, 8106, 8104, 1, 0, 0, 0, 8106, 8107, 1, 0, 0, 0,
		8107, 1011, 1, 0, 0, 0, 8108, 8106, 1, 0, 0, 0, 8109, 8110, 3, 1010, 505,
		0, 8110, 1013, 1, 0, 0, 0, 8111, 8113, 5, 168, 0, 0, 8112, 8111, 1, 0,
		0, 0, 8112, 8113, 1, 0, 0, 0, 8113, 8114, 1, 0, 0, 0, 8114, 8115, 5, 469,
		0, 0, 8115, 8116, 5, 27, 0, 0, 8116, 8117, 5, 287, 0, 0, 8117, 8118, 3,
		1016, 508, 0, 8118, 1015, 1, 0, 0, 0, 8119, 8124, 5, 526, 0, 0, 8120, 8124,
		3, 1038, 519, 0, 8121, 8124, 5, 527, 0, 0, 8122, 8124, 5, 528, 0, 0, 8123,
		8119, 1, 0, 0, 0, 8123, 8120, 1, 0, 0, 0, 8123, 8121, 1, 0, 0, 0, 8123,
		8122, 1, 0, 0, 0, 8124, 1017, 1, 0, 0, 0, 8125, 8128, 3, 1016, 508, 0,
		8126, 8127, 5, 27, 0, 0, 8127, 8129, 3, 1016, 508, 0, 8128, 8126, 1, 0,
		0, 0, 8128, 8129, 1, 0, 0, 0, 8129, 1019, 1, 0, 0, 0, 8130, 8131, 5, 2,
		0, 0, 8131, 8136, 3, 1018, 509, 0, 8132, 8133, 5, 3, 0, 0, 8133, 8135,
		3, 1018, 509, 0, 8134, 8132, 1, 0, 0, 0, 8135, 8138, 1, 0, 0, 0, 8136,
		8134, 1, 0, 0, 0, 8136, 8137, 1, 0, 0, 0, 8137, 8139, 1, 0, 0, 0, 8138,
		8136, 1, 0, 0, 0, 8139, 8140, 5, 4, 0, 0, 8140, 1021, 1, 0, 0, 0, 8141,
		8142, 5, 2, 0, 0, 8142, 8147, 3, 1016, 508, 0, 8143, 8144, 5, 3, 0, 0,
		8144, 8146, 3, 1016, 508, 0, 8145, 8143, 1, 0, 0, 0, 8146, 8149, 1, 0,
		0, 0, 8147, 8145, 1, 0, 0, 0, 8147, 8148, 1, 0, 0, 0, 8148, 8150, 1, 0,
		0, 0, 8149, 8147, 1, 0, 0, 0, 8150, 8151, 5, 4, 0, 0, 8151, 1023, 1, 0,
		0, 0, 8152, 8155, 3, 1016, 508, 0, 8153, 8155, 3, 974, 487, 0, 8154, 8152,
		1, 0, 0, 0, 8154, 8153, 1, 0, 0, 0, 8155, 1025, 1, 0, 0, 0, 8156, 8161,
		3, 1024, 512, 0, 8157, 8158, 5, 3, 0, 0, 8158, 8160, 3, 1024, 512, 0, 8159,
		8157, 1, 0, 0, 0, 8160, 8163, 1, 0, 0, 0, 8161, 8159, 1, 0, 0, 0, 8161,
		8162, 1, 0, 0, 0, 8162, 1027, 1, 0, 0, 0, 8163, 8161, 1, 0, 0, 0, 8164,
		8168, 5, 503, 0, 0, 8165, 8168, 3, 1016, 508, 0, 8166, 8168, 3, 974, 487,
		0, 8167, 8164, 1, 0, 0, 0, 8167, 8165, 1, 0, 0, 0, 8167, 8166, 1, 0, 0,
		0, 8168, 1029, 1, 0, 0, 0, 8169, 8181, 3, 1024, 512, 0, 8170, 8171, 3,
		1024, 512, 0, 8171, 8172, 5, 518, 0, 0, 8172, 8173, 3, 1024, 512, 0, 8173,
		8181, 1, 0, 0, 0, 8174, 8175, 3, 1024, 512, 0, 8175, 8176, 5, 518, 0, 0,
		8176, 8177, 5, 6, 0, 0, 8177, 8178, 3, 1024, 512, 0, 8178, 8179, 5, 7,
		0, 0, 8179, 8181, 1, 0, 0, 0, 8180, 8169, 1, 0, 0, 0, 8180, 8170, 1, 0,
		0, 0, 8180, 8174, 1, 0, 0, 0, 8181, 1031, 1, 0, 0, 0, 8182, 8183, 3, 1016,
		508, 0, 8183, 8184, 5, 493, 0, 0, 8184, 8185, 3, 842, 421, 0, 8185, 1033,
		1, 0, 0, 0, 8186, 8191, 3, 1032, 516, 0, 8187, 8188, 5, 3, 0, 0, 8188,
		8190, 3, 1032, 516, 0, 8189, 8187, 1, 0, 0, 0, 8190, 8193, 1, 0, 0, 0,
		8191, 8189, 1, 0, 0, 0, 8191, 8192, 1, 0, 0, 0, 8192, 1035, 1, 0, 0, 0,
		8193, 8191, 1, 0, 0, 0, 8194, 8198, 5, 520, 0, 0, 8195, 8198, 5, 521, 0,
		0, 8196, 8198, 5, 519, 0, 0, 8197, 8194, 1, 0, 0, 0, 8197, 8195, 1, 0,
		0, 0, 8197, 8196, 1, 0, 0, 0, 8198, 1037, 1, 0, 0, 0, 8199, 8200, 7, 64,
		0, 0, 8200, 1039, 1, 0, 0, 0, 975, 1043, 1051, 1295, 1311, 1317, 1325,
		1327, 1345, 1352, 1357, 1361, 1364, 1367, 1373, 1378, 1382, 1405, 1413,
		1417, 1423, 1432, 1439, 1444, 1447, 1450, 1453, 1456, 1459, 1462, 1465,
		1468, 1471, 1475, 1478, 1481, 1484, 1487, 1492, 1495, 1505, 1517, 1527,
		1529, 1532, 1539, 1546, 1549, 1554, 1558, 1573, 1577, 1586, 1600, 1609,
		1617, 1620, 1623, 1634, 1639, 1643, 1649, 1658, 1665, 1673, 1676, 1680,
		1683, 1686, 1689, 1692, 1695, 1698, 1705, 1710, 1714, 1731, 1744, 1757,
		1760, 1770, 1772, 1775, 1788, 1793, 1799, 1806, 1812, 1820, 1826, 1834,
		1840, 1847, 1853, 1866, 1871, 1879, 1883, 1892, 1895, 1898, 1906, 1910,
		1919, 1922, 1925, 1927, 1932, 1936, 1940, 1946, 1950, 1953, 1956, 1968,
		1978, 1984, 1994, 1998, 2006, 2010, 2017, 2026, 2029, 2032, 2043, 2049,
		2058, 2063, 2066, 2070, 2084, 2089, 2113, 2117, 2123, 2129, 2134, 2139,
		2146, 2150, 2156, 2164, 2177, 2186, 2193, 2198, 2201, 2206, 2219, 2224,
		2233, 2240, 2246, 2253, 2265, 2273, 2282, 2284, 2287, 2292, 2297, 2305,
		2316, 2330, 2339, 2348, 2352, 2359, 2367, 2385, 2394, 2397, 2401, 2414,
		2435, 2448, 2452, 2465, 2473, 2486, 2492, 2495, 2510, 2517, 2530, 2535,
		2565, 2567, 2573, 2575, 2581, 2586, 2599, 2604, 2610, 2619, 2632, 2683,
		2707, 2715, 2717, 2726, 2734, 2736, 2739, 2748, 2764, 2774, 2782, 2784,
		2794, 2802, 2804, 2814, 2825, 2832, 2839, 2856, 2871, 2885, 2900, 2913,
		2915, 2918, 2944, 2947, 2950, 2953, 2956, 2959, 2967, 2971, 2974, 2984,
		2990, 2993, 3000, 3003, 3011, 3015, 3018, 3031, 3034, 3042, 3047, 3051,
		3057, 3059, 3071, 3074, 3083, 3087, 3099, 3104, 3108, 3120, 3125, 3131,
		3139, 3150, 3153, 3159, 3162, 3165, 3181, 3203, 3217, 3222, 3225, 3228,
		3232, 3236, 3239, 3242, 3244, 3248, 3253, 3259, 3262, 3265, 3269, 3274,
		3278, 3282, 3287, 3292, 3299, 3301, 3313, 3320, 3327, 3335, 3341, 3344,
		3351, 3356, 3360, 3369, 3372, 3378, 3383, 3386, 3389, 3398, 3401, 3404,
		3410, 3414, 3418, 3426, 3436, 3439, 3442, 3447, 3456, 3464, 3467, 3470,
		3473, 3485, 3503, 3508, 3512, 3528, 3539, 3550, 3556, 3564, 3567, 3571,
		3575, 3584, 3587, 3590, 3598, 3610, 3616, 3624, 3627, 3631, 3635, 3644,
		3647, 3650, 3654, 3659, 3662, 3667, 3670, 3678, 3688, 3703, 3708, 3713,
		3728, 3731, 3737, 3750, 3756, 3760, 3765, 3770, 3775, 3785, 3790, 3793,
		3797, 3806, 3811, 3815, 3824, 3827, 3830, 3835, 3841, 3850, 3853, 3856,
		3863, 3872, 3875, 3878, 3898, 3901, 3905, 3910, 3915, 3930, 3934, 3943,
		3946, 3955, 3975, 3989, 4012, 4017, 4021, 4028, 4033, 4035, 4046, 4050,
		4055, 4076, 4079, 4084, 4090, 4094, 4099, 4109, 4112, 4124, 4127, 4133,
		4139, 4144, 4150, 4153, 4157, 4161, 4167, 4172, 4174, 4179, 4189, 4198,
		4204, 4210, 4216, 4219, 4222, 4225, 4232, 4236, 4240, 4247, 4253, 4257,
		4261, 4263, 4269, 4274, 4279, 4284, 4291, 4297, 4299, 4305, 4310, 4314,
		4318, 4327, 4330, 4333, 4340, 4344, 4347, 4354, 4360, 4364, 4372, 4376,
		4398, 4404, 4412, 4418, 4426, 4432, 4438, 4466, 4474, 4479, 4485, 4492,
		4496, 4503, 4513, 4517, 4526, 4529, 4532, 4534, 4540, 4544, 4548, 4553,
		4559, 4565, 4569, 4575, 4579, 4581, 4585, 4592, 4597, 4607, 4611, 4616,
		4619, 4625, 4633, 4642, 4650, 4656, 4662, 4674, 4676, 4684, 4691, 4695,
		4701, 4713, 4724, 4734, 4740, 4750, 4763, 4768, 4776, 4782, 4787, 4798,
		4806, 4817, 4823, 4832, 4843, 4855, 4868, 4875, 4877, 4888, 4905, 4938,
		4943, 4951, 4959, 4964, 4972, 4974, 4979, 4986, 5001, 5009, 5014, 5038,
		5055, 5071, 5091, 5149, 5153, 5166, 5171, 5175, 5184, 5190, 5203, 5209,
		5211, 5220, 5225, 5229, 5238, 5244, 5248, 5256, 5261, 5268, 5275, 5292,
		5309, 5320, 5339, 5344, 5348, 5370, 5377, 5380, 5386, 5393, 5396, 5399,
		5405, 5411, 5417, 5423, 5432, 5435, 5438, 5445, 5456, 5465, 5473, 5481,
		5490, 5503, 5522, 5531, 5534, 5537, 5545, 5553, 5557, 5562, 5567, 5569,
		5579, 5591, 5598, 5609, 5613, 5625, 5631, 5644, 5650, 5656, 5665, 5681,
		5686, 5690, 5693, 5699, 5702, 5705, 5732, 5736, 5739, 5745, 5753, 5761,
		5767, 5771, 5779, 5793, 5802, 5804, 5819, 5823, 5826, 5835, 5839, 5868,
		5872, 5874, 5878, 5882, 5885, 5888, 5891, 5895, 5899, 5902, 5905, 5908,
		5919, 5923, 5927, 5930, 5940, 5951, 5954, 5957, 5960, 5969, 5978, 5984,
		5991, 5998, 6003, 6009, 6012, 6014, 6027, 6031, 6036, 6042, 6049, 6053,
		6060, 6066, 6071, 6075, 6082, 6087, 6089, 6093, 6098, 6104, 6115, 6121,
		6125, 6131, 6138, 6149, 6153, 6155, 6161, 6165, 6167, 6176, 6184, 6189,
		6196, 6204, 6209, 6213, 6216, 6219, 6222, 6225, 6228, 6231, 6234, 6238,
		6247, 6252, 6256, 6258, 6262, 6266, 6268, 6275, 6279, 6281, 6291, 6295,
		6297, 6302, 6306, 6308, 6314, 6323, 6329, 6338, 6346, 6350, 6352, 6356,
		6359, 6363, 6365, 6369, 6373, 6380, 6389, 6392, 6396, 6400, 6403, 6408,
		6416, 6445, 6453, 6465, 6480, 6485, 6493, 6499, 6508, 6514, 6519, 6528,
		6540, 6552, 6564, 6567, 6580, 6591, 6598, 6605, 6617, 6622, 6630, 6632,
		6640, 6649, 6662, 6664, 6669, 6672, 6680, 6684, 6692, 6700, 6708, 6716,
		6720, 6749, 6751, 6803, 6807, 6815, 6819, 6824, 6828, 6834, 6841, 6846,
		6855, 6859, 6866, 6874, 6880, 6890, 6894, 6900, 6902, 6915, 6931, 6934,
		6944, 6947, 6955, 6967, 6970, 6980, 6983, 6987, 6989, 6994, 7002, 7009,
		7011, 7018, 7021, 7027, 7035, 7043, 7051, 7061, 7064, 7078, 7081, 7088,
		7095, 7105, 7108, 7112, 7116, 7126, 7147, 7152, 7157, 7159, 7164, 7169,
		7174, 7177, 7182, 7187, 7189, 7213, 7216, 7269, 7272, 7332, 7352, 7359,
		7365, 7368, 7372, 7378, 7384, 7387, 7391, 7397, 7403, 7406, 7410, 7416,
		7422, 7425, 7429, 7431, 7441, 7450, 7453, 7462, 7465, 7468, 7491, 7502,
		7511, 7513, 7519, 7529, 7531, 7539, 7541, 7543, 7547, 7551, 7555, 7559,
		7564, 7568, 7580, 7583, 7597, 7600, 7607, 7616, 7619, 7626, 7638, 7641,
		7655, 7658, 7662, 7668, 7675, 7681, 7688, 7696, 7707, 7714, 7718, 7726,
		7737, 7744, 7750, 7756, 7784, 7799, 7807, 7815, 7826, 7834, 7840, 7848,
		7859, 7861, 7865, 7874, 7883, 7894, 7908, 7918, 7929, 7945, 7948, 7954,
		7983, 7999, 8008, 8023, 8027, 8031, 8035, 8039, 8043, 8047, 8051, 8055,
		8059, 8068, 8072, 8082, 8086, 8088, 8095, 8098, 8104, 8106, 8112, 8123,
		8128, 8136, 8147, 8154, 8161, 8167, 8180, 8191, 8197,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// StarRocksParserInit initializes any static state used to implement StarRocksParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewStarRocksParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func StarRocksParserInit() {
	staticData := &StarRocksParserStaticData
	staticData.once.Do(starrocksParserInit)
}

// NewStarRocksParser produces a new parser instance for the optional input parser.TokenStream.
func NewStarRocksParser(input antlr.TokenStream) *StarRocksParser {
	StarRocksParserInit()
	this := new(StarRocksParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &StarRocksParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "StarRocks.g4"

	return this
}

// StarRocksParser tokens.
const (
	StarRocksParserEOF                       = antlr.TokenEOF
	StarRocksParserT__0                      = 1
	StarRocksParserT__1                      = 2
	StarRocksParserT__2                      = 3
	StarRocksParserT__3                      = 4
	StarRocksParserT__4                      = 5
	StarRocksParserT__5                      = 6
	StarRocksParserT__6                      = 7
	StarRocksParserT__7                      = 8
	StarRocksParserT__8                      = 9
	StarRocksParserT__9                      = 10
	StarRocksParserACCESS                    = 11
	StarRocksParserACTIVE                    = 12
	StarRocksParserADD                       = 13
	StarRocksParserADMIN                     = 14
	StarRocksParserADVISOR                   = 15
	StarRocksParserAFTER                     = 16
	StarRocksParserAGGREGATE                 = 17
	StarRocksParserALL                       = 18
	StarRocksParserALTER                     = 19
	StarRocksParserANALYZE                   = 20
	StarRocksParserAND                       = 21
	StarRocksParserANTI                      = 22
	StarRocksParserAPPLY                     = 23
	StarRocksParserARRAY                     = 24
	StarRocksParserARRAY_AGG                 = 25
	StarRocksParserARRAY_AGG_DISTINCT        = 26
	StarRocksParserAS                        = 27
	StarRocksParserASC                       = 28
	StarRocksParserASYNC                     = 29
	StarRocksParserAUTHORS                   = 30
	StarRocksParserAUTHENTICATION            = 31
	StarRocksParserAUTOMATED                 = 32
	StarRocksParserAUTO_INCREMENT            = 33
	StarRocksParserAVG                       = 34
	StarRocksParserBACKEND                   = 35
	StarRocksParserBACKENDS                  = 36
	StarRocksParserBACKUP                    = 37
	StarRocksParserBASE                      = 38
	StarRocksParserBASELINE                  = 39
	StarRocksParserBEGIN                     = 40
	StarRocksParserBETWEEN                   = 41
	StarRocksParserBIGINT                    = 42
	StarRocksParserBINARY                    = 43
	StarRocksParserBITMAP                    = 44
	StarRocksParserBITMAP_UNION              = 45
	StarRocksParserBLACKHOLE                 = 46
	StarRocksParserBLACKLIST                 = 47
	StarRocksParserBODY                      = 48
	StarRocksParserBOOLEAN                   = 49
	StarRocksParserBOTH                      = 50
	StarRocksParserBRANCH                    = 51
	StarRocksParserBROKER                    = 52
	StarRocksParserBUCKETS                   = 53
	StarRocksParserBUILTIN                   = 54
	StarRocksParserBY                        = 55
	StarRocksParserCACHE                     = 56
	StarRocksParserCANCEL                    = 57
	StarRocksParserCASE                      = 58
	StarRocksParserCAST                      = 59
	StarRocksParserCATALOG                   = 60
	StarRocksParserCATALOGS                  = 61
	StarRocksParserCEIL                      = 62
	StarRocksParserCHAIN                     = 63
	StarRocksParserCHAR                      = 64
	StarRocksParserCHARACTER                 = 65
	StarRocksParserCHARSET                   = 66
	StarRocksParserCHECK                     = 67
	StarRocksParserCLEAN                     = 68
	StarRocksParserCLEAR                     = 69
	StarRocksParserCLUSTER                   = 70
	StarRocksParserCLUSTERS                  = 71
	StarRocksParserCNGROUP                   = 72
	StarRocksParserCNGROUPS                  = 73
	StarRocksParserCOLLATE                   = 74
	StarRocksParserCOLLATION                 = 75
	StarRocksParserCOLUMN                    = 76
	StarRocksParserCOLUMNS                   = 77
	StarRocksParserCOMMENT                   = 78
	StarRocksParserCOMMIT                    = 79
	StarRocksParserCOMMITTED                 = 80
	StarRocksParserCOMPACT                   = 81
	StarRocksParserCOMPACTION                = 82
	StarRocksParserCOMPUTE                   = 83
	StarRocksParserCONFIG                    = 84
	StarRocksParserCONNECTION                = 85
	StarRocksParserCONSISTENT                = 86
	StarRocksParserCONVERT                   = 87
	StarRocksParserCOSTS                     = 88
	StarRocksParserCOUNT                     = 89
	StarRocksParserCREATE                    = 90
	StarRocksParserCROSS                     = 91
	StarRocksParserCUBE                      = 92
	StarRocksParserCUME_DIST                 = 93
	StarRocksParserCUMULATIVE                = 94
	StarRocksParserCURRENT                   = 95
	StarRocksParserCURRENT_DATE              = 96
	StarRocksParserCURRENT_GROUP             = 97
	StarRocksParserCURRENT_ROLE              = 98
	StarRocksParserCURRENT_TIME              = 99
	StarRocksParserCURRENT_TIMESTAMP         = 100
	StarRocksParserCURRENT_USER              = 101
	StarRocksParserDATA                      = 102
	StarRocksParserDATACACHE                 = 103
	StarRocksParserDATABASE                  = 104
	StarRocksParserDATABASES                 = 105
	StarRocksParserDATE                      = 106
	StarRocksParserDATETIME                  = 107
	StarRocksParserDAY                       = 108
	StarRocksParserDAYS                      = 109
	StarRocksParserDEALLOCATE                = 110
	StarRocksParserDECIMAL                   = 111
	StarRocksParserDECIMALV2                 = 112
	StarRocksParserDECIMAL32                 = 113
	StarRocksParserDECIMAL64                 = 114
	StarRocksParserDECIMAL128                = 115
	StarRocksParserDECOMMISSION              = 116
	StarRocksParserDEFAULT                   = 117
	StarRocksParserDELETE                    = 118
	StarRocksParserDENSE_RANK                = 119
	StarRocksParserDEFERRED                  = 120
	StarRocksParserDIALECT                   = 121
	StarRocksParserDICTIONARY                = 122
	StarRocksParserDICTIONARY_GET            = 123
	StarRocksParserNTILE                     = 124
	StarRocksParserDESC                      = 125
	StarRocksParserDESCRIBE                  = 126
	StarRocksParserDISABLE                   = 127
	StarRocksParserDISTINCT                  = 128
	StarRocksParserDISTRIBUTED               = 129
	StarRocksParserDISTRIBUTION              = 130
	StarRocksParserDOUBLE                    = 131
	StarRocksParserDROP                      = 132
	StarRocksParserDUAL                      = 133
	StarRocksParserDUPLICATE                 = 134
	StarRocksParserDYNAMIC                   = 135
	StarRocksParserELSE                      = 136
	StarRocksParserENABLE                    = 137
	StarRocksParserENCLOSE                   = 138
	StarRocksParserEND                       = 139
	StarRocksParserENGINE                    = 140
	StarRocksParserENGINES                   = 141
	StarRocksParserERRORS                    = 142
	StarRocksParserESCAPE                    = 143
	StarRocksParserEVENTS                    = 144
	StarRocksParserEXCEPT                    = 145
	StarRocksParserEXCLUDE                   = 146
	StarRocksParserEXECUTE                   = 147
	StarRocksParserEXISTS                    = 148
	StarRocksParserEXPLAIN                   = 149
	StarRocksParserEXPORT                    = 150
	StarRocksParserEXTERNAL                  = 151
	StarRocksParserEXTRACT                   = 152
	StarRocksParserEVERY                     = 153
	StarRocksParserFAILPOINT                 = 154
	StarRocksParserFAILPOINTS                = 155
	StarRocksParserFALSE                     = 156
	StarRocksParserFIELDS                    = 157
	StarRocksParserFILE                      = 158
	StarRocksParserFILES                     = 159
	StarRocksParserFILTER                    = 160
	StarRocksParserFIRST                     = 161
	StarRocksParserFIRST_VALUE               = 162
	StarRocksParserFLOAT                     = 163
	StarRocksParserFLOOR                     = 164
	StarRocksParserFN                        = 165
	StarRocksParserFOLLOWING                 = 166
	StarRocksParserFOLLOWER                  = 167
	StarRocksParserFOR                       = 168
	StarRocksParserFORCE                     = 169
	StarRocksParserFORMAT                    = 170
	StarRocksParserFREE                      = 171
	StarRocksParserFROM                      = 172
	StarRocksParserFRONTEND                  = 173
	StarRocksParserFRONTENDS                 = 174
	StarRocksParserFULL                      = 175
	StarRocksParserFUNCTION                  = 176
	StarRocksParserFUNCTIONS                 = 177
	StarRocksParserGLOBAL                    = 178
	StarRocksParserGRANT                     = 179
	StarRocksParserGRANTS                    = 180
	StarRocksParserGROUP                     = 181
	StarRocksParserGROUPS                    = 182
	StarRocksParserGROUPING                  = 183
	StarRocksParserGROUPING_ID               = 184
	StarRocksParserGROUP_CONCAT              = 185
	StarRocksParserHASH                      = 186
	StarRocksParserHAVING                    = 187
	StarRocksParserHELP                      = 188
	StarRocksParserHISTOGRAM                 = 189
	StarRocksParserHLL                       = 190
	StarRocksParserHLL_UNION                 = 191
	StarRocksParserHOST                      = 192
	StarRocksParserHOUR                      = 193
	StarRocksParserHOURS                     = 194
	StarRocksParserHUB                       = 195
	StarRocksParserIDENTIFIED                = 196
	StarRocksParserIF                        = 197
	StarRocksParserIMPERSONATE               = 198
	StarRocksParserIMMEDIATE                 = 199
	StarRocksParserIGNORE                    = 200
	StarRocksParserIMAGE                     = 201
	StarRocksParserIN                        = 202
	StarRocksParserINACTIVE                  = 203
	StarRocksParserINCREMENTAL               = 204
	StarRocksParserINDEX                     = 205
	StarRocksParserINDEXES                   = 206
	StarRocksParserINFILE                    = 207
	StarRocksParserINNER                     = 208
	StarRocksParserINSTALL                   = 209
	StarRocksParserINSERT                    = 210
	StarRocksParserINT                       = 211
	StarRocksParserINTEGER                   = 212
	StarRocksParserINTEGRATION               = 213
	StarRocksParserINTEGRATIONS              = 214
	StarRocksParserINTERMEDIATE              = 215
	StarRocksParserINTERSECT                 = 216
	StarRocksParserINTERVAL                  = 217
	StarRocksParserINTO                      = 218
	StarRocksParserINVOKER                   = 219
	StarRocksParserGIN                       = 220
	StarRocksParserOVERWRITE                 = 221
	StarRocksParserIS                        = 222
	StarRocksParserISOLATION                 = 223
	StarRocksParserJOB                       = 224
	StarRocksParserJOIN                      = 225
	StarRocksParserJSON                      = 226
	StarRocksParserKEY                       = 227
	StarRocksParserKEYS                      = 228
	StarRocksParserKILL                      = 229
	StarRocksParserLABEL                     = 230
	StarRocksParserLAG                       = 231
	StarRocksParserLARGEINT                  = 232
	StarRocksParserLAST                      = 233
	StarRocksParserLAST_VALUE                = 234
	StarRocksParserLATERAL                   = 235
	StarRocksParserLEAD                      = 236
	StarRocksParserLEFT                      = 237
	StarRocksParserLESS                      = 238
	StarRocksParserLEVEL                     = 239
	StarRocksParserLIKE                      = 240
	StarRocksParserLIMIT                     = 241
	StarRocksParserLIST                      = 242
	StarRocksParserLOAD                      = 243
	StarRocksParserLOCAL                     = 244
	StarRocksParserLOCALTIME                 = 245
	StarRocksParserLOCALTIMESTAMP            = 246
	StarRocksParserLOCATION                  = 247
	StarRocksParserLOCATIONS                 = 248
	StarRocksParserLOGS                      = 249
	StarRocksParserLOGICAL                   = 250
	StarRocksParserMANUAL                    = 251
	StarRocksParserMAP                       = 252
	StarRocksParserMAPPING                   = 253
	StarRocksParserMAPPINGS                  = 254
	StarRocksParserMASKING                   = 255
	StarRocksParserMATCH                     = 256
	StarRocksParserMATERIALIZED              = 257
	StarRocksParserMAX                       = 258
	StarRocksParserMAXVALUE                  = 259
	StarRocksParserMERGE                     = 260
	StarRocksParserMICROSECOND               = 261
	StarRocksParserMILLISECOND               = 262
	StarRocksParserMIN                       = 263
	StarRocksParserMINUTE                    = 264
	StarRocksParserMINUTES                   = 265
	StarRocksParserMINUS                     = 266
	StarRocksParserMETA                      = 267
	StarRocksParserMOD                       = 268
	StarRocksParserMODE                      = 269
	StarRocksParserMODIFY                    = 270
	StarRocksParserMONTH                     = 271
	StarRocksParserMULTIPLE                  = 272
	StarRocksParserNAME                      = 273
	StarRocksParserNAMES                     = 274
	StarRocksParserNEGATIVE                  = 275
	StarRocksParserNGRAMBF                   = 276
	StarRocksParserNO                        = 277
	StarRocksParserNODE                      = 278
	StarRocksParserNODES                     = 279
	StarRocksParserNONE                      = 280
	StarRocksParserNOT                       = 281
	StarRocksParserNULL                      = 282
	StarRocksParserNULLS                     = 283
	StarRocksParserNUMBER                    = 284
	StarRocksParserNUMERIC                   = 285
	StarRocksParserOBSERVER                  = 286
	StarRocksParserOF                        = 287
	StarRocksParserOFF                       = 288
	StarRocksParserOFFSET                    = 289
	StarRocksParserON                        = 290
	StarRocksParserONLY                      = 291
	StarRocksParserOPEN                      = 292
	StarRocksParserOPERATE                   = 293
	StarRocksParserOPTIMIZE                  = 294
	StarRocksParserOPTIMIZER                 = 295
	StarRocksParserOPTION                    = 296
	StarRocksParserOR                        = 297
	StarRocksParserORDER                     = 298
	StarRocksParserOUTER                     = 299
	StarRocksParserOUTFILE                   = 300
	StarRocksParserOVER                      = 301
	StarRocksParserPARAMETER                 = 302
	StarRocksParserPARTITION                 = 303
	StarRocksParserPARTITIONS                = 304
	StarRocksParserPASSWORD                  = 305
	StarRocksParserPATH                      = 306
	StarRocksParserPAUSE                     = 307
	StarRocksParserPENDING                   = 308
	StarRocksParserPERCENT_RANK              = 309
	StarRocksParserPERCENTILE                = 310
	StarRocksParserPERCENTILE_UNION          = 311
	StarRocksParserPLAN                      = 312
	StarRocksParserPLUGIN                    = 313
	StarRocksParserPLUGINS                   = 314
	StarRocksParserPIPE                      = 315
	StarRocksParserPIPES                     = 316
	StarRocksParserPIVOT                     = 317
	StarRocksParserPOLICY                    = 318
	StarRocksParserPOLICIES                  = 319
	StarRocksParserPRECEDING                 = 320
	StarRocksParserPREDICATE                 = 321
	StarRocksParserPREPARE                   = 322
	StarRocksParserPRIMARY                   = 323
	StarRocksParserPRIORITY                  = 324
	StarRocksParserPRIVILEGES                = 325
	StarRocksParserPROBABILITY               = 326
	StarRocksParserPROC                      = 327
	StarRocksParserPROCEDURE                 = 328
	StarRocksParserPROCESSLIST               = 329
	StarRocksParserPROFILE                   = 330
	StarRocksParserPROFILELIST               = 331
	StarRocksParserPROPERTIES                = 332
	StarRocksParserPROPERTY                  = 333
	StarRocksParserPROVIDER                  = 334
	StarRocksParserPROVIDERS                 = 335
	StarRocksParserQUALIFY                   = 336
	StarRocksParserQUARTER                   = 337
	StarRocksParserQUERY                     = 338
	StarRocksParserQUERIES                   = 339
	StarRocksParserQUEUE                     = 340
	StarRocksParserQUOTA                     = 341
	StarRocksParserRANDOM                    = 342
	StarRocksParserRANGE                     = 343
	StarRocksParserRANK                      = 344
	StarRocksParserREAD                      = 345
	StarRocksParserREASON                    = 346
	StarRocksParserRECOVER                   = 347
	StarRocksParserREFRESH                   = 348
	StarRocksParserREWRITE                   = 349
	StarRocksParserREGEXP                    = 350
	StarRocksParserRELEASE                   = 351
	StarRocksParserREMOVE                    = 352
	StarRocksParserRENAME                    = 353
	StarRocksParserREPAIR                    = 354
	StarRocksParserREPEATABLE                = 355
	StarRocksParserREPLACE                   = 356
	StarRocksParserREPLACE_IF_NOT_NULL       = 357
	StarRocksParserREPLICA                   = 358
	StarRocksParserREPOSITORY                = 359
	StarRocksParserREPOSITORIES              = 360
	StarRocksParserRESOURCE                  = 361
	StarRocksParserRESOURCES                 = 362
	StarRocksParserRESTORE                   = 363
	StarRocksParserRESUME                    = 364
	StarRocksParserRETAIN                    = 365
	StarRocksParserRETENTION                 = 366
	StarRocksParserRETURNS                   = 367
	StarRocksParserRETRY                     = 368
	StarRocksParserREVOKE                    = 369
	StarRocksParserREVERT                    = 370
	StarRocksParserRIGHT                     = 371
	StarRocksParserRLIKE                     = 372
	StarRocksParserROLE                      = 373
	StarRocksParserROLES                     = 374
	StarRocksParserROLLBACK                  = 375
	StarRocksParserROLLUP                    = 376
	StarRocksParserROUTINE                   = 377
	StarRocksParserROW                       = 378
	StarRocksParserROWS                      = 379
	StarRocksParserROW_NUMBER                = 380
	StarRocksParserRULE                      = 381
	StarRocksParserRULES                     = 382
	StarRocksParserRUNNING                   = 383
	StarRocksParserSAMPLE                    = 384
	StarRocksParserSCHEDULE                  = 385
	StarRocksParserSCHEDULER                 = 386
	StarRocksParserSCHEMA                    = 387
	StarRocksParserSCHEMAS                   = 388
	StarRocksParserSECOND                    = 389
	StarRocksParserSECURITY                  = 390
	StarRocksParserSELECT                    = 391
	StarRocksParserSEMI                      = 392
	StarRocksParserSEPARATOR                 = 393
	StarRocksParserSERIALIZABLE              = 394
	StarRocksParserSESSION                   = 395
	StarRocksParserSET                       = 396
	StarRocksParserSETS                      = 397
	StarRocksParserSET_VAR                   = 398
	StarRocksParserSIGNED                    = 399
	StarRocksParserSKIP_HEADER               = 400
	StarRocksParserSHOW                      = 401
	StarRocksParserSMALLINT                  = 402
	StarRocksParserSNAPSHOT                  = 403
	StarRocksParserSNAPSHOTS                 = 404
	StarRocksParserSQLBLACKLIST              = 405
	StarRocksParserSTARROCKS                 = 406
	StarRocksParserSTART                     = 407
	StarRocksParserSTATS                     = 408
	StarRocksParserSTATUS                    = 409
	StarRocksParserSTOP                      = 410
	StarRocksParserSTORAGE                   = 411
	StarRocksParserSTREAM                    = 412
	StarRocksParserSTRING                    = 413
	StarRocksParserTEXT                      = 414
	StarRocksParserSUBMIT                    = 415
	StarRocksParserSUM                       = 416
	StarRocksParserSUSPEND                   = 417
	StarRocksParserSYNC                      = 418
	StarRocksParserSYSTEM                    = 419
	StarRocksParserSYSTEM_TIME               = 420
	StarRocksParserSWAP                      = 421
	StarRocksParserSTRUCT                    = 422
	StarRocksParserTABLE                     = 423
	StarRocksParserTABLES                    = 424
	StarRocksParserTABLET                    = 425
	StarRocksParserTABLETS                   = 426
	StarRocksParserTAG                       = 427
	StarRocksParserTASK                      = 428
	StarRocksParserTEMPORARY                 = 429
	StarRocksParserTERMINATED                = 430
	StarRocksParserTHAN                      = 431
	StarRocksParserTHEN                      = 432
	StarRocksParserTIME                      = 433
	StarRocksParserTIMES                     = 434
	StarRocksParserTIMESTAMP                 = 435
	StarRocksParserTIMESTAMPADD              = 436
	StarRocksParserTIMESTAMPDIFF             = 437
	StarRocksParserTINYINT                   = 438
	StarRocksParserTRANSACTION               = 439
	StarRocksParserTRANSLATE                 = 440
	StarRocksParserTO                        = 441
	StarRocksParserTRACE                     = 442
	StarRocksParserTRIGGERS                  = 443
	StarRocksParserTRIM_SPACE                = 444
	StarRocksParserTRUE                      = 445
	StarRocksParserTRUNCATE                  = 446
	StarRocksParserTYPE                      = 447
	StarRocksParserTYPES                     = 448
	StarRocksParserUNBOUNDED                 = 449
	StarRocksParserUNCOMMITTED               = 450
	StarRocksParserUNION                     = 451
	StarRocksParserUNIQUE                    = 452
	StarRocksParserUNINSTALL                 = 453
	StarRocksParserUNSET                     = 454
	StarRocksParserUNSIGNED                  = 455
	StarRocksParserUPDATE                    = 456
	StarRocksParserUSAGE                     = 457
	StarRocksParserUSE                       = 458
	StarRocksParserUSER                      = 459
	StarRocksParserUSERS                     = 460
	StarRocksParserUSING                     = 461
	StarRocksParserVALUE                     = 462
	StarRocksParserVALUES                    = 463
	StarRocksParserVARBINARY                 = 464
	StarRocksParserVARCHAR                   = 465
	StarRocksParserVARIABLES                 = 466
	StarRocksParserVECTOR                    = 467
	StarRocksParserVERBOSE                   = 468
	StarRocksParserVERSION                   = 469
	StarRocksParserVIEW                      = 470
	StarRocksParserVIEWS                     = 471
	StarRocksParserVOLUME                    = 472
	StarRocksParserVOLUMES                   = 473
	StarRocksParserWAREHOUSE                 = 474
	StarRocksParserWAREHOUSES                = 475
	StarRocksParserWARNINGS                  = 476
	StarRocksParserWEEK                      = 477
	StarRocksParserWHEN                      = 478
	StarRocksParserWHERE                     = 479
	StarRocksParserWHITELIST                 = 480
	StarRocksParserWITH                      = 481
	StarRocksParserWORK                      = 482
	StarRocksParserWRITE                     = 483
	StarRocksParserYEAR                      = 484
	StarRocksParserLOCK                      = 485
	StarRocksParserUNLOCK                    = 486
	StarRocksParserLOW_PRIORITY              = 487
	StarRocksParserDISK                      = 488
	StarRocksParserBEFORE                    = 489
	StarRocksParserDOUBLE_DOLLAR             = 490
	StarRocksParserFIELD                     = 491
	StarRocksParserPERSISTENT                = 492
	StarRocksParserEQ                        = 493
	StarRocksParserNEQ                       = 494
	StarRocksParserLT                        = 495
	StarRocksParserLTE                       = 496
	StarRocksParserGT                        = 497
	StarRocksParserGTE                       = 498
	StarRocksParserEQ_FOR_NULL               = 499
	StarRocksParserARRAY_ELEMENT             = 500
	StarRocksParserPLUS_SYMBOL               = 501
	StarRocksParserMINUS_SYMBOL              = 502
	StarRocksParserASTERISK_SYMBOL           = 503
	StarRocksParserSLASH_SYMBOL              = 504
	StarRocksParserPERCENT_SYMBOL            = 505
	StarRocksParserLOGICAL_OR                = 506
	StarRocksParserLOGICAL_AND               = 507
	StarRocksParserLOGICAL_NOT               = 508
	StarRocksParserINT_DIV                   = 509
	StarRocksParserBITAND                    = 510
	StarRocksParserBITOR                     = 511
	StarRocksParserBITXOR                    = 512
	StarRocksParserBITNOT                    = 513
	StarRocksParserBIT_SHIFT_LEFT            = 514
	StarRocksParserBIT_SHIFT_RIGHT           = 515
	StarRocksParserBIT_SHIFT_RIGHT_LOGICAL   = 516
	StarRocksParserARROW                     = 517
	StarRocksParserAT                        = 518
	StarRocksParserINTEGER_VALUE             = 519
	StarRocksParserDECIMAL_VALUE             = 520
	StarRocksParserDOUBLE_VALUE              = 521
	StarRocksParserSINGLE_QUOTED_TEXT        = 522
	StarRocksParserDOUBLE_QUOTED_TEXT        = 523
	StarRocksParserBINARY_SINGLE_QUOTED_TEXT = 524
	StarRocksParserBINARY_DOUBLE_QUOTED_TEXT = 525
	StarRocksParserLETTER_IDENTIFIER         = 526
	StarRocksParserDIGIT_IDENTIFIER          = 527
	StarRocksParserBACKQUOTED_IDENTIFIER     = 528
	StarRocksParserDOT_IDENTIFIER            = 529
	StarRocksParserSIMPLE_COMMENT            = 530
	StarRocksParserBRACKETED_COMMENT         = 531
	StarRocksParserOPTIMIZER_HINT            = 532
	StarRocksParserSEMICOLON                 = 533
	StarRocksParserDOTDOTDOT                 = 534
	StarRocksParserWS                        = 535
	StarRocksParserATTACHMENT                = 536
	StarRocksParserCONCAT                    = 537
)

// StarRocksParser rules.
const (
	StarRocksParserRULE_sqlStatements                          = 0
	StarRocksParserRULE_singleStatement                        = 1
	StarRocksParserRULE_emptyStatement                         = 2
	StarRocksParserRULE_statement                              = 3
	StarRocksParserRULE_useDatabaseStatement                   = 4
	StarRocksParserRULE_useCatalogStatement                    = 5
	StarRocksParserRULE_setCatalogStatement                    = 6
	StarRocksParserRULE_showDatabasesStatement                 = 7
	StarRocksParserRULE_alterDbQuotaStatement                  = 8
	StarRocksParserRULE_createDbStatement                      = 9
	StarRocksParserRULE_dropDbStatement                        = 10
	StarRocksParserRULE_showCreateDbStatement                  = 11
	StarRocksParserRULE_alterDatabaseRenameStatement           = 12
	StarRocksParserRULE_recoverDbStmt                          = 13
	StarRocksParserRULE_showDataStmt                           = 14
	StarRocksParserRULE_showDataDistributionStmt               = 15
	StarRocksParserRULE_createTableStatement                   = 16
	StarRocksParserRULE_columnDesc                             = 17
	StarRocksParserRULE_charsetName                            = 18
	StarRocksParserRULE_defaultDesc                            = 19
	StarRocksParserRULE_generatedColumnDesc                    = 20
	StarRocksParserRULE_indexDesc                              = 21
	StarRocksParserRULE_engineDesc                             = 22
	StarRocksParserRULE_charsetDesc                            = 23
	StarRocksParserRULE_collateDesc                            = 24
	StarRocksParserRULE_keyDesc                                = 25
	StarRocksParserRULE_orderByDesc                            = 26
	StarRocksParserRULE_columnNullable                         = 27
	StarRocksParserRULE_typeWithNullable                       = 28
	StarRocksParserRULE_aggStateDesc                           = 29
	StarRocksParserRULE_aggDesc                                = 30
	StarRocksParserRULE_rollupDesc                             = 31
	StarRocksParserRULE_rollupItem                             = 32
	StarRocksParserRULE_dupKeys                                = 33
	StarRocksParserRULE_fromRollup                             = 34
	StarRocksParserRULE_orReplace                              = 35
	StarRocksParserRULE_ifNotExists                            = 36
	StarRocksParserRULE_createTableAsSelectStatement           = 37
	StarRocksParserRULE_dropTableStatement                     = 38
	StarRocksParserRULE_cleanTemporaryTableStatement           = 39
	StarRocksParserRULE_alterTableStatement                    = 40
	StarRocksParserRULE_createIndexStatement                   = 41
	StarRocksParserRULE_dropIndexStatement                     = 42
	StarRocksParserRULE_indexType                              = 43
	StarRocksParserRULE_showTableStatement                     = 44
	StarRocksParserRULE_showTemporaryTablesStatement           = 45
	StarRocksParserRULE_showCreateTableStatement               = 46
	StarRocksParserRULE_showColumnStatement                    = 47
	StarRocksParserRULE_showTableStatusStatement               = 48
	StarRocksParserRULE_refreshTableStatement                  = 49
	StarRocksParserRULE_showAlterStatement                     = 50
	StarRocksParserRULE_descTableStatement                     = 51
	StarRocksParserRULE_createTableLikeStatement               = 52
	StarRocksParserRULE_showIndexStatement                     = 53
	StarRocksParserRULE_recoverTableStatement                  = 54
	StarRocksParserRULE_truncateTableStatement                 = 55
	StarRocksParserRULE_cancelAlterTableStatement              = 56
	StarRocksParserRULE_showPartitionsStatement                = 57
	StarRocksParserRULE_recoverPartitionStatement              = 58
	StarRocksParserRULE_createViewStatement                    = 59
	StarRocksParserRULE_alterViewStatement                     = 60
	StarRocksParserRULE_dropViewStatement                      = 61
	StarRocksParserRULE_columnNameWithComment                  = 62
	StarRocksParserRULE_submitTaskStatement                    = 63
	StarRocksParserRULE_taskClause                             = 64
	StarRocksParserRULE_dropTaskStatement                      = 65
	StarRocksParserRULE_taskScheduleDesc                       = 66
	StarRocksParserRULE_createMaterializedViewStatement        = 67
	StarRocksParserRULE_mvPartitionExprs                       = 68
	StarRocksParserRULE_materializedViewDesc                   = 69
	StarRocksParserRULE_showMaterializedViewsStatement         = 70
	StarRocksParserRULE_dropMaterializedViewStatement          = 71
	StarRocksParserRULE_alterMaterializedViewStatement         = 72
	StarRocksParserRULE_refreshMaterializedViewStatement       = 73
	StarRocksParserRULE_cancelRefreshMaterializedViewStatement = 74
	StarRocksParserRULE_adminSetConfigStatement                = 75
	StarRocksParserRULE_adminSetReplicaStatusStatement         = 76
	StarRocksParserRULE_adminShowConfigStatement               = 77
	StarRocksParserRULE_adminShowReplicaDistributionStatement  = 78
	StarRocksParserRULE_adminShowReplicaStatusStatement        = 79
	StarRocksParserRULE_adminRepairTableStatement              = 80
	StarRocksParserRULE_adminCancelRepairTableStatement        = 81
	StarRocksParserRULE_adminCheckTabletsStatement             = 82
	StarRocksParserRULE_adminSetPartitionVersion               = 83
	StarRocksParserRULE_killStatement                          = 84
	StarRocksParserRULE_syncStatement                          = 85
	StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement   = 86
	StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement  = 87
	StarRocksParserRULE_alterSystemStatement                   = 88
	StarRocksParserRULE_cancelAlterSystemStatement             = 89
	StarRocksParserRULE_showComputeNodesStatement              = 90
	StarRocksParserRULE_createExternalCatalogStatement         = 91
	StarRocksParserRULE_showCreateExternalCatalogStatement     = 92
	StarRocksParserRULE_dropExternalCatalogStatement           = 93
	StarRocksParserRULE_showCatalogsStatement                  = 94
	StarRocksParserRULE_alterCatalogStatement                  = 95
	StarRocksParserRULE_createStorageVolumeStatement           = 96
	StarRocksParserRULE_typeDesc                               = 97
	StarRocksParserRULE_locationsDesc                          = 98
	StarRocksParserRULE_showStorageVolumesStatement            = 99
	StarRocksParserRULE_dropStorageVolumeStatement             = 100
	StarRocksParserRULE_alterStorageVolumeStatement            = 101
	StarRocksParserRULE_alterStorageVolumeClause               = 102
	StarRocksParserRULE_modifyStorageVolumePropertiesClause    = 103
	StarRocksParserRULE_modifyStorageVolumeCommentClause       = 104
	StarRocksParserRULE_descStorageVolumeStatement             = 105
	StarRocksParserRULE_setDefaultStorageVolumeStatement       = 106
	StarRocksParserRULE_updateFailPointStatusStatement         = 107
	StarRocksParserRULE_showFailPointStatement                 = 108
	StarRocksParserRULE_createDictionaryStatement              = 109
	StarRocksParserRULE_dropDictionaryStatement                = 110
	StarRocksParserRULE_refreshDictionaryStatement             = 111
	StarRocksParserRULE_showDictionaryStatement                = 112
	StarRocksParserRULE_cancelRefreshDictionaryStatement       = 113
	StarRocksParserRULE_dictionaryColumnDesc                   = 114
	StarRocksParserRULE_dictionaryName                         = 115
	StarRocksParserRULE_alterClause                            = 116
	StarRocksParserRULE_addFrontendClause                      = 117
	StarRocksParserRULE_dropFrontendClause                     = 118
	StarRocksParserRULE_modifyFrontendHostClause               = 119
	StarRocksParserRULE_addBackendClause                       = 120
	StarRocksParserRULE_dropBackendClause                      = 121
	StarRocksParserRULE_decommissionBackendClause              = 122
	StarRocksParserRULE_modifyBackendClause                    = 123
	StarRocksParserRULE_addComputeNodeClause                   = 124
	StarRocksParserRULE_dropComputeNodeClause                  = 125
	StarRocksParserRULE_modifyBrokerClause                     = 126
	StarRocksParserRULE_alterLoadErrorUrlClause                = 127
	StarRocksParserRULE_createImageClause                      = 128
	StarRocksParserRULE_cleanTabletSchedQClause                = 129
	StarRocksParserRULE_decommissionDiskClause                 = 130
	StarRocksParserRULE_cancelDecommissionDiskClause           = 131
	StarRocksParserRULE_disableDiskClause                      = 132
	StarRocksParserRULE_cancelDisableDiskClause                = 133
	StarRocksParserRULE_createIndexClause                      = 134
	StarRocksParserRULE_dropIndexClause                        = 135
	StarRocksParserRULE_tableRenameClause                      = 136
	StarRocksParserRULE_swapTableClause                        = 137
	StarRocksParserRULE_modifyPropertiesClause                 = 138
	StarRocksParserRULE_modifyCommentClause                    = 139
	StarRocksParserRULE_optimizeRange                          = 140
	StarRocksParserRULE_optimizeClause                         = 141
	StarRocksParserRULE_addColumnClause                        = 142
	StarRocksParserRULE_addColumnsClause                       = 143
	StarRocksParserRULE_dropColumnClause                       = 144
	StarRocksParserRULE_modifyColumnClause                     = 145
	StarRocksParserRULE_columnRenameClause                     = 146
	StarRocksParserRULE_reorderColumnsClause                   = 147
	StarRocksParserRULE_rollupRenameClause                     = 148
	StarRocksParserRULE_compactionClause                       = 149
	StarRocksParserRULE_subfieldName                           = 150
	StarRocksParserRULE_nestedFieldName                        = 151
	StarRocksParserRULE_addFieldClause                         = 152
	StarRocksParserRULE_dropFieldClause                        = 153
	StarRocksParserRULE_createOrReplaceTagClause               = 154
	StarRocksParserRULE_createOrReplaceBranchClause            = 155
	StarRocksParserRULE_dropBranchClause                       = 156
	StarRocksParserRULE_dropTagClause                          = 157
	StarRocksParserRULE_tableOperationClause                   = 158
	StarRocksParserRULE_tagOptions                             = 159
	StarRocksParserRULE_branchOptions                          = 160
	StarRocksParserRULE_snapshotRetention                      = 161
	StarRocksParserRULE_refRetain                              = 162
	StarRocksParserRULE_maxSnapshotAge                         = 163
	StarRocksParserRULE_minSnapshotsToKeep                     = 164
	StarRocksParserRULE_snapshotId                             = 165
	StarRocksParserRULE_timeUnit                               = 166
	StarRocksParserRULE_integer_list                           = 167
	StarRocksParserRULE_dropPersistentIndexClause              = 168
	StarRocksParserRULE_addPartitionClause                     = 169
	StarRocksParserRULE_dropPartitionClause                    = 170
	StarRocksParserRULE_truncatePartitionClause                = 171
	StarRocksParserRULE_modifyPartitionClause                  = 172
	StarRocksParserRULE_replacePartitionClause                 = 173
	StarRocksParserRULE_partitionRenameClause                  = 174
	StarRocksParserRULE_insertStatement                        = 175
	StarRocksParserRULE_insertLabelOrColumnAliases             = 176
	StarRocksParserRULE_columnAliasesOrByName                  = 177
	StarRocksParserRULE_updateStatement                        = 178
	StarRocksParserRULE_deleteStatement                        = 179
	StarRocksParserRULE_createRoutineLoadStatement             = 180
	StarRocksParserRULE_alterRoutineLoadStatement              = 181
	StarRocksParserRULE_dataSource                             = 182
	StarRocksParserRULE_loadProperties                         = 183
	StarRocksParserRULE_colSeparatorProperty                   = 184
	StarRocksParserRULE_rowDelimiterProperty                   = 185
	StarRocksParserRULE_importColumns                          = 186
	StarRocksParserRULE_columnProperties                       = 187
	StarRocksParserRULE_jobProperties                          = 188
	StarRocksParserRULE_dataSourceProperties                   = 189
	StarRocksParserRULE_stopRoutineLoadStatement               = 190
	StarRocksParserRULE_resumeRoutineLoadStatement             = 191
	StarRocksParserRULE_pauseRoutineLoadStatement              = 192
	StarRocksParserRULE_showRoutineLoadStatement               = 193
	StarRocksParserRULE_showRoutineLoadTaskStatement           = 194
	StarRocksParserRULE_showCreateRoutineLoadStatement         = 195
	StarRocksParserRULE_showStreamLoadStatement                = 196
	StarRocksParserRULE_analyzeStatement                       = 197
	StarRocksParserRULE_analyzeColumnClause                    = 198
	StarRocksParserRULE_dropStatsStatement                     = 199
	StarRocksParserRULE_histogramStatement                     = 200
	StarRocksParserRULE_analyzeHistogramStatement              = 201
	StarRocksParserRULE_dropHistogramStatement                 = 202
	StarRocksParserRULE_createAnalyzeStatement                 = 203
	StarRocksParserRULE_dropAnalyzeJobStatement                = 204
	StarRocksParserRULE_showAnalyzeStatement                   = 205
	StarRocksParserRULE_showStatsMetaStatement                 = 206
	StarRocksParserRULE_showHistogramMetaStatement             = 207
	StarRocksParserRULE_killAnalyzeStatement                   = 208
	StarRocksParserRULE_analyzeProfileStatement                = 209
	StarRocksParserRULE_createBaselinePlanStatement            = 210
	StarRocksParserRULE_dropBaselinePlanStatement              = 211
	StarRocksParserRULE_showBaselinePlanStatement              = 212
	StarRocksParserRULE_createResourceGroupStatement           = 213
	StarRocksParserRULE_dropResourceGroupStatement             = 214
	StarRocksParserRULE_alterResourceGroupStatement            = 215
	StarRocksParserRULE_showResourceGroupStatement             = 216
	StarRocksParserRULE_showResourceGroupUsageStatement        = 217
	StarRocksParserRULE_createResourceStatement                = 218
	StarRocksParserRULE_alterResourceStatement                 = 219
	StarRocksParserRULE_dropResourceStatement                  = 220
	StarRocksParserRULE_showResourceStatement                  = 221
	StarRocksParserRULE_classifier                             = 222
	StarRocksParserRULE_showFunctionsStatement                 = 223
	StarRocksParserRULE_dropFunctionStatement                  = 224
	StarRocksParserRULE_createFunctionStatement                = 225
	StarRocksParserRULE_inlineFunction                         = 226
	StarRocksParserRULE_typeList                               = 227
	StarRocksParserRULE_loadStatement                          = 228
	StarRocksParserRULE_labelName                              = 229
	StarRocksParserRULE_dataDescList                           = 230
	StarRocksParserRULE_dataDesc                               = 231
	StarRocksParserRULE_formatProps                            = 232
	StarRocksParserRULE_brokerDesc                             = 233
	StarRocksParserRULE_resourceDesc                           = 234
	StarRocksParserRULE_showLoadStatement                      = 235
	StarRocksParserRULE_showLoadWarningsStatement              = 236
	StarRocksParserRULE_cancelLoadStatement                    = 237
	StarRocksParserRULE_alterLoadStatement                     = 238
	StarRocksParserRULE_cancelCompactionStatement              = 239
	StarRocksParserRULE_showAuthorStatement                    = 240
	StarRocksParserRULE_showBackendsStatement                  = 241
	StarRocksParserRULE_showBrokerStatement                    = 242
	StarRocksParserRULE_showCharsetStatement                   = 243
	StarRocksParserRULE_showCollationStatement                 = 244
	StarRocksParserRULE_showDeleteStatement                    = 245
	StarRocksParserRULE_showDynamicPartitionStatement          = 246
	StarRocksParserRULE_showEventsStatement                    = 247
	StarRocksParserRULE_showEnginesStatement                   = 248
	StarRocksParserRULE_showFrontendsStatement                 = 249
	StarRocksParserRULE_showPluginsStatement                   = 250
	StarRocksParserRULE_showRepositoriesStatement              = 251
	StarRocksParserRULE_showOpenTableStatement                 = 252
	StarRocksParserRULE_showPrivilegesStatement                = 253
	StarRocksParserRULE_showProcedureStatement                 = 254
	StarRocksParserRULE_showProcStatement                      = 255
	StarRocksParserRULE_showProcesslistStatement               = 256
	StarRocksParserRULE_showProfilelistStatement               = 257
	StarRocksParserRULE_showRunningQueriesStatement            = 258
	StarRocksParserRULE_showStatusStatement                    = 259
	StarRocksParserRULE_showTabletStatement                    = 260
	StarRocksParserRULE_showTransactionStatement               = 261
	StarRocksParserRULE_showTriggersStatement                  = 262
	StarRocksParserRULE_showUserPropertyStatement              = 263
	StarRocksParserRULE_showVariablesStatement                 = 264
	StarRocksParserRULE_showWarningStatement                   = 265
	StarRocksParserRULE_helpStatement                          = 266
	StarRocksParserRULE_createUserStatement                    = 267
	StarRocksParserRULE_dropUserStatement                      = 268
	StarRocksParserRULE_alterUserStatement                     = 269
	StarRocksParserRULE_showUserStatement                      = 270
	StarRocksParserRULE_showAuthenticationStatement            = 271
	StarRocksParserRULE_executeAsStatement                     = 272
	StarRocksParserRULE_createRoleStatement                    = 273
	StarRocksParserRULE_alterRoleStatement                     = 274
	StarRocksParserRULE_dropRoleStatement                      = 275
	StarRocksParserRULE_showRolesStatement                     = 276
	StarRocksParserRULE_grantRoleStatement                     = 277
	StarRocksParserRULE_revokeRoleStatement                    = 278
	StarRocksParserRULE_setRoleStatement                       = 279
	StarRocksParserRULE_setDefaultRoleStatement                = 280
	StarRocksParserRULE_grantRevokeClause                      = 281
	StarRocksParserRULE_grantPrivilegeStatement                = 282
	StarRocksParserRULE_revokePrivilegeStatement               = 283
	StarRocksParserRULE_showGrantsStatement                    = 284
	StarRocksParserRULE_authOption                             = 285
	StarRocksParserRULE_privObjectName                         = 286
	StarRocksParserRULE_privObjectNameList                     = 287
	StarRocksParserRULE_privFunctionObjectNameList             = 288
	StarRocksParserRULE_privilegeTypeList                      = 289
	StarRocksParserRULE_privilegeType                          = 290
	StarRocksParserRULE_privObjectType                         = 291
	StarRocksParserRULE_privObjectTypePlural                   = 292
	StarRocksParserRULE_createSecurityIntegrationStatement     = 293
	StarRocksParserRULE_alterSecurityIntegrationStatement      = 294
	StarRocksParserRULE_dropSecurityIntegrationStatement       = 295
	StarRocksParserRULE_showSecurityIntegrationStatement       = 296
	StarRocksParserRULE_showCreateSecurityIntegrationStatement = 297
	StarRocksParserRULE_createGroupProviderStatement           = 298
	StarRocksParserRULE_dropGroupProviderStatement             = 299
	StarRocksParserRULE_showGroupProvidersStatement            = 300
	StarRocksParserRULE_showCreateGroupProviderStatement       = 301
	StarRocksParserRULE_backupStatement                        = 302
	StarRocksParserRULE_cancelBackupStatement                  = 303
	StarRocksParserRULE_showBackupStatement                    = 304
	StarRocksParserRULE_restoreStatement                       = 305
	StarRocksParserRULE_cancelRestoreStatement                 = 306
	StarRocksParserRULE_showRestoreStatement                   = 307
	StarRocksParserRULE_showSnapshotStatement                  = 308
	StarRocksParserRULE_createRepositoryStatement              = 309
	StarRocksParserRULE_dropRepositoryStatement                = 310
	StarRocksParserRULE_addSqlBlackListStatement               = 311
	StarRocksParserRULE_delSqlBlackListStatement               = 312
	StarRocksParserRULE_showSqlBlackListStatement              = 313
	StarRocksParserRULE_showWhiteListStatement                 = 314
	StarRocksParserRULE_addBackendBlackListStatement           = 315
	StarRocksParserRULE_delBackendBlackListStatement           = 316
	StarRocksParserRULE_showBackendBlackListStatement          = 317
	StarRocksParserRULE_dataCacheTarget                        = 318
	StarRocksParserRULE_createDataCacheRuleStatement           = 319
	StarRocksParserRULE_showDataCacheRulesStatement            = 320
	StarRocksParserRULE_dropDataCacheRuleStatement             = 321
	StarRocksParserRULE_clearDataCacheRulesStatement           = 322
	StarRocksParserRULE_dataCacheSelectStatement               = 323
	StarRocksParserRULE_exportStatement                        = 324
	StarRocksParserRULE_cancelExportStatement                  = 325
	StarRocksParserRULE_showExportStatement                    = 326
	StarRocksParserRULE_installPluginStatement                 = 327
	StarRocksParserRULE_uninstallPluginStatement               = 328
	StarRocksParserRULE_createFileStatement                    = 329
	StarRocksParserRULE_dropFileStatement                      = 330
	StarRocksParserRULE_showSmallFilesStatement                = 331
	StarRocksParserRULE_createPipeStatement                    = 332
	StarRocksParserRULE_dropPipeStatement                      = 333
	StarRocksParserRULE_alterPipeClause                        = 334
	StarRocksParserRULE_alterPipeStatement                     = 335
	StarRocksParserRULE_descPipeStatement                      = 336
	StarRocksParserRULE_showPipeStatement                      = 337
	StarRocksParserRULE_setStatement                           = 338
	StarRocksParserRULE_setVar                                 = 339
	StarRocksParserRULE_transaction_characteristics            = 340
	StarRocksParserRULE_transaction_access_mode                = 341
	StarRocksParserRULE_isolation_level                        = 342
	StarRocksParserRULE_isolation_types                        = 343
	StarRocksParserRULE_setExprOrDefault                       = 344
	StarRocksParserRULE_setUserPropertyStatement               = 345
	StarRocksParserRULE_roleList                               = 346
	StarRocksParserRULE_executeScriptStatement                 = 347
	StarRocksParserRULE_unsupportedStatement                   = 348
	StarRocksParserRULE_lock_item                              = 349
	StarRocksParserRULE_lock_type                              = 350
	StarRocksParserRULE_alterPlanAdvisorAddStatement           = 351
	StarRocksParserRULE_truncatePlanAdvisorStatement           = 352
	StarRocksParserRULE_alterPlanAdvisorDropStatement          = 353
	StarRocksParserRULE_showPlanAdvisorStatement               = 354
	StarRocksParserRULE_createWarehouseStatement               = 355
	StarRocksParserRULE_dropWarehouseStatement                 = 356
	StarRocksParserRULE_suspendWarehouseStatement              = 357
	StarRocksParserRULE_resumeWarehouseStatement               = 358
	StarRocksParserRULE_setWarehouseStatement                  = 359
	StarRocksParserRULE_showWarehousesStatement                = 360
	StarRocksParserRULE_showClustersStatement                  = 361
	StarRocksParserRULE_showNodesStatement                     = 362
	StarRocksParserRULE_alterWarehouseStatement                = 363
	StarRocksParserRULE_createCNGroupStatement                 = 364
	StarRocksParserRULE_dropCNGroupStatement                   = 365
	StarRocksParserRULE_enableCNGroupStatement                 = 366
	StarRocksParserRULE_disableCNGroupStatement                = 367
	StarRocksParserRULE_alterCNGroupStatement                  = 368
	StarRocksParserRULE_beginStatement                         = 369
	StarRocksParserRULE_commitStatement                        = 370
	StarRocksParserRULE_rollbackStatement                      = 371
	StarRocksParserRULE_translateStatement                     = 372
	StarRocksParserRULE_dialect                                = 373
	StarRocksParserRULE_translateSQL                           = 374
	StarRocksParserRULE_queryStatement                         = 375
	StarRocksParserRULE_queryRelation                          = 376
	StarRocksParserRULE_withClause                             = 377
	StarRocksParserRULE_queryNoWith                            = 378
	StarRocksParserRULE_queryPeriod                            = 379
	StarRocksParserRULE_periodType                             = 380
	StarRocksParserRULE_queryPrimary                           = 381
	StarRocksParserRULE_subquery                               = 382
	StarRocksParserRULE_rowConstructor                         = 383
	StarRocksParserRULE_sortItem                               = 384
	StarRocksParserRULE_limitConstExpr                         = 385
	StarRocksParserRULE_limitElement                           = 386
	StarRocksParserRULE_querySpecification                     = 387
	StarRocksParserRULE_fromClause                             = 388
	StarRocksParserRULE_groupingElement                        = 389
	StarRocksParserRULE_groupingSet                            = 390
	StarRocksParserRULE_commonTableExpression                  = 391
	StarRocksParserRULE_setQuantifier                          = 392
	StarRocksParserRULE_selectItem                             = 393
	StarRocksParserRULE_excludeClause                          = 394
	StarRocksParserRULE_relations                              = 395
	StarRocksParserRULE_relation                               = 396
	StarRocksParserRULE_relationPrimary                        = 397
	StarRocksParserRULE_pivotClause                            = 398
	StarRocksParserRULE_pivotAggregationExpression             = 399
	StarRocksParserRULE_pivotValue                             = 400
	StarRocksParserRULE_sampleClause                           = 401
	StarRocksParserRULE_argumentList                           = 402
	StarRocksParserRULE_namedArgumentList                      = 403
	StarRocksParserRULE_namedArgument                          = 404
	StarRocksParserRULE_joinRelation                           = 405
	StarRocksParserRULE_crossOrInnerJoinType                   = 406
	StarRocksParserRULE_outerAndSemiJoinType                   = 407
	StarRocksParserRULE_bracketHint                            = 408
	StarRocksParserRULE_hintMap                                = 409
	StarRocksParserRULE_joinCriteria                           = 410
	StarRocksParserRULE_columnAliases                          = 411
	StarRocksParserRULE_partitionNames                         = 412
	StarRocksParserRULE_keyPartitions                          = 413
	StarRocksParserRULE_tabletList                             = 414
	StarRocksParserRULE_prepareStatement                       = 415
	StarRocksParserRULE_prepareSql                             = 416
	StarRocksParserRULE_executeStatement                       = 417
	StarRocksParserRULE_deallocateStatement                    = 418
	StarRocksParserRULE_replicaList                            = 419
	StarRocksParserRULE_expressionsWithDefault                 = 420
	StarRocksParserRULE_expressionOrDefault                    = 421
	StarRocksParserRULE_mapExpressionList                      = 422
	StarRocksParserRULE_mapExpression                          = 423
	StarRocksParserRULE_expressionSingleton                    = 424
	StarRocksParserRULE_expression                             = 425
	StarRocksParserRULE_expressionList                         = 426
	StarRocksParserRULE_booleanExpression                      = 427
	StarRocksParserRULE_predicate                              = 428
	StarRocksParserRULE_tupleInSubquery                        = 429
	StarRocksParserRULE_predicateOperations                    = 430
	StarRocksParserRULE_valueExpression                        = 431
	StarRocksParserRULE_primaryExpression                      = 432
	StarRocksParserRULE_literalExpression                      = 433
	StarRocksParserRULE_functionCall                           = 434
	StarRocksParserRULE_aggregationFunction                    = 435
	StarRocksParserRULE_userVariable                           = 436
	StarRocksParserRULE_systemVariable                         = 437
	StarRocksParserRULE_columnReference                        = 438
	StarRocksParserRULE_informationFunctionExpression          = 439
	StarRocksParserRULE_specialDateTimeExpression              = 440
	StarRocksParserRULE_specialFunctionExpression              = 441
	StarRocksParserRULE_windowFunction                         = 442
	StarRocksParserRULE_whenClause                             = 443
	StarRocksParserRULE_over                                   = 444
	StarRocksParserRULE_ignoreNulls                            = 445
	StarRocksParserRULE_windowFrame                            = 446
	StarRocksParserRULE_frameBound                             = 447
	StarRocksParserRULE_backupRestoreObjectDesc                = 448
	StarRocksParserRULE_tableDesc                              = 449
	StarRocksParserRULE_backupRestoreTableDesc                 = 450
	StarRocksParserRULE_explainDesc                            = 451
	StarRocksParserRULE_optimizerTrace                         = 452
	StarRocksParserRULE_partitionExpr                          = 453
	StarRocksParserRULE_partitionDesc                          = 454
	StarRocksParserRULE_listPartitionDesc                      = 455
	StarRocksParserRULE_singleItemListPartitionDesc            = 456
	StarRocksParserRULE_multiItemListPartitionDesc             = 457
	StarRocksParserRULE_multiListPartitionValues               = 458
	StarRocksParserRULE_singleListPartitionValues              = 459
	StarRocksParserRULE_listPartitionValues                    = 460
	StarRocksParserRULE_listPartitionValue                     = 461
	StarRocksParserRULE_stringList                             = 462
	StarRocksParserRULE_literalExpressionList                  = 463
	StarRocksParserRULE_rangePartitionDesc                     = 464
	StarRocksParserRULE_singleRangePartition                   = 465
	StarRocksParserRULE_multiRangePartition                    = 466
	StarRocksParserRULE_partitionRangeDesc                     = 467
	StarRocksParserRULE_partitionKeyDesc                       = 468
	StarRocksParserRULE_partitionValueList                     = 469
	StarRocksParserRULE_keyPartition                           = 470
	StarRocksParserRULE_partitionValue                         = 471
	StarRocksParserRULE_distributionClause                     = 472
	StarRocksParserRULE_distributionDesc                       = 473
	StarRocksParserRULE_refreshSchemeDesc                      = 474
	StarRocksParserRULE_statusDesc                             = 475
	StarRocksParserRULE_properties                             = 476
	StarRocksParserRULE_extProperties                          = 477
	StarRocksParserRULE_propertyList                           = 478
	StarRocksParserRULE_userPropertyList                       = 479
	StarRocksParserRULE_property                               = 480
	StarRocksParserRULE_inlineProperties                       = 481
	StarRocksParserRULE_inlineProperty                         = 482
	StarRocksParserRULE_varType                                = 483
	StarRocksParserRULE_comment                                = 484
	StarRocksParserRULE_outfile                                = 485
	StarRocksParserRULE_fileFormat                             = 486
	StarRocksParserRULE_string                                 = 487
	StarRocksParserRULE_binary                                 = 488
	StarRocksParserRULE_comparisonOperator                     = 489
	StarRocksParserRULE_booleanValue                           = 490
	StarRocksParserRULE_interval                               = 491
	StarRocksParserRULE_taskInterval                           = 492
	StarRocksParserRULE_taskUnitIdentifier                     = 493
	StarRocksParserRULE_unitIdentifier                         = 494
	StarRocksParserRULE_unitBoundary                           = 495
	StarRocksParserRULE_type                                   = 496
	StarRocksParserRULE_arrayType                              = 497
	StarRocksParserRULE_mapType                                = 498
	StarRocksParserRULE_subfieldDesc                           = 499
	StarRocksParserRULE_subfieldDescs                          = 500
	StarRocksParserRULE_structType                             = 501
	StarRocksParserRULE_typeParameter                          = 502
	StarRocksParserRULE_baseType                               = 503
	StarRocksParserRULE_decimalType                            = 504
	StarRocksParserRULE_qualifiedName                          = 505
	StarRocksParserRULE_tableName                              = 506
	StarRocksParserRULE_writeBranch                            = 507
	StarRocksParserRULE_identifier                             = 508
	StarRocksParserRULE_identifierWithAlias                    = 509
	StarRocksParserRULE_identifierWithAliasList                = 510
	StarRocksParserRULE_identifierList                         = 511
	StarRocksParserRULE_identifierOrString                     = 512
	StarRocksParserRULE_identifierOrStringList                 = 513
	StarRocksParserRULE_identifierOrStringOrStar               = 514
	StarRocksParserRULE_user                                   = 515
	StarRocksParserRULE_assignment                             = 516
	StarRocksParserRULE_assignmentList                         = 517
	StarRocksParserRULE_number                                 = 518
	StarRocksParserRULE_nonReserved                            = 519
)

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSingleStatement() []ISingleStatementContext
	SingleStatement(i int) ISingleStatementContext

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEOF, 0)
}

func (s *SqlStatementsContext) AllSingleStatement() []ISingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleStatementContext); ok {
			tst[i] = t.(ISingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (s *SqlStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSqlStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, StarRocksParserRULE_sqlStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216174019065962500) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&433475862185117699) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&72198331526709249) != 0) || ((int64((_la-209)) & ^0x3f) == 0 && ((int64(1)<<(_la-209))&17180917763) != 0) || ((int64((_la-307)) & ^0x3f) == 0 && ((int64(1)<<(_la-307))&4827862099076087809) != 0) || ((int64((_la-375)) & ^0x3f) == 0 && ((int64(1)<<(_la-375))&14332375138305) != 0) || ((int64((_la-440)) & ^0x3f) == 0 && ((int64(1)<<(_la-440))&107752139857989) != 0) || _la == StarRocksParserSEMICOLON {
		{
			p.SetState(1040)
			p.SingleStatement()
		}

		p.SetState(1043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1045)
		p.Match(StarRocksParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SEMICOLON() antlr.TerminalNode
	EOF() antlr.TerminalNode
	EmptyStatement() IEmptyStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMICOLON, 0)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEOF, 0)
}

func (s *SingleStatementContext) EmptyStatement() IEmptyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (s *SingleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSingleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, StarRocksParserRULE_singleStatement)
	var _la int

	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserADD, StarRocksParserADMIN, StarRocksParserALTER, StarRocksParserANALYZE, StarRocksParserBACKUP, StarRocksParserBEGIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCOMMIT, StarRocksParserCREATE, StarRocksParserDEALLOCATE, StarRocksParserDELETE, StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserDROP, StarRocksParserEXECUTE, StarRocksParserEXPLAIN, StarRocksParserEXPORT, StarRocksParserGRANT, StarRocksParserHELP, StarRocksParserINSTALL, StarRocksParserINSERT, StarRocksParserKILL, StarRocksParserLOAD, StarRocksParserPAUSE, StarRocksParserPREPARE, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserREVOKE, StarRocksParserROLLBACK, StarRocksParserSELECT, StarRocksParserSET, StarRocksParserSHOW, StarRocksParserSTART, StarRocksParserSTOP, StarRocksParserSUBMIT, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRUNCATE, StarRocksParserUNINSTALL, StarRocksParserUPDATE, StarRocksParserUSE, StarRocksParserWITH, StarRocksParserLOCK, StarRocksParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1047)
			p.Statement()
		}
		{
			p.SetState(1048)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserEOF || _la == StarRocksParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StarRocksParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1050)
			p.EmptyStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatementContext is an interface to support dynamic dispatch.
type IEmptyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode

	// IsEmptyStatementContext differentiates from other interfaces.
	IsEmptyStatementContext()
}

type EmptyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatementContext() *EmptyStatementContext {
	var p = new(EmptyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_emptyStatement
	return p
}

func InitEmptyEmptyStatementContext(p *EmptyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_emptyStatement
}

func (*EmptyStatementContext) IsEmptyStatementContext() {}

func NewEmptyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatementContext {
	var p = new(EmptyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_emptyStatement

	return p
}

func (s *EmptyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMICOLON, 0)
}

func (s *EmptyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitEmptyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) EmptyStatement() (localctx IEmptyStatementContext) {
	localctx = NewEmptyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, StarRocksParserRULE_emptyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1053)
		p.Match(StarRocksParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryStatement() IQueryStatementContext
	UseDatabaseStatement() IUseDatabaseStatementContext
	UseCatalogStatement() IUseCatalogStatementContext
	SetCatalogStatement() ISetCatalogStatementContext
	ShowDatabasesStatement() IShowDatabasesStatementContext
	AlterDbQuotaStatement() IAlterDbQuotaStatementContext
	CreateDbStatement() ICreateDbStatementContext
	DropDbStatement() IDropDbStatementContext
	ShowCreateDbStatement() IShowCreateDbStatementContext
	AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext
	RecoverDbStmt() IRecoverDbStmtContext
	ShowDataStmt() IShowDataStmtContext
	ShowDataDistributionStmt() IShowDataDistributionStmtContext
	CreateTableStatement() ICreateTableStatementContext
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	CreateTableLikeStatement() ICreateTableLikeStatementContext
	ShowCreateTableStatement() IShowCreateTableStatementContext
	DropTableStatement() IDropTableStatementContext
	CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext
	RecoverTableStatement() IRecoverTableStatementContext
	TruncateTableStatement() ITruncateTableStatementContext
	ShowTableStatement() IShowTableStatementContext
	DescTableStatement() IDescTableStatementContext
	ShowTableStatusStatement() IShowTableStatusStatementContext
	ShowColumnStatement() IShowColumnStatementContext
	RefreshTableStatement() IRefreshTableStatementContext
	AlterTableStatement() IAlterTableStatementContext
	CancelAlterTableStatement() ICancelAlterTableStatementContext
	ShowAlterStatement() IShowAlterStatementContext
	ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext
	CreateViewStatement() ICreateViewStatementContext
	AlterViewStatement() IAlterViewStatementContext
	DropViewStatement() IDropViewStatementContext
	ShowPartitionsStatement() IShowPartitionsStatementContext
	RecoverPartitionStatement() IRecoverPartitionStatementContext
	CreateIndexStatement() ICreateIndexStatementContext
	DropIndexStatement() IDropIndexStatementContext
	ShowIndexStatement() IShowIndexStatementContext
	SubmitTaskStatement() ISubmitTaskStatementContext
	DropTaskStatement() IDropTaskStatementContext
	CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext
	ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext
	DropMaterializedViewStatement() IDropMaterializedViewStatementContext
	AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext
	RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext
	CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext
	CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext
	DropExternalCatalogStatement() IDropExternalCatalogStatementContext
	ShowCatalogsStatement() IShowCatalogsStatementContext
	ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext
	AlterCatalogStatement() IAlterCatalogStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext
	AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext
	StopRoutineLoadStatement() IStopRoutineLoadStatementContext
	ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext
	PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext
	ShowRoutineLoadStatement() IShowRoutineLoadStatementContext
	ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext
	ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext
	ShowStreamLoadStatement() IShowStreamLoadStatementContext
	AdminSetConfigStatement() IAdminSetConfigStatementContext
	AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext
	AdminShowConfigStatement() IAdminShowConfigStatementContext
	AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext
	AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext
	AdminRepairTableStatement() IAdminRepairTableStatementContext
	AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext
	AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext
	AdminSetPartitionVersion() IAdminSetPartitionVersionContext
	KillStatement() IKillStatementContext
	SyncStatement() ISyncStatementContext
	ExecuteScriptStatement() IExecuteScriptStatementContext
	AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext
	AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext
	AlterSystemStatement() IAlterSystemStatementContext
	CancelAlterSystemStatement() ICancelAlterSystemStatementContext
	ShowComputeNodesStatement() IShowComputeNodesStatementContext
	AnalyzeStatement() IAnalyzeStatementContext
	DropStatsStatement() IDropStatsStatementContext
	CreateAnalyzeStatement() ICreateAnalyzeStatementContext
	DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext
	AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext
	DropHistogramStatement() IDropHistogramStatementContext
	ShowAnalyzeStatement() IShowAnalyzeStatementContext
	ShowStatsMetaStatement() IShowStatsMetaStatementContext
	ShowHistogramMetaStatement() IShowHistogramMetaStatementContext
	KillAnalyzeStatement() IKillAnalyzeStatementContext
	AnalyzeProfileStatement() IAnalyzeProfileStatementContext
	CreateResourceGroupStatement() ICreateResourceGroupStatementContext
	DropResourceGroupStatement() IDropResourceGroupStatementContext
	AlterResourceGroupStatement() IAlterResourceGroupStatementContext
	ShowResourceGroupStatement() IShowResourceGroupStatementContext
	ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext
	CreateResourceStatement() ICreateResourceStatementContext
	AlterResourceStatement() IAlterResourceStatementContext
	DropResourceStatement() IDropResourceStatementContext
	ShowResourceStatement() IShowResourceStatementContext
	ShowFunctionsStatement() IShowFunctionsStatementContext
	DropFunctionStatement() IDropFunctionStatementContext
	CreateFunctionStatement() ICreateFunctionStatementContext
	LoadStatement() ILoadStatementContext
	ShowLoadStatement() IShowLoadStatementContext
	ShowLoadWarningsStatement() IShowLoadWarningsStatementContext
	CancelLoadStatement() ICancelLoadStatementContext
	AlterLoadStatement() IAlterLoadStatementContext
	ShowAuthorStatement() IShowAuthorStatementContext
	ShowBackendsStatement() IShowBackendsStatementContext
	ShowBrokerStatement() IShowBrokerStatementContext
	ShowCharsetStatement() IShowCharsetStatementContext
	ShowCollationStatement() IShowCollationStatementContext
	ShowDeleteStatement() IShowDeleteStatementContext
	ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext
	ShowEventsStatement() IShowEventsStatementContext
	ShowEnginesStatement() IShowEnginesStatementContext
	ShowFrontendsStatement() IShowFrontendsStatementContext
	ShowPluginsStatement() IShowPluginsStatementContext
	ShowRepositoriesStatement() IShowRepositoriesStatementContext
	ShowOpenTableStatement() IShowOpenTableStatementContext
	ShowPrivilegesStatement() IShowPrivilegesStatementContext
	ShowProcedureStatement() IShowProcedureStatementContext
	ShowProcStatement() IShowProcStatementContext
	ShowProcesslistStatement() IShowProcesslistStatementContext
	ShowProfilelistStatement() IShowProfilelistStatementContext
	ShowRunningQueriesStatement() IShowRunningQueriesStatementContext
	ShowStatusStatement() IShowStatusStatementContext
	ShowTabletStatement() IShowTabletStatementContext
	ShowTransactionStatement() IShowTransactionStatementContext
	ShowTriggersStatement() IShowTriggersStatementContext
	ShowUserPropertyStatement() IShowUserPropertyStatementContext
	ShowVariablesStatement() IShowVariablesStatementContext
	ShowWarningStatement() IShowWarningStatementContext
	HelpStatement() IHelpStatementContext
	CreateUserStatement() ICreateUserStatementContext
	DropUserStatement() IDropUserStatementContext
	AlterUserStatement() IAlterUserStatementContext
	ShowUserStatement() IShowUserStatementContext
	ShowAuthenticationStatement() IShowAuthenticationStatementContext
	ExecuteAsStatement() IExecuteAsStatementContext
	CreateRoleStatement() ICreateRoleStatementContext
	AlterRoleStatement() IAlterRoleStatementContext
	DropRoleStatement() IDropRoleStatementContext
	ShowRolesStatement() IShowRolesStatementContext
	GrantRoleStatement() IGrantRoleStatementContext
	RevokeRoleStatement() IRevokeRoleStatementContext
	SetRoleStatement() ISetRoleStatementContext
	SetDefaultRoleStatement() ISetDefaultRoleStatementContext
	GrantPrivilegeStatement() IGrantPrivilegeStatementContext
	RevokePrivilegeStatement() IRevokePrivilegeStatementContext
	ShowGrantsStatement() IShowGrantsStatementContext
	CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext
	AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext
	DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext
	ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext
	ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext
	CreateGroupProviderStatement() ICreateGroupProviderStatementContext
	DropGroupProviderStatement() IDropGroupProviderStatementContext
	ShowGroupProvidersStatement() IShowGroupProvidersStatementContext
	ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext
	BackupStatement() IBackupStatementContext
	CancelBackupStatement() ICancelBackupStatementContext
	ShowBackupStatement() IShowBackupStatementContext
	RestoreStatement() IRestoreStatementContext
	CancelRestoreStatement() ICancelRestoreStatementContext
	ShowRestoreStatement() IShowRestoreStatementContext
	ShowSnapshotStatement() IShowSnapshotStatementContext
	CreateRepositoryStatement() ICreateRepositoryStatementContext
	DropRepositoryStatement() IDropRepositoryStatementContext
	AddSqlBlackListStatement() IAddSqlBlackListStatementContext
	DelSqlBlackListStatement() IDelSqlBlackListStatementContext
	ShowSqlBlackListStatement() IShowSqlBlackListStatementContext
	ShowWhiteListStatement() IShowWhiteListStatementContext
	AddBackendBlackListStatement() IAddBackendBlackListStatementContext
	DelBackendBlackListStatement() IDelBackendBlackListStatementContext
	ShowBackendBlackListStatement() IShowBackendBlackListStatementContext
	CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext
	ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext
	DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext
	ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	ExportStatement() IExportStatementContext
	CancelExportStatement() ICancelExportStatementContext
	ShowExportStatement() IShowExportStatementContext
	InstallPluginStatement() IInstallPluginStatementContext
	UninstallPluginStatement() IUninstallPluginStatementContext
	CreateFileStatement() ICreateFileStatementContext
	DropFileStatement() IDropFileStatementContext
	ShowSmallFilesStatement() IShowSmallFilesStatementContext
	SetStatement() ISetStatementContext
	SetUserPropertyStatement() ISetUserPropertyStatementContext
	CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext
	AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext
	DropStorageVolumeStatement() IDropStorageVolumeStatementContext
	ShowStorageVolumesStatement() IShowStorageVolumesStatementContext
	DescStorageVolumeStatement() IDescStorageVolumeStatementContext
	SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext
	CreatePipeStatement() ICreatePipeStatementContext
	DropPipeStatement() IDropPipeStatementContext
	AlterPipeStatement() IAlterPipeStatementContext
	ShowPipeStatement() IShowPipeStatementContext
	DescPipeStatement() IDescPipeStatementContext
	CancelCompactionStatement() ICancelCompactionStatementContext
	UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext
	ShowFailPointStatement() IShowFailPointStatementContext
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocateStatement() IDeallocateStatementContext
	CreateDictionaryStatement() ICreateDictionaryStatementContext
	DropDictionaryStatement() IDropDictionaryStatementContext
	RefreshDictionaryStatement() IRefreshDictionaryStatementContext
	ShowDictionaryStatement() IShowDictionaryStatementContext
	CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext
	AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext
	TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext
	AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext
	ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext
	CreateWarehouseStatement() ICreateWarehouseStatementContext
	DropWarehouseStatement() IDropWarehouseStatementContext
	SuspendWarehouseStatement() ISuspendWarehouseStatementContext
	ResumeWarehouseStatement() IResumeWarehouseStatementContext
	SetWarehouseStatement() ISetWarehouseStatementContext
	ShowWarehousesStatement() IShowWarehousesStatementContext
	ShowClustersStatement() IShowClustersStatementContext
	ShowNodesStatement() IShowNodesStatementContext
	AlterWarehouseStatement() IAlterWarehouseStatementContext
	CreateCNGroupStatement() ICreateCNGroupStatementContext
	DropCNGroupStatement() IDropCNGroupStatementContext
	EnableCNGroupStatement() IEnableCNGroupStatementContext
	DisableCNGroupStatement() IDisableCNGroupStatementContext
	AlterCNGroupStatement() IAlterCNGroupStatementContext
	BeginStatement() IBeginStatementContext
	CommitStatement() ICommitStatementContext
	RollbackStatement() IRollbackStatementContext
	TranslateStatement() ITranslateStatementContext
	CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext
	DropBaselinePlanStatement() IDropBaselinePlanStatementContext
	ShowBaselinePlanStatement() IShowBaselinePlanStatementContext
	UnsupportedStatement() IUnsupportedStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

/*func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	parser.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_statement
	return p
}*/


func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *StatementContext) UseDatabaseStatement() IUseDatabaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDatabaseStatementContext)
}

func (s *StatementContext) UseCatalogStatement() IUseCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseCatalogStatementContext)
}

func (s *StatementContext) SetCatalogStatement() ISetCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetCatalogStatementContext)
}

func (s *StatementContext) ShowDatabasesStatement() IShowDatabasesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDatabasesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDatabasesStatementContext)
}

func (s *StatementContext) AlterDbQuotaStatement() IAlterDbQuotaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDbQuotaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDbQuotaStatementContext)
}

func (s *StatementContext) CreateDbStatement() ICreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDbStatementContext)
}

func (s *StatementContext) DropDbStatement() IDropDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDbStatementContext)
}

func (s *StatementContext) ShowCreateDbStatement() IShowCreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateDbStatementContext)
}

func (s *StatementContext) AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseRenameStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseRenameStatementContext)
}

func (s *StatementContext) RecoverDbStmt() IRecoverDbStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverDbStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverDbStmtContext)
}

func (s *StatementContext) ShowDataStmt() IShowDataStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataStmtContext)
}

func (s *StatementContext) ShowDataDistributionStmt() IShowDataDistributionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataDistributionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataDistributionStmtContext)
}

func (s *StatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *StatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *StatementContext) CreateTableLikeStatement() ICreateTableLikeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableLikeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableLikeStatementContext)
}

func (s *StatementContext) ShowCreateTableStatement() IShowCreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateTableStatementContext)
}

func (s *StatementContext) DropTableStatement() IDropTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableStatementContext)
}

func (s *StatementContext) CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTemporaryTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTemporaryTableStatementContext)
}

func (s *StatementContext) RecoverTableStatement() IRecoverTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverTableStatementContext)
}

func (s *StatementContext) TruncateTableStatement() ITruncateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableStatementContext)
}

func (s *StatementContext) ShowTableStatement() IShowTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatementContext)
}

func (s *StatementContext) DescTableStatement() IDescTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescTableStatementContext)
}

func (s *StatementContext) ShowTableStatusStatement() IShowTableStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatusStatementContext)
}

func (s *StatementContext) ShowColumnStatement() IShowColumnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowColumnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowColumnStatementContext)
}

func (s *StatementContext) RefreshTableStatement() IRefreshTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTableStatementContext)
}

func (s *StatementContext) AlterTableStatement() IAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableStatementContext)
}

func (s *StatementContext) CancelAlterTableStatement() ICancelAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterTableStatementContext)
}

func (s *StatementContext) ShowAlterStatement() IShowAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAlterStatementContext)
}

func (s *StatementContext) ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTemporaryTablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTemporaryTablesStatementContext)
}

func (s *StatementContext) CreateViewStatement() ICreateViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewStatementContext)
}

func (s *StatementContext) AlterViewStatement() IAlterViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewStatementContext)
}

func (s *StatementContext) DropViewStatement() IDropViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewStatementContext)
}

func (s *StatementContext) ShowPartitionsStatement() IShowPartitionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPartitionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPartitionsStatementContext)
}

func (s *StatementContext) RecoverPartitionStatement() IRecoverPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverPartitionStatementContext)
}

func (s *StatementContext) CreateIndexStatement() ICreateIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexStatementContext)
}

func (s *StatementContext) DropIndexStatement() IDropIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexStatementContext)
}

func (s *StatementContext) ShowIndexStatement() IShowIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowIndexStatementContext)
}

func (s *StatementContext) SubmitTaskStatement() ISubmitTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubmitTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubmitTaskStatementContext)
}

func (s *StatementContext) DropTaskStatement() IDropTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTaskStatementContext)
}

func (s *StatementContext) CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewStatementContext)
}

func (s *StatementContext) ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowMaterializedViewsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowMaterializedViewsStatementContext)
}

func (s *StatementContext) DropMaterializedViewStatement() IDropMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewStatementContext)
}

func (s *StatementContext) AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewStatementContext)
}

func (s *StatementContext) RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateExternalCatalogStatementContext)
}

func (s *StatementContext) DropExternalCatalogStatement() IDropExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropExternalCatalogStatementContext)
}

func (s *StatementContext) ShowCatalogsStatement() IShowCatalogsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCatalogsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCatalogsStatementContext)
}

func (s *StatementContext) ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateExternalCatalogStatementContext)
}

func (s *StatementContext) AlterCatalogStatement() IAlterCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCatalogStatementContext)
}

func (s *StatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *StatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoutineLoadStatementContext)
}

func (s *StatementContext) AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineLoadStatementContext)
}

func (s *StatementContext) StopRoutineLoadStatement() IStopRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopRoutineLoadStatementContext)
}

func (s *StatementContext) ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeRoutineLoadStatementContext)
}

func (s *StatementContext) PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPauseRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPauseRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadStatement() IShowRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadTaskStatementContext)
}

func (s *StatementContext) ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateRoutineLoadStatementContext)
}

func (s *StatementContext) ShowStreamLoadStatement() IShowStreamLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStreamLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStreamLoadStatementContext)
}

func (s *StatementContext) AdminSetConfigStatement() IAdminSetConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetConfigStatementContext)
}

func (s *StatementContext) AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetReplicaStatusStatementContext)
}

func (s *StatementContext) AdminShowConfigStatement() IAdminShowConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowConfigStatementContext)
}

func (s *StatementContext) AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaDistributionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaDistributionStatementContext)
}

func (s *StatementContext) AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaStatusStatementContext)
}

func (s *StatementContext) AdminRepairTableStatement() IAdminRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminRepairTableStatementContext)
}

func (s *StatementContext) AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCancelRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCancelRepairTableStatementContext)
}

func (s *StatementContext) AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCheckTabletsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCheckTabletsStatementContext)
}

func (s *StatementContext) AdminSetPartitionVersion() IAdminSetPartitionVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetPartitionVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetPartitionVersionContext)
}

func (s *StatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *StatementContext) SyncStatement() ISyncStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyncStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyncStatementContext)
}

func (s *StatementContext) ExecuteScriptStatement() IExecuteScriptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteScriptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteScriptStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOnStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOffStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOffStatementContext)
}

func (s *StatementContext) AlterSystemStatement() IAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemStatementContext)
}

func (s *StatementContext) CancelAlterSystemStatement() ICancelAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterSystemStatementContext)
}

func (s *StatementContext) ShowComputeNodesStatement() IShowComputeNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowComputeNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowComputeNodesStatementContext)
}

func (s *StatementContext) AnalyzeStatement() IAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeStatementContext)
}

func (s *StatementContext) DropStatsStatement() IDropStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStatsStatementContext)
}

func (s *StatementContext) CreateAnalyzeStatement() ICreateAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateAnalyzeStatementContext)
}

func (s *StatementContext) DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropAnalyzeJobStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropAnalyzeJobStatementContext)
}

func (s *StatementContext) AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeHistogramStatementContext)
}

func (s *StatementContext) DropHistogramStatement() IDropHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropHistogramStatementContext)
}

func (s *StatementContext) ShowAnalyzeStatement() IShowAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAnalyzeStatementContext)
}

func (s *StatementContext) ShowStatsMetaStatement() IShowStatsMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatsMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatsMetaStatementContext)
}

func (s *StatementContext) ShowHistogramMetaStatement() IShowHistogramMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowHistogramMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowHistogramMetaStatementContext)
}

func (s *StatementContext) KillAnalyzeStatement() IKillAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillAnalyzeStatementContext)
}

func (s *StatementContext) AnalyzeProfileStatement() IAnalyzeProfileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeProfileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeProfileStatementContext)
}

func (s *StatementContext) CreateResourceGroupStatement() ICreateResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceGroupStatementContext)
}

func (s *StatementContext) DropResourceGroupStatement() IDropResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceGroupStatementContext)
}

func (s *StatementContext) AlterResourceGroupStatement() IAlterResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupStatement() IShowResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupUsageStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupUsageStatementContext)
}

func (s *StatementContext) CreateResourceStatement() ICreateResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceStatementContext)
}

func (s *StatementContext) AlterResourceStatement() IAlterResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceStatementContext)
}

func (s *StatementContext) DropResourceStatement() IDropResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceStatementContext)
}

func (s *StatementContext) ShowResourceStatement() IShowResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceStatementContext)
}

func (s *StatementContext) ShowFunctionsStatement() IShowFunctionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFunctionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFunctionsStatementContext)
}

func (s *StatementContext) DropFunctionStatement() IDropFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionStatementContext)
}

func (s *StatementContext) CreateFunctionStatement() ICreateFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionStatementContext)
}

func (s *StatementContext) LoadStatement() ILoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadStatementContext)
}

func (s *StatementContext) ShowLoadStatement() IShowLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadStatementContext)
}

func (s *StatementContext) ShowLoadWarningsStatement() IShowLoadWarningsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadWarningsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadWarningsStatementContext)
}

func (s *StatementContext) CancelLoadStatement() ICancelLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelLoadStatementContext)
}

func (s *StatementContext) AlterLoadStatement() IAlterLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadStatementContext)
}

func (s *StatementContext) ShowAuthorStatement() IShowAuthorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthorStatementContext)
}

func (s *StatementContext) ShowBackendsStatement() IShowBackendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendsStatementContext)
}

func (s *StatementContext) ShowBrokerStatement() IShowBrokerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBrokerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBrokerStatementContext)
}

func (s *StatementContext) ShowCharsetStatement() IShowCharsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCharsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCharsetStatementContext)
}

func (s *StatementContext) ShowCollationStatement() IShowCollationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCollationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCollationStatementContext)
}

func (s *StatementContext) ShowDeleteStatement() IShowDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDeleteStatementContext)
}

func (s *StatementContext) ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDynamicPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDynamicPartitionStatementContext)
}

func (s *StatementContext) ShowEventsStatement() IShowEventsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEventsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEventsStatementContext)
}

func (s *StatementContext) ShowEnginesStatement() IShowEnginesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEnginesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEnginesStatementContext)
}

func (s *StatementContext) ShowFrontendsStatement() IShowFrontendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFrontendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFrontendsStatementContext)
}

func (s *StatementContext) ShowPluginsStatement() IShowPluginsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPluginsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPluginsStatementContext)
}

func (s *StatementContext) ShowRepositoriesStatement() IShowRepositoriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRepositoriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRepositoriesStatementContext)
}

func (s *StatementContext) ShowOpenTableStatement() IShowOpenTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowOpenTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowOpenTableStatementContext)
}

func (s *StatementContext) ShowPrivilegesStatement() IShowPrivilegesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPrivilegesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPrivilegesStatementContext)
}

func (s *StatementContext) ShowProcedureStatement() IShowProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcedureStatementContext)
}

func (s *StatementContext) ShowProcStatement() IShowProcStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcStatementContext)
}

func (s *StatementContext) ShowProcesslistStatement() IShowProcesslistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcesslistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcesslistStatementContext)
}

func (s *StatementContext) ShowProfilelistStatement() IShowProfilelistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfilelistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfilelistStatementContext)
}

func (s *StatementContext) ShowRunningQueriesStatement() IShowRunningQueriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRunningQueriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRunningQueriesStatementContext)
}

func (s *StatementContext) ShowStatusStatement() IShowStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatusStatementContext)
}

func (s *StatementContext) ShowTabletStatement() IShowTabletStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTabletStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTabletStatementContext)
}

func (s *StatementContext) ShowTransactionStatement() IShowTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTransactionStatementContext)
}

func (s *StatementContext) ShowTriggersStatement() IShowTriggersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTriggersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTriggersStatementContext)
}

func (s *StatementContext) ShowUserPropertyStatement() IShowUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserPropertyStatementContext)
}

func (s *StatementContext) ShowVariablesStatement() IShowVariablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowVariablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowVariablesStatementContext)
}

func (s *StatementContext) ShowWarningStatement() IShowWarningStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarningStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarningStatementContext)
}

func (s *StatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *StatementContext) CreateUserStatement() ICreateUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserStatementContext)
}

func (s *StatementContext) DropUserStatement() IDropUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserStatementContext)
}

func (s *StatementContext) AlterUserStatement() IAlterUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserStatementContext)
}

func (s *StatementContext) ShowUserStatement() IShowUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserStatementContext)
}

func (s *StatementContext) ShowAuthenticationStatement() IShowAuthenticationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthenticationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthenticationStatementContext)
}

func (s *StatementContext) ExecuteAsStatement() IExecuteAsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteAsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteAsStatementContext)
}

func (s *StatementContext) CreateRoleStatement() ICreateRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleStatementContext)
}

func (s *StatementContext) AlterRoleStatement() IAlterRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoleStatementContext)
}

func (s *StatementContext) DropRoleStatement() IDropRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleStatementContext)
}

func (s *StatementContext) ShowRolesStatement() IShowRolesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRolesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRolesStatementContext)
}

func (s *StatementContext) GrantRoleStatement() IGrantRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRoleStatementContext)
}

func (s *StatementContext) RevokeRoleStatement() IRevokeRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeRoleStatementContext)
}

func (s *StatementContext) SetRoleStatement() ISetRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleStatementContext)
}

func (s *StatementContext) SetDefaultRoleStatement() ISetDefaultRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultRoleStatementContext)
}

func (s *StatementContext) GrantPrivilegeStatement() IGrantPrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantPrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantPrivilegeStatementContext)
}

func (s *StatementContext) RevokePrivilegeStatement() IRevokePrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokePrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokePrivilegeStatementContext)
}

func (s *StatementContext) ShowGrantsStatement() IShowGrantsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGrantsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGrantsStatementContext)
}

func (s *StatementContext) CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSecurityIntegrationStatementContext)
}

func (s *StatementContext) DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) CreateGroupProviderStatement() ICreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateGroupProviderStatementContext)
}

func (s *StatementContext) DropGroupProviderStatement() IDropGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropGroupProviderStatementContext)
}

func (s *StatementContext) ShowGroupProvidersStatement() IShowGroupProvidersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGroupProvidersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGroupProvidersStatementContext)
}

func (s *StatementContext) ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateGroupProviderStatementContext)
}

func (s *StatementContext) BackupStatement() IBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupStatementContext)
}

func (s *StatementContext) CancelBackupStatement() ICancelBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelBackupStatementContext)
}

func (s *StatementContext) ShowBackupStatement() IShowBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackupStatementContext)
}

func (s *StatementContext) RestoreStatement() IRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestoreStatementContext)
}

func (s *StatementContext) CancelRestoreStatement() ICancelRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRestoreStatementContext)
}

func (s *StatementContext) ShowRestoreStatement() IShowRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRestoreStatementContext)
}

func (s *StatementContext) ShowSnapshotStatement() IShowSnapshotStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSnapshotStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSnapshotStatementContext)
}

func (s *StatementContext) CreateRepositoryStatement() ICreateRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRepositoryStatementContext)
}

func (s *StatementContext) DropRepositoryStatement() IDropRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRepositoryStatementContext)
}

func (s *StatementContext) AddSqlBlackListStatement() IAddSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddSqlBlackListStatementContext)
}

func (s *StatementContext) DelSqlBlackListStatement() IDelSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelSqlBlackListStatementContext)
}

func (s *StatementContext) ShowSqlBlackListStatement() IShowSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSqlBlackListStatementContext)
}

func (s *StatementContext) ShowWhiteListStatement() IShowWhiteListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWhiteListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWhiteListStatementContext)
}

func (s *StatementContext) AddBackendBlackListStatement() IAddBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendBlackListStatementContext)
}

func (s *StatementContext) DelBackendBlackListStatement() IDelBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelBackendBlackListStatementContext)
}

func (s *StatementContext) ShowBackendBlackListStatement() IShowBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendBlackListStatementContext)
}

func (s *StatementContext) CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDataCacheRuleStatementContext)
}

func (s *StatementContext) ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataCacheRulesStatementContext)
}

func (s *StatementContext) DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDataCacheRuleStatementContext)
}

func (s *StatementContext) ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClearDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClearDataCacheRulesStatementContext)
}

func (s *StatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) CancelExportStatement() ICancelExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelExportStatementContext)
}

func (s *StatementContext) ShowExportStatement() IShowExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowExportStatementContext)
}

func (s *StatementContext) InstallPluginStatement() IInstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginStatementContext)
}

func (s *StatementContext) UninstallPluginStatement() IUninstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginStatementContext)
}

func (s *StatementContext) CreateFileStatement() ICreateFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFileStatementContext)
}

func (s *StatementContext) DropFileStatement() IDropFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFileStatementContext)
}

func (s *StatementContext) ShowSmallFilesStatement() IShowSmallFilesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSmallFilesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSmallFilesStatementContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) SetUserPropertyStatement() ISetUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetUserPropertyStatementContext)
}

func (s *StatementContext) CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStorageVolumeStatementContext)
}

func (s *StatementContext) AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeStatementContext)
}

func (s *StatementContext) DropStorageVolumeStatement() IDropStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStorageVolumeStatementContext)
}

func (s *StatementContext) ShowStorageVolumesStatement() IShowStorageVolumesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStorageVolumesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStorageVolumesStatementContext)
}

func (s *StatementContext) DescStorageVolumeStatement() IDescStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescStorageVolumeStatementContext)
}

func (s *StatementContext) SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultStorageVolumeStatementContext)
}

func (s *StatementContext) CreatePipeStatement() ICreatePipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatePipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatePipeStatementContext)
}

func (s *StatementContext) DropPipeStatement() IDropPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPipeStatementContext)
}

func (s *StatementContext) AlterPipeStatement() IAlterPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeStatementContext)
}

func (s *StatementContext) ShowPipeStatement() IShowPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPipeStatementContext)
}

func (s *StatementContext) DescPipeStatement() IDescPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescPipeStatementContext)
}

func (s *StatementContext) CancelCompactionStatement() ICancelCompactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelCompactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelCompactionStatementContext)
}

func (s *StatementContext) UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateFailPointStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateFailPointStatusStatementContext)
}

func (s *StatementContext) ShowFailPointStatement() IShowFailPointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFailPointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFailPointStatementContext)
}

func (s *StatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *StatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *StatementContext) DeallocateStatement() IDeallocateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocateStatementContext)
}

func (s *StatementContext) CreateDictionaryStatement() ICreateDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDictionaryStatementContext)
}

func (s *StatementContext) DropDictionaryStatement() IDropDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDictionaryStatementContext)
}

func (s *StatementContext) RefreshDictionaryStatement() IRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshDictionaryStatementContext)
}

func (s *StatementContext) ShowDictionaryStatement() IShowDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDictionaryStatementContext)
}

func (s *StatementContext) CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshDictionaryStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorAddStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorAddStatementContext)
}

func (s *StatementContext) TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePlanAdvisorStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorDropStatementContext)
}

func (s *StatementContext) ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPlanAdvisorStatementContext)
}

func (s *StatementContext) CreateWarehouseStatement() ICreateWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateWarehouseStatementContext)
}

func (s *StatementContext) DropWarehouseStatement() IDropWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropWarehouseStatementContext)
}

func (s *StatementContext) SuspendWarehouseStatement() ISuspendWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuspendWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuspendWarehouseStatementContext)
}

func (s *StatementContext) ResumeWarehouseStatement() IResumeWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeWarehouseStatementContext)
}

func (s *StatementContext) SetWarehouseStatement() ISetWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetWarehouseStatementContext)
}

func (s *StatementContext) ShowWarehousesStatement() IShowWarehousesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarehousesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarehousesStatementContext)
}

func (s *StatementContext) ShowClustersStatement() IShowClustersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowClustersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowClustersStatementContext)
}

func (s *StatementContext) ShowNodesStatement() IShowNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowNodesStatementContext)
}

func (s *StatementContext) AlterWarehouseStatement() IAlterWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterWarehouseStatementContext)
}

func (s *StatementContext) CreateCNGroupStatement() ICreateCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateCNGroupStatementContext)
}

func (s *StatementContext) DropCNGroupStatement() IDropCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropCNGroupStatementContext)
}

func (s *StatementContext) EnableCNGroupStatement() IEnableCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableCNGroupStatementContext)
}

func (s *StatementContext) DisableCNGroupStatement() IDisableCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableCNGroupStatementContext)
}

func (s *StatementContext) AlterCNGroupStatement() IAlterCNGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCNGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCNGroupStatementContext)
}

func (s *StatementContext) BeginStatement() IBeginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginStatementContext)
}

func (s *StatementContext) CommitStatement() ICommitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitStatementContext)
}

func (s *StatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *StatementContext) TranslateStatement() ITranslateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateStatementContext)
}

func (s *StatementContext) CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateBaselinePlanStatementContext)
}

func (s *StatementContext) DropBaselinePlanStatement() IDropBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBaselinePlanStatementContext)
}

func (s *StatementContext) ShowBaselinePlanStatement() IShowBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBaselinePlanStatementContext)
}

func (s *StatementContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, StarRocksParserRULE_statement)
	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1055)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1056)
			p.UseDatabaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1057)
			p.UseCatalogStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1058)
			p.SetCatalogStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1059)
			p.ShowDatabasesStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1060)
			p.AlterDbQuotaStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1061)
			p.CreateDbStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1062)
			p.DropDbStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1063)
			p.ShowCreateDbStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1064)
			p.AlterDatabaseRenameStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1065)
			p.RecoverDbStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1066)
			p.ShowDataStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1067)
			p.ShowDataDistributionStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1068)
			p.CreateTableStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1069)
			p.CreateTableAsSelectStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1070)
			p.CreateTableLikeStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1071)
			p.ShowCreateTableStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1072)
			p.DropTableStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1073)
			p.CleanTemporaryTableStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1074)
			p.RecoverTableStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1075)
			p.TruncateTableStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1076)
			p.ShowTableStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1077)
			p.DescTableStatement()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1078)
			p.ShowTableStatusStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1079)
			p.ShowColumnStatement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1080)
			p.RefreshTableStatement()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1081)
			p.AlterTableStatement()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1082)
			p.CancelAlterTableStatement()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1083)
			p.ShowAlterStatement()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1084)
			p.ShowTemporaryTablesStatement()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1085)
			p.CreateViewStatement()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1086)
			p.AlterViewStatement()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1087)
			p.DropViewStatement()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1088)
			p.ShowPartitionsStatement()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1089)
			p.RecoverPartitionStatement()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1090)
			p.CreateIndexStatement()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1091)
			p.DropIndexStatement()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1092)
			p.ShowIndexStatement()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1093)
			p.SubmitTaskStatement()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1094)
			p.DropTaskStatement()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1095)
			p.CreateMaterializedViewStatement()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1096)
			p.ShowMaterializedViewsStatement()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1097)
			p.DropMaterializedViewStatement()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1098)
			p.AlterMaterializedViewStatement()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1099)
			p.RefreshMaterializedViewStatement()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1100)
			p.CancelRefreshMaterializedViewStatement()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(1101)
			p.CreateExternalCatalogStatement()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(1102)
			p.DropExternalCatalogStatement()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(1103)
			p.ShowCatalogsStatement()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(1104)
			p.ShowCreateExternalCatalogStatement()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(1105)
			p.AlterCatalogStatement()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(1106)
			p.InsertStatement()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(1107)
			p.UpdateStatement()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(1108)
			p.DeleteStatement()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(1109)
			p.CreateRoutineLoadStatement()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(1110)
			p.AlterRoutineLoadStatement()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(1111)
			p.StopRoutineLoadStatement()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(1112)
			p.ResumeRoutineLoadStatement()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(1113)
			p.PauseRoutineLoadStatement()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(1114)
			p.ShowRoutineLoadStatement()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(1115)
			p.ShowRoutineLoadTaskStatement()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(1116)
			p.ShowCreateRoutineLoadStatement()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(1117)
			p.ShowStreamLoadStatement()
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(1118)
			p.AdminSetConfigStatement()
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(1119)
			p.AdminSetReplicaStatusStatement()
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(1120)
			p.AdminShowConfigStatement()
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(1121)
			p.AdminShowReplicaDistributionStatement()
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(1122)
			p.AdminShowReplicaStatusStatement()
		}

	case 69:
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(1123)
			p.AdminRepairTableStatement()
		}

	case 70:
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(1124)
			p.AdminCancelRepairTableStatement()
		}

	case 71:
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(1125)
			p.AdminCheckTabletsStatement()
		}

	case 72:
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(1126)
			p.AdminSetPartitionVersion()
		}

	case 73:
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(1127)
			p.KillStatement()
		}

	case 74:
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(1128)
			p.SyncStatement()
		}

	case 75:
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(1129)
			p.ExecuteScriptStatement()
		}

	case 76:
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(1130)
			p.AdminSetAutomatedSnapshotOnStatement()
		}

	case 77:
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(1131)
			p.AdminSetAutomatedSnapshotOffStatement()
		}

	case 78:
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(1132)
			p.AlterSystemStatement()
		}

	case 79:
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(1133)
			p.CancelAlterSystemStatement()
		}

	case 80:
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(1134)
			p.ShowComputeNodesStatement()
		}

	case 81:
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(1135)
			p.AnalyzeStatement()
		}

	case 82:
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(1136)
			p.DropStatsStatement()
		}

	case 83:
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(1137)
			p.CreateAnalyzeStatement()
		}

	case 84:
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(1138)
			p.DropAnalyzeJobStatement()
		}

	case 85:
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(1139)
			p.AnalyzeHistogramStatement()
		}

	case 86:
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(1140)
			p.DropHistogramStatement()
		}

	case 87:
		p.EnterOuterAlt(localctx, 87)
		{
			p.SetState(1141)
			p.ShowAnalyzeStatement()
		}

	case 88:
		p.EnterOuterAlt(localctx, 88)
		{
			p.SetState(1142)
			p.ShowStatsMetaStatement()
		}

	case 89:
		p.EnterOuterAlt(localctx, 89)
		{
			p.SetState(1143)
			p.ShowHistogramMetaStatement()
		}

	case 90:
		p.EnterOuterAlt(localctx, 90)
		{
			p.SetState(1144)
			p.KillAnalyzeStatement()
		}

	case 91:
		p.EnterOuterAlt(localctx, 91)
		{
			p.SetState(1145)
			p.AnalyzeProfileStatement()
		}

	case 92:
		p.EnterOuterAlt(localctx, 92)
		{
			p.SetState(1146)
			p.CreateResourceGroupStatement()
		}

	case 93:
		p.EnterOuterAlt(localctx, 93)
		{
			p.SetState(1147)
			p.DropResourceGroupStatement()
		}

	case 94:
		p.EnterOuterAlt(localctx, 94)
		{
			p.SetState(1148)
			p.AlterResourceGroupStatement()
		}

	case 95:
		p.EnterOuterAlt(localctx, 95)
		{
			p.SetState(1149)
			p.ShowResourceGroupStatement()
		}

	case 96:
		p.EnterOuterAlt(localctx, 96)
		{
			p.SetState(1150)
			p.ShowResourceGroupUsageStatement()
		}

	case 97:
		p.EnterOuterAlt(localctx, 97)
		{
			p.SetState(1151)
			p.CreateResourceStatement()
		}

	case 98:
		p.EnterOuterAlt(localctx, 98)
		{
			p.SetState(1152)
			p.AlterResourceStatement()
		}

	case 99:
		p.EnterOuterAlt(localctx, 99)
		{
			p.SetState(1153)
			p.DropResourceStatement()
		}

	case 100:
		p.EnterOuterAlt(localctx, 100)
		{
			p.SetState(1154)
			p.ShowResourceStatement()
		}

	case 101:
		p.EnterOuterAlt(localctx, 101)
		{
			p.SetState(1155)
			p.ShowFunctionsStatement()
		}

	case 102:
		p.EnterOuterAlt(localctx, 102)
		{
			p.SetState(1156)
			p.DropFunctionStatement()
		}

	case 103:
		p.EnterOuterAlt(localctx, 103)
		{
			p.SetState(1157)
			p.CreateFunctionStatement()
		}

	case 104:
		p.EnterOuterAlt(localctx, 104)
		{
			p.SetState(1158)
			p.LoadStatement()
		}

	case 105:
		p.EnterOuterAlt(localctx, 105)
		{
			p.SetState(1159)
			p.ShowLoadStatement()
		}

	case 106:
		p.EnterOuterAlt(localctx, 106)
		{
			p.SetState(1160)
			p.ShowLoadWarningsStatement()
		}

	case 107:
		p.EnterOuterAlt(localctx, 107)
		{
			p.SetState(1161)
			p.CancelLoadStatement()
		}

	case 108:
		p.EnterOuterAlt(localctx, 108)
		{
			p.SetState(1162)
			p.AlterLoadStatement()
		}

	case 109:
		p.EnterOuterAlt(localctx, 109)
		{
			p.SetState(1163)
			p.ShowAuthorStatement()
		}

	case 110:
		p.EnterOuterAlt(localctx, 110)
		{
			p.SetState(1164)
			p.ShowBackendsStatement()
		}

	case 111:
		p.EnterOuterAlt(localctx, 111)
		{
			p.SetState(1165)
			p.ShowBrokerStatement()
		}

	case 112:
		p.EnterOuterAlt(localctx, 112)
		{
			p.SetState(1166)
			p.ShowCharsetStatement()
		}

	case 113:
		p.EnterOuterAlt(localctx, 113)
		{
			p.SetState(1167)
			p.ShowCollationStatement()
		}

	case 114:
		p.EnterOuterAlt(localctx, 114)
		{
			p.SetState(1168)
			p.ShowDeleteStatement()
		}

	case 115:
		p.EnterOuterAlt(localctx, 115)
		{
			p.SetState(1169)
			p.ShowDynamicPartitionStatement()
		}

	case 116:
		p.EnterOuterAlt(localctx, 116)
		{
			p.SetState(1170)
			p.ShowEventsStatement()
		}

	case 117:
		p.EnterOuterAlt(localctx, 117)
		{
			p.SetState(1171)
			p.ShowEnginesStatement()
		}

	case 118:
		p.EnterOuterAlt(localctx, 118)
		{
			p.SetState(1172)
			p.ShowFrontendsStatement()
		}

	case 119:
		p.EnterOuterAlt(localctx, 119)
		{
			p.SetState(1173)
			p.ShowPluginsStatement()
		}

	case 120:
		p.EnterOuterAlt(localctx, 120)
		{
			p.SetState(1174)
			p.ShowRepositoriesStatement()
		}

	case 121:
		p.EnterOuterAlt(localctx, 121)
		{
			p.SetState(1175)
			p.ShowOpenTableStatement()
		}

	case 122:
		p.EnterOuterAlt(localctx, 122)
		{
			p.SetState(1176)
			p.ShowPrivilegesStatement()
		}

	case 123:
		p.EnterOuterAlt(localctx, 123)
		{
			p.SetState(1177)
			p.ShowProcedureStatement()
		}

	case 124:
		p.EnterOuterAlt(localctx, 124)
		{
			p.SetState(1178)
			p.ShowProcStatement()
		}

	case 125:
		p.EnterOuterAlt(localctx, 125)
		{
			p.SetState(1179)
			p.ShowProcesslistStatement()
		}

	case 126:
		p.EnterOuterAlt(localctx, 126)
		{
			p.SetState(1180)
			p.ShowProfilelistStatement()
		}

	case 127:
		p.EnterOuterAlt(localctx, 127)
		{
			p.SetState(1181)
			p.ShowRunningQueriesStatement()
		}

	case 128:
		p.EnterOuterAlt(localctx, 128)
		{
			p.SetState(1182)
			p.ShowStatusStatement()
		}

	case 129:
		p.EnterOuterAlt(localctx, 129)
		{
			p.SetState(1183)
			p.ShowTabletStatement()
		}

	case 130:
		p.EnterOuterAlt(localctx, 130)
		{
			p.SetState(1184)
			p.ShowTransactionStatement()
		}

	case 131:
		p.EnterOuterAlt(localctx, 131)
		{
			p.SetState(1185)
			p.ShowTriggersStatement()
		}

	case 132:
		p.EnterOuterAlt(localctx, 132)
		{
			p.SetState(1186)
			p.ShowUserPropertyStatement()
		}

	case 133:
		p.EnterOuterAlt(localctx, 133)
		{
			p.SetState(1187)
			p.ShowVariablesStatement()
		}

	case 134:
		p.EnterOuterAlt(localctx, 134)
		{
			p.SetState(1188)
			p.ShowWarningStatement()
		}

	case 135:
		p.EnterOuterAlt(localctx, 135)
		{
			p.SetState(1189)
			p.HelpStatement()
		}

	case 136:
		p.EnterOuterAlt(localctx, 136)
		{
			p.SetState(1190)
			p.CreateUserStatement()
		}

	case 137:
		p.EnterOuterAlt(localctx, 137)
		{
			p.SetState(1191)
			p.DropUserStatement()
		}

	case 138:
		p.EnterOuterAlt(localctx, 138)
		{
			p.SetState(1192)
			p.AlterUserStatement()
		}

	case 139:
		p.EnterOuterAlt(localctx, 139)
		{
			p.SetState(1193)
			p.ShowUserStatement()
		}

	case 140:
		p.EnterOuterAlt(localctx, 140)
		{
			p.SetState(1194)
			p.ShowAuthenticationStatement()
		}

	case 141:
		p.EnterOuterAlt(localctx, 141)
		{
			p.SetState(1195)
			p.ExecuteAsStatement()
		}

	case 142:
		p.EnterOuterAlt(localctx, 142)
		{
			p.SetState(1196)
			p.CreateRoleStatement()
		}

	case 143:
		p.EnterOuterAlt(localctx, 143)
		{
			p.SetState(1197)
			p.AlterRoleStatement()
		}

	case 144:
		p.EnterOuterAlt(localctx, 144)
		{
			p.SetState(1198)
			p.DropRoleStatement()
		}

	case 145:
		p.EnterOuterAlt(localctx, 145)
		{
			p.SetState(1199)
			p.ShowRolesStatement()
		}

	case 146:
		p.EnterOuterAlt(localctx, 146)
		{
			p.SetState(1200)
			p.GrantRoleStatement()
		}

	case 147:
		p.EnterOuterAlt(localctx, 147)
		{
			p.SetState(1201)
			p.RevokeRoleStatement()
		}

	case 148:
		p.EnterOuterAlt(localctx, 148)
		{
			p.SetState(1202)
			p.SetRoleStatement()
		}

	case 149:
		p.EnterOuterAlt(localctx, 149)
		{
			p.SetState(1203)
			p.SetDefaultRoleStatement()
		}

	case 150:
		p.EnterOuterAlt(localctx, 150)
		{
			p.SetState(1204)
			p.GrantPrivilegeStatement()
		}

	case 151:
		p.EnterOuterAlt(localctx, 151)
		{
			p.SetState(1205)
			p.RevokePrivilegeStatement()
		}

	case 152:
		p.EnterOuterAlt(localctx, 152)
		{
			p.SetState(1206)
			p.ShowGrantsStatement()
		}

	case 153:
		p.EnterOuterAlt(localctx, 153)
		{
			p.SetState(1207)
			p.CreateSecurityIntegrationStatement()
		}

	case 154:
		p.EnterOuterAlt(localctx, 154)
		{
			p.SetState(1208)
			p.AlterSecurityIntegrationStatement()
		}

	case 155:
		p.EnterOuterAlt(localctx, 155)
		{
			p.SetState(1209)
			p.DropSecurityIntegrationStatement()
		}

	case 156:
		p.EnterOuterAlt(localctx, 156)
		{
			p.SetState(1210)
			p.ShowSecurityIntegrationStatement()
		}

	case 157:
		p.EnterOuterAlt(localctx, 157)
		{
			p.SetState(1211)
			p.ShowCreateSecurityIntegrationStatement()
		}

	case 158:
		p.EnterOuterAlt(localctx, 158)
		{
			p.SetState(1212)
			p.CreateGroupProviderStatement()
		}

	case 159:
		p.EnterOuterAlt(localctx, 159)
		{
			p.SetState(1213)
			p.DropGroupProviderStatement()
		}

	case 160:
		p.EnterOuterAlt(localctx, 160)
		{
			p.SetState(1214)
			p.ShowGroupProvidersStatement()
		}

	case 161:
		p.EnterOuterAlt(localctx, 161)
		{
			p.SetState(1215)
			p.ShowCreateGroupProviderStatement()
		}

	case 162:
		p.EnterOuterAlt(localctx, 162)
		{
			p.SetState(1216)
			p.BackupStatement()
		}

	case 163:
		p.EnterOuterAlt(localctx, 163)
		{
			p.SetState(1217)
			p.CancelBackupStatement()
		}

	case 164:
		p.EnterOuterAlt(localctx, 164)
		{
			p.SetState(1218)
			p.ShowBackupStatement()
		}

	case 165:
		p.EnterOuterAlt(localctx, 165)
		{
			p.SetState(1219)
			p.RestoreStatement()
		}

	case 166:
		p.EnterOuterAlt(localctx, 166)
		{
			p.SetState(1220)
			p.CancelRestoreStatement()
		}

	case 167:
		p.EnterOuterAlt(localctx, 167)
		{
			p.SetState(1221)
			p.ShowRestoreStatement()
		}

	case 168:
		p.EnterOuterAlt(localctx, 168)
		{
			p.SetState(1222)
			p.ShowSnapshotStatement()
		}

	case 169:
		p.EnterOuterAlt(localctx, 169)
		{
			p.SetState(1223)
			p.CreateRepositoryStatement()
		}

	case 170:
		p.EnterOuterAlt(localctx, 170)
		{
			p.SetState(1224)
			p.DropRepositoryStatement()
		}

	case 171:
		p.EnterOuterAlt(localctx, 171)
		{
			p.SetState(1225)
			p.AddSqlBlackListStatement()
		}

	case 172:
		p.EnterOuterAlt(localctx, 172)
		{
			p.SetState(1226)
			p.DelSqlBlackListStatement()
		}

	case 173:
		p.EnterOuterAlt(localctx, 173)
		{
			p.SetState(1227)
			p.ShowSqlBlackListStatement()
		}

	case 174:
		p.EnterOuterAlt(localctx, 174)
		{
			p.SetState(1228)
			p.ShowWhiteListStatement()
		}

	case 175:
		p.EnterOuterAlt(localctx, 175)
		{
			p.SetState(1229)
			p.AddBackendBlackListStatement()
		}

	case 176:
		p.EnterOuterAlt(localctx, 176)
		{
			p.SetState(1230)
			p.DelBackendBlackListStatement()
		}

	case 177:
		p.EnterOuterAlt(localctx, 177)
		{
			p.SetState(1231)
			p.ShowBackendBlackListStatement()
		}

	case 178:
		p.EnterOuterAlt(localctx, 178)
		{
			p.SetState(1232)
			p.CreateDataCacheRuleStatement()
		}

	case 179:
		p.EnterOuterAlt(localctx, 179)
		{
			p.SetState(1233)
			p.ShowDataCacheRulesStatement()
		}

	case 180:
		p.EnterOuterAlt(localctx, 180)
		{
			p.SetState(1234)
			p.DropDataCacheRuleStatement()
		}

	case 181:
		p.EnterOuterAlt(localctx, 181)
		{
			p.SetState(1235)
			p.ClearDataCacheRulesStatement()
		}

	case 182:
		p.EnterOuterAlt(localctx, 182)
		{
			p.SetState(1236)
			p.DataCacheSelectStatement()
		}

	case 183:
		p.EnterOuterAlt(localctx, 183)
		{
			p.SetState(1237)
			p.ExportStatement()
		}

	case 184:
		p.EnterOuterAlt(localctx, 184)
		{
			p.SetState(1238)
			p.CancelExportStatement()
		}

	case 185:
		p.EnterOuterAlt(localctx, 185)
		{
			p.SetState(1239)
			p.ShowExportStatement()
		}

	case 186:
		p.EnterOuterAlt(localctx, 186)
		{
			p.SetState(1240)
			p.InstallPluginStatement()
		}

	case 187:
		p.EnterOuterAlt(localctx, 187)
		{
			p.SetState(1241)
			p.UninstallPluginStatement()
		}

	case 188:
		p.EnterOuterAlt(localctx, 188)
		{
			p.SetState(1242)
			p.CreateFileStatement()
		}

	case 189:
		p.EnterOuterAlt(localctx, 189)
		{
			p.SetState(1243)
			p.DropFileStatement()
		}

	case 190:
		p.EnterOuterAlt(localctx, 190)
		{
			p.SetState(1244)
			p.ShowSmallFilesStatement()
		}

	case 191:
		p.EnterOuterAlt(localctx, 191)
		{
			p.SetState(1245)
			p.SetStatement()
		}

	case 192:
		p.EnterOuterAlt(localctx, 192)
		{
			p.SetState(1246)
			p.SetUserPropertyStatement()
		}

	case 193:
		p.EnterOuterAlt(localctx, 193)
		{
			p.SetState(1247)
			p.CreateStorageVolumeStatement()
		}

	case 194:
		p.EnterOuterAlt(localctx, 194)
		{
			p.SetState(1248)
			p.AlterStorageVolumeStatement()
		}

	case 195:
		p.EnterOuterAlt(localctx, 195)
		{
			p.SetState(1249)
			p.DropStorageVolumeStatement()
		}

	case 196:
		p.EnterOuterAlt(localctx, 196)
		{
			p.SetState(1250)
			p.ShowStorageVolumesStatement()
		}

	case 197:
		p.EnterOuterAlt(localctx, 197)
		{
			p.SetState(1251)
			p.DescStorageVolumeStatement()
		}

	case 198:
		p.EnterOuterAlt(localctx, 198)
		{
			p.SetState(1252)
			p.SetDefaultStorageVolumeStatement()
		}

	case 199:
		p.EnterOuterAlt(localctx, 199)
		{
			p.SetState(1253)
			p.CreatePipeStatement()
		}

	case 200:
		p.EnterOuterAlt(localctx, 200)
		{
			p.SetState(1254)
			p.DropPipeStatement()
		}

	case 201:
		p.EnterOuterAlt(localctx, 201)
		{
			p.SetState(1255)
			p.AlterPipeStatement()
		}

	case 202:
		p.EnterOuterAlt(localctx, 202)
		{
			p.SetState(1256)
			p.ShowPipeStatement()
		}

	case 203:
		p.EnterOuterAlt(localctx, 203)
		{
			p.SetState(1257)
			p.DescPipeStatement()
		}

	case 204:
		p.EnterOuterAlt(localctx, 204)
		{
			p.SetState(1258)
			p.CancelCompactionStatement()
		}

	case 205:
		p.EnterOuterAlt(localctx, 205)
		{
			p.SetState(1259)
			p.UpdateFailPointStatusStatement()
		}

	case 206:
		p.EnterOuterAlt(localctx, 206)
		{
			p.SetState(1260)
			p.ShowFailPointStatement()
		}

	case 207:
		p.EnterOuterAlt(localctx, 207)
		{
			p.SetState(1261)
			p.PrepareStatement()
		}

	case 208:
		p.EnterOuterAlt(localctx, 208)
		{
			p.SetState(1262)
			p.ExecuteStatement()
		}

	case 209:
		p.EnterOuterAlt(localctx, 209)
		{
			p.SetState(1263)
			p.DeallocateStatement()
		}

	case 210:
		p.EnterOuterAlt(localctx, 210)
		{
			p.SetState(1264)
			p.CreateDictionaryStatement()
		}

	case 211:
		p.EnterOuterAlt(localctx, 211)
		{
			p.SetState(1265)
			p.DropDictionaryStatement()
		}

	case 212:
		p.EnterOuterAlt(localctx, 212)
		{
			p.SetState(1266)
			p.RefreshDictionaryStatement()
		}

	case 213:
		p.EnterOuterAlt(localctx, 213)
		{
			p.SetState(1267)
			p.ShowDictionaryStatement()
		}

	case 214:
		p.EnterOuterAlt(localctx, 214)
		{
			p.SetState(1268)
			p.CancelRefreshDictionaryStatement()
		}

	case 215:
		p.EnterOuterAlt(localctx, 215)
		{
			p.SetState(1269)
			p.AlterPlanAdvisorAddStatement()
		}

	case 216:
		p.EnterOuterAlt(localctx, 216)
		{
			p.SetState(1270)
			p.TruncatePlanAdvisorStatement()
		}

	case 217:
		p.EnterOuterAlt(localctx, 217)
		{
			p.SetState(1271)
			p.AlterPlanAdvisorDropStatement()
		}

	case 218:
		p.EnterOuterAlt(localctx, 218)
		{
			p.SetState(1272)
			p.ShowPlanAdvisorStatement()
		}

	case 219:
		p.EnterOuterAlt(localctx, 219)
		{
			p.SetState(1273)
			p.CreateWarehouseStatement()
		}

	case 220:
		p.EnterOuterAlt(localctx, 220)
		{
			p.SetState(1274)
			p.DropWarehouseStatement()
		}

	case 221:
		p.EnterOuterAlt(localctx, 221)
		{
			p.SetState(1275)
			p.SuspendWarehouseStatement()
		}

	case 222:
		p.EnterOuterAlt(localctx, 222)
		{
			p.SetState(1276)
			p.ResumeWarehouseStatement()
		}

	case 223:
		p.EnterOuterAlt(localctx, 223)
		{
			p.SetState(1277)
			p.SetWarehouseStatement()
		}

	case 224:
		p.EnterOuterAlt(localctx, 224)
		{
			p.SetState(1278)
			p.ShowWarehousesStatement()
		}

	case 225:
		p.EnterOuterAlt(localctx, 225)
		{
			p.SetState(1279)
			p.ShowClustersStatement()
		}

	case 226:
		p.EnterOuterAlt(localctx, 226)
		{
			p.SetState(1280)
			p.ShowNodesStatement()
		}

	case 227:
		p.EnterOuterAlt(localctx, 227)
		{
			p.SetState(1281)
			p.AlterWarehouseStatement()
		}

	case 228:
		p.EnterOuterAlt(localctx, 228)
		{
			p.SetState(1282)
			p.CreateCNGroupStatement()
		}

	case 229:
		p.EnterOuterAlt(localctx, 229)
		{
			p.SetState(1283)
			p.DropCNGroupStatement()
		}

	case 230:
		p.EnterOuterAlt(localctx, 230)
		{
			p.SetState(1284)
			p.EnableCNGroupStatement()
		}

	case 231:
		p.EnterOuterAlt(localctx, 231)
		{
			p.SetState(1285)
			p.DisableCNGroupStatement()
		}

	case 232:
		p.EnterOuterAlt(localctx, 232)
		{
			p.SetState(1286)
			p.AlterCNGroupStatement()
		}

	case 233:
		p.EnterOuterAlt(localctx, 233)
		{
			p.SetState(1287)
			p.BeginStatement()
		}

	case 234:
		p.EnterOuterAlt(localctx, 234)
		{
			p.SetState(1288)
			p.CommitStatement()
		}

	case 235:
		p.EnterOuterAlt(localctx, 235)
		{
			p.SetState(1289)
			p.RollbackStatement()
		}

	case 236:
		p.EnterOuterAlt(localctx, 236)
		{
			p.SetState(1290)
			p.TranslateStatement()
		}

	case 237:
		p.EnterOuterAlt(localctx, 237)
		{
			p.SetState(1291)
			p.CreateBaselinePlanStatement()
		}

	case 238:
		p.EnterOuterAlt(localctx, 238)
		{
			p.SetState(1292)
			p.DropBaselinePlanStatement()
		}

	case 239:
		p.EnterOuterAlt(localctx, 239)
		{
			p.SetState(1293)
			p.ShowBaselinePlanStatement()
		}

	case 240:
		p.EnterOuterAlt(localctx, 240)
		{
			p.SetState(1294)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseDatabaseStatementContext is an interface to support dynamic dispatch.
type IUseDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsUseDatabaseStatementContext differentiates from other interfaces.
	IsUseDatabaseStatementContext()
}

type UseDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDatabaseStatementContext() *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useDatabaseStatement
	return p
}

func InitEmptyUseDatabaseStatementContext(p *UseDatabaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useDatabaseStatement
}

func (*UseDatabaseStatementContext) IsUseDatabaseStatementContext() {}

func NewUseDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_useDatabaseStatement

	return p
}

func (s *UseDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDatabaseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSE, 0)
}

func (s *UseDatabaseStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UseDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUseDatabaseStatement(s)
	}
}

func (s *UseDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUseDatabaseStatement(s)
	}
}

func (s *UseDatabaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUseDatabaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UseDatabaseStatement() (localctx IUseDatabaseStatementContext) {
	localctx = NewUseDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, StarRocksParserRULE_useDatabaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1297)
		p.Match(StarRocksParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1298)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseCatalogStatementContext is an interface to support dynamic dispatch.
type IUseCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	String_() IStringContext

	// IsUseCatalogStatementContext differentiates from other interfaces.
	IsUseCatalogStatementContext()
}

type UseCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseCatalogStatementContext() *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useCatalogStatement
	return p
}

func InitEmptyUseCatalogStatementContext(p *UseCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useCatalogStatement
}

func (*UseCatalogStatementContext) IsUseCatalogStatementContext() {}

func NewUseCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_useCatalogStatement

	return p
}

func (s *UseCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseCatalogStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSE, 0)
}

func (s *UseCatalogStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UseCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUseCatalogStatement(s)
	}
}

func (s *UseCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUseCatalogStatement(s)
	}
}

func (s *UseCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUseCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UseCatalogStatement() (localctx IUseCatalogStatementContext) {
	localctx = NewUseCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, StarRocksParserRULE_useCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		p.Match(StarRocksParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1301)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetCatalogStatementContext is an interface to support dynamic dispatch.
type ISetCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsSetCatalogStatementContext differentiates from other interfaces.
	IsSetCatalogStatementContext()
}

type SetCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetCatalogStatementContext() *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setCatalogStatement
	return p
}

func InitEmptySetCatalogStatementContext(p *SetCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setCatalogStatement
}

func (*SetCatalogStatementContext) IsSetCatalogStatementContext() {}

func NewSetCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setCatalogStatement

	return p
}

func (s *SetCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetCatalogStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *SetCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetCatalogStatement(s)
	}
}

func (s *SetCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetCatalogStatement(s)
	}
}

func (s *SetCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetCatalogStatement() (localctx ISetCatalogStatementContext) {
	localctx = NewSetCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, StarRocksParserRULE_setCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1303)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1304)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1305)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDatabasesStatementContext is an interface to support dynamic dispatch.
type IShowDatabasesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext
	SCHEMAS() antlr.TerminalNode

	// IsShowDatabasesStatementContext differentiates from other interfaces.
	IsShowDatabasesStatementContext()
}

type ShowDatabasesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowDatabasesStatementContext() *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDatabasesStatement
	return p
}

func InitEmptyShowDatabasesStatementContext(p *ShowDatabasesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDatabasesStatement
}

func (*ShowDatabasesStatementContext) IsShowDatabasesStatementContext() {}

func NewShowDatabasesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDatabasesStatement

	return p
}

func (s *ShowDatabasesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDatabasesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowDatabasesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowDatabasesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowDatabasesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowDatabasesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDatabasesStatementContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *ShowDatabasesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDatabasesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowDatabasesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDatabasesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowDatabasesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowDatabasesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowDatabasesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowDatabasesStatementContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMAS, 0)
}

func (s *ShowDatabasesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDatabasesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDatabasesStatement(s)
	}
}

func (s *ShowDatabasesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDatabasesStatement(s)
	}
}

func (s *ShowDatabasesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowDatabasesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowDatabasesStatement() (localctx IShowDatabasesStatementContext) {
	localctx = NewShowDatabasesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, StarRocksParserRULE_showDatabasesStatement)
	var _la int

	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1307)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1308)
			p.Match(StarRocksParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM || _la == StarRocksParserIN {
			{
				p.SetState(1309)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1310)

				var _x = p.QualifiedName()

				localctx.(*ShowDatabasesStatementContext).catalog = _x
			}

		}
		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case StarRocksParserLIKE:
			{
				p.SetState(1313)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1314)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case StarRocksParserWHERE:
			{
				p.SetState(1315)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1316)
				p.expression(0)
			}

		case StarRocksParserEOF, StarRocksParserSEMICOLON:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1319)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1320)
			p.Match(StarRocksParserSCHEMAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case StarRocksParserLIKE:
			{
				p.SetState(1321)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1322)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case StarRocksParserWHERE:
			{
				p.SetState(1323)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1324)
				p.expression(0)
			}

		case StarRocksParserEOF, StarRocksParserSEMICOLON:

		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDbQuotaStatementContext is an interface to support dynamic dispatch.
type IAlterDbQuotaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	SET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsAlterDbQuotaStatementContext differentiates from other interfaces.
	IsAlterDbQuotaStatementContext()
}

type AlterDbQuotaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDbQuotaStatementContext() *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDbQuotaStatement
	return p
}

func InitEmptyAlterDbQuotaStatementContext(p *AlterDbQuotaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDbQuotaStatement
}

func (*AlterDbQuotaStatementContext) IsAlterDbQuotaStatementContext() {}

func NewAlterDbQuotaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterDbQuotaStatement

	return p
}

func (s *AlterDbQuotaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDbQuotaStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterDbQuotaStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *AlterDbQuotaStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDbQuotaStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDbQuotaStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterDbQuotaStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *AlterDbQuotaStatementContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUOTA, 0)
}

func (s *AlterDbQuotaStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AlterDbQuotaStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *AlterDbQuotaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDbQuotaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDbQuotaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterDbQuotaStatement(s)
	}
}

func (s *AlterDbQuotaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterDbQuotaStatement(s)
	}
}

func (s *AlterDbQuotaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterDbQuotaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterDbQuotaStatement() (localctx IAlterDbQuotaStatementContext) {
	localctx = NewAlterDbQuotaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, StarRocksParserRULE_alterDbQuotaStatement)
	p.SetState(1345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1330)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1331)
			p.Identifier()
		}
		{
			p.SetState(1332)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.Match(StarRocksParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1335)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1337)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1338)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1339)
			p.Identifier()
		}
		{
			p.SetState(1340)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Match(StarRocksParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1342)
			p.Match(StarRocksParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1343)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDbStatementContext is an interface to support dynamic dispatch.
type ICreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	CharsetDesc() ICharsetDescContext
	CollateDesc() ICollateDescContext
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsCreateDbStatementContext differentiates from other interfaces.
	IsCreateDbStatementContext()
}

type CreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyCreateDbStatementContext() *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDbStatement
	return p
}

func InitEmptyCreateDbStatementContext(p *CreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDbStatement
}

func (*CreateDbStatementContext) IsCreateDbStatementContext() {}

func NewCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createDbStatement

	return p
}

func (s *CreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *CreateDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *CreateDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *CreateDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *CreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *CreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *CreateDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateDbStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateDbStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateDbStatementContext) CollateDesc() ICollateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateDescContext)
}

func (s *CreateDbStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateDbStatement(s)
	}
}

func (s *CreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateDbStatement(s)
	}
}

func (s *CreateDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateDbStatement() (localctx ICreateDbStatementContext) {
	localctx = NewCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, StarRocksParserRULE_createDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1347)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1348)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1349)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1350)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1351)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1354)

			var _x = p.Identifier()

			localctx.(*CreateDbStatementContext).catalog = _x
		}
		{
			p.SetState(1355)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1359)

		var _x = p.QualifiedName()

		localctx.(*CreateDbStatementContext).database = _x
	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1360)
			p.CharsetDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOLLATE || _la == StarRocksParserDEFAULT {
		{
			p.SetState(1363)
			p.CollateDesc()
		}

	}
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1366)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDbStatementContext is an interface to support dynamic dispatch.
type IDropDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropDbStatementContext differentiates from other interfaces.
	IsDropDbStatementContext()
}

type DropDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyDropDbStatementContext() *DropDbStatementContext {
	var p = new(DropDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDbStatement
	return p
}

func InitEmptyDropDbStatementContext(p *DropDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDbStatement
}

func (*DropDbStatementContext) IsDropDbStatementContext() {}

func NewDropDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDbStatementContext {
	var p = new(DropDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropDbStatement

	return p
}

func (s *DropDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *DropDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *DropDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *DropDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *DropDbStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *DropDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *DropDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropDbStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropDbStatement(s)
	}
}

func (s *DropDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropDbStatement(s)
	}
}

func (s *DropDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropDbStatement() (localctx IDropDbStatementContext) {
	localctx = NewDropDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, StarRocksParserRULE_dropDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1369)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1370)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1371)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1372)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1378)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1375)

			var _x = p.Identifier()

			localctx.(*DropDbStatementContext).catalog = _x
		}
		{
			p.SetState(1376)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1380)

		var _x = p.QualifiedName()

		localctx.(*DropDbStatementContext).database = _x
	}
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(1381)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateDbStatementContext is an interface to support dynamic dispatch.
type IShowCreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsShowCreateDbStatementContext differentiates from other interfaces.
	IsShowCreateDbStatementContext()
}

type ShowCreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateDbStatementContext() *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateDbStatement
	return p
}

func InitEmptyShowCreateDbStatementContext(p *ShowCreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateDbStatement
}

func (*ShowCreateDbStatementContext) IsShowCreateDbStatementContext() {}

func NewShowCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateDbStatement

	return p
}

func (s *ShowCreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateDbStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *ShowCreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *ShowCreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateDbStatement(s)
	}
}

func (s *ShowCreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateDbStatement(s)
	}
}

func (s *ShowCreateDbStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCreateDbStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCreateDbStatement() (localctx IShowCreateDbStatementContext) {
	localctx = NewShowCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, StarRocksParserRULE_showCreateDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1384)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1385)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1386)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1387)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseRenameStatementContext is an interface to support dynamic dispatch.
type IAlterDatabaseRenameStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RENAME() antlr.TerminalNode

	// IsAlterDatabaseRenameStatementContext differentiates from other interfaces.
	IsAlterDatabaseRenameStatementContext()
}

type AlterDatabaseRenameStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseRenameStatementContext() *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDatabaseRenameStatement
	return p
}

func InitEmptyAlterDatabaseRenameStatementContext(p *AlterDatabaseRenameStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDatabaseRenameStatement
}

func (*AlterDatabaseRenameStatementContext) IsAlterDatabaseRenameStatementContext() {}

func NewAlterDatabaseRenameStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterDatabaseRenameStatement

	return p
}

func (s *AlterDatabaseRenameStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseRenameStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterDatabaseRenameStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *AlterDatabaseRenameStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameStatementContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *AlterDatabaseRenameStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseRenameStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterDatabaseRenameStatement(s)
	}
}

func (s *AlterDatabaseRenameStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterDatabaseRenameStatement(s)
	}
}

func (s *AlterDatabaseRenameStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterDatabaseRenameStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterDatabaseRenameStatement() (localctx IAlterDatabaseRenameStatementContext) {
	localctx = NewAlterDatabaseRenameStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, StarRocksParserRULE_alterDatabaseRenameStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1389)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1390)
		p.Match(StarRocksParserDATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1391)
		p.Identifier()
	}
	{
		p.SetState(1392)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1393)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverDbStmtContext is an interface to support dynamic dispatch.
type IRecoverDbStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsRecoverDbStmtContext differentiates from other interfaces.
	IsRecoverDbStmtContext()
}

type RecoverDbStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverDbStmtContext() *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverDbStmt
	return p
}

func InitEmptyRecoverDbStmtContext(p *RecoverDbStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverDbStmt
}

func (*RecoverDbStmtContext) IsRecoverDbStmtContext() {}

func NewRecoverDbStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_recoverDbStmt

	return p
}

func (s *RecoverDbStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverDbStmtContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *RecoverDbStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverDbStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *RecoverDbStmtContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *RecoverDbStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverDbStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverDbStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRecoverDbStmt(s)
	}
}

func (s *RecoverDbStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRecoverDbStmt(s)
	}
}

func (s *RecoverDbStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRecoverDbStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RecoverDbStmt() (localctx IRecoverDbStmtContext) {
	localctx = NewRecoverDbStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, StarRocksParserRULE_recoverDbStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1395)
		p.Match(StarRocksParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1396)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1397)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataStmtContext is an interface to support dynamic dispatch.
type IShowDataStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDataStmtContext differentiates from other interfaces.
	IsShowDataStmtContext()
}

type ShowDataStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataStmtContext() *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataStmt
	return p
}

func InitEmptyShowDataStmtContext(p *ShowDataStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataStmt
}

func (*ShowDataStmtContext) IsShowDataStmtContext() {}

func NewShowDataStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDataStmt

	return p
}

func (s *ShowDataStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDataStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *ShowDataStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDataStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDataStmt(s)
	}
}

func (s *ShowDataStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDataStmt(s)
	}
}

func (s *ShowDataStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowDataStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowDataStmt() (localctx IShowDataStmtContext) {
	localctx = NewShowDataStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, StarRocksParserRULE_showDataStmt)
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1399)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1400)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1401)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1403)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1404)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataDistributionStmtContext is an interface to support dynamic dispatch.
type IShowDataDistributionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsShowDataDistributionStmtContext differentiates from other interfaces.
	IsShowDataDistributionStmtContext()
}

type ShowDataDistributionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataDistributionStmtContext() *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataDistributionStmt
	return p
}

func InitEmptyShowDataDistributionStmtContext(p *ShowDataDistributionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataDistributionStmt
}

func (*ShowDataDistributionStmtContext) IsShowDataDistributionStmtContext() {}

func NewShowDataDistributionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDataDistributionStmt

	return p
}

func (s *ShowDataDistributionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataDistributionStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDataDistributionStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *ShowDataDistributionStmtContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTION, 0)
}

func (s *ShowDataDistributionStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDataDistributionStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataDistributionStmtContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowDataDistributionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataDistributionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataDistributionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDataDistributionStmt(s)
	}
}

func (s *ShowDataDistributionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDataDistributionStmt(s)
	}
}

func (s *ShowDataDistributionStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowDataDistributionStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowDataDistributionStmt() (localctx IShowDataDistributionStmtContext) {
	localctx = NewShowDataDistributionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, StarRocksParserRULE_showDataDistributionStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1408)
		p.Match(StarRocksParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1409)
		p.Match(StarRocksParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1410)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1411)
		p.QualifiedName()
	}
	p.SetState(1413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1412)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext
	EngineDesc() IEngineDescContext
	CharsetDesc() ICharsetDescContext
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RollupDesc() IRollupDescContext
	Properties() IPropertiesContext
	ExtProperties() IExtPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableStatementContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *CreateTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateTableStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateTableStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableStatementContext) EngineDesc() IEngineDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineDescContext)
}

func (s *CreateTableStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateTableStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableStatementContext) RollupDesc() IRollupDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDescContext)
}

func (s *CreateTableStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableStatementContext) ExtProperties() IExtPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtPropertiesContext)
}

func (s *CreateTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CreateTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, StarRocksParserRULE_createTableStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1415)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1416)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1419)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1420)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1421)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1422)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1425)
		p.QualifiedName()
	}
	{
		p.SetState(1426)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1427)
		p.ColumnDesc()
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1428)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1429)
				p.ColumnDesc()
			}

		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(1435)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1436)
			p.IndexDesc()
		}

		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1442)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserENGINE {
		{
			p.SetState(1443)
			p.EngineDesc()
		}

	}
	p.SetState(1447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&9007199254740999) != 0 {
		{
			p.SetState(1446)
			p.CharsetDesc()
		}

	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE {
		{
			p.SetState(1449)
			p.KeyDesc()
		}

	}
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1452)
			p.Comment()
		}

	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1455)
			p.PartitionDesc()
		}

	}
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(1458)
			p.DistributionDesc()
		}

	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(1461)
			p.OrderByDesc()
		}

	}
	p.SetState(1465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserROLLUP {
		{
			p.SetState(1464)
			p.RollupDesc()
		}

	}
	p.SetState(1468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1467)
			p.Properties()
		}

	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBROKER {
		{
			p.SetState(1470)
			p.ExtProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDescContext is an interface to support dynamic dispatch.
type IColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext
	CharsetName() ICharsetNameContext
	KEY() antlr.TerminalNode
	AggDesc() IAggDescContext
	ColumnNullable() IColumnNullableContext
	DefaultDesc() IDefaultDescContext
	AUTO_INCREMENT() antlr.TerminalNode
	GeneratedColumnDesc() IGeneratedColumnDescContext
	Comment() ICommentContext

	// IsColumnDescContext differentiates from other interfaces.
	IsColumnDescContext()
}

type ColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDescContext() *ColumnDescContext {
	var p = new(ColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnDesc
	return p
}

func InitEmptyColumnDescContext(p *ColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnDesc
}

func (*ColumnDescContext) IsColumnDescContext() {}

func NewColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDescContext {
	var p = new(ColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnDesc

	return p
}

func (s *ColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ColumnDescContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *ColumnDescContext) AggDesc() IAggDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggDescContext)
}

func (s *ColumnDescContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *ColumnDescContext) DefaultDesc() IDefaultDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDescContext)
}

func (s *ColumnDescContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTO_INCREMENT, 0)
}

func (s *ColumnDescContext) GeneratedColumnDesc() IGeneratedColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratedColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratedColumnDescContext)
}

func (s *ColumnDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnDesc(s)
	}
}

func (s *ColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnDesc(s)
	}
}

func (s *ColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnDesc() (localctx IColumnDescContext) {
	localctx = NewColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, StarRocksParserRULE_columnDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.Identifier()
	}
	p.SetState(1475)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1474)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1478)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1477)
			p.CharsetName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserKEY {
		{
			p.SetState(1480)
			p.Match(StarRocksParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1484)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1483)
			p.AggDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNOT || _la == StarRocksParserNULL {
		{
			p.SetState(1486)
			p.ColumnNullable()
		}

	}
	p.SetState(1492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserDEFAULT:
		{
			p.SetState(1489)
			p.DefaultDesc()
		}

	case StarRocksParserAUTO_INCREMENT:
		{
			p.SetState(1490)
			p.Match(StarRocksParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAS:
		{
			p.SetState(1491)
			p.GeneratedColumnDesc()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserT__3, StarRocksParserAFTER, StarRocksParserCOMMENT, StarRocksParserFIRST, StarRocksParserFROM, StarRocksParserIN, StarRocksParserPROPERTIES, StarRocksParserTO, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1494)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	Identifier() IIdentifierContext
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *CharsetNameContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *CharsetNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CharsetNameContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *CharsetNameContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, StarRocksParserRULE_charsetName)
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1497)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1498)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1499)
			p.Identifier()
		}

	case StarRocksParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1500)
			p.Match(StarRocksParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1501)
			p.Identifier()
		}

	case StarRocksParserCHARACTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1502)
			p.Match(StarRocksParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1503)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1504)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultDescContext is an interface to support dynamic dispatch.
type IDefaultDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	String_() IStringContext
	NULL() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsDefaultDescContext differentiates from other interfaces.
	IsDefaultDescContext()
}

type DefaultDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDescContext() *DefaultDescContext {
	var p = new(DefaultDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_defaultDesc
	return p
}

func InitEmptyDefaultDescContext(p *DefaultDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_defaultDesc
}

func (*DefaultDescContext) IsDefaultDescContext() {}

func NewDefaultDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDescContext {
	var p = new(DefaultDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_defaultDesc

	return p
}

func (s *DefaultDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *DefaultDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DefaultDescContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *DefaultDescContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_TIMESTAMP, 0)
}

func (s *DefaultDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DefaultDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDefaultDesc(s)
	}
}

func (s *DefaultDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDefaultDesc(s)
	}
}

func (s *DefaultDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDefaultDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DefaultDesc() (localctx IDefaultDescContext) {
	localctx = NewDefaultDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, StarRocksParserRULE_defaultDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1507)
		p.Match(StarRocksParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(1508)
			p.String_()
		}

	case StarRocksParserNULL:
		{
			p.SetState(1509)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCURRENT_TIMESTAMP:
		{
			p.SetState(1510)
			p.Match(StarRocksParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserT__1:
		{
			p.SetState(1511)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1512)
			p.QualifiedName()
		}
		{
			p.SetState(1513)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1514)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1515)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratedColumnDescContext is an interface to support dynamic dispatch.
type IGeneratedColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGeneratedColumnDescContext differentiates from other interfaces.
	IsGeneratedColumnDescContext()
}

type GeneratedColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratedColumnDescContext() *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_generatedColumnDesc
	return p
}

func InitEmptyGeneratedColumnDescContext(p *GeneratedColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_generatedColumnDesc
}

func (*GeneratedColumnDescContext) IsGeneratedColumnDescContext() {}

func NewGeneratedColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_generatedColumnDesc

	return p
}

func (s *GeneratedColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratedColumnDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *GeneratedColumnDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratedColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGeneratedColumnDesc(s)
	}
}

func (s *GeneratedColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGeneratedColumnDesc(s)
	}
}

func (s *GeneratedColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGeneratedColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) GeneratedColumnDesc() (localctx IGeneratedColumnDescContext) {
	localctx = NewGeneratedColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, StarRocksParserRULE_generatedColumnDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1520)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDescContext is an interface to support dynamic dispatch.
type IIndexDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsIndexDescContext differentiates from other interfaces.
	IsIndexDescContext()
}

type IndexDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyIndexDescContext() *IndexDescContext {
	var p = new(IndexDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexDesc
	return p
}

func InitEmptyIndexDescContext(p *IndexDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexDesc
}

func (*IndexDescContext) IsIndexDescContext() {}

func NewIndexDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDescContext {
	var p = new(IndexDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_indexDesc

	return p
}

func (s *IndexDescContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDescContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDescContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDescContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *IndexDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDescContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *IndexDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *IndexDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIndexDesc(s)
	}
}

func (s *IndexDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIndexDesc(s)
	}
}

func (s *IndexDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIndexDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IndexDesc() (localctx IIndexDescContext) {
	localctx = NewIndexDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, StarRocksParserRULE_indexDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1522)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1523)

		var _x = p.Identifier()

		localctx.(*IndexDescContext).indexName = _x
	}
	{
		p.SetState(1524)
		p.IdentifierList()
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(1525)
			p.IndexType()
		}
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(1526)
				p.PropertyList()
			}

		}

	}
	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1531)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineDescContext is an interface to support dynamic dispatch.
type IEngineDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsEngineDescContext differentiates from other interfaces.
	IsEngineDescContext()
}

type EngineDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineDescContext() *EngineDescContext {
	var p = new(EngineDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_engineDesc
	return p
}

func InitEmptyEngineDescContext(p *EngineDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_engineDesc
}

func (*EngineDescContext) IsEngineDescContext() {}

func NewEngineDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineDescContext {
	var p = new(EngineDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_engineDesc

	return p
}

func (s *EngineDescContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineDescContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINE, 0)
}

func (s *EngineDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *EngineDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EngineDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterEngineDesc(s)
	}
}

func (s *EngineDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitEngineDesc(s)
	}
}

func (s *EngineDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitEngineDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) EngineDesc() (localctx IEngineDescContext) {
	localctx = NewEngineDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, StarRocksParserRULE_engineDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1534)
		p.Match(StarRocksParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1535)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1536)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetDescContext is an interface to support dynamic dispatch.
type ICharsetDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrString() IIdentifierOrStringContext
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCharsetDescContext differentiates from other interfaces.
	IsCharsetDescContext()
}

type CharsetDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetDescContext() *CharsetDescContext {
	var p = new(CharsetDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetDesc
	return p
}

func InitEmptyCharsetDescContext(p *CharsetDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetDesc
}

func (*CharsetDescContext) IsCharsetDescContext() {}

func NewCharsetDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetDescContext {
	var p = new(CharsetDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_charsetDesc

	return p
}

func (s *CharsetDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CharsetDescContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *CharsetDescContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *CharsetDescContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *CharsetDescContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *CharsetDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *CharsetDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *CharsetDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCharsetDesc(s)
	}
}

func (s *CharsetDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCharsetDesc(s)
	}
}

func (s *CharsetDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCharsetDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CharsetDesc() (localctx ICharsetDescContext) {
	localctx = NewCharsetDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, StarRocksParserRULE_charsetDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFAULT {
		{
			p.SetState(1538)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		{
			p.SetState(1541)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1542)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARSET:
		{
			p.SetState(1543)
			p.Match(StarRocksParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARACTER:
		{
			p.SetState(1544)
			p.Match(StarRocksParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1545)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEQ {
		{
			p.SetState(1548)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1551)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateDescContext is an interface to support dynamic dispatch.
type ICollateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCollateDescContext differentiates from other interfaces.
	IsCollateDescContext()
}

type CollateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateDescContext() *CollateDescContext {
	var p = new(CollateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_collateDesc
	return p
}

func InitEmptyCollateDescContext(p *CollateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_collateDesc
}

func (*CollateDescContext) IsCollateDescContext() {}

func NewCollateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateDescContext {
	var p = new(CollateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_collateDesc

	return p
}

func (s *CollateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateDescContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATE, 0)
}

func (s *CollateDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CollateDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *CollateDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *CollateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCollateDesc(s)
	}
}

func (s *CollateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCollateDesc(s)
	}
}

func (s *CollateDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCollateDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CollateDesc() (localctx ICollateDescContext) {
	localctx = NewCollateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, StarRocksParserRULE_collateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFAULT {
		{
			p.SetState(1553)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1556)
		p.Match(StarRocksParserCOLLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEQ {
		{
			p.SetState(1557)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1560)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyDescContext is an interface to support dynamic dispatch.
type IKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AGGREGATE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode

	// IsKeyDescContext differentiates from other interfaces.
	IsKeyDescContext()
}

type KeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyDescContext() *KeyDescContext {
	var p = new(KeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyDesc
	return p
}

func InitEmptyKeyDescContext(p *KeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyDesc
}

func (*KeyDescContext) IsKeyDescContext() {}

func NewKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyDescContext {
	var p = new(KeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_keyDesc

	return p
}

func (s *KeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *KeyDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *KeyDescContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAGGREGATE, 0)
}

func (s *KeyDescContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNIQUE, 0)
}

func (s *KeyDescContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIMARY, 0)
}

func (s *KeyDescContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUPLICATE, 0)
}

func (s *KeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKeyDesc(s)
	}
}

func (s *KeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKeyDesc(s)
	}
}

func (s *KeyDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitKeyDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) KeyDesc() (localctx IKeyDescContext) {
	localctx = NewKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, StarRocksParserRULE_keyDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1562)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1563)
		p.Match(StarRocksParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1564)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByDescContext is an interface to support dynamic dispatch.
type IOrderByDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsOrderByDescContext differentiates from other interfaces.
	IsOrderByDescContext()
}

type OrderByDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByDescContext() *OrderByDescContext {
	var p = new(OrderByDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orderByDesc
	return p
}

func InitEmptyOrderByDescContext(p *OrderByDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orderByDesc
}

func (*OrderByDescContext) IsOrderByDescContext() {}

func NewOrderByDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByDescContext {
	var p = new(OrderByDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_orderByDesc

	return p
}

func (s *OrderByDescContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByDescContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *OrderByDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *OrderByDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *OrderByDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOrderByDesc(s)
	}
}

func (s *OrderByDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOrderByDesc(s)
	}
}

func (s *OrderByDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOrderByDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) OrderByDesc() (localctx IOrderByDescContext) {
	localctx = NewOrderByDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, StarRocksParserRULE_orderByDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1566)
		p.Match(StarRocksParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1567)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1568)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNullableContext is an interface to support dynamic dispatch.
type IColumnNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsColumnNullableContext differentiates from other interfaces.
	IsColumnNullableContext()
}

type ColumnNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNullableContext() *ColumnNullableContext {
	var p = new(ColumnNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNullable
	return p
}

func InitEmptyColumnNullableContext(p *ColumnNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNullable
}

func (*ColumnNullableContext) IsColumnNullableContext() {}

func NewColumnNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNullableContext {
	var p = new(ColumnNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnNullable

	return p
}

func (s *ColumnNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *ColumnNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *ColumnNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnNullable(s)
	}
}

func (s *ColumnNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnNullable(s)
	}
}

func (s *ColumnNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnNullable() (localctx IColumnNullableContext) {
	localctx = NewColumnNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, StarRocksParserRULE_columnNullable)
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1570)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1571)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1572)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeWithNullableContext is an interface to support dynamic dispatch.
type ITypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	ColumnNullable() IColumnNullableContext

	// IsTypeWithNullableContext differentiates from other interfaces.
	IsTypeWithNullableContext()
}

type TypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeWithNullableContext() *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeWithNullable
	return p
}

func InitEmptyTypeWithNullableContext(p *TypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeWithNullable
}

func (*TypeWithNullableContext) IsTypeWithNullableContext() {}

func NewTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeWithNullable

	return p
}

func (s *TypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeWithNullableContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeWithNullableContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *TypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeWithNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeWithNullable(s)
	}
}

func (s *TypeWithNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeWithNullable(s)
	}
}

func (s *TypeWithNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTypeWithNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TypeWithNullable() (localctx ITypeWithNullableContext) {
	localctx = NewTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, StarRocksParserRULE_typeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1575)
		p.Type_()
	}
	p.SetState(1577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNOT || _la == StarRocksParserNULL {
		{
			p.SetState(1576)
			p.ColumnNullable()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggStateDescContext is an interface to support dynamic dispatch.
type IAggStateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllTypeWithNullable() []ITypeWithNullableContext
	TypeWithNullable(i int) ITypeWithNullableContext

	// IsAggStateDescContext differentiates from other interfaces.
	IsAggStateDescContext()
}

type AggStateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggStateDescContext() *AggStateDescContext {
	var p = new(AggStateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggStateDesc
	return p
}

func InitEmptyAggStateDescContext(p *AggStateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggStateDesc
}

func (*AggStateDescContext) IsAggStateDescContext() {}

func NewAggStateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggStateDescContext {
	var p = new(AggStateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_aggStateDesc

	return p
}

func (s *AggStateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggStateDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AggStateDescContext) AllTypeWithNullable() []ITypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]ITypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeWithNullableContext); ok {
			tst[i] = t.(ITypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDescContext) TypeWithNullable(i int) ITypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeWithNullableContext)
}

func (s *AggStateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggStateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggStateDesc(s)
	}
}

func (s *AggStateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggStateDesc(s)
	}
}

func (s *AggStateDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAggStateDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AggStateDesc() (localctx IAggStateDescContext) {
	localctx = NewAggStateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, StarRocksParserRULE_aggStateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1579)
		p.Identifier()
	}
	{
		p.SetState(1580)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1581)
		p.TypeWithNullable()
	}
	p.SetState(1586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(1582)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1583)
			p.TypeWithNullable()
		}

		p.SetState(1588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1589)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggDescContext is an interface to support dynamic dispatch.
type IAggDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUM() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	AggStateDesc() IAggStateDescContext

	// IsAggDescContext differentiates from other interfaces.
	IsAggDescContext()
}

type AggDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggDescContext() *AggDescContext {
	var p = new(AggDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggDesc
	return p
}

func InitEmptyAggDescContext(p *AggDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggDesc
}

func (*AggDescContext) IsAggDescContext() {}

func NewAggDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggDescContext {
	var p = new(AggDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_aggDesc

	return p
}

func (s *AggDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggDescContext) SUM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUM, 0)
}

func (s *AggDescContext) MAX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAX, 0)
}

func (s *AggDescContext) MIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMIN, 0)
}

func (s *AggDescContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *AggDescContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHLL_UNION, 0)
}

func (s *AggDescContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP_UNION, 0)
}

func (s *AggDescContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENTILE_UNION, 0)
}

func (s *AggDescContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggDescContext) AggStateDesc() IAggStateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggStateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggStateDescContext)
}

func (s *AggDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggDesc(s)
	}
}

func (s *AggDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggDesc(s)
	}
}

func (s *AggDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAggDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AggDesc() (localctx IAggDescContext) {
	localctx = NewAggDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, StarRocksParserRULE_aggDesc)
	p.SetState(1600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1591)
			p.Match(StarRocksParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1592)
			p.Match(StarRocksParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1593)
			p.Match(StarRocksParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1594)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1595)
			p.Match(StarRocksParserHLL_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1596)
			p.Match(StarRocksParserBITMAP_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1597)
			p.Match(StarRocksParserPERCENTILE_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1598)
			p.Match(StarRocksParserREPLACE_IF_NOT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1599)
			p.AggStateDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDescContext is an interface to support dynamic dispatch.
type IRollupDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext

	// IsRollupDescContext differentiates from other interfaces.
	IsRollupDescContext()
}

type RollupDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollupDescContext() *RollupDescContext {
	var p = new(RollupDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupDesc
	return p
}

func InitEmptyRollupDescContext(p *RollupDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupDesc
}

func (*RollupDescContext) IsRollupDescContext() {}

func NewRollupDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDescContext {
	var p = new(RollupDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollupDesc

	return p
}

func (s *RollupDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDescContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *RollupDescContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *RollupDescContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *RollupDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollupDesc(s)
	}
}

func (s *RollupDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollupDesc(s)
	}
}

func (s *RollupDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRollupDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RollupDesc() (localctx IRollupDescContext) {
	localctx = NewRollupDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, StarRocksParserRULE_rollupDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1602)
		p.Match(StarRocksParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1603)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1604)
		p.RollupItem()
	}
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(1605)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1606)
			p.RollupItem()
		}

		p.SetState(1611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1612)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupItemContext is an interface to support dynamic dispatch.
type IRollupItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	DupKeys() IDupKeysContext
	FromRollup() IFromRollupContext
	Properties() IPropertiesContext

	// IsRollupItemContext differentiates from other interfaces.
	IsRollupItemContext()
}

type RollupItemContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyRollupItemContext() *RollupItemContext {
	var p = new(RollupItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupItem
	return p
}

func InitEmptyRollupItemContext(p *RollupItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupItem
}

func (*RollupItemContext) IsRollupItemContext() {}

func NewRollupItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupItemContext {
	var p = new(RollupItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollupItem

	return p
}

func (s *RollupItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupItemContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupItemContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupItemContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupItemContext) DupKeys() IDupKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDupKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDupKeysContext)
}

func (s *RollupItemContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *RollupItemContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RollupItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollupItem(s)
	}
}

func (s *RollupItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollupItem(s)
	}
}

func (s *RollupItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRollupItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RollupItem() (localctx IRollupItemContext) {
	localctx = NewRollupItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, StarRocksParserRULE_rollupItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1614)

		var _x = p.Identifier()

		localctx.(*RollupItemContext).rollupName = _x
	}
	{
		p.SetState(1615)
		p.IdentifierList()
	}
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDUPLICATE {
		{
			p.SetState(1616)
			p.DupKeys()
		}

	}
	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(1619)
			p.FromRollup()
		}

	}
	p.SetState(1623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1622)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDupKeysContext is an interface to support dynamic dispatch.
type IDupKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsDupKeysContext differentiates from other interfaces.
	IsDupKeysContext()
}

type DupKeysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDupKeysContext() *DupKeysContext {
	var p = new(DupKeysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dupKeys
	return p
}

func InitEmptyDupKeysContext(p *DupKeysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dupKeys
}

func (*DupKeysContext) IsDupKeysContext() {}

func NewDupKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DupKeysContext {
	var p = new(DupKeysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dupKeys

	return p
}

func (s *DupKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *DupKeysContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUPLICATE, 0)
}

func (s *DupKeysContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *DupKeysContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DupKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DupKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DupKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDupKeys(s)
	}
}

func (s *DupKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDupKeys(s)
	}
}

func (s *DupKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDupKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DupKeys() (localctx IDupKeysContext) {
	localctx = NewDupKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, StarRocksParserRULE_dupKeys)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1625)
		p.Match(StarRocksParserDUPLICATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1626)
		p.Match(StarRocksParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1627)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFromRollup(s)
	}
}

func (s *FromRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFromRollup(s)
	}
}

func (s *FromRollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitFromRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, StarRocksParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1629)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1630)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (s *OrReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOrReplace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, StarRocksParserRULE_orReplace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserOR {
		{
			p.SetState(1632)
			p.Match(StarRocksParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1633)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, StarRocksParserRULE_ifNotExists)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1636)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1637)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1638)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableAsSelectStatementContext is an interface to support dynamic dispatch.
type ICreateTableAsSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	Properties() IPropertiesContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateTableAsSelectStatementContext differentiates from other interfaces.
	IsCreateTableAsSelectStatementContext()
}

type CreateTableAsSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableAsSelectStatementContext() *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableAsSelectStatement
	return p
}

func InitEmptyCreateTableAsSelectStatementContext(p *CreateTableAsSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableAsSelectStatement
}

func (*CreateTableAsSelectStatementContext) IsCreateTableAsSelectStatementContext() {}

func NewCreateTableAsSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createTableAsSelectStatement

	return p
}

func (s *CreateTableAsSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableAsSelectStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateTableAsSelectStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateTableAsSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreateTableAsSelectStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateTableAsSelectStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CreateTableAsSelectStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateTableAsSelectStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateTableAsSelectStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateTableAsSelectStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableAsSelectStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableAsSelectStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableAsSelectStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableAsSelectStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableAsSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableAsSelectStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableAsSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableAsSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateTableAsSelectStatement(s)
	}
}

func (s *CreateTableAsSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateTableAsSelectStatement(s)
	}
}

func (s *CreateTableAsSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateTableAsSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateTableAsSelectStatement() (localctx ICreateTableAsSelectStatementContext) {
	localctx = NewCreateTableAsSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, StarRocksParserRULE_createTableAsSelectStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1641)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1642)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1645)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1646)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1648)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1651)
		p.QualifiedName()
	}
	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(1652)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(1653)
				p.Identifier()
			}
			p.SetState(1658)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1654)
						p.Match(StarRocksParserT__2)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1655)
						p.Identifier()
					}

				}
				p.SetState(1660)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1665)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1661)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1662)
					p.IndexDesc()
				}

				p.SetState(1667)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case StarRocksParserINDEX:
			{
				p.SetState(1668)
				p.IndexDesc()
			}
			p.SetState(1673)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1669)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1670)
					p.IndexDesc()
				}

				p.SetState(1675)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1678)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE {
		{
			p.SetState(1682)
			p.KeyDesc()
		}

	}
	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1685)
			p.Comment()
		}

	}
	p.SetState(1689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1688)
			p.PartitionDesc()
		}

	}
	p.SetState(1692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(1691)
			p.DistributionDesc()
		}

	}
	p.SetState(1695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(1694)
			p.OrderByDesc()
		}

	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1697)
			p.Properties()
		}

	}
	{
		p.SetState(1700)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1701)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableStatementContext is an interface to support dynamic dispatch.
type IDropTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropTableStatementContext differentiates from other interfaces.
	IsDropTableStatementContext()
}

type DropTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableStatementContext() *DropTableStatementContext {
	var p = new(DropTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTableStatement
	return p
}

func InitEmptyDropTableStatementContext(p *DropTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTableStatement
}

func (*DropTableStatementContext) IsDropTableStatementContext() {}

func NewDropTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableStatementContext {
	var p = new(DropTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropTableStatement

	return p
}

func (s *DropTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *DropTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *DropTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropTableStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropTableStatement() (localctx IDropTableStatementContext) {
	localctx = NewDropTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, StarRocksParserRULE_dropTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1703)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1704)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1707)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1708)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1709)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1712)
		p.QualifiedName()
	}
	p.SetState(1714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(1713)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTemporaryTableStatementContext is an interface to support dynamic dispatch.
type ICleanTemporaryTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	String_() IStringContext

	// IsCleanTemporaryTableStatementContext differentiates from other interfaces.
	IsCleanTemporaryTableStatementContext()
}

type CleanTemporaryTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTemporaryTableStatementContext() *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTemporaryTableStatement
	return p
}

func InitEmptyCleanTemporaryTableStatementContext(p *CleanTemporaryTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTemporaryTableStatement
}

func (*CleanTemporaryTableStatementContext) IsCleanTemporaryTableStatementContext() {}

func NewCleanTemporaryTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cleanTemporaryTableStatement

	return p
}

func (s *CleanTemporaryTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTemporaryTableStatementContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAN, 0)
}

func (s *CleanTemporaryTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CleanTemporaryTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CleanTemporaryTableStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CleanTemporaryTableStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *CleanTemporaryTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CleanTemporaryTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTemporaryTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTemporaryTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCleanTemporaryTableStatement(s)
	}
}

func (s *CleanTemporaryTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCleanTemporaryTableStatement(s)
	}
}

func (s *CleanTemporaryTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCleanTemporaryTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CleanTemporaryTableStatement() (localctx ICleanTemporaryTableStatementContext) {
	localctx = NewCleanTemporaryTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, StarRocksParserRULE_cleanTemporaryTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1716)
		p.Match(StarRocksParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1717)
		p.Match(StarRocksParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1718)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1719)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1720)
		p.Match(StarRocksParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1721)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableStatementContext is an interface to support dynamic dispatch.
type IAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllAlterClause() []IAlterClauseContext
	AlterClause(i int) IAlterClauseContext
	ADD() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext
	DROP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAlterTableStatementContext differentiates from other interfaces.
	IsAlterTableStatementContext()
}

type AlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableStatementContext() *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterTableStatement
	return p
}

func InitEmptyAlterTableStatementContext(p *AlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterTableStatement
}

func (*AlterTableStatementContext) IsAlterTableStatementContext() {}

func NewAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterTableStatement

	return p
}

func (s *AlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterTableStatementContext) AllAlterClause() []IAlterClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterClauseContext); ok {
			tst[i] = t.(IAlterClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) AlterClause(i int) IAlterClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterTableStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *AlterTableStatementContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *AlterTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *AlterTableStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterTableStatement(s)
	}
}

func (s *AlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterTableStatement(s)
	}
}

func (s *AlterTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterTableStatement() (localctx IAlterTableStatementContext) {
	localctx = NewAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, StarRocksParserRULE_alterTableStatement)
	var _la int

	p.SetState(1760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1723)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1724)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1725)
			p.QualifiedName()
		}
		{
			p.SetState(1726)
			p.AlterClause()
		}
		p.SetState(1731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1727)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1728)
				p.AlterClause()
			}

			p.SetState(1733)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1734)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1735)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1736)
			p.QualifiedName()
		}
		{
			p.SetState(1737)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1738)
			p.Match(StarRocksParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1739)
			p.RollupItem()
		}
		p.SetState(1744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1740)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1741)
				p.RollupItem()
			}

			p.SetState(1746)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1747)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1748)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1749)
			p.QualifiedName()
		}
		{
			p.SetState(1750)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1751)
			p.Match(StarRocksParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1752)
			p.Identifier()
		}
		p.SetState(1757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1753)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1754)
				p.Identifier()
			}

			p.SetState(1759)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexStatementContext is an interface to support dynamic dispatch.
type ICreateIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexStatementContext differentiates from other interfaces.
	IsCreateIndexStatementContext()
}

type CreateIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexStatementContext() *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexStatement
	return p
}

func InitEmptyCreateIndexStatementContext(p *CreateIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexStatement
}

func (*CreateIndexStatementContext) IsCreateIndexStatementContext() {}

func NewCreateIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createIndexStatement

	return p
}

func (s *CreateIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *CreateIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateIndexStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexStatementContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateIndexStatement() (localctx ICreateIndexStatementContext) {
	localctx = NewCreateIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, StarRocksParserRULE_createIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1762)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1763)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1764)

		var _x = p.Identifier()

		localctx.(*CreateIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1765)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1766)
		p.QualifiedName()
	}
	{
		p.SetState(1767)
		p.IdentifierList()
	}
	p.SetState(1772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(1768)
			p.IndexType()
		}
		p.SetState(1770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(1769)
				p.PropertyList()
			}

		}

	}
	p.SetState(1775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1774)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexStatementContext is an interface to support dynamic dispatch.
type IDropIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	Identifier() IIdentifierContext

	// IsDropIndexStatementContext differentiates from other interfaces.
	IsDropIndexStatementContext()
}

type DropIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexStatementContext() *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexStatement
	return p
}

func InitEmptyDropIndexStatementContext(p *DropIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexStatement
}

func (*DropIndexStatementContext) IsDropIndexStatementContext() {}

func NewDropIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropIndexStatement

	return p
}

func (s *DropIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *DropIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DropIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropIndexStatement(s)
	}
}

func (s *DropIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropIndexStatement(s)
	}
}

func (s *DropIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropIndexStatement() (localctx IDropIndexStatementContext) {
	localctx = NewDropIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, StarRocksParserRULE_dropIndexStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1778)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1779)

		var _x = p.Identifier()

		localctx.(*DropIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1780)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1781)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	GIN() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *IndexTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP, 0)
}

func (s *IndexTypeContext) GIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGIN, 0)
}

func (s *IndexTypeContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNGRAMBF, 0)
}

func (s *IndexTypeContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVECTOR, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, StarRocksParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1783)
		p.Match(StarRocksParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1784)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserBITMAP || _la == StarRocksParserGIN || _la == StarRocksParserNGRAMBF || _la == StarRocksParserVECTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatementContext is an interface to support dynamic dispatch.
type IShowTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatementContext differentiates from other interfaces.
	IsShowTableStatementContext()
}

type ShowTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatementContext() *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatement
	return p
}

func InitEmptyShowTableStatementContext(p *ShowTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatement
}

func (*ShowTableStatementContext) IsShowTableStatementContext() {}

func NewShowTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTableStatement

	return p
}

func (s *ShowTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowTableStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTableStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTableStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTableStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTableStatement(s)
	}
}

func (s *ShowTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTableStatement(s)
	}
}

func (s *ShowTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowTableStatement() (localctx IShowTableStatementContext) {
	localctx = NewShowTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, StarRocksParserRULE_showTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1786)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(1787)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1790)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1791)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1792)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatementContext).db = _x
		}

	}
	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1795)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1796)

			var _x = p.String_()

			localctx.(*ShowTableStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1797)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1798)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTemporaryTablesStatementContext is an interface to support dynamic dispatch.
type IShowTemporaryTablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTemporaryTablesStatementContext differentiates from other interfaces.
	IsShowTemporaryTablesStatementContext()
}

type ShowTemporaryTablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTemporaryTablesStatementContext() *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTemporaryTablesStatement
	return p
}

func InitEmptyShowTemporaryTablesStatementContext(p *ShowTemporaryTablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTemporaryTablesStatement
}

func (*ShowTemporaryTablesStatementContext) IsShowTemporaryTablesStatementContext() {}

func NewShowTemporaryTablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTemporaryTablesStatement

	return p
}

func (s *ShowTemporaryTablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTemporaryTablesStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTemporaryTablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTemporaryTablesStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTemporaryTablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTemporaryTablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTemporaryTablesStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *ShowTemporaryTablesStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowTemporaryTablesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTemporaryTablesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTemporaryTablesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTemporaryTablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTemporaryTablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTemporaryTablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTemporaryTablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTemporaryTablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTemporaryTablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTemporaryTablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTemporaryTablesStatement(s)
	}
}

func (s *ShowTemporaryTablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTemporaryTablesStatement(s)
	}
}

func (s *ShowTemporaryTablesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowTemporaryTablesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowTemporaryTablesStatement() (localctx IShowTemporaryTablesStatementContext) {
	localctx = NewShowTemporaryTablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, StarRocksParserRULE_showTemporaryTablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1801)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1802)
		p.Match(StarRocksParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1803)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1804)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1805)

			var _x = p.QualifiedName()

			localctx.(*ShowTemporaryTablesStatementContext).db = _x
		}

	}
	p.SetState(1812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1808)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1809)

			var _x = p.String_()

			localctx.(*ShowTemporaryTablesStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1810)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1811)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateTableStatementContext is an interface to support dynamic dispatch.
type IShowCreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode

	// IsShowCreateTableStatementContext differentiates from other interfaces.
	IsShowCreateTableStatementContext()
}

type ShowCreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowCreateTableStatementContext() *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateTableStatement
	return p
}

func InitEmptyShowCreateTableStatementContext(p *ShowCreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateTableStatement
}

func (*ShowCreateTableStatementContext) IsShowCreateTableStatementContext() {}

func NewShowCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateTableStatement

	return p
}

func (s *ShowCreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowCreateTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowCreateTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ShowCreateTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *ShowCreateTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *ShowCreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateTableStatement(s)
	}
}

func (s *ShowCreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateTableStatement(s)
	}
}

func (s *ShowCreateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCreateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCreateTableStatement() (localctx IShowCreateTableStatementContext) {
	localctx = NewShowCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, StarRocksParserRULE_showCreateTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1814)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1815)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserTABLE:
		{
			p.SetState(1816)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserVIEW:
		{
			p.SetState(1817)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMATERIALIZED:
		{
			p.SetState(1818)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1819)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1822)

		var _x = p.QualifiedName()

		localctx.(*ShowCreateTableStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowColumnStatementContext is an interface to support dynamic dispatch.
type IShowColumnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowColumnStatementContext differentiates from other interfaces.
	IsShowColumnStatementContext()
}

type ShowColumnStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	table   IQualifiedNameContext
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowColumnStatementContext() *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showColumnStatement
	return p
}

func InitEmptyShowColumnStatementContext(p *ShowColumnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showColumnStatement
}

func (*ShowColumnStatementContext) IsShowColumnStatementContext() {}

func NewShowColumnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showColumnStatement

	return p
}

func (s *ShowColumnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowColumnStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowColumnStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowColumnStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowColumnStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowColumnStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowColumnStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowColumnStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowColumnStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ShowColumnStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELDS, 0)
}

func (s *ShowColumnStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowColumnStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserFROM)
}

func (s *ShowColumnStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, i)
}

func (s *ShowColumnStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserIN)
}

func (s *ShowColumnStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, i)
}

func (s *ShowColumnStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowColumnStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowColumnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowColumnStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowColumnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowColumnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowColumnStatement(s)
	}
}

func (s *ShowColumnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowColumnStatement(s)
	}
}

func (s *ShowColumnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowColumnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowColumnStatement() (localctx IShowColumnStatementContext) {
	localctx = NewShowColumnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, StarRocksParserRULE_showColumnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1824)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(1825)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1828)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserCOLUMNS || _la == StarRocksParserFIELDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1829)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1830)

		var _x = p.QualifiedName()

		localctx.(*ShowColumnStatementContext).table = _x
	}

	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1832)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1833)

			var _x = p.QualifiedName()

			localctx.(*ShowColumnStatementContext).db = _x
		}

	}
	p.SetState(1840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1836)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1837)

			var _x = p.String_()

			localctx.(*ShowColumnStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1838)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1839)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatusStatementContext is an interface to support dynamic dispatch.
type IShowTableStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatusStatementContext differentiates from other interfaces.
	IsShowTableStatusStatementContext()
}

type ShowTableStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatusStatementContext() *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatusStatement
	return p
}

func InitEmptyShowTableStatusStatementContext(p *ShowTableStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatusStatement
}

func (*ShowTableStatusStatementContext) IsShowTableStatusStatementContext() {}

func NewShowTableStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTableStatusStatement

	return p
}

func (s *ShowTableStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatusStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatusStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTableStatusStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ShowTableStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowTableStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTableStatusStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTableStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTableStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTableStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTableStatusStatement(s)
	}
}

func (s *ShowTableStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTableStatusStatement(s)
	}
}

func (s *ShowTableStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowTableStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowTableStatusStatement() (localctx IShowTableStatusStatementContext) {
	localctx = NewShowTableStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, StarRocksParserRULE_showTableStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1842)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1843)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1844)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1845)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1846)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatusStatementContext).db = _x
		}

	}
	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1849)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1850)

			var _x = p.String_()

			localctx.(*ShowTableStatusStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1851)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1852)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTableStatementContext is an interface to support dynamic dispatch.
type IRefreshTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsRefreshTableStatementContext differentiates from other interfaces.
	IsRefreshTableStatementContext()
}

type RefreshTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTableStatementContext() *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshTableStatement
	return p
}

func InitEmptyRefreshTableStatementContext(p *RefreshTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshTableStatement
}

func (*RefreshTableStatementContext) IsRefreshTableStatementContext() {}

func NewRefreshTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshTableStatement

	return p
}

func (s *RefreshTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTableStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *RefreshTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *RefreshTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshTableStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *RefreshTableStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *RefreshTableStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshTableStatement(s)
	}
}

func (s *RefreshTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshTableStatement(s)
	}
}

func (s *RefreshTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRefreshTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RefreshTableStatement() (localctx IRefreshTableStatementContext) {
	localctx = NewRefreshTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, StarRocksParserRULE_refreshTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1855)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1856)
		p.Match(StarRocksParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1857)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1858)
		p.QualifiedName()
	}
	p.SetState(1871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1859)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1860)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1861)
			p.String_()
		}
		p.SetState(1866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1862)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1863)
				p.String_()
			}

			p.SetState(1868)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1869)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAlterStatementContext is an interface to support dynamic dispatch.
type IShowAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsShowAlterStatementContext differentiates from other interfaces.
	IsShowAlterStatementContext()
}

type ShowAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowAlterStatementContext() *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAlterStatement
	return p
}

func InitEmptyShowAlterStatementContext(p *ShowAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAlterStatement
}

func (*ShowAlterStatementContext) IsShowAlterStatementContext() {}

func NewShowAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAlterStatement

	return p
}

func (s *ShowAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAlterStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowAlterStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowAlterStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *ShowAlterStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ShowAlterStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *ShowAlterStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *ShowAlterStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTIMIZE, 0)
}

func (s *ShowAlterStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowAlterStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAlterStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowAlterStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowAlterStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAlterStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAlterStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAlterStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowAlterStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowAlterStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowAlterStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *ShowAlterStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *ShowAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAlterStatement(s)
	}
}

func (s *ShowAlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAlterStatement(s)
	}
}

func (s *ShowAlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowAlterStatement() (localctx IShowAlterStatementContext) {
	localctx = NewShowAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, StarRocksParserRULE_showAlterStatement)
	var _la int

	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1873)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1874)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1875)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1876)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserCOLUMN || _la == StarRocksParserOPTIMIZE || _la == StarRocksParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM || _la == StarRocksParserIN {
			{
				p.SetState(1877)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1878)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(1881)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1882)
				p.expression(0)
			}

		}
		p.SetState(1895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(1885)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1886)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1887)
				p.SortItem()
			}
			p.SetState(1892)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1888)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1889)
					p.SortItem()
				}

				p.SetState(1894)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(1897)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1900)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1901)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1902)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1903)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM || _la == StarRocksParserIN {
			{
				p.SetState(1904)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1905)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(1908)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1909)
				p.expression(0)
			}

		}
		p.SetState(1922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(1912)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1913)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1914)
				p.SortItem()
			}
			p.SetState(1919)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1915)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1916)
					p.SortItem()
				}

				p.SetState(1921)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(1924)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescTableStatementContext is an interface to support dynamic dispatch.
type IDescTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	QualifiedName() IQualifiedNameContext
	ALL() antlr.TerminalNode

	// IsDescTableStatementContext differentiates from other interfaces.
	IsDescTableStatementContext()
}

type DescTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyDescTableStatementContext() *DescTableStatementContext {
	var p = new(DescTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descTableStatement
	return p
}

func InitEmptyDescTableStatementContext(p *DescTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descTableStatement
}

func (*DescTableStatementContext) IsDescTableStatementContext() {}

func NewDescTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescTableStatementContext {
	var p = new(DescTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_descTableStatement

	return p
}

func (s *DescTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *DescTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *DescTableStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *DescTableStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *DescTableStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILES, 0)
}

func (s *DescTableStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DescTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescTableStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *DescTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDescTableStatement(s)
	}
}

func (s *DescTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDescTableStatement(s)
	}
}

func (s *DescTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDescTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DescTableStatement() (localctx IDescTableStatementContext) {
	localctx = NewDescTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, StarRocksParserRULE_descTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1929)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDESC || _la == StarRocksParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(1930)

			var _x = p.QualifiedName()

			localctx.(*DescTableStatementContext).table = _x
		}
		p.SetState(1932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL {
			{
				p.SetState(1931)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserFILES:
		{
			p.SetState(1934)
			p.Match(StarRocksParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.PropertyList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableLikeStatementContext is an interface to support dynamic dispatch.
type ICreateTableLikeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableLikeStatementContext differentiates from other interfaces.
	IsCreateTableLikeStatementContext()
}

type CreateTableLikeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableLikeStatementContext() *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableLikeStatement
	return p
}

func InitEmptyCreateTableLikeStatementContext(p *CreateTableLikeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableLikeStatement
}

func (*CreateTableLikeStatementContext) IsCreateTableLikeStatementContext() {}

func NewCreateTableLikeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createTableLikeStatement

	return p
}

func (s *CreateTableLikeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableLikeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateTableLikeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateTableLikeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableLikeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *CreateTableLikeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateTableLikeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateTableLikeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateTableLikeStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableLikeStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableLikeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableLikeStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CreateTableLikeStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateTableLikeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableLikeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateTableLikeStatement(s)
	}
}

func (s *CreateTableLikeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateTableLikeStatement(s)
	}
}

func (s *CreateTableLikeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateTableLikeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateTableLikeStatement() (localctx ICreateTableLikeStatementContext) {
	localctx = NewCreateTableLikeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, StarRocksParserRULE_createTableLikeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1938)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1939)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1942)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1943)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1944)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1945)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1948)
		p.QualifiedName()
	}
	p.SetState(1950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1949)
			p.PartitionDesc()
		}

	}
	p.SetState(1953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(1952)
			p.DistributionDesc()
		}

	}
	p.SetState(1956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1955)
			p.Properties()
		}

	}
	{
		p.SetState(1958)
		p.Match(StarRocksParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1959)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowIndexStatementContext is an interface to support dynamic dispatch.
type IShowIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KEYS() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowIndexStatementContext differentiates from other interfaces.
	IsShowIndexStatementContext()
}

type ShowIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
	db     IQualifiedNameContext
}

func NewEmptyShowIndexStatementContext() *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showIndexStatement
	return p
}

func InitEmptyShowIndexStatementContext(p *ShowIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showIndexStatement
}

func (*ShowIndexStatementContext) IsShowIndexStatementContext() {}

func NewShowIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showIndexStatement

	return p
}

func (s *ShowIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowIndexStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowIndexStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowIndexStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowIndexStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowIndexStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *ShowIndexStatementContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEXES, 0)
}

func (s *ShowIndexStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *ShowIndexStatementContext) KEYS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEYS, 0)
}

func (s *ShowIndexStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserFROM)
}

func (s *ShowIndexStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, i)
}

func (s *ShowIndexStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserIN)
}

func (s *ShowIndexStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, i)
}

func (s *ShowIndexStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowIndexStatement(s)
	}
}

func (s *ShowIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowIndexStatement(s)
	}
}

func (s *ShowIndexStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowIndexStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowIndexStatement() (localctx IShowIndexStatementContext) {
	localctx = NewShowIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, StarRocksParserRULE_showIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1961)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1962)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-205)) & ^0x3f) == 0 && ((int64(1)<<(_la-205))&12582915) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1963)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1964)

		var _x = p.QualifiedName()

		localctx.(*ShowIndexStatementContext).table = _x
	}

	p.SetState(1968)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1966)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1967)

			var _x = p.QualifiedName()

			localctx.(*ShowIndexStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverTableStatementContext is an interface to support dynamic dispatch.
type IRecoverTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverTableStatementContext differentiates from other interfaces.
	IsRecoverTableStatementContext()
}

type RecoverTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverTableStatementContext() *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverTableStatement
	return p
}

func InitEmptyRecoverTableStatementContext(p *RecoverTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverTableStatement
}

func (*RecoverTableStatementContext) IsRecoverTableStatementContext() {}

func NewRecoverTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_recoverTableStatement

	return p
}

func (s *RecoverTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverTableStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *RecoverTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *RecoverTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRecoverTableStatement(s)
	}
}

func (s *RecoverTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRecoverTableStatement(s)
	}
}

func (s *RecoverTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRecoverTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RecoverTableStatement() (localctx IRecoverTableStatementContext) {
	localctx = NewRecoverTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, StarRocksParserRULE_recoverTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1970)
		p.Match(StarRocksParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1971)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1972)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateTableStatementContext is an interface to support dynamic dispatch.
type ITruncateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTruncateTableStatementContext differentiates from other interfaces.
	IsTruncateTableStatementContext()
}

type TruncateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableStatementContext() *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncateTableStatement
	return p
}

func InitEmptyTruncateTableStatementContext(p *TruncateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncateTableStatement
}

func (*TruncateTableStatementContext) IsTruncateTableStatementContext() {}

func NewTruncateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_truncateTableStatement

	return p
}

func (s *TruncateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *TruncateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *TruncateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TruncateTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTruncateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TruncateTableStatement() (localctx ITruncateTableStatementContext) {
	localctx = NewTruncateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, StarRocksParserRULE_truncateTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1974)
		p.Match(StarRocksParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1975)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1976)
		p.QualifiedName()
	}
	p.SetState(1978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1977)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterTableStatementContext is an interface to support dynamic dispatch.
type ICancelAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsCancelAlterTableStatementContext differentiates from other interfaces.
	IsCancelAlterTableStatementContext()
}

type CancelAlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterTableStatementContext() *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterTableStatement
	return p
}

func InitEmptyCancelAlterTableStatementContext(p *CancelAlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterTableStatement
}

func (*CancelAlterTableStatementContext) IsCancelAlterTableStatementContext() {}

func NewCancelAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelAlterTableStatement

	return p
}

func (s *CancelAlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelAlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *CancelAlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CancelAlterTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelAlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelAlterTableStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *CancelAlterTableStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *CancelAlterTableStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *CancelAlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *CancelAlterTableStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTIMIZE, 0)
}

func (s *CancelAlterTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *CancelAlterTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CancelAlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelAlterTableStatement(s)
	}
}

func (s *CancelAlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelAlterTableStatement(s)
	}
}

func (s *CancelAlterTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelAlterTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelAlterTableStatement() (localctx ICancelAlterTableStatementContext) {
	localctx = NewCancelAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, StarRocksParserRULE_cancelAlterTableStatement)
	var _la int

	p.SetState(2006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1980)
			p.Match(StarRocksParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1981)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1982)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCOLUMN || _la == StarRocksParserOPTIMIZE || _la == StarRocksParserROLLUP {
			{
				p.SetState(1983)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserCOLUMN || _la == StarRocksParserOPTIMIZE || _la == StarRocksParserROLLUP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1986)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1987)
			p.QualifiedName()
		}
		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(1988)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1989)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1994)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1990)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1991)
					p.Match(StarRocksParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1996)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1997)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2000)
			p.Match(StarRocksParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2001)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2002)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2003)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2004)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2005)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPartitionsStatementContext is an interface to support dynamic dispatch.
type IShowPartitionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowPartitionsStatementContext differentiates from other interfaces.
	IsShowPartitionsStatementContext()
}

type ShowPartitionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowPartitionsStatementContext() *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPartitionsStatement
	return p
}

func InitEmptyShowPartitionsStatementContext(p *ShowPartitionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPartitionsStatement
}

func (*ShowPartitionsStatementContext) IsShowPartitionsStatementContext() {}

func NewShowPartitionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPartitionsStatement

	return p
}

func (s *ShowPartitionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPartitionsStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowPartitionsStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowPartitionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPartitionsStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *ShowPartitionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowPartitionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPartitionsStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *ShowPartitionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowPartitionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPartitionsStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowPartitionsStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowPartitionsStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPartitionsStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPartitionsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPartitionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPartitionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPartitionsStatement(s)
	}
}

func (s *ShowPartitionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPartitionsStatement(s)
	}
}

func (s *ShowPartitionsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowPartitionsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowPartitionsStatement() (localctx IShowPartitionsStatementContext) {
	localctx = NewShowPartitionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, StarRocksParserRULE_showPartitionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2008)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2009)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2012)
		p.Match(StarRocksParserPARTITIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2013)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2014)

		var _x = p.QualifiedName()

		localctx.(*ShowPartitionsStatementContext).table = _x
	}
	p.SetState(2017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(2015)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2016)
			p.expression(0)
		}

	}
	p.SetState(2029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(2019)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2020)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2021)
			p.SortItem()
		}
		p.SetState(2026)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2022)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2023)
				p.SortItem()
			}

			p.SetState(2028)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(2031)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverPartitionStatementContext is an interface to support dynamic dispatch.
type IRecoverPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	RECOVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverPartitionStatementContext differentiates from other interfaces.
	IsRecoverPartitionStatementContext()
}

type RecoverPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyRecoverPartitionStatementContext() *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverPartitionStatement
	return p
}

func InitEmptyRecoverPartitionStatementContext(p *RecoverPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverPartitionStatement
}

func (*RecoverPartitionStatementContext) IsRecoverPartitionStatementContext() {}

func NewRecoverPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_recoverPartitionStatement

	return p
}

func (s *RecoverPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverPartitionStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *RecoverPartitionStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *RecoverPartitionStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *RecoverPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *RecoverPartitionStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RecoverPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRecoverPartitionStatement(s)
	}
}

func (s *RecoverPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRecoverPartitionStatement(s)
	}
}

func (s *RecoverPartitionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRecoverPartitionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RecoverPartitionStatement() (localctx IRecoverPartitionStatementContext) {
	localctx = NewRecoverPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, StarRocksParserRULE_recoverPartitionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2034)
		p.Match(StarRocksParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2035)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2036)
		p.Identifier()
	}
	{
		p.SetState(2037)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2038)

		var _x = p.QualifiedName()

		localctx.(*RecoverPartitionStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewStatementContext is an interface to support dynamic dispatch.
type ICreateViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode

	// IsCreateViewStatementContext differentiates from other interfaces.
	IsCreateViewStatementContext()
}

type CreateViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewStatementContext() *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createViewStatement
	return p
}

func InitEmptyCreateViewStatementContext(p *CreateViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createViewStatement
}

func (*CreateViewStatementContext) IsCreateViewStatementContext() {}

func NewCreateViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createViewStatement

	return p
}

func (s *CreateViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CreateViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreateViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateViewStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateViewStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *CreateViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *CreateViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINVOKER, 0)
}

func (s *CreateViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateViewStatement() (localctx ICreateViewStatementContext) {
	localctx = NewCreateViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, StarRocksParserRULE_createViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2040)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserOR {
		{
			p.SetState(2041)
			p.Match(StarRocksParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2042)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2045)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2046)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2047)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2048)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2051)
		p.QualifiedName()
	}
	p.SetState(2063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(2052)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2053)
			p.ColumnNameWithComment()
		}
		p.SetState(2058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2054)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2055)
				p.ColumnNameWithComment()
			}

			p.SetState(2060)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2061)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2065)
			p.Comment()
		}

	}
	p.SetState(2070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSECURITY {
		{
			p.SetState(2068)
			p.Match(StarRocksParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2069)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserINVOKER || _la == StarRocksParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2072)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2073)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewStatementContext is an interface to support dynamic dispatch.
type IAlterViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	SET() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	Properties() IPropertiesContext
	DIALECT() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	STARROCKS() antlr.TerminalNode

	// IsAlterViewStatementContext differentiates from other interfaces.
	IsAlterViewStatementContext()
}

type AlterViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewStatementContext() *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterViewStatement
	return p
}

func InitEmptyAlterViewStatementContext(p *AlterViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterViewStatement
}

func (*AlterViewStatementContext) IsAlterViewStatementContext() {}

func NewAlterViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterViewStatement

	return p
}

func (s *AlterViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *AlterViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *AlterViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *AlterViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *AlterViewStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *AlterViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *AlterViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINVOKER, 0)
}

func (s *AlterViewStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterViewStatementContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDIALECT, 0)
}

func (s *AlterViewStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterViewStatementContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *AlterViewStatementContext) STARROCKS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTARROCKS, 0)
}

func (s *AlterViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterViewStatement(s)
	}
}

func (s *AlterViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterViewStatement(s)
	}
}

func (s *AlterViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterViewStatement() (localctx IAlterViewStatementContext) {
	localctx = NewAlterViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, StarRocksParserRULE_alterViewStatement)
	var _la int

	p.SetState(2117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2075)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2076)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2077)
			p.QualifiedName()
		}
		p.SetState(2089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(2078)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2079)
				p.ColumnNameWithComment()
			}
			p.SetState(2084)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(2080)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2081)
					p.ColumnNameWithComment()
				}

				p.SetState(2086)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2087)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2091)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2092)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2094)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2095)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)
			p.QualifiedName()
		}
		{
			p.SetState(2097)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.Match(StarRocksParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2099)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserINVOKER || _la == StarRocksParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2101)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2102)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2103)
			p.QualifiedName()
		}
		{
			p.SetState(2104)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2105)
			p.Properties()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2107)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2108)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2109)
			p.QualifiedName()
		}
		{
			p.SetState(2110)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserADD || _la == StarRocksParserMODIFY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2111)
			p.Match(StarRocksParserDIALECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSTARROCKS {
			{
				p.SetState(2112)
				p.Match(StarRocksParserSTARROCKS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2115)
			p.QueryStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewStatementContext is an interface to support dynamic dispatch.
type IDropViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropViewStatementContext differentiates from other interfaces.
	IsDropViewStatementContext()
}

type DropViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewStatementContext() *DropViewStatementContext {
	var p = new(DropViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropViewStatement
	return p
}

func InitEmptyDropViewStatementContext(p *DropViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropViewStatement
}

func (*DropViewStatementContext) IsDropViewStatementContext() {}

func NewDropViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewStatementContext {
	var p = new(DropViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropViewStatement

	return p
}

func (s *DropViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *DropViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropViewStatement() (localctx IDropViewStatementContext) {
	localctx = NewDropViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, StarRocksParserRULE_dropViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2119)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2120)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2121)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2122)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2125)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameWithCommentContext is an interface to support dynamic dispatch.
type IColumnNameWithCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnName returns the columnName rule contexts.
	GetColumnName() IIdentifierContext

	// SetColumnName sets the columnName rule contexts.
	SetColumnName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	Comment() ICommentContext

	// IsColumnNameWithCommentContext differentiates from other interfaces.
	IsColumnNameWithCommentContext()
}

type ColumnNameWithCommentContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	columnName IIdentifierContext
}

func NewEmptyColumnNameWithCommentContext() *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNameWithComment
	return p
}

func InitEmptyColumnNameWithCommentContext(p *ColumnNameWithCommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNameWithComment
}

func (*ColumnNameWithCommentContext) IsColumnNameWithCommentContext() {}

func NewColumnNameWithCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnNameWithComment

	return p
}

func (s *ColumnNameWithCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameWithCommentContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *ColumnNameWithCommentContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *ColumnNameWithCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnNameWithCommentContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnNameWithCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameWithCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameWithCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnNameWithComment(s)
	}
}

func (s *ColumnNameWithCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnNameWithComment(s)
	}
}

func (s *ColumnNameWithCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnNameWithComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnNameWithComment() (localctx IColumnNameWithCommentContext) {
	localctx = NewColumnNameWithCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, StarRocksParserRULE_columnNameWithComment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2127)

		var _x = p.Identifier()

		localctx.(*ColumnNameWithCommentContext).columnName = _x
	}
	p.SetState(2129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2128)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubmitTaskStatementContext is an interface to support dynamic dispatch.
type ISubmitTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBMIT() antlr.TerminalNode
	TASK() antlr.TerminalNode
	AS() antlr.TerminalNode
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	InsertStatement() IInsertStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	QualifiedName() IQualifiedNameContext
	AllTaskClause() []ITaskClauseContext
	TaskClause(i int) ITaskClauseContext

	// IsSubmitTaskStatementContext differentiates from other interfaces.
	IsSubmitTaskStatementContext()
}

type SubmitTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubmitTaskStatementContext() *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_submitTaskStatement
	return p
}

func InitEmptySubmitTaskStatementContext(p *SubmitTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_submitTaskStatement
}

func (*SubmitTaskStatementContext) IsSubmitTaskStatementContext() {}

func NewSubmitTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_submitTaskStatement

	return p
}

func (s *SubmitTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubmitTaskStatementContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUBMIT, 0)
}

func (s *SubmitTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *SubmitTaskStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SubmitTaskStatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *SubmitTaskStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *SubmitTaskStatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *SubmitTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SubmitTaskStatementContext) AllTaskClause() []ITaskClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITaskClauseContext); ok {
			len++
		}
	}

	tst := make([]ITaskClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITaskClauseContext); ok {
			tst[i] = t.(ITaskClauseContext)
			i++
		}
	}

	return tst
}

func (s *SubmitTaskStatementContext) TaskClause(i int) ITaskClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskClauseContext)
}

func (s *SubmitTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubmitTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubmitTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubmitTaskStatement(s)
	}
}

func (s *SubmitTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubmitTaskStatement(s)
	}
}

func (s *SubmitTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSubmitTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SubmitTaskStatement() (localctx ISubmitTaskStatementContext) {
	localctx = NewSubmitTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, StarRocksParserRULE_submitTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2131)
		p.Match(StarRocksParserSUBMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2132)
		p.Match(StarRocksParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2134)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2133)
			p.QualifiedName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserPROPERTIES || _la == StarRocksParserSCHEDULE {
		{
			p.SetState(2136)
			p.TaskClause()
		}

		p.SetState(2141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2142)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCREATE:
		{
			p.SetState(2143)
			p.CreateTableAsSelectStatement()
		}

	case StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserEXPLAIN, StarRocksParserINSERT:
		{
			p.SetState(2144)
			p.InsertStatement()
		}

	case StarRocksParserCACHE:
		{
			p.SetState(2145)
			p.DataCacheSelectStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskClauseContext is an interface to support dynamic dispatch.
type ITaskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext
	TaskScheduleDesc() ITaskScheduleDescContext

	// IsTaskClauseContext differentiates from other interfaces.
	IsTaskClauseContext()
}

type TaskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskClauseContext() *TaskClauseContext {
	var p = new(TaskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskClause
	return p
}

func InitEmptyTaskClauseContext(p *TaskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskClause
}

func (*TaskClauseContext) IsTaskClauseContext() {}

func NewTaskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskClauseContext {
	var p = new(TaskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskClause

	return p
}

func (s *TaskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *TaskClauseContext) TaskScheduleDesc() ITaskScheduleDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskScheduleDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskScheduleDescContext)
}

func (s *TaskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskClause(s)
	}
}

func (s *TaskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskClause(s)
	}
}

func (s *TaskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTaskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TaskClause() (localctx ITaskClauseContext) {
	localctx = NewTaskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, StarRocksParserRULE_taskClause)
	p.SetState(2150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserPROPERTIES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2148)
			p.Properties()
		}

	case StarRocksParserSCHEDULE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2149)
			p.TaskScheduleDesc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTaskStatementContext is an interface to support dynamic dispatch.
type IDropTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TASK() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FORCE() antlr.TerminalNode

	// IsDropTaskStatementContext differentiates from other interfaces.
	IsDropTaskStatementContext()
}

type DropTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTaskStatementContext() *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTaskStatement
	return p
}

func InitEmptyDropTaskStatementContext(p *DropTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTaskStatement
}

func (*DropTaskStatementContext) IsDropTaskStatementContext() {}

func NewDropTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropTaskStatement

	return p
}

func (s *DropTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTaskStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *DropTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTaskStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropTaskStatement(s)
	}
}

func (s *DropTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropTaskStatement(s)
	}
}

func (s *DropTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropTaskStatement() (localctx IDropTaskStatementContext) {
	localctx = NewDropTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, StarRocksParserRULE_dropTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2152)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2153)
		p.Match(StarRocksParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2154)
		p.QualifiedName()
	}
	p.SetState(2156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2155)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskScheduleDescContext is an interface to support dynamic dispatch.
type ITaskScheduleDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEDULE() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	TaskInterval() ITaskIntervalContext
	START() antlr.TerminalNode
	String_() IStringContext

	// IsTaskScheduleDescContext differentiates from other interfaces.
	IsTaskScheduleDescContext()
}

type TaskScheduleDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskScheduleDescContext() *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskScheduleDesc
	return p
}

func InitEmptyTaskScheduleDescContext(p *TaskScheduleDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskScheduleDesc
}

func (*TaskScheduleDescContext) IsTaskScheduleDescContext() {}

func NewTaskScheduleDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskScheduleDesc

	return p
}

func (s *TaskScheduleDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskScheduleDescContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULE, 0)
}

func (s *TaskScheduleDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *TaskScheduleDescContext) TaskInterval() ITaskIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskIntervalContext)
}

func (s *TaskScheduleDescContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *TaskScheduleDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TaskScheduleDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskScheduleDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskScheduleDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskScheduleDesc(s)
	}
}

func (s *TaskScheduleDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskScheduleDesc(s)
	}
}

func (s *TaskScheduleDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTaskScheduleDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TaskScheduleDesc() (localctx ITaskScheduleDescContext) {
	localctx = NewTaskScheduleDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, StarRocksParserRULE_taskScheduleDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2158)
		p.Match(StarRocksParserSCHEDULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSTART {
		{
			p.SetState(2159)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2160)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2161)
			p.String_()
		}
		{
			p.SetState(2162)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2166)
		p.Match(StarRocksParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2167)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2168)
		p.TaskInterval()
	}
	{
		p.SetState(2169)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	AllMaterializedViewDesc() []IMaterializedViewDescContext
	MaterializedViewDesc(i int) IMaterializedViewDescContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateMaterializedViewStatementContext differentiates from other interfaces.
	IsCreateMaterializedViewStatementContext()
}

type CreateMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCreateMaterializedViewStatementContext() *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createMaterializedViewStatement
	return p
}

func InitEmptyCreateMaterializedViewStatementContext(p *CreateMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createMaterializedViewStatement
}

func (*CreateMaterializedViewStatementContext) IsCreateMaterializedViewStatementContext() {}

func NewCreateMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createMaterializedViewStatement

	return p
}

func (s *CreateMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *CreateMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *CreateMaterializedViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *CreateMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CreateMaterializedViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreateMaterializedViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateMaterializedViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateMaterializedViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateMaterializedViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateMaterializedViewStatementContext) AllMaterializedViewDesc() []IMaterializedViewDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			len++
		}
	}

	tst := make([]IMaterializedViewDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMaterializedViewDescContext); ok {
			tst[i] = t.(IMaterializedViewDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) MaterializedViewDesc(i int) IMaterializedViewDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewDescContext)
}

func (s *CreateMaterializedViewStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateMaterializedViewStatement() (localctx ICreateMaterializedViewStatementContext) {
	localctx = NewCreateMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, StarRocksParserRULE_createMaterializedViewStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2171)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2172)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2173)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2174)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2176)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2179)

		var _x = p.QualifiedName()

		localctx.(*CreateMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(2180)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2181)
			p.ColumnNameWithComment()
		}
		p.SetState(2186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2182)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2183)
					p.ColumnNameWithComment()
				}

			}
			p.SetState(2188)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2189)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2190)
				p.IndexDesc()
			}

			p.SetState(2195)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2196)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2200)
			p.Comment()
		}

	}
	p.SetState(2206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserDISTRIBUTED || ((int64((_la-298)) & ^0x3f) == 0 && ((int64(1)<<(_la-298))&1125917086711841) != 0) {
		{
			p.SetState(2203)
			p.MaterializedViewDesc()
		}

		p.SetState(2208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2209)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2210)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionExprsContext is an interface to support dynamic dispatch.
type IMvPartitionExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext

	// IsMvPartitionExprsContext differentiates from other interfaces.
	IsMvPartitionExprsContext()
}

type MvPartitionExprsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvPartitionExprsContext() *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mvPartitionExprs
	return p
}

func InitEmptyMvPartitionExprsContext(p *MvPartitionExprsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mvPartitionExprs
}

func (*MvPartitionExprsContext) IsMvPartitionExprsContext() {}

func NewMvPartitionExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mvPartitionExprs

	return p
}

func (s *MvPartitionExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionExprsContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MvPartitionExprsContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MvPartitionExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMvPartitionExprs(s)
	}
}

func (s *MvPartitionExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMvPartitionExprs(s)
	}
}

func (s *MvPartitionExprsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMvPartitionExprs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MvPartitionExprs() (localctx IMvPartitionExprsContext) {
	localctx = NewMvPartitionExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, StarRocksParserRULE_mvPartitionExprs)
	var _la int

	p.SetState(2224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2212)
			p.primaryExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2213)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2214)
			p.primaryExpression(0)
		}
		p.SetState(2219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2215)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2216)
				p.primaryExpression(0)
			}

			p.SetState(2221)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2222)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewDescContext is an interface to support dynamic dispatch.
type IMaterializedViewDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	MvPartitionExprs() IMvPartitionExprsContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	Properties() IPropertiesContext

	// IsMaterializedViewDescContext differentiates from other interfaces.
	IsMaterializedViewDescContext()
}

type MaterializedViewDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewDescContext() *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_materializedViewDesc
	return p
}

func InitEmptyMaterializedViewDescContext(p *MaterializedViewDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_materializedViewDesc
}

func (*MaterializedViewDescContext) IsMaterializedViewDescContext() {}

func NewMaterializedViewDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_materializedViewDesc

	return p
}

func (s *MaterializedViewDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *MaterializedViewDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *MaterializedViewDescContext) MvPartitionExprs() IMvPartitionExprsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionExprsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionExprsContext)
}

func (s *MaterializedViewDescContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *MaterializedViewDescContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *MaterializedViewDescContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *MaterializedViewDescContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *MaterializedViewDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMaterializedViewDesc(s)
	}
}

func (s *MaterializedViewDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMaterializedViewDesc(s)
	}
}

func (s *MaterializedViewDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMaterializedViewDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MaterializedViewDesc() (localctx IMaterializedViewDescContext) {
	localctx = NewMaterializedViewDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, StarRocksParserRULE_materializedViewDesc)
	p.SetState(2233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2226)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2227)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2228)
			p.MvPartitionExprs()
		}

	case StarRocksParserDISTRIBUTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2229)
			p.DistributionDesc()
		}

	case StarRocksParserORDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2230)
			p.OrderByDesc()
		}

	case StarRocksParserREFRESH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2231)
			p.RefreshSchemeDesc()
		}

	case StarRocksParserPROPERTIES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2232)
			p.Properties()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowMaterializedViewsStatementContext is an interface to support dynamic dispatch.
type IShowMaterializedViewsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowMaterializedViewsStatementContext differentiates from other interfaces.
	IsShowMaterializedViewsStatementContext()
}

type ShowMaterializedViewsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowMaterializedViewsStatementContext() *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showMaterializedViewsStatement
	return p
}

func InitEmptyShowMaterializedViewsStatementContext(p *ShowMaterializedViewsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showMaterializedViewsStatement
}

func (*ShowMaterializedViewsStatementContext) IsShowMaterializedViewsStatementContext() {}

func NewShowMaterializedViewsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showMaterializedViewsStatement

	return p
}

func (s *ShowMaterializedViewsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowMaterializedViewsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowMaterializedViewsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowMaterializedViewsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowMaterializedViewsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowMaterializedViewsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowMaterializedViewsStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *ShowMaterializedViewsStatementContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *ShowMaterializedViewsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowMaterializedViewsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowMaterializedViewsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowMaterializedViewsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowMaterializedViewsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowMaterializedViewsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowMaterializedViewsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowMaterializedViewsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMaterializedViewsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowMaterializedViewsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowMaterializedViewsStatement(s)
	}
}

func (s *ShowMaterializedViewsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowMaterializedViewsStatement(s)
	}
}

func (s *ShowMaterializedViewsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowMaterializedViewsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowMaterializedViewsStatement() (localctx IShowMaterializedViewsStatementContext) {
	localctx = NewShowMaterializedViewsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, StarRocksParserRULE_showMaterializedViewsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2235)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2236)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2237)
		p.Match(StarRocksParserVIEWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(2238)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2239)

			var _x = p.QualifiedName()

			localctx.(*ShowMaterializedViewsStatementContext).db = _x
		}

	}
	p.SetState(2246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(2242)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2243)

			var _x = p.String_()

			localctx.(*ShowMaterializedViewsStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(2244)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2245)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropMaterializedViewStatementContext differentiates from other interfaces.
	IsDropMaterializedViewStatementContext()
}

type DropMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyDropMaterializedViewStatementContext() *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropMaterializedViewStatement
	return p
}

func InitEmptyDropMaterializedViewStatementContext(p *DropMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropMaterializedViewStatement
}

func (*DropMaterializedViewStatementContext) IsDropMaterializedViewStatementContext() {}

func NewDropMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropMaterializedViewStatement

	return p
}

func (s *DropMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *DropMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *DropMaterializedViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *DropMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *DropMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropMaterializedViewStatement() (localctx IDropMaterializedViewStatementContext) {
	localctx = NewDropMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, StarRocksParserRULE_dropMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2248)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2249)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2250)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2251)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2252)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2255)

		var _x = p.QualifiedName()

		localctx.(*DropMaterializedViewStatementContext).mvName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	TableRenameClause() ITableRenameClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	SwapTableClause() ISwapTableClauseContext
	StatusDesc() IStatusDescContext

	// IsAlterMaterializedViewStatementContext differentiates from other interfaces.
	IsAlterMaterializedViewStatementContext()
}

type AlterMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyAlterMaterializedViewStatementContext() *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterMaterializedViewStatement
	return p
}

func InitEmptyAlterMaterializedViewStatementContext(p *AlterMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterMaterializedViewStatement
}

func (*AlterMaterializedViewStatementContext) IsAlterMaterializedViewStatementContext() {}

func NewAlterMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterMaterializedViewStatement

	return p
}

func (s *AlterMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *AlterMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *AlterMaterializedViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *AlterMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *AlterMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterMaterializedViewStatementContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *AlterMaterializedViewStatementContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterMaterializedViewStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterMaterializedViewStatementContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterMaterializedViewStatementContext) StatusDesc() IStatusDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatusDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatusDescContext)
}

func (s *AlterMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterMaterializedViewStatement(s)
	}
}

func (s *AlterMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterMaterializedViewStatement(s)
	}
}

func (s *AlterMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterMaterializedViewStatement() (localctx IAlterMaterializedViewStatementContext) {
	localctx = NewAlterMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, StarRocksParserRULE_alterMaterializedViewStatement)
	p.SetState(2273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2257)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2258)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2259)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2260)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		p.SetState(2265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserREFRESH:
			{
				p.SetState(2261)
				p.RefreshSchemeDesc()
			}

		case StarRocksParserRENAME:
			{
				p.SetState(2262)
				p.TableRenameClause()
			}

		case StarRocksParserSET:
			{
				p.SetState(2263)
				p.ModifyPropertiesClause()
			}

		case StarRocksParserSWAP:
			{
				p.SetState(2264)
				p.SwapTableClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2267)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2268)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2269)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2270)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		{
			p.SetState(2271)
			p.StatusDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	MODE() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	PartitionRangeDesc() IPartitionRangeDescContext
	ListPartitionValues() IListPartitionValuesContext

	// IsRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsRefreshMaterializedViewStatementContext()
}

type RefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	mvName   IQualifiedNameContext
	priority antlr.Token
}

func NewEmptyRefreshMaterializedViewStatementContext() *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshMaterializedViewStatement
	return p
}

func InitEmptyRefreshMaterializedViewStatementContext(p *RefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshMaterializedViewStatement
}

func (*RefreshMaterializedViewStatementContext) IsRefreshMaterializedViewStatementContext() {}

func NewRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshMaterializedViewStatement

	return p
}

func (s *RefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMaterializedViewStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *RefreshMaterializedViewStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *RefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *RefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *RefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *RefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *RefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshMaterializedViewStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *RefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *RefreshMaterializedViewStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserWITH)
}

func (s *RefreshMaterializedViewStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, i)
}

func (s *RefreshMaterializedViewStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIORITY, 0)
}

func (s *RefreshMaterializedViewStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PartitionRangeDesc() IPartitionRangeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRangeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRangeDescContext)
}

func (s *RefreshMaterializedViewStatementContext) ListPartitionValues() IListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValuesContext)
}

func (s *RefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshMaterializedViewStatement(s)
	}
}

func (s *RefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshMaterializedViewStatement(s)
	}
}

func (s *RefreshMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRefreshMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RefreshMaterializedViewStatement() (localctx IRefreshMaterializedViewStatementContext) {
	localctx = NewRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, StarRocksParserRULE_refreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2275)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2276)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2277)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2278)

		var _x = p.QualifiedName()

		localctx.(*RefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(2279)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserSTART:
			{
				p.SetState(2280)
				p.PartitionRangeDesc()
			}

		case StarRocksParserT__1:
			{
				p.SetState(2281)
				p.ListPartitionValues()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2286)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2292)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2289)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2290)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2291)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(2294)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2295)
			p.Match(StarRocksParserPRIORITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2296)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*RefreshMaterializedViewStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FORCE() antlr.TerminalNode

	// IsCancelRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsCancelRefreshMaterializedViewStatementContext()
}

type CancelRefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCancelRefreshMaterializedViewStatementContext() *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshMaterializedViewStatement
	return p
}

func InitEmptyCancelRefreshMaterializedViewStatementContext(p *CancelRefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshMaterializedViewStatement
}

func (*CancelRefreshMaterializedViewStatementContext) IsCancelRefreshMaterializedViewStatementContext() {
}

func NewCancelRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelRefreshMaterializedViewStatement

	return p
}

func (s *CancelRefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext {
	return s.mvName
}

func (s *CancelRefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) {
	s.mvName = v
}

func (s *CancelRefreshMaterializedViewStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelRefreshMaterializedViewStatement(s)
	}
}

func (s *CancelRefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelRefreshMaterializedViewStatement(s)
	}
}

func (s *CancelRefreshMaterializedViewStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelRefreshMaterializedViewStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelRefreshMaterializedViewStatement() (localctx ICancelRefreshMaterializedViewStatementContext) {
	localctx = NewCancelRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, StarRocksParserRULE_cancelRefreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2299)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2300)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2301)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2302)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2303)

		var _x = p.QualifiedName()

		localctx.(*CancelRefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2304)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetConfigStatementContext is an interface to support dynamic dispatch.
type IAdminSetConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	Property() IPropertyContext
	WITH() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode

	// IsAdminSetConfigStatementContext differentiates from other interfaces.
	IsAdminSetConfigStatementContext()
}

type AdminSetConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetConfigStatementContext() *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetConfigStatement
	return p
}

func InitEmptyAdminSetConfigStatementContext(p *AdminSetConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetConfigStatement
}

func (*AdminSetConfigStatementContext) IsAdminSetConfigStatementContext() {}

func NewAdminSetConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetConfigStatement

	return p
}

func (s *AdminSetConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetConfigStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *AdminSetConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONFIG, 0)
}

func (s *AdminSetConfigStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminSetConfigStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AdminSetConfigStatementContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERSISTENT, 0)
}

func (s *AdminSetConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetConfigStatement(s)
	}
}

func (s *AdminSetConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetConfigStatement(s)
	}
}

func (s *AdminSetConfigStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminSetConfigStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminSetConfigStatement() (localctx IAdminSetConfigStatementContext) {
	localctx = NewAdminSetConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, StarRocksParserRULE_adminSetConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2307)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2308)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2309)
		p.Match(StarRocksParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2310)
		p.Match(StarRocksParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2311)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2312)
		p.Property()
	}
	{
		p.SetState(2313)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(2314)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2315)
			p.Match(StarRocksParserPERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminSetReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAdminSetReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminSetReplicaStatusStatementContext()
}

type AdminSetReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetReplicaStatusStatementContext() *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetReplicaStatusStatement
	return p
}

func InitEmptyAdminSetReplicaStatusStatementContext(p *AdminSetReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetReplicaStatusStatement
}

func (*AdminSetReplicaStatusStatementContext) IsAdminSetReplicaStatusStatementContext() {}

func NewAdminSetReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetReplicaStatusStatement

	return p
}

func (s *AdminSetReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetReplicaStatusStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AdminSetReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetReplicaStatusStatement(s)
	}
}

func (s *AdminSetReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetReplicaStatusStatement(s)
	}
}

func (s *AdminSetReplicaStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminSetReplicaStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminSetReplicaStatusStatement() (localctx IAdminSetReplicaStatusStatementContext) {
	localctx = NewAdminSetReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, StarRocksParserRULE_adminSetReplicaStatusStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2318)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2319)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2320)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2321)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2322)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowConfigStatementContext is an interface to support dynamic dispatch.
type IAdminShowConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsAdminShowConfigStatementContext differentiates from other interfaces.
	IsAdminShowConfigStatementContext()
}

type AdminShowConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyAdminShowConfigStatementContext() *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowConfigStatement
	return p
}

func InitEmptyAdminShowConfigStatementContext(p *AdminShowConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowConfigStatement
}

func (*AdminShowConfigStatementContext) IsAdminShowConfigStatementContext() {}

func NewAdminShowConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminShowConfigStatement

	return p
}

func (s *AdminShowConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowConfigStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *AdminShowConfigStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *AdminShowConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminShowConfigStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *AdminShowConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *AdminShowConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONFIG, 0)
}

func (s *AdminShowConfigStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *AdminShowConfigStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AdminShowConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminShowConfigStatement(s)
	}
}

func (s *AdminShowConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminShowConfigStatement(s)
	}
}

func (s *AdminShowConfigStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminShowConfigStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminShowConfigStatement() (localctx IAdminShowConfigStatementContext) {
	localctx = NewAdminShowConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, StarRocksParserRULE_adminShowConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2324)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2325)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2326)
		p.Match(StarRocksParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2327)
		p.Match(StarRocksParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2328)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2329)

			var _x = p.String_()

			localctx.(*AdminShowConfigStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaDistributionStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaDistributionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminShowReplicaDistributionStatementContext differentiates from other interfaces.
	IsAdminShowReplicaDistributionStatementContext()
}

type AdminShowReplicaDistributionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminShowReplicaDistributionStatementContext() *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaDistributionStatement
	return p
}

func InitEmptyAdminShowReplicaDistributionStatementContext(p *AdminShowReplicaDistributionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaDistributionStatement
}

func (*AdminShowReplicaDistributionStatementContext) IsAdminShowReplicaDistributionStatementContext() {
}

func NewAdminShowReplicaDistributionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaDistributionStatement

	return p
}

func (s *AdminShowReplicaDistributionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaDistributionStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaDistributionStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaDistributionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaDistributionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminShowReplicaDistributionStatement(s)
	}
}

func (s *AdminShowReplicaDistributionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminShowReplicaDistributionStatement(s)
	}
}

func (s *AdminShowReplicaDistributionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminShowReplicaDistributionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminShowReplicaDistributionStatement() (localctx IAdminShowReplicaDistributionStatementContext) {
	localctx = NewAdminShowReplicaDistributionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, StarRocksParserRULE_adminShowReplicaDistributionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2332)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2333)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2334)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2335)
		p.Match(StarRocksParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2336)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2337)
		p.QualifiedName()
	}
	p.SetState(2339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2338)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsAdminShowReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminShowReplicaStatusStatementContext()
}

type AdminShowReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyAdminShowReplicaStatusStatementContext() *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaStatusStatement
	return p
}

func InitEmptyAdminShowReplicaStatusStatementContext(p *AdminShowReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaStatusStatement
}

func (*AdminShowReplicaStatusStatementContext) IsAdminShowReplicaStatusStatementContext() {}

func NewAdminShowReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaStatusStatement

	return p
}

func (s *AdminShowReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaStatusStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *AdminShowReplicaStatusStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *AdminShowReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminShowReplicaStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *AdminShowReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *AdminShowReplicaStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *AdminShowReplicaStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaStatusStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *AdminShowReplicaStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdminShowReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminShowReplicaStatusStatement(s)
	}
}

func (s *AdminShowReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminShowReplicaStatusStatement(s)
	}
}

func (s *AdminShowReplicaStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminShowReplicaStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminShowReplicaStatusStatement() (localctx IAdminShowReplicaStatusStatementContext) {
	localctx = NewAdminShowReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, StarRocksParserRULE_adminShowReplicaStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2341)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2342)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2343)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2344)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2345)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2346)
		p.QualifiedName()
	}
	p.SetState(2348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2347)
			p.PartitionNames()
		}

	}
	p.SetState(2352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(2350)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2351)

			var _x = p.expression(0)

			localctx.(*AdminShowReplicaStatusStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminRepairTableStatementContext differentiates from other interfaces.
	IsAdminRepairTableStatementContext()
}

type AdminRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminRepairTableStatementContext() *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminRepairTableStatement
	return p
}

func InitEmptyAdminRepairTableStatementContext(p *AdminRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminRepairTableStatement
}

func (*AdminRepairTableStatementContext) IsAdminRepairTableStatementContext() {}

func NewAdminRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminRepairTableStatement

	return p
}

func (s *AdminRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPAIR, 0)
}

func (s *AdminRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AdminRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminRepairTableStatement(s)
	}
}

func (s *AdminRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminRepairTableStatement(s)
	}
}

func (s *AdminRepairTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminRepairTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminRepairTableStatement() (localctx IAdminRepairTableStatementContext) {
	localctx = NewAdminRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, StarRocksParserRULE_adminRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2354)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2355)
		p.Match(StarRocksParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2356)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2357)
		p.QualifiedName()
	}
	p.SetState(2359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2358)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCancelRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminCancelRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminCancelRepairTableStatementContext differentiates from other interfaces.
	IsAdminCancelRepairTableStatementContext()
}

type AdminCancelRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCancelRepairTableStatementContext() *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCancelRepairTableStatement
	return p
}

func InitEmptyAdminCancelRepairTableStatementContext(p *AdminCancelRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCancelRepairTableStatement
}

func (*AdminCancelRepairTableStatementContext) IsAdminCancelRepairTableStatementContext() {}

func NewAdminCancelRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminCancelRepairTableStatement

	return p
}

func (s *AdminCancelRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCancelRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminCancelRepairTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *AdminCancelRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPAIR, 0)
}

func (s *AdminCancelRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AdminCancelRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminCancelRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminCancelRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCancelRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminCancelRepairTableStatement(s)
	}
}

func (s *AdminCancelRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminCancelRepairTableStatement(s)
	}
}

func (s *AdminCancelRepairTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminCancelRepairTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminCancelRepairTableStatement() (localctx IAdminCancelRepairTableStatementContext) {
	localctx = NewAdminCancelRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, StarRocksParserRULE_adminCancelRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2361)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2362)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2363)
		p.Match(StarRocksParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2364)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2365)
		p.QualifiedName()
	}
	p.SetState(2367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2366)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCheckTabletsStatementContext is an interface to support dynamic dispatch.
type IAdminCheckTabletsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	TabletList() ITabletListContext
	PROPERTIES() antlr.TerminalNode
	Property() IPropertyContext

	// IsAdminCheckTabletsStatementContext differentiates from other interfaces.
	IsAdminCheckTabletsStatementContext()
}

type AdminCheckTabletsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCheckTabletsStatementContext() *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCheckTabletsStatement
	return p
}

func InitEmptyAdminCheckTabletsStatementContext(p *AdminCheckTabletsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCheckTabletsStatement
}

func (*AdminCheckTabletsStatementContext) IsAdminCheckTabletsStatementContext() {}

func NewAdminCheckTabletsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminCheckTabletsStatement

	return p
}

func (s *AdminCheckTabletsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCheckTabletsStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminCheckTabletsStatementContext) CHECK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHECK, 0)
}

func (s *AdminCheckTabletsStatementContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *AdminCheckTabletsStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminCheckTabletsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCheckTabletsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminCheckTabletsStatement(s)
	}
}

func (s *AdminCheckTabletsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminCheckTabletsStatement(s)
	}
}

func (s *AdminCheckTabletsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminCheckTabletsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminCheckTabletsStatement() (localctx IAdminCheckTabletsStatementContext) {
	localctx = NewAdminCheckTabletsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, StarRocksParserRULE_adminCheckTabletsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2369)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2370)
		p.Match(StarRocksParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2371)
		p.TabletList()
	}
	{
		p.SetState(2372)
		p.Match(StarRocksParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2373)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2374)
		p.Property()
	}
	{
		p.SetState(2375)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetPartitionVersionContext is an interface to support dynamic dispatch.
type IAdminSetPartitionVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionId returns the partitionId token.
	GetPartitionId() antlr.Token

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetPartitionId sets the partitionId token.
	SetPartitionId(antlr.Token)

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierOrStringContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierOrStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsAdminSetPartitionVersionContext differentiates from other interfaces.
	IsAdminSetPartitionVersionContext()
}

type AdminSetPartitionVersionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierOrStringContext
	partitionId   antlr.Token
	version       antlr.Token
}

func NewEmptyAdminSetPartitionVersionContext() *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetPartitionVersion
	return p
}

func InitEmptyAdminSetPartitionVersionContext(p *AdminSetPartitionVersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetPartitionVersion
}

func (*AdminSetPartitionVersionContext) IsAdminSetPartitionVersionContext() {}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetPartitionVersion

	return p
}

func (s *AdminSetPartitionVersionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetPartitionVersionContext) GetPartitionId() antlr.Token { return s.partitionId }

func (s *AdminSetPartitionVersionContext) GetVersion() antlr.Token { return s.version }

func (s *AdminSetPartitionVersionContext) SetPartitionId(v antlr.Token) { s.partitionId = v }

func (s *AdminSetPartitionVersionContext) SetVersion(v antlr.Token) { s.version = v }

func (s *AdminSetPartitionVersionContext) GetPartitionName() IIdentifierOrStringContext {
	return s.partitionName
}

func (s *AdminSetPartitionVersionContext) SetPartitionName(v IIdentifierOrStringContext) {
	s.partitionName = v
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *AdminSetPartitionVersionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AdminSetPartitionVersionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AdminSetPartitionVersionContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetPartitionVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminSetPartitionVersion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminSetPartitionVersion() (localctx IAdminSetPartitionVersionContext) {
	localctx = NewAdminSetPartitionVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, StarRocksParserRULE_adminSetPartitionVersion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2377)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2378)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2379)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2380)
		p.QualifiedName()
	}
	{
		p.SetState(2381)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2382)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(2383)

			var _x = p.IdentifierOrString()

			localctx.(*AdminSetPartitionVersionContext).partitionName = _x
		}

	case StarRocksParserINTEGER_VALUE:
		{
			p.SetState(2384)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*AdminSetPartitionVersionContext).partitionId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2387)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2388)
		p.Match(StarRocksParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2389)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2390)

		var _m = p.Match(StarRocksParserINTEGER_VALUE)

		localctx.(*AdminSetPartitionVersionContext).version = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnId returns the connId token.
	GetConnId() antlr.Token

	// SetConnId sets the connId token.
	SetConnId(antlr.Token)

	// GetQueryId returns the queryId rule contexts.
	GetQueryId() IStringContext

	// SetQueryId sets the queryId rule contexts.
	SetQueryId(IStringContext)

	// Getter signatures
	KILL() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	String_() IStringContext
	CONNECTION() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	connId  antlr.Token
	queryId IStringContext
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killStatement
	return p
}

func InitEmptyKillStatementContext(p *KillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killStatement
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnId() antlr.Token { return s.connId }

func (s *KillStatementContext) SetConnId(v antlr.Token) { s.connId = v }

func (s *KillStatementContext) GetQueryId() IStringContext { return s.queryId }

func (s *KillStatementContext) SetQueryId(v IStringContext) { s.queryId = v }

func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKILL, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERY, 0)
}

func (s *KillStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *KillStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONNECTION, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (s *KillStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitKillStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) KillStatement() (localctx IKillStatementContext) {
	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, StarRocksParserRULE_killStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2392)
		p.Match(StarRocksParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCONNECTION, StarRocksParserINTEGER_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.SetState(2394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCONNECTION {
			{
				p.SetState(2393)
				p.Match(StarRocksParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserQUERY:
		{
			p.SetState(2396)
			p.Match(StarRocksParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserINTEGER_VALUE:
		{
			p.SetState(2399)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*KillStatementContext).connId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(2400)

			var _x = p.String_()

			localctx.(*KillStatementContext).queryId = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyncStatementContext is an interface to support dynamic dispatch.
type ISyncStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYNC() antlr.TerminalNode

	// IsSyncStatementContext differentiates from other interfaces.
	IsSyncStatementContext()
}

type SyncStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyncStatementContext() *SyncStatementContext {
	var p = new(SyncStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_syncStatement
	return p
}

func InitEmptySyncStatementContext(p *SyncStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_syncStatement
}

func (*SyncStatementContext) IsSyncStatementContext() {}

func NewSyncStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyncStatementContext {
	var p = new(SyncStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_syncStatement

	return p
}

func (s *SyncStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SyncStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *SyncStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyncStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyncStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSyncStatement(s)
	}
}

func (s *SyncStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSyncStatement(s)
	}
}

func (s *SyncStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSyncStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SyncStatement() (localctx ISyncStatementContext) {
	localctx = NewSyncStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, StarRocksParserRULE_syncStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2403)
		p.Match(StarRocksParserSYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOnStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSvName returns the svName rule contexts.
	GetSvName() IIdentifierContext

	// SetSvName sets the svName rule contexts.
	SetSvName(IIdentifierContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAdminSetAutomatedSnapshotOnStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOnStatementContext()
}

type AdminSetAutomatedSnapshotOnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	svName IIdentifierContext
}

func NewEmptyAdminSetAutomatedSnapshotOnStatementContext() *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOnStatementContext(p *AdminSetAutomatedSnapshotOnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement
}

func (*AdminSetAutomatedSnapshotOnStatementContext) IsAdminSetAutomatedSnapshotOnStatementContext() {}

func NewAdminSetAutomatedSnapshotOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetSvName() IIdentifierContext { return s.svName }

func (s *AdminSetAutomatedSnapshotOnStatementContext) SetSvName(v IIdentifierContext) { s.svName = v }

func (s *AdminSetAutomatedSnapshotOnStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminSetAutomatedSnapshotOnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminSetAutomatedSnapshotOnStatement() (localctx IAdminSetAutomatedSnapshotOnStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2405)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2406)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2407)
		p.Match(StarRocksParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2408)
		p.Match(StarRocksParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2409)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2410)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSTORAGE {
		{
			p.SetState(2411)
			p.Match(StarRocksParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2412)
			p.Match(StarRocksParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2413)

			var _x = p.Identifier()

			localctx.(*AdminSetAutomatedSnapshotOnStatementContext).svName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOffStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOffStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	OFF() antlr.TerminalNode

	// IsAdminSetAutomatedSnapshotOffStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOffStatementContext()
}

type AdminSetAutomatedSnapshotOffStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetAutomatedSnapshotOffStatementContext() *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOffStatementContext(p *AdminSetAutomatedSnapshotOffStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement
}

func (*AdminSetAutomatedSnapshotOffStatementContext) IsAdminSetAutomatedSnapshotOffStatementContext() {
}

func NewAdminSetAutomatedSnapshotOffStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOffStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) OFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFF, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAdminSetAutomatedSnapshotOffStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AdminSetAutomatedSnapshotOffStatement() (localctx IAdminSetAutomatedSnapshotOffStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOffStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2416)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2417)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2418)
		p.Match(StarRocksParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2419)
		p.Match(StarRocksParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2420)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2421)
		p.Match(StarRocksParserOFF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemStatementContext is an interface to support dynamic dispatch.
type IAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	AlterClause() IAlterClauseContext

	// IsAlterSystemStatementContext differentiates from other interfaces.
	IsAlterSystemStatementContext()
}

type AlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemStatementContext() *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSystemStatement
	return p
}

func InitEmptyAlterSystemStatementContext(p *AlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSystemStatement
}

func (*AlterSystemStatementContext) IsAlterSystemStatementContext() {}

func NewAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterSystemStatement

	return p
}

func (s *AlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterSystemStatementContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *AlterSystemStatementContext) AlterClause() IAlterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterSystemStatement(s)
	}
}

func (s *AlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterSystemStatement(s)
	}
}

func (s *AlterSystemStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterSystemStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterSystemStatement() (localctx IAlterSystemStatementContext) {
	localctx = NewAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, StarRocksParserRULE_alterSystemStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2423)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2424)
		p.Match(StarRocksParserSYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2425)
		p.AlterClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterSystemStatementContext is an interface to support dynamic dispatch.
type ICancelAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsCancelAlterSystemStatementContext differentiates from other interfaces.
	IsCancelAlterSystemStatementContext()
}

type CancelAlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterSystemStatementContext() *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterSystemStatement
	return p
}

func InitEmptyCancelAlterSystemStatementContext(p *CancelAlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterSystemStatement
}

func (*CancelAlterSystemStatementContext) IsCancelAlterSystemStatementContext() {}

func NewCancelAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelAlterSystemStatement

	return p
}

func (s *CancelAlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterSystemStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelAlterSystemStatementContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *CancelAlterSystemStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *CancelAlterSystemStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelAlterSystemStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelAlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelAlterSystemStatement(s)
	}
}

func (s *CancelAlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelAlterSystemStatement(s)
	}
}

func (s *CancelAlterSystemStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelAlterSystemStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelAlterSystemStatement() (localctx ICancelAlterSystemStatementContext) {
	localctx = NewCancelAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, StarRocksParserRULE_cancelAlterSystemStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2427)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2428)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2429)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2430)
		p.String_()
	}
	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2431)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2432)
			p.String_()
		}

		p.SetState(2437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowComputeNodesStatementContext is an interface to support dynamic dispatch.
type IShowComputeNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODES() antlr.TerminalNode

	// IsShowComputeNodesStatementContext differentiates from other interfaces.
	IsShowComputeNodesStatementContext()
}

type ShowComputeNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowComputeNodesStatementContext() *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showComputeNodesStatement
	return p
}

func InitEmptyShowComputeNodesStatementContext(p *ShowComputeNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showComputeNodesStatement
}

func (*ShowComputeNodesStatementContext) IsShowComputeNodesStatementContext() {}

func NewShowComputeNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showComputeNodesStatement

	return p
}

func (s *ShowComputeNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowComputeNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowComputeNodesStatementContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *ShowComputeNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODES, 0)
}

func (s *ShowComputeNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowComputeNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowComputeNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowComputeNodesStatement(s)
	}
}

func (s *ShowComputeNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowComputeNodesStatement(s)
	}
}

func (s *ShowComputeNodesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowComputeNodesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowComputeNodesStatement() (localctx IShowComputeNodesStatementContext) {
	localctx = NewShowComputeNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, StarRocksParserRULE_showComputeNodesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2438)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2439)
		p.Match(StarRocksParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2440)
		p.Match(StarRocksParserNODES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type ICreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsCreateExternalCatalogStatementContext()
}

type CreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyCreateExternalCatalogStatementContext() *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createExternalCatalogStatement
	return p
}

func InitEmptyCreateExternalCatalogStatementContext(p *CreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createExternalCatalogStatement
}

func (*CreateExternalCatalogStatementContext) IsCreateExternalCatalogStatementContext() {}

func NewCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createExternalCatalogStatement

	return p
}

func (s *CreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *CreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *CreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateExternalCatalogStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *CreateExternalCatalogStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateExternalCatalogStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateExternalCatalogStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateExternalCatalogStatement(s)
	}
}

func (s *CreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateExternalCatalogStatement(s)
	}
}

func (s *CreateExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateExternalCatalogStatement() (localctx ICreateExternalCatalogStatementContext) {
	localctx = NewCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, StarRocksParserRULE_createExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2442)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2443)
		p.Match(StarRocksParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2444)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2445)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2446)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2447)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2450)

		var _x = p.IdentifierOrString()

		localctx.(*CreateExternalCatalogStatementContext).catalogName = _x
	}
	p.SetState(2452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2451)
			p.Comment()
		}

	}
	{
		p.SetState(2454)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IShowCreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsShowCreateExternalCatalogStatementContext()
}

type ShowCreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyShowCreateExternalCatalogStatementContext() *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateExternalCatalogStatement
	return p
}

func InitEmptyShowCreateExternalCatalogStatementContext(p *ShowCreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateExternalCatalogStatement
}

func (*ShowCreateExternalCatalogStatementContext) IsShowCreateExternalCatalogStatementContext() {}

func NewShowCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateExternalCatalogStatement

	return p
}

func (s *ShowCreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *ShowCreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *ShowCreateExternalCatalogStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowCreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateExternalCatalogStatement(s)
	}
}

func (s *ShowCreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateExternalCatalogStatement(s)
	}
}

func (s *ShowCreateExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCreateExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCreateExternalCatalogStatement() (localctx IShowCreateExternalCatalogStatementContext) {
	localctx = NewShowCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, StarRocksParserRULE_showCreateExternalCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2456)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2457)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2458)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2459)

		var _x = p.IdentifierOrString()

		localctx.(*ShowCreateExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IDropExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropExternalCatalogStatementContext differentiates from other interfaces.
	IsDropExternalCatalogStatementContext()
}

type DropExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyDropExternalCatalogStatementContext() *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropExternalCatalogStatement
	return p
}

func InitEmptyDropExternalCatalogStatementContext(p *DropExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropExternalCatalogStatement
}

func (*DropExternalCatalogStatementContext) IsDropExternalCatalogStatementContext() {}

func NewDropExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropExternalCatalogStatement

	return p
}

func (s *DropExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *DropExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *DropExternalCatalogStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *DropExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropExternalCatalogStatement(s)
	}
}

func (s *DropExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropExternalCatalogStatement(s)
	}
}

func (s *DropExternalCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropExternalCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropExternalCatalogStatement() (localctx IDropExternalCatalogStatementContext) {
	localctx = NewDropExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, StarRocksParserRULE_dropExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2461)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2462)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2463)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2464)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2467)

		var _x = p.IdentifierOrString()

		localctx.(*DropExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCatalogsStatementContext is an interface to support dynamic dispatch.
type IShowCatalogsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowCatalogsStatementContext differentiates from other interfaces.
	IsShowCatalogsStatementContext()
}

type ShowCatalogsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCatalogsStatementContext() *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCatalogsStatement
	return p
}

func InitEmptyShowCatalogsStatementContext(p *ShowCatalogsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCatalogsStatement
}

func (*ShowCatalogsStatementContext) IsShowCatalogsStatementContext() {}

func NewShowCatalogsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCatalogsStatement

	return p
}

func (s *ShowCatalogsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCatalogsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCatalogsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCatalogsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCatalogsStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *ShowCatalogsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowCatalogsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCatalogsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCatalogsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCatalogsStatement(s)
	}
}

func (s *ShowCatalogsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCatalogsStatement(s)
	}
}

func (s *ShowCatalogsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCatalogsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCatalogsStatement() (localctx IShowCatalogsStatementContext) {
	localctx = NewShowCatalogsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, StarRocksParserRULE_showCatalogsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2469)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2470)
		p.Match(StarRocksParserCATALOGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2471)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2472)

			var _x = p.String_()

			localctx.(*ShowCatalogsStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCatalogStatementContext is an interface to support dynamic dispatch.
type IAlterCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterCatalogStatementContext differentiates from other interfaces.
	IsAlterCatalogStatementContext()
}

type AlterCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyAlterCatalogStatementContext() *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterCatalogStatement
	return p
}

func InitEmptyAlterCatalogStatementContext(p *AlterCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterCatalogStatement
}

func (*AlterCatalogStatementContext) IsAlterCatalogStatementContext() {}

func NewAlterCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterCatalogStatement

	return p
}

func (s *AlterCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *AlterCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *AlterCatalogStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *AlterCatalogStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterCatalogStatement(s)
	}
}

func (s *AlterCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterCatalogStatement(s)
	}
}

func (s *AlterCatalogStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterCatalogStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterCatalogStatement() (localctx IAlterCatalogStatementContext) {
	localctx = NewAlterCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, StarRocksParserRULE_alterCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2475)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2476)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2477)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCatalogStatementContext).catalogName = _x
	}
	{
		p.SetState(2478)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ICreateStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	TypeDesc() ITypeDescContext
	LocationsDesc() ILocationsDescContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateStorageVolumeStatementContext differentiates from other interfaces.
	IsCreateStorageVolumeStatementContext()
}

type CreateStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyCreateStorageVolumeStatementContext() *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createStorageVolumeStatement
	return p
}

func InitEmptyCreateStorageVolumeStatementContext(p *CreateStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createStorageVolumeStatement
}

func (*CreateStorageVolumeStatementContext) IsCreateStorageVolumeStatementContext() {}

func NewCreateStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createStorageVolumeStatement

	return p
}

func (s *CreateStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *CreateStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *CreateStorageVolumeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *CreateStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *CreateStorageVolumeStatementContext) TypeDesc() ITypeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDescContext)
}

func (s *CreateStorageVolumeStatementContext) LocationsDesc() ILocationsDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationsDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationsDescContext)
}

func (s *CreateStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateStorageVolumeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateStorageVolumeStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateStorageVolumeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateStorageVolumeStatement(s)
	}
}

func (s *CreateStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateStorageVolumeStatement(s)
	}
}

func (s *CreateStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateStorageVolumeStatement() (localctx ICreateStorageVolumeStatementContext) {
	localctx = NewCreateStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, StarRocksParserRULE_createStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2480)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2481)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2482)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2483)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2484)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2485)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2488)

		var _x = p.IdentifierOrString()

		localctx.(*CreateStorageVolumeStatementContext).storageVolumeName = _x
	}
	{
		p.SetState(2489)
		p.TypeDesc()
	}
	{
		p.SetState(2490)
		p.LocationsDesc()
	}
	p.SetState(2492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2491)
			p.Comment()
		}

	}
	p.SetState(2495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2494)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDescContext is an interface to support dynamic dispatch.
type ITypeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTypeDescContext differentiates from other interfaces.
	IsTypeDescContext()
}

type TypeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDescContext() *TypeDescContext {
	var p = new(TypeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeDesc
	return p
}

func InitEmptyTypeDescContext(p *TypeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeDesc
}

func (*TypeDescContext) IsTypeDescContext() {}

func NewTypeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDescContext {
	var p = new(TypeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeDesc

	return p
}

func (s *TypeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDescContext) TYPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTYPE, 0)
}

func (s *TypeDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *TypeDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeDesc(s)
	}
}

func (s *TypeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeDesc(s)
	}
}

func (s *TypeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTypeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TypeDesc() (localctx ITypeDescContext) {
	localctx = NewTypeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, StarRocksParserRULE_typeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2497)
		p.Match(StarRocksParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2498)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2499)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocationsDescContext is an interface to support dynamic dispatch.
type ILocationsDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCATIONS() antlr.TerminalNode
	EQ() antlr.TerminalNode
	StringList() IStringListContext

	// IsLocationsDescContext differentiates from other interfaces.
	IsLocationsDescContext()
}

type LocationsDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationsDescContext() *LocationsDescContext {
	var p = new(LocationsDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_locationsDesc
	return p
}

func InitEmptyLocationsDescContext(p *LocationsDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_locationsDesc
}

func (*LocationsDescContext) IsLocationsDescContext() {}

func NewLocationsDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationsDescContext {
	var p = new(LocationsDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_locationsDesc

	return p
}

func (s *LocationsDescContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationsDescContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATIONS, 0)
}

func (s *LocationsDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *LocationsDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *LocationsDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationsDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocationsDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLocationsDesc(s)
	}
}

func (s *LocationsDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLocationsDesc(s)
	}
}

func (s *LocationsDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLocationsDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LocationsDesc() (localctx ILocationsDescContext) {
	localctx = NewLocationsDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, StarRocksParserRULE_locationsDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2501)
		p.Match(StarRocksParserLOCATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2502)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2503)
		p.StringList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStorageVolumesStatementContext is an interface to support dynamic dispatch.
type IShowStorageVolumesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowStorageVolumesStatementContext differentiates from other interfaces.
	IsShowStorageVolumesStatementContext()
}

type ShowStorageVolumesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStorageVolumesStatementContext() *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStorageVolumesStatement
	return p
}

func InitEmptyShowStorageVolumesStatementContext(p *ShowStorageVolumesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStorageVolumesStatement
}

func (*ShowStorageVolumesStatementContext) IsShowStorageVolumesStatementContext() {}

func NewShowStorageVolumesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStorageVolumesStatement

	return p
}

func (s *ShowStorageVolumesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStorageVolumesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStorageVolumesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStorageVolumesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStorageVolumesStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *ShowStorageVolumesStatementContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUMES, 0)
}

func (s *ShowStorageVolumesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowStorageVolumesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStorageVolumesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageVolumesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStorageVolumesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStorageVolumesStatement(s)
	}
}

func (s *ShowStorageVolumesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStorageVolumesStatement(s)
	}
}

func (s *ShowStorageVolumesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowStorageVolumesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowStorageVolumesStatement() (localctx IShowStorageVolumesStatementContext) {
	localctx = NewShowStorageVolumesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, StarRocksParserRULE_showStorageVolumesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2505)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2506)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2507)
		p.Match(StarRocksParserVOLUMES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2508)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2509)

			var _x = p.String_()

			localctx.(*ShowStorageVolumesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDropStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropStorageVolumeStatementContext differentiates from other interfaces.
	IsDropStorageVolumeStatementContext()
}

type DropStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyDropStorageVolumeStatementContext() *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStorageVolumeStatement
	return p
}

func InitEmptyDropStorageVolumeStatementContext(p *DropStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStorageVolumeStatement
}

func (*DropStorageVolumeStatementContext) IsDropStorageVolumeStatementContext() {}

func NewDropStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropStorageVolumeStatement

	return p
}

func (s *DropStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *DropStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *DropStorageVolumeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *DropStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *DropStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropStorageVolumeStatement(s)
	}
}

func (s *DropStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropStorageVolumeStatement(s)
	}
}

func (s *DropStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropStorageVolumeStatement() (localctx IDropStorageVolumeStatementContext) {
	localctx = NewDropStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, StarRocksParserRULE_dropStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2512)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2513)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2514)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2515)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2516)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2519)

		var _x = p.IdentifierOrString()

		localctx.(*DropStorageVolumeStatementContext).storageVolumeName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext
	AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext

	// IsAlterStorageVolumeStatementContext differentiates from other interfaces.
	IsAlterStorageVolumeStatementContext()
}

type AlterStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeStatementContext() *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeStatement
	return p
}

func InitEmptyAlterStorageVolumeStatementContext(p *AlterStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeStatement
}

func (*AlterStorageVolumeStatementContext) IsAlterStorageVolumeStatementContext() {}

func NewAlterStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeStatement

	return p
}

func (s *AlterStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *AlterStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *AlterStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterStorageVolumeStatementContext) AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterStorageVolumeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			tst[i] = t.(IAlterStorageVolumeClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterStorageVolumeStatementContext) AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeClauseContext)
}

func (s *AlterStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterStorageVolumeStatement(s)
	}
}

func (s *AlterStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterStorageVolumeStatement(s)
	}
}

func (s *AlterStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterStorageVolumeStatement() (localctx IAlterStorageVolumeStatementContext) {
	localctx = NewAlterStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, StarRocksParserRULE_alterStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2521)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2522)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2523)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2524)
		p.IdentifierOrString()
	}
	{
		p.SetState(2525)
		p.AlterStorageVolumeClause()
	}
	p.SetState(2530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2526)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2527)
			p.AlterStorageVolumeClause()
		}

		p.SetState(2532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeClauseContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext
	ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext

	// IsAlterStorageVolumeClauseContext differentiates from other interfaces.
	IsAlterStorageVolumeClauseContext()
}

type AlterStorageVolumeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeClauseContext() *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeClause
	return p
}

func InitEmptyAlterStorageVolumeClauseContext(p *AlterStorageVolumeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeClause
}

func (*AlterStorageVolumeClauseContext) IsAlterStorageVolumeClauseContext() {}

func NewAlterStorageVolumeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeClause

	return p
}

func (s *AlterStorageVolumeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumeCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumeCommentClauseContext)
}

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumePropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumePropertiesClauseContext)
}

func (s *AlterStorageVolumeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterStorageVolumeClause(s)
	}
}

func (s *AlterStorageVolumeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterStorageVolumeClause(s)
	}
}

func (s *AlterStorageVolumeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterStorageVolumeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterStorageVolumeClause() (localctx IAlterStorageVolumeClauseContext) {
	localctx = NewAlterStorageVolumeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, StarRocksParserRULE_alterStorageVolumeClause)
	p.SetState(2535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCOMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2533)
			p.ModifyStorageVolumeCommentClause()
		}

	case StarRocksParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2534)
			p.ModifyStorageVolumePropertiesClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumePropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumePropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyStorageVolumePropertiesClauseContext differentiates from other interfaces.
	IsModifyStorageVolumePropertiesClauseContext()
}

type ModifyStorageVolumePropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumePropertiesClauseContext() *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumePropertiesClause
	return p
}

func InitEmptyModifyStorageVolumePropertiesClauseContext(p *ModifyStorageVolumePropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumePropertiesClause
}

func (*ModifyStorageVolumePropertiesClauseContext) IsModifyStorageVolumePropertiesClauseContext() {}

func NewModifyStorageVolumePropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumePropertiesClause

	return p
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumePropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyStorageVolumePropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumePropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumePropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyStorageVolumePropertiesClause(s)
	}
}

func (s *ModifyStorageVolumePropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyStorageVolumePropertiesClause(s)
	}
}

func (s *ModifyStorageVolumePropertiesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyStorageVolumePropertiesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyStorageVolumePropertiesClause() (localctx IModifyStorageVolumePropertiesClauseContext) {
	localctx = NewModifyStorageVolumePropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, StarRocksParserRULE_modifyStorageVolumePropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2537)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2538)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumeCommentClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumeCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyStorageVolumeCommentClauseContext differentiates from other interfaces.
	IsModifyStorageVolumeCommentClauseContext()
}

type ModifyStorageVolumeCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumeCommentClauseContext() *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumeCommentClause
	return p
}

func InitEmptyModifyStorageVolumeCommentClauseContext(p *ModifyStorageVolumeCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumeCommentClause
}

func (*ModifyStorageVolumeCommentClauseContext) IsModifyStorageVolumeCommentClauseContext() {}

func NewModifyStorageVolumeCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumeCommentClause

	return p
}

func (s *ModifyStorageVolumeCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumeCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyStorageVolumeCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumeCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumeCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyStorageVolumeCommentClause(s)
	}
}

func (s *ModifyStorageVolumeCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyStorageVolumeCommentClause(s)
	}
}

func (s *ModifyStorageVolumeCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyStorageVolumeCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyStorageVolumeCommentClause() (localctx IModifyStorageVolumeCommentClauseContext) {
	localctx = NewModifyStorageVolumeCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, StarRocksParserRULE_modifyStorageVolumeCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2540)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2541)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2542)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDescStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescStorageVolumeStatementContext differentiates from other interfaces.
	IsDescStorageVolumeStatementContext()
}

type DescStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescStorageVolumeStatementContext() *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descStorageVolumeStatement
	return p
}

func InitEmptyDescStorageVolumeStatementContext(p *DescStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descStorageVolumeStatement
}

func (*DescStorageVolumeStatementContext) IsDescStorageVolumeStatementContext() {}

func NewDescStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_descStorageVolumeStatement

	return p
}

func (s *DescStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *DescStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *DescStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DescStorageVolumeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *DescStorageVolumeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *DescStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDescStorageVolumeStatement(s)
	}
}

func (s *DescStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDescStorageVolumeStatement(s)
	}
}

func (s *DescStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDescStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DescStorageVolumeStatement() (localctx IDescStorageVolumeStatementContext) {
	localctx = NewDescStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, StarRocksParserRULE_descStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2544)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDESC || _la == StarRocksParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2545)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2546)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2547)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ISetDefaultStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode

	// IsSetDefaultStorageVolumeStatementContext differentiates from other interfaces.
	IsSetDefaultStorageVolumeStatementContext()
}

type SetDefaultStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultStorageVolumeStatementContext() *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultStorageVolumeStatement
	return p
}

func InitEmptySetDefaultStorageVolumeStatementContext(p *SetDefaultStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultStorageVolumeStatement
}

func (*SetDefaultStorageVolumeStatementContext) IsSetDefaultStorageVolumeStatementContext() {}

func NewSetDefaultStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setDefaultStorageVolumeStatement

	return p
}

func (s *SetDefaultStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultStorageVolumeStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetDefaultStorageVolumeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetDefaultStorageVolumeStatement(s)
	}
}

func (s *SetDefaultStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetDefaultStorageVolumeStatement(s)
	}
}

func (s *SetDefaultStorageVolumeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetDefaultStorageVolumeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetDefaultStorageVolumeStatement() (localctx ISetDefaultStorageVolumeStatementContext) {
	localctx = NewSetDefaultStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, StarRocksParserRULE_setDefaultStorageVolumeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2549)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2550)
		p.IdentifierOrString()
	}
	{
		p.SetState(2551)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2552)
		p.Match(StarRocksParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2553)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2554)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateFailPointStatusStatementContext is an interface to support dynamic dispatch.
type IUpdateFailPointStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimes returns the times token.
	GetTimes() antlr.Token

	// GetProb returns the prob token.
	GetProb() antlr.Token

	// SetTimes sets the times token.
	SetTimes(antlr.Token)

	// SetProb sets the prob token.
	SetProb(antlr.Token)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	DISABLE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	ON() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode

	// IsUpdateFailPointStatusStatementContext differentiates from other interfaces.
	IsUpdateFailPointStatusStatementContext()
}

type UpdateFailPointStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	times  antlr.Token
	prob   antlr.Token
}

func NewEmptyUpdateFailPointStatusStatementContext() *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateFailPointStatusStatement
	return p
}

func InitEmptyUpdateFailPointStatusStatementContext(p *UpdateFailPointStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateFailPointStatusStatement
}

func (*UpdateFailPointStatusStatementContext) IsUpdateFailPointStatusStatementContext() {}

func NewUpdateFailPointStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_updateFailPointStatusStatement

	return p
}

func (s *UpdateFailPointStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateFailPointStatusStatementContext) GetTimes() antlr.Token { return s.times }

func (s *UpdateFailPointStatusStatementContext) GetProb() antlr.Token { return s.prob }

func (s *UpdateFailPointStatusStatementContext) SetTimes(v antlr.Token) { s.times = v }

func (s *UpdateFailPointStatusStatementContext) SetProb(v antlr.Token) { s.prob = v }

func (s *UpdateFailPointStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *UpdateFailPointStatusStatementContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINT, 0)
}

func (s *UpdateFailPointStatusStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *UpdateFailPointStatusStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UpdateFailPointStatusStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *UpdateFailPointStatusStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *UpdateFailPointStatusStatementContext) TIMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMES, 0)
}

func (s *UpdateFailPointStatusStatementContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROBABILITY, 0)
}

func (s *UpdateFailPointStatusStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *UpdateFailPointStatusStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *UpdateFailPointStatusStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateFailPointStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateFailPointStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUpdateFailPointStatusStatement(s)
	}
}

func (s *UpdateFailPointStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUpdateFailPointStatusStatement(s)
	}
}

func (s *UpdateFailPointStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUpdateFailPointStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UpdateFailPointStatusStatement() (localctx IUpdateFailPointStatusStatementContext) {
	localctx = NewUpdateFailPointStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, StarRocksParserRULE_updateFailPointStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2556)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2557)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDISABLE || _la == StarRocksParserENABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2558)
		p.Match(StarRocksParserFAILPOINT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2559)
		p.String_()
	}
	p.SetState(2567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(2560)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserINTEGER_VALUE:
			{
				p.SetState(2561)

				var _m = p.Match(StarRocksParserINTEGER_VALUE)

				localctx.(*UpdateFailPointStatusStatementContext).times = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2562)
				p.Match(StarRocksParserTIMES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserDECIMAL_VALUE:
			{
				p.SetState(2563)

				var _m = p.Match(StarRocksParserDECIMAL_VALUE)

				localctx.(*UpdateFailPointStatusStatementContext).prob = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2564)
				p.Match(StarRocksParserPROBABILITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(2569)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserBACKEND:
			{
				p.SetState(2570)
				p.Match(StarRocksParserBACKEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2571)
				p.String_()
			}

		case StarRocksParserFRONTEND:
			{
				p.SetState(2572)
				p.Match(StarRocksParserFRONTEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFailPointStatementContext is an interface to support dynamic dispatch.
type IShowFailPointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode

	// IsShowFailPointStatementContext differentiates from other interfaces.
	IsShowFailPointStatementContext()
}

type ShowFailPointStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowFailPointStatementContext() *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFailPointStatement
	return p
}

func InitEmptyShowFailPointStatementContext(p *ShowFailPointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFailPointStatement
}

func (*ShowFailPointStatementContext) IsShowFailPointStatementContext() {}

func NewShowFailPointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showFailPointStatement

	return p
}

func (s *ShowFailPointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFailPointStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFailPointStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFailPointStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowFailPointStatementContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINTS, 0)
}

func (s *ShowFailPointStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ShowFailPointStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *ShowFailPointStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowFailPointStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFailPointStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowFailPointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFailPointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFailPointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowFailPointStatement(s)
	}
}

func (s *ShowFailPointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowFailPointStatement(s)
	}
}

func (s *ShowFailPointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowFailPointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowFailPointStatement() (localctx IShowFailPointStatementContext) {
	localctx = NewShowFailPointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, StarRocksParserRULE_showFailPointStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2577)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2578)
		p.Match(StarRocksParserFAILPOINTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2579)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2580)

			var _x = p.String_()

			localctx.(*ShowFailPointStatementContext).pattern = _x
		}

	}
	p.SetState(2586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(2583)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.Match(StarRocksParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2585)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDictionaryStatementContext is an interface to support dynamic dispatch.
type ICreateDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DictionaryName() IDictionaryNameContext
	USING() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllDictionaryColumnDesc() []IDictionaryColumnDescContext
	DictionaryColumnDesc(i int) IDictionaryColumnDescContext
	Properties() IPropertiesContext

	// IsCreateDictionaryStatementContext differentiates from other interfaces.
	IsCreateDictionaryStatementContext()
}

type CreateDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDictionaryStatementContext() *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDictionaryStatement
	return p
}

func InitEmptyCreateDictionaryStatementContext(p *CreateDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDictionaryStatement
}

func (*CreateDictionaryStatementContext) IsCreateDictionaryStatementContext() {}

func NewCreateDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createDictionaryStatement

	return p
}

func (s *CreateDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDictionaryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *CreateDictionaryStatementContext) DictionaryName() IDictionaryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryNameContext)
}

func (s *CreateDictionaryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *CreateDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDictionaryStatementContext) AllDictionaryColumnDesc() []IDictionaryColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryColumnDescContext); ok {
			tst[i] = t.(IDictionaryColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateDictionaryStatementContext) DictionaryColumnDesc(i int) IDictionaryColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDescContext)
}

func (s *CreateDictionaryStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateDictionaryStatement(s)
	}
}

func (s *CreateDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateDictionaryStatement(s)
	}
}

func (s *CreateDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateDictionaryStatement() (localctx ICreateDictionaryStatementContext) {
	localctx = NewCreateDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, StarRocksParserRULE_createDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2588)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2589)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2590)
		p.DictionaryName()
	}
	{
		p.SetState(2591)
		p.Match(StarRocksParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2592)
		p.QualifiedName()
	}
	{
		p.SetState(2593)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2594)
		p.DictionaryColumnDesc()
	}
	p.SetState(2599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2595)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2596)
			p.DictionaryColumnDesc()
		}

		p.SetState(2601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2602)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2603)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDictionaryStatementContext is an interface to support dynamic dispatch.
type IDropDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	CACHE() antlr.TerminalNode

	// IsDropDictionaryStatementContext differentiates from other interfaces.
	IsDropDictionaryStatementContext()
}

type DropDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDictionaryStatementContext() *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDictionaryStatement
	return p
}

func InitEmptyDropDictionaryStatementContext(p *DropDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDictionaryStatement
}

func (*DropDictionaryStatementContext) IsDropDictionaryStatementContext() {}

func NewDropDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropDictionaryStatement

	return p
}

func (s *DropDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDictionaryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *DropDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDictionaryStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCACHE, 0)
}

func (s *DropDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropDictionaryStatement(s)
	}
}

func (s *DropDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropDictionaryStatement(s)
	}
}

func (s *DropDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropDictionaryStatement() (localctx IDropDictionaryStatementContext) {
	localctx = NewDropDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, StarRocksParserRULE_dropDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2606)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2607)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2608)
		p.QualifiedName()
	}
	p.SetState(2610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCACHE {
		{
			p.SetState(2609)
			p.Match(StarRocksParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type IRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRefreshDictionaryStatementContext differentiates from other interfaces.
	IsRefreshDictionaryStatementContext()
}

type RefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshDictionaryStatementContext() *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshDictionaryStatement
	return p
}

func InitEmptyRefreshDictionaryStatementContext(p *RefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshDictionaryStatement
}

func (*RefreshDictionaryStatementContext) IsRefreshDictionaryStatementContext() {}

func NewRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshDictionaryStatement

	return p
}

func (s *RefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *RefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshDictionaryStatement(s)
	}
}

func (s *RefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshDictionaryStatement(s)
	}
}

func (s *RefreshDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRefreshDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RefreshDictionaryStatement() (localctx IRefreshDictionaryStatementContext) {
	localctx = NewRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, StarRocksParserRULE_refreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2612)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2613)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2614)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDictionaryStatementContext is an interface to support dynamic dispatch.
type IShowDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDictionaryStatementContext differentiates from other interfaces.
	IsShowDictionaryStatementContext()
}

type ShowDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDictionaryStatementContext() *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDictionaryStatement
	return p
}

func InitEmptyShowDictionaryStatementContext(p *ShowDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDictionaryStatement
}

func (*ShowDictionaryStatementContext) IsShowDictionaryStatementContext() {}

func NewShowDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDictionaryStatement

	return p
}

func (s *ShowDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDictionaryStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *ShowDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDictionaryStatement(s)
	}
}

func (s *ShowDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDictionaryStatement(s)
	}
}

func (s *ShowDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowDictionaryStatement() (localctx IShowDictionaryStatementContext) {
	localctx = NewShowDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, StarRocksParserRULE_showDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2616)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2617)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&4534550861405212027) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&141699191925459) != 0) || ((int64((_la-526)) & ^0x3f) == 0 && ((int64(1)<<(_la-526))&263) != 0) {
		{
			p.SetState(2618)
			p.QualifiedName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCancelRefreshDictionaryStatementContext differentiates from other interfaces.
	IsCancelRefreshDictionaryStatementContext()
}

type CancelRefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRefreshDictionaryStatementContext() *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshDictionaryStatement
	return p
}

func InitEmptyCancelRefreshDictionaryStatementContext(p *CancelRefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshDictionaryStatement
}

func (*CancelRefreshDictionaryStatementContext) IsCancelRefreshDictionaryStatementContext() {}

func NewCancelRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelRefreshDictionaryStatement

	return p
}

func (s *CancelRefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshDictionaryStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelRefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *CancelRefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *CancelRefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelRefreshDictionaryStatement(s)
	}
}

func (s *CancelRefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelRefreshDictionaryStatement(s)
	}
}

func (s *CancelRefreshDictionaryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelRefreshDictionaryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelRefreshDictionaryStatement() (localctx ICancelRefreshDictionaryStatementContext) {
	localctx = NewCancelRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, StarRocksParserRULE_cancelRefreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2621)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2622)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2623)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2624)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDescContext is an interface to support dynamic dispatch.
type IDictionaryColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	KEY() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDictionaryColumnDescContext differentiates from other interfaces.
	IsDictionaryColumnDescContext()
}

type DictionaryColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryColumnDescContext() *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryColumnDesc
	return p
}

func InitEmptyDictionaryColumnDescContext(p *DictionaryColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryColumnDesc
}

func (*DictionaryColumnDescContext) IsDictionaryColumnDescContext() {}

func NewDictionaryColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dictionaryColumnDesc

	return p
}

func (s *DictionaryColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *DictionaryColumnDescContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUE, 0)
}

func (s *DictionaryColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDictionaryColumnDesc(s)
	}
}

func (s *DictionaryColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDictionaryColumnDesc(s)
	}
}

func (s *DictionaryColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDictionaryColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DictionaryColumnDesc() (localctx IDictionaryColumnDescContext) {
	localctx = NewDictionaryColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, StarRocksParserRULE_dictionaryColumnDesc)
	p.SetState(2632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2626)
			p.QualifiedName()
		}
		{
			p.SetState(2627)
			p.Match(StarRocksParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2629)
			p.QualifiedName()
		}
		{
			p.SetState(2630)
			p.Match(StarRocksParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryNameContext is an interface to support dynamic dispatch.
type IDictionaryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsDictionaryNameContext differentiates from other interfaces.
	IsDictionaryNameContext()
}

type DictionaryNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryNameContext() *DictionaryNameContext {
	var p = new(DictionaryNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryName
	return p
}

func InitEmptyDictionaryNameContext(p *DictionaryNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryName
}

func (*DictionaryNameContext) IsDictionaryNameContext() {}

func NewDictionaryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryNameContext {
	var p = new(DictionaryNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dictionaryName

	return p
}

func (s *DictionaryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDictionaryName(s)
	}
}

func (s *DictionaryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDictionaryName(s)
	}
}

func (s *DictionaryNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDictionaryName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DictionaryName() (localctx IDictionaryNameContext) {
	localctx = NewDictionaryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, StarRocksParserRULE_dictionaryName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2634)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterClauseContext is an interface to support dynamic dispatch.
type IAlterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AddFrontendClause() IAddFrontendClauseContext
	DropFrontendClause() IDropFrontendClauseContext
	ModifyFrontendHostClause() IModifyFrontendHostClauseContext
	AddBackendClause() IAddBackendClauseContext
	DropBackendClause() IDropBackendClauseContext
	DecommissionBackendClause() IDecommissionBackendClauseContext
	ModifyBackendClause() IModifyBackendClauseContext
	AddComputeNodeClause() IAddComputeNodeClauseContext
	DropComputeNodeClause() IDropComputeNodeClauseContext
	ModifyBrokerClause() IModifyBrokerClauseContext
	AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext
	CreateImageClause() ICreateImageClauseContext
	CleanTabletSchedQClause() ICleanTabletSchedQClauseContext
	DecommissionDiskClause() IDecommissionDiskClauseContext
	CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext
	DisableDiskClause() IDisableDiskClauseContext
	CancelDisableDiskClause() ICancelDisableDiskClauseContext
	CreateIndexClause() ICreateIndexClauseContext
	DropIndexClause() IDropIndexClauseContext
	TableRenameClause() ITableRenameClauseContext
	SwapTableClause() ISwapTableClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	AddColumnClause() IAddColumnClauseContext
	AddColumnsClause() IAddColumnsClauseContext
	DropColumnClause() IDropColumnClauseContext
	ModifyColumnClause() IModifyColumnClauseContext
	ColumnRenameClause() IColumnRenameClauseContext
	ReorderColumnsClause() IReorderColumnsClauseContext
	RollupRenameClause() IRollupRenameClauseContext
	CompactionClause() ICompactionClauseContext
	ModifyCommentClause() IModifyCommentClauseContext
	OptimizeClause() IOptimizeClauseContext
	AddFieldClause() IAddFieldClauseContext
	DropFieldClause() IDropFieldClauseContext
	CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext
	CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext
	DropBranchClause() IDropBranchClauseContext
	DropTagClause() IDropTagClauseContext
	TableOperationClause() ITableOperationClauseContext
	DropPersistentIndexClause() IDropPersistentIndexClauseContext
	AddPartitionClause() IAddPartitionClauseContext
	DropPartitionClause() IDropPartitionClauseContext
	DistributionClause() IDistributionClauseContext
	TruncatePartitionClause() ITruncatePartitionClauseContext
	ModifyPartitionClause() IModifyPartitionClauseContext
	ReplacePartitionClause() IReplacePartitionClauseContext
	PartitionRenameClause() IPartitionRenameClauseContext

	// IsAlterClauseContext differentiates from other interfaces.
	IsAlterClauseContext()
}

type AlterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterClauseContext() *AlterClauseContext {
	var p = new(AlterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterClause
	return p
}

func InitEmptyAlterClauseContext(p *AlterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterClause
}

func (*AlterClauseContext) IsAlterClauseContext() {}

func NewAlterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterClauseContext {
	var p = new(AlterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterClause

	return p
}

func (s *AlterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterClauseContext) AddFrontendClause() IAddFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFrontendClauseContext)
}

func (s *AlterClauseContext) DropFrontendClause() IDropFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFrontendClauseContext)
}

func (s *AlterClauseContext) ModifyFrontendHostClause() IModifyFrontendHostClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyFrontendHostClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyFrontendHostClauseContext)
}

func (s *AlterClauseContext) AddBackendClause() IAddBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendClauseContext)
}

func (s *AlterClauseContext) DropBackendClause() IDropBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBackendClauseContext)
}

func (s *AlterClauseContext) DecommissionBackendClause() IDecommissionBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionBackendClauseContext)
}

func (s *AlterClauseContext) ModifyBackendClause() IModifyBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBackendClauseContext)
}

func (s *AlterClauseContext) AddComputeNodeClause() IAddComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddComputeNodeClauseContext)
}

func (s *AlterClauseContext) DropComputeNodeClause() IDropComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropComputeNodeClauseContext)
}

func (s *AlterClauseContext) ModifyBrokerClause() IModifyBrokerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBrokerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBrokerClauseContext)
}

func (s *AlterClauseContext) AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadErrorUrlClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadErrorUrlClauseContext)
}

func (s *AlterClauseContext) CreateImageClause() ICreateImageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateImageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateImageClauseContext)
}

func (s *AlterClauseContext) CleanTabletSchedQClause() ICleanTabletSchedQClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTabletSchedQClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTabletSchedQClauseContext)
}

func (s *AlterClauseContext) DecommissionDiskClause() IDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) DisableDiskClause() IDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableDiskClauseContext)
}

func (s *AlterClauseContext) CancelDisableDiskClause() ICancelDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDisableDiskClauseContext)
}

func (s *AlterClauseContext) CreateIndexClause() ICreateIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexClauseContext)
}

func (s *AlterClauseContext) DropIndexClause() IDropIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexClauseContext)
}

func (s *AlterClauseContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterClauseContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterClauseContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterClauseContext) AddColumnClause() IAddColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnClauseContext)
}

func (s *AlterClauseContext) AddColumnsClause() IAddColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnsClauseContext)
}

func (s *AlterClauseContext) DropColumnClause() IDropColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropColumnClauseContext)
}

func (s *AlterClauseContext) ModifyColumnClause() IModifyColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyColumnClauseContext)
}

func (s *AlterClauseContext) ColumnRenameClause() IColumnRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRenameClauseContext)
}

func (s *AlterClauseContext) ReorderColumnsClause() IReorderColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReorderColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReorderColumnsClauseContext)
}

func (s *AlterClauseContext) RollupRenameClause() IRollupRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupRenameClauseContext)
}

func (s *AlterClauseContext) CompactionClause() ICompactionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionClauseContext)
}

func (s *AlterClauseContext) ModifyCommentClause() IModifyCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyCommentClauseContext)
}

func (s *AlterClauseContext) OptimizeClause() IOptimizeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeClauseContext)
}

func (s *AlterClauseContext) AddFieldClause() IAddFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFieldClauseContext)
}

func (s *AlterClauseContext) DropFieldClause() IDropFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFieldClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceBranchClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceTagClauseContext)
}

func (s *AlterClauseContext) DropBranchClause() IDropBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBranchClauseContext)
}

func (s *AlterClauseContext) DropTagClause() IDropTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTagClauseContext)
}

func (s *AlterClauseContext) TableOperationClause() ITableOperationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOperationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOperationClauseContext)
}

func (s *AlterClauseContext) DropPersistentIndexClause() IDropPersistentIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPersistentIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPersistentIndexClauseContext)
}

func (s *AlterClauseContext) AddPartitionClause() IAddPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddPartitionClauseContext)
}

func (s *AlterClauseContext) DropPartitionClause() IDropPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPartitionClauseContext)
}

func (s *AlterClauseContext) DistributionClause() IDistributionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionClauseContext)
}

func (s *AlterClauseContext) TruncatePartitionClause() ITruncatePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePartitionClauseContext)
}

func (s *AlterClauseContext) ModifyPartitionClause() IModifyPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPartitionClauseContext)
}

func (s *AlterClauseContext) ReplacePartitionClause() IReplacePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePartitionClauseContext)
}

func (s *AlterClauseContext) PartitionRenameClause() IPartitionRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRenameClauseContext)
}

func (s *AlterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterClause(s)
	}
}

func (s *AlterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterClause(s)
	}
}

func (s *AlterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterClause() (localctx IAlterClauseContext) {
	localctx = NewAlterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, StarRocksParserRULE_alterClause)
	p.SetState(2683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2636)
			p.AddFrontendClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2637)
			p.DropFrontendClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2638)
			p.ModifyFrontendHostClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2639)
			p.AddBackendClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2640)
			p.DropBackendClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2641)
			p.DecommissionBackendClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2642)
			p.ModifyBackendClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2643)
			p.AddComputeNodeClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2644)
			p.DropComputeNodeClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2645)
			p.ModifyBrokerClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2646)
			p.AlterLoadErrorUrlClause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2647)
			p.CreateImageClause()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2648)
			p.CleanTabletSchedQClause()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2649)
			p.DecommissionDiskClause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2650)
			p.CancelDecommissionDiskClause()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2651)
			p.DisableDiskClause()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2652)
			p.CancelDisableDiskClause()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2653)
			p.CreateIndexClause()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2654)
			p.DropIndexClause()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2655)
			p.TableRenameClause()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2656)
			p.SwapTableClause()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2657)
			p.ModifyPropertiesClause()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2658)
			p.AddColumnClause()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2659)
			p.AddColumnsClause()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2660)
			p.DropColumnClause()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2661)
			p.ModifyColumnClause()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2662)
			p.ColumnRenameClause()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2663)
			p.ReorderColumnsClause()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2664)
			p.RollupRenameClause()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2665)
			p.CompactionClause()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2666)
			p.ModifyCommentClause()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2667)
			p.OptimizeClause()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2668)
			p.AddFieldClause()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2669)
			p.DropFieldClause()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2670)
			p.CreateOrReplaceBranchClause()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2671)
			p.CreateOrReplaceTagClause()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2672)
			p.DropBranchClause()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2673)
			p.DropTagClause()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2674)
			p.TableOperationClause()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2675)
			p.DropPersistentIndexClause()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2676)
			p.AddPartitionClause()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2677)
			p.DropPartitionClause()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2678)
			p.DistributionClause()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2679)
			p.TruncatePartitionClause()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2680)
			p.ModifyPartitionClause()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2681)
			p.ReplacePartitionClause()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2682)
			p.PartitionRenameClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFrontendClauseContext is an interface to support dynamic dispatch.
type IAddFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsAddFrontendClauseContext differentiates from other interfaces.
	IsAddFrontendClauseContext()
}

type AddFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFrontendClauseContext() *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFrontendClause
	return p
}

func InitEmptyAddFrontendClauseContext(p *AddFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFrontendClause
}

func (*AddFrontendClauseContext) IsAddFrontendClauseContext() {}

func NewAddFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addFrontendClause

	return p
}

func (s *AddFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFrontendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWER, 0)
}

func (s *AddFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOBSERVER, 0)
}

func (s *AddFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddFrontendClause(s)
	}
}

func (s *AddFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddFrontendClause(s)
	}
}

func (s *AddFrontendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddFrontendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddFrontendClause() (localctx IAddFrontendClauseContext) {
	localctx = NewAddFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, StarRocksParserRULE_addFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2685)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2686)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFOLLOWER || _la == StarRocksParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2687)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFrontendClauseContext is an interface to support dynamic dispatch.
type IDropFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsDropFrontendClauseContext differentiates from other interfaces.
	IsDropFrontendClauseContext()
}

type DropFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFrontendClauseContext() *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFrontendClause
	return p
}

func InitEmptyDropFrontendClauseContext(p *DropFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFrontendClause
}

func (*DropFrontendClauseContext) IsDropFrontendClauseContext() {}

func NewDropFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFrontendClause

	return p
}

func (s *DropFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFrontendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWER, 0)
}

func (s *DropFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOBSERVER, 0)
}

func (s *DropFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFrontendClause(s)
	}
}

func (s *DropFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFrontendClause(s)
	}
}

func (s *DropFrontendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropFrontendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropFrontendClause() (localctx IDropFrontendClauseContext) {
	localctx = NewDropFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, StarRocksParserRULE_dropFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2689)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2690)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFOLLOWER || _la == StarRocksParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2691)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyFrontendHostClauseContext is an interface to support dynamic dispatch.
type IModifyFrontendHostClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode

	// IsModifyFrontendHostClauseContext differentiates from other interfaces.
	IsModifyFrontendHostClauseContext()
}

type ModifyFrontendHostClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyFrontendHostClauseContext() *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyFrontendHostClause
	return p
}

func InitEmptyModifyFrontendHostClauseContext(p *ModifyFrontendHostClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyFrontendHostClause
}

func (*ModifyFrontendHostClauseContext) IsModifyFrontendHostClauseContext() {}

func NewModifyFrontendHostClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyFrontendHostClause

	return p
}

func (s *ModifyFrontendHostClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyFrontendHostClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyFrontendHostClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *ModifyFrontendHostClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOST, 0)
}

func (s *ModifyFrontendHostClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyFrontendHostClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyFrontendHostClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ModifyFrontendHostClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendHostClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyFrontendHostClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyFrontendHostClause(s)
	}
}

func (s *ModifyFrontendHostClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyFrontendHostClause(s)
	}
}

func (s *ModifyFrontendHostClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyFrontendHostClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyFrontendHostClause() (localctx IModifyFrontendHostClauseContext) {
	localctx = NewModifyFrontendHostClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, StarRocksParserRULE_modifyFrontendHostClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2693)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2694)
		p.Match(StarRocksParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2695)
		p.Match(StarRocksParserHOST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2696)
		p.String_()
	}
	{
		p.SetState(2697)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2698)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendClauseContext is an interface to support dynamic dispatch.
type IAddBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsAddBackendClauseContext differentiates from other interfaces.
	IsAddBackendClauseContext()
}

type AddBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAddBackendClauseContext() *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendClause
	return p
}

func InitEmptyAddBackendClauseContext(p *AddBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendClause
}

func (*AddBackendClauseContext) IsAddBackendClauseContext() {}

func NewAddBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addBackendClause

	return p
}

func (s *AddBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddBackendClauseContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *AddBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) { s.warehouseName = v }

func (s *AddBackendClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddBackendClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *AddBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *AddBackendClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AddBackendClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddBackendClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddBackendClause() (localctx IAddBackendClauseContext) {
	localctx = NewAddBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, StarRocksParserRULE_addBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2700)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2701)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2702)
		p.String_()
	}
	p.SetState(2707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2703)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2704)
				p.String_()
			}

		}
		p.SetState(2709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserINTO {
		{
			p.SetState(2710)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2711)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2712)

			var _x = p.IdentifierOrString()

			localctx.(*AddBackendClauseContext).warehouseName = _x
		}
		p.SetState(2715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCNGROUP {
			{
				p.SetState(2713)
				p.Match(StarRocksParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2714)

				var _x = p.IdentifierOrString()

				localctx.(*AddBackendClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBackendClauseContext is an interface to support dynamic dispatch.
type IDropBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsDropBackendClauseContext differentiates from other interfaces.
	IsDropBackendClauseContext()
}

type DropBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropBackendClauseContext() *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBackendClause
	return p
}

func InitEmptyDropBackendClauseContext(p *DropBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBackendClause
}

func (*DropBackendClauseContext) IsDropBackendClauseContext() {}

func NewDropBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropBackendClause

	return p
}

func (s *DropBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropBackendClauseContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *DropBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropBackendClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DropBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropBackendClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DropBackendClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropBackendClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropBackendClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropBackendClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropBackendClause() (localctx IDropBackendClauseContext) {
	localctx = NewDropBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, StarRocksParserRULE_dropBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2719)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2720)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2721)
		p.String_()
	}
	p.SetState(2726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2722)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2723)
				p.String_()
			}

		}
		p.SetState(2728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(2729)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2730)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2731)

			var _x = p.IdentifierOrString()

			localctx.(*DropBackendClauseContext).warehouseName = _x
		}
		p.SetState(2734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCNGROUP {
			{
				p.SetState(2732)
				p.Match(StarRocksParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2733)

				var _x = p.IdentifierOrString()

				localctx.(*DropBackendClauseContext).cngroupName = _x
			}

		}

	}
	p.SetState(2739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2738)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionBackendClauseContext is an interface to support dynamic dispatch.
type IDecommissionBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsDecommissionBackendClauseContext differentiates from other interfaces.
	IsDecommissionBackendClauseContext()
}

type DecommissionBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionBackendClauseContext() *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionBackendClause
	return p
}

func InitEmptyDecommissionBackendClauseContext(p *DecommissionBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionBackendClause
}

func (*DecommissionBackendClauseContext) IsDecommissionBackendClauseContext() {}

func NewDecommissionBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_decommissionBackendClause

	return p
}

func (s *DecommissionBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDecommissionBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DecommissionBackendClause() (localctx IDecommissionBackendClauseContext) {
	localctx = NewDecommissionBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, StarRocksParserRULE_decommissionBackendClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2741)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2742)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2743)
		p.String_()
	}
	p.SetState(2748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2744)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2745)
				p.String_()
			}

		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBackendClauseContext is an interface to support dynamic dispatch.
type IModifyBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyBackendClauseContext differentiates from other interfaces.
	IsModifyBackendClauseContext()
}

type ModifyBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBackendClauseContext() *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBackendClause
	return p
}

func InitEmptyModifyBackendClauseContext(p *ModifyBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBackendClause
}

func (*ModifyBackendClauseContext) IsModifyBackendClauseContext() {}

func NewModifyBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyBackendClause

	return p
}

func (s *ModifyBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOST, 0)
}

func (s *ModifyBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBackendClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyBackendClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyBackendClause() (localctx IModifyBackendClauseContext) {
	localctx = NewModifyBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, StarRocksParserRULE_modifyBackendClause)
	p.SetState(2764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2751)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2752)
			p.Match(StarRocksParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.Match(StarRocksParserHOST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2754)
			p.String_()
		}
		{
			p.SetState(2755)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2756)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2758)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2759)
			p.Match(StarRocksParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2760)
			p.String_()
		}
		{
			p.SetState(2761)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2762)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddComputeNodeClauseContext is an interface to support dynamic dispatch.
type IAddComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsAddComputeNodeClauseContext differentiates from other interfaces.
	IsAddComputeNodeClauseContext()
}

type AddComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAddComputeNodeClauseContext() *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addComputeNodeClause
	return p
}

func InitEmptyAddComputeNodeClauseContext(p *AddComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addComputeNodeClause
}

func (*AddComputeNodeClauseContext) IsAddComputeNodeClauseContext() {}

func NewAddComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addComputeNodeClause

	return p
}

func (s *AddComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddComputeNodeClauseContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *AddComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AddComputeNodeClauseContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *AddComputeNodeClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *AddComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *AddComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddComputeNodeClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *AddComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *AddComputeNodeClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AddComputeNodeClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddComputeNodeClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *AddComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddComputeNodeClause(s)
	}
}

func (s *AddComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddComputeNodeClause(s)
	}
}

func (s *AddComputeNodeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddComputeNodeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddComputeNodeClause() (localctx IAddComputeNodeClauseContext) {
	localctx = NewAddComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, StarRocksParserRULE_addComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2766)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2767)
		p.Match(StarRocksParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2768)
		p.Match(StarRocksParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2769)
		p.String_()
	}
	p.SetState(2774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2770)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2771)
				p.String_()
			}

		}
		p.SetState(2776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserINTO {
		{
			p.SetState(2777)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2778)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2779)

			var _x = p.IdentifierOrString()

			localctx.(*AddComputeNodeClauseContext).warehouseName = _x
		}
		p.SetState(2782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCNGROUP {
			{
				p.SetState(2780)
				p.Match(StarRocksParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2781)

				var _x = p.IdentifierOrString()

				localctx.(*AddComputeNodeClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropComputeNodeClauseContext is an interface to support dynamic dispatch.
type IDropComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	CNGROUP() antlr.TerminalNode

	// IsDropComputeNodeClauseContext differentiates from other interfaces.
	IsDropComputeNodeClauseContext()
}

type DropComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropComputeNodeClauseContext() *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropComputeNodeClause
	return p
}

func InitEmptyDropComputeNodeClauseContext(p *DropComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropComputeNodeClause
}

func (*DropComputeNodeClauseContext) IsDropComputeNodeClauseContext() {}

func NewDropComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropComputeNodeClause

	return p
}

func (s *DropComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropComputeNodeClauseContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DropComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropComputeNodeClauseContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *DropComputeNodeClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *DropComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *DropComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropComputeNodeClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DropComputeNodeClauseContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropComputeNodeClauseContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropComputeNodeClauseContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *DropComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropComputeNodeClause(s)
	}
}

func (s *DropComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropComputeNodeClause(s)
	}
}

func (s *DropComputeNodeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropComputeNodeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropComputeNodeClause() (localctx IDropComputeNodeClauseContext) {
	localctx = NewDropComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, StarRocksParserRULE_dropComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2786)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2787)
		p.Match(StarRocksParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2788)
		p.Match(StarRocksParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2789)
		p.String_()
	}
	p.SetState(2794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2790)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2791)
				p.String_()
			}

		}
		p.SetState(2796)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(2797)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2798)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2799)

			var _x = p.IdentifierOrString()

			localctx.(*DropComputeNodeClauseContext).warehouseName = _x
		}
		p.SetState(2802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCNGROUP {
			{
				p.SetState(2800)
				p.Match(StarRocksParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2801)

				var _x = p.IdentifierOrString()

				localctx.(*DropComputeNodeClauseContext).cngroupName = _x
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBrokerClauseContext is an interface to support dynamic dispatch.
type IModifyBrokerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	DROP() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsModifyBrokerClauseContext differentiates from other interfaces.
	IsModifyBrokerClauseContext()
}

type ModifyBrokerClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBrokerClauseContext() *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBrokerClause
	return p
}

func InitEmptyModifyBrokerClauseContext(p *ModifyBrokerClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBrokerClause
}

func (*ModifyBrokerClauseContext) IsModifyBrokerClauseContext() {}

func NewModifyBrokerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyBrokerClause

	return p
}

func (s *ModifyBrokerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *ModifyBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *ModifyBrokerClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ModifyBrokerClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBrokerClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *ModifyBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ModifyBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBrokerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyBrokerClause(s)
	}
}

func (s *ModifyBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyBrokerClause(s)
	}
}

func (s *ModifyBrokerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyBrokerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyBrokerClause() (localctx IModifyBrokerClauseContext) {
	localctx = NewModifyBrokerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, StarRocksParserRULE_modifyBrokerClause)
	var _alt int

	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2806)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2807)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2808)
			p.IdentifierOrString()
		}
		{
			p.SetState(2809)
			p.String_()
		}
		p.SetState(2814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2810)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2811)
					p.String_()
				}

			}
			p.SetState(2816)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2817)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2818)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2819)
			p.IdentifierOrString()
		}
		{
			p.SetState(2820)
			p.String_()
		}
		p.SetState(2825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2821)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2822)
					p.String_()
				}

			}
			p.SetState(2827)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2828)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2829)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2830)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2831)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadErrorUrlClauseContext is an interface to support dynamic dispatch.
type IAlterLoadErrorUrlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterLoadErrorUrlClauseContext differentiates from other interfaces.
	IsAlterLoadErrorUrlClauseContext()
}

type AlterLoadErrorUrlClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLoadErrorUrlClauseContext() *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadErrorUrlClause
	return p
}

func InitEmptyAlterLoadErrorUrlClauseContext(p *AlterLoadErrorUrlClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadErrorUrlClause
}

func (*AlterLoadErrorUrlClauseContext) IsAlterLoadErrorUrlClauseContext() {}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterLoadErrorUrlClause

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadErrorUrlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterLoadErrorUrlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterLoadErrorUrlClause() (localctx IAlterLoadErrorUrlClauseContext) {
	localctx = NewAlterLoadErrorUrlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, StarRocksParserRULE_alterLoadErrorUrlClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2834)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2835)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2836)
		p.Match(StarRocksParserERRORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2837)
		p.Match(StarRocksParserHUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2838)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateImageClauseContext is an interface to support dynamic dispatch.
type ICreateImageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	IMAGE() antlr.TerminalNode

	// IsCreateImageClauseContext differentiates from other interfaces.
	IsCreateImageClauseContext()
}

type CreateImageClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateImageClauseContext() *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createImageClause
	return p
}

func InitEmptyCreateImageClauseContext(p *CreateImageClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createImageClause
}

func (*CreateImageClauseContext) IsCreateImageClauseContext() {}

func NewCreateImageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createImageClause

	return p
}

func (s *CreateImageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateImageClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateImageClauseContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMAGE, 0)
}

func (s *CreateImageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateImageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateImageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateImageClause(s)
	}
}

func (s *CreateImageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateImageClause(s)
	}
}

func (s *CreateImageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateImageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateImageClause() (localctx ICreateImageClauseContext) {
	localctx = NewCreateImageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, StarRocksParserRULE_createImageClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2841)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2842)
		p.Match(StarRocksParserIMAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTabletSchedQClauseContext is an interface to support dynamic dispatch.
type ICleanTabletSchedQClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	QUEUE() antlr.TerminalNode

	// IsCleanTabletSchedQClauseContext differentiates from other interfaces.
	IsCleanTabletSchedQClauseContext()
}

type CleanTabletSchedQClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTabletSchedQClauseContext() *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTabletSchedQClause
	return p
}

func InitEmptyCleanTabletSchedQClauseContext(p *CleanTabletSchedQClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTabletSchedQClause
}

func (*CleanTabletSchedQClauseContext) IsCleanTabletSchedQClauseContext() {}

func NewCleanTabletSchedQClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cleanTabletSchedQClause

	return p
}

func (s *CleanTabletSchedQClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTabletSchedQClauseContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAN, 0)
}

func (s *CleanTabletSchedQClauseContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *CleanTabletSchedQClauseContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULER, 0)
}

func (s *CleanTabletSchedQClauseContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUEUE, 0)
}

func (s *CleanTabletSchedQClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTabletSchedQClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTabletSchedQClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCleanTabletSchedQClause(s)
	}
}

func (s *CleanTabletSchedQClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCleanTabletSchedQClause(s)
	}
}

func (s *CleanTabletSchedQClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCleanTabletSchedQClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CleanTabletSchedQClause() (localctx ICleanTabletSchedQClauseContext) {
	localctx = NewCleanTabletSchedQClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, StarRocksParserRULE_cleanTabletSchedQClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2844)
		p.Match(StarRocksParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2845)
		p.Match(StarRocksParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2846)
		p.Match(StarRocksParserSCHEDULER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2847)
		p.Match(StarRocksParserQUEUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type IDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDecommissionDiskClauseContext differentiates from other interfaces.
	IsDecommissionDiskClauseContext()
}

type DecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionDiskClauseContext() *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionDiskClause
	return p
}

func InitEmptyDecommissionDiskClauseContext(p *DecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionDiskClause
}

func (*DecommissionDiskClauseContext) IsDecommissionDiskClauseContext() {}

func NewDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_decommissionDiskClause

	return p
}

func (s *DecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *DecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *DecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecommissionDiskClause(s)
	}
}

func (s *DecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecommissionDiskClause(s)
	}
}

func (s *DecommissionDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDecommissionDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DecommissionDiskClause() (localctx IDecommissionDiskClauseContext) {
	localctx = NewDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, StarRocksParserRULE_decommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2849)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2850)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2851)
		p.String_()
	}
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2852)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2853)
			p.String_()
		}

		p.SetState(2858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2859)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2860)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2861)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDecommissionDiskClauseContext differentiates from other interfaces.
	IsCancelDecommissionDiskClauseContext()
}

type CancelDecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDecommissionDiskClauseContext() *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDecommissionDiskClause
	return p
}

func InitEmptyCancelDecommissionDiskClauseContext(p *CancelDecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDecommissionDiskClause
}

func (*CancelDecommissionDiskClauseContext) IsCancelDecommissionDiskClauseContext() {}

func NewCancelDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelDecommissionDiskClause

	return p
}

func (s *CancelDecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDecommissionDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelDecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *CancelDecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *CancelDecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CancelDecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *CancelDecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelDecommissionDiskClause(s)
	}
}

func (s *CancelDecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelDecommissionDiskClause(s)
	}
}

func (s *CancelDecommissionDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelDecommissionDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelDecommissionDiskClause() (localctx ICancelDecommissionDiskClauseContext) {
	localctx = NewCancelDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, StarRocksParserRULE_cancelDecommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2863)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2864)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2865)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2866)
		p.String_()
	}
	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2867)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2868)
			p.String_()
		}

		p.SetState(2873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2874)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2875)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2876)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisableDiskClauseContext is an interface to support dynamic dispatch.
type IDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDisableDiskClauseContext differentiates from other interfaces.
	IsDisableDiskClauseContext()
}

type DisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableDiskClauseContext() *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_disableDiskClause
	return p
}

func InitEmptyDisableDiskClauseContext(p *DisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_disableDiskClause
}

func (*DisableDiskClauseContext) IsDisableDiskClauseContext() {}

func NewDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_disableDiskClause

	return p
}

func (s *DisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *DisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *DisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDisableDiskClause(s)
	}
}

func (s *DisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDisableDiskClause(s)
	}
}

func (s *DisableDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDisableDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DisableDiskClause() (localctx IDisableDiskClauseContext) {
	localctx = NewDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, StarRocksParserRULE_disableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2878)
		p.Match(StarRocksParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2879)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2880)
		p.String_()
	}
	p.SetState(2885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2881)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2882)
			p.String_()
		}

		p.SetState(2887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2888)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2889)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2890)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDisableDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDisableDiskClauseContext differentiates from other interfaces.
	IsCancelDisableDiskClauseContext()
}

type CancelDisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDisableDiskClauseContext() *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDisableDiskClause
	return p
}

func InitEmptyCancelDisableDiskClauseContext(p *CancelDisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDisableDiskClause
}

func (*CancelDisableDiskClauseContext) IsCancelDisableDiskClauseContext() {}

func NewCancelDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelDisableDiskClause

	return p
}

func (s *CancelDisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDisableDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelDisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *CancelDisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *CancelDisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CancelDisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *CancelDisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelDisableDiskClause(s)
	}
}

func (s *CancelDisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelDisableDiskClause(s)
	}
}

func (s *CancelDisableDiskClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelDisableDiskClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelDisableDiskClause() (localctx ICancelDisableDiskClauseContext) {
	localctx = NewCancelDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, StarRocksParserRULE_cancelDisableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2892)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2893)
		p.Match(StarRocksParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2894)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2895)
		p.String_()
	}
	p.SetState(2900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2896)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2897)
			p.String_()
		}

		p.SetState(2902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2903)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2904)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2905)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexClauseContext is an interface to support dynamic dispatch.
type ICreateIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexClauseContext differentiates from other interfaces.
	IsCreateIndexClauseContext()
}

type CreateIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexClauseContext() *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexClause
	return p
}

func InitEmptyCreateIndexClauseContext(p *CreateIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexClause
}

func (*CreateIndexClauseContext) IsCreateIndexClauseContext() {}

func NewCreateIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createIndexClause

	return p
}

func (s *CreateIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *CreateIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *CreateIndexClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexClauseContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexClauseContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateIndexClause() (localctx ICreateIndexClauseContext) {
	localctx = NewCreateIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, StarRocksParserRULE_createIndexClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2907)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2908)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2909)

		var _x = p.Identifier()

		localctx.(*CreateIndexClauseContext).indexName = _x
	}
	{
		p.SetState(2910)
		p.IdentifierList()
	}
	p.SetState(2915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(2911)
			p.IndexType()
		}
		p.SetState(2913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(2912)
				p.PropertyList()
			}

		}

	}
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2917)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexClauseContext is an interface to support dynamic dispatch.
type IDropIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropIndexClauseContext differentiates from other interfaces.
	IsDropIndexClauseContext()
}

type DropIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexClauseContext() *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexClause
	return p
}

func InitEmptyDropIndexClauseContext(p *DropIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexClause
}

func (*DropIndexClauseContext) IsDropIndexClauseContext() {}

func NewDropIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropIndexClause

	return p
}

func (s *DropIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropIndexClause() (localctx IDropIndexClauseContext) {
	localctx = NewDropIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, StarRocksParserRULE_dropIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2920)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2921)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2922)

		var _x = p.Identifier()

		localctx.(*DropIndexClauseContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRenameClauseContext is an interface to support dynamic dispatch.
type ITableRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTableRenameClauseContext differentiates from other interfaces.
	IsTableRenameClauseContext()
}

type TableRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRenameClauseContext() *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableRenameClause
	return p
}

func InitEmptyTableRenameClauseContext(p *TableRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableRenameClause
}

func (*TableRenameClauseContext) IsTableRenameClauseContext() {}

func NewTableRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableRenameClause

	return p
}

func (s *TableRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *TableRenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableRenameClause(s)
	}
}

func (s *TableRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableRenameClause(s)
	}
}

func (s *TableRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTableRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TableRenameClause() (localctx ITableRenameClauseContext) {
	localctx = NewTableRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, StarRocksParserRULE_tableRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2924)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2925)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwapTableClauseContext is an interface to support dynamic dispatch.
type ISwapTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWAP() antlr.TerminalNode
	WITH() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSwapTableClauseContext differentiates from other interfaces.
	IsSwapTableClauseContext()
}

type SwapTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwapTableClauseContext() *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_swapTableClause
	return p
}

func InitEmptySwapTableClauseContext(p *SwapTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_swapTableClause
}

func (*SwapTableClauseContext) IsSwapTableClauseContext() {}

func NewSwapTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_swapTableClause

	return p
}

func (s *SwapTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwapTableClauseContext) SWAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSWAP, 0)
}

func (s *SwapTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *SwapTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwapTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwapTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwapTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSwapTableClause(s)
	}
}

func (s *SwapTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSwapTableClause(s)
	}
}

func (s *SwapTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSwapTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SwapTableClause() (localctx ISwapTableClauseContext) {
	localctx = NewSwapTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, StarRocksParserRULE_swapTableClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2927)
		p.Match(StarRocksParserSWAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2928)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2929)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyPropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyPropertiesClauseContext differentiates from other interfaces.
	IsModifyPropertiesClauseContext()
}

type ModifyPropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPropertiesClauseContext() *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPropertiesClause
	return p
}

func InitEmptyModifyPropertiesClauseContext(p *ModifyPropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPropertiesClause
}

func (*ModifyPropertiesClauseContext) IsModifyPropertiesClauseContext() {}

func NewModifyPropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyPropertiesClause

	return p
}

func (s *ModifyPropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyPropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyPropertiesClause(s)
	}
}

func (s *ModifyPropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyPropertiesClause(s)
	}
}

func (s *ModifyPropertiesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyPropertiesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyPropertiesClause() (localctx IModifyPropertiesClauseContext) {
	localctx = NewModifyPropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, StarRocksParserRULE_modifyPropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2932)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyCommentClauseContext is an interface to support dynamic dispatch.
type IModifyCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyCommentClauseContext differentiates from other interfaces.
	IsModifyCommentClauseContext()
}

type ModifyCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyCommentClauseContext() *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyCommentClause
	return p
}

func InitEmptyModifyCommentClauseContext(p *ModifyCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyCommentClause
}

func (*ModifyCommentClauseContext) IsModifyCommentClauseContext() {}

func NewModifyCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyCommentClause

	return p
}

func (s *ModifyCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *ModifyCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *ModifyCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyCommentClause(s)
	}
}

func (s *ModifyCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyCommentClause(s)
	}
}

func (s *ModifyCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyCommentClause() (localctx IModifyCommentClauseContext) {
	localctx = NewModifyCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, StarRocksParserRULE_modifyCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2934)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2935)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2936)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeRangeContext is an interface to support dynamic dispatch.
type IOptimizeRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IStringContext

	// GetEnd returns the end rule contexts.
	GetEnd() IStringContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IStringContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IStringContext)

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsOptimizeRangeContext differentiates from other interfaces.
	IsOptimizeRangeContext()
}

type OptimizeRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IStringContext
	end    IStringContext
}

func NewEmptyOptimizeRangeContext() *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeRange
	return p
}

func InitEmptyOptimizeRangeContext(p *OptimizeRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeRange
}

func (*OptimizeRangeContext) IsOptimizeRangeContext() {}

func NewOptimizeRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_optimizeRange

	return p
}

func (s *OptimizeRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeRangeContext) GetStart_() IStringContext { return s.start_ }

func (s *OptimizeRangeContext) GetEnd() IStringContext { return s.end }

func (s *OptimizeRangeContext) SetStart_(v IStringContext) { s.start_ = v }

func (s *OptimizeRangeContext) SetEnd(v IStringContext) { s.end = v }

func (s *OptimizeRangeContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *OptimizeRangeContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *OptimizeRangeContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *OptimizeRangeContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OptimizeRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOptimizeRange(s)
	}
}

func (s *OptimizeRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOptimizeRange(s)
	}
}

func (s *OptimizeRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOptimizeRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) OptimizeRange() (localctx IOptimizeRangeContext) {
	localctx = NewOptimizeRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, StarRocksParserRULE_optimizeRange)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2938)
		p.Match(StarRocksParserBETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2939)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).start_ = _x
	}
	{
		p.SetState(2940)
		p.Match(StarRocksParserAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2941)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).end = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeClauseContext is an interface to support dynamic dispatch.
type IOptimizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionNames() IPartitionNamesContext
	KeyDesc() IKeyDescContext
	PartitionDesc() IPartitionDescContext
	OrderByDesc() IOrderByDescContext
	DistributionDesc() IDistributionDescContext
	OptimizeRange() IOptimizeRangeContext

	// IsOptimizeClauseContext differentiates from other interfaces.
	IsOptimizeClauseContext()
}

type OptimizeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizeClauseContext() *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeClause
	return p
}

func InitEmptyOptimizeClauseContext(p *OptimizeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeClause
}

func (*OptimizeClauseContext) IsOptimizeClauseContext() {}

func NewOptimizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_optimizeClause

	return p
}

func (s *OptimizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *OptimizeClauseContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *OptimizeClauseContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *OptimizeClauseContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *OptimizeClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *OptimizeClauseContext) OptimizeRange() IOptimizeRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeRangeContext)
}

func (s *OptimizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOptimizeClause(s)
	}
}

func (s *OptimizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOptimizeClause(s)
	}
}

func (s *OptimizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOptimizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) OptimizeClause() (localctx IOptimizeClauseContext) {
	localctx = NewOptimizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, StarRocksParserRULE_optimizeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2944)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2943)
			p.PartitionNames()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE {
		{
			p.SetState(2946)
			p.KeyDesc()
		}

	}
	p.SetState(2950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(2949)
			p.PartitionDesc()
		}

	}
	p.SetState(2953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(2952)
			p.OrderByDesc()
		}

	}
	p.SetState(2956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(2955)
			p.DistributionDesc()
		}

	}
	p.SetState(2959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBETWEEN {
		{
			p.SetState(2958)
			p.OptimizeRange()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnClauseContext is an interface to support dynamic dispatch.
type IAddColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsAddColumnClauseContext differentiates from other interfaces.
	IsAddColumnClauseContext()
}

type AddColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnClauseContext() *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnClause
	return p
}

func InitEmptyAddColumnClauseContext(p *AddColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnClause
}

func (*AddColumnClauseContext) IsAddColumnClauseContext() {}

func NewAddColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addColumnClause

	return p
}

func (s *AddColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *AddColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *AddColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *AddColumnClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddColumnClause() (localctx IAddColumnClauseContext) {
	localctx = NewAddColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, StarRocksParserRULE_addColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2961)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2962)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2963)
		p.ColumnDesc()
	}
	p.SetState(2967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFIRST:
		{
			p.SetState(2964)
			p.Match(StarRocksParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAFTER:
		{
			p.SetState(2965)
			p.Match(StarRocksParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2966)
			p.Identifier()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserIN, StarRocksParserPROPERTIES, StarRocksParserTO, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(2971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIN || _la == StarRocksParserTO {
		{
			p.SetState(2969)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserIN || _la == StarRocksParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2970)

			var _x = p.Identifier()

			localctx.(*AddColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(2974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2973)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnsClauseContext is an interface to support dynamic dispatch.
type IAddColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAddColumnsClauseContext differentiates from other interfaces.
	IsAddColumnsClauseContext()
}

type AddColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnsClauseContext() *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnsClause
	return p
}

func InitEmptyAddColumnsClauseContext(p *AddColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnsClause
}

func (*AddColumnsClauseContext) IsAddColumnsClauseContext() {}

func NewAddColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addColumnsClause

	return p
}

func (s *AddColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnsClauseContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnsClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *AddColumnsClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *AddColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddColumnsClause() (localctx IAddColumnsClauseContext) {
	localctx = NewAddColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, StarRocksParserRULE_addColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2976)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2977)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2978)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2979)
		p.ColumnDesc()
	}
	p.SetState(2984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2980)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.ColumnDesc()
		}

		p.SetState(2986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2987)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIN || _la == StarRocksParserTO {
		{
			p.SetState(2988)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserIN || _la == StarRocksParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2989)

			var _x = p.Identifier()

			localctx.(*AddColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(2993)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2992)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropColumnClauseContext is an interface to support dynamic dispatch.
type IDropColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsDropColumnClauseContext differentiates from other interfaces.
	IsDropColumnClauseContext()
}

type DropColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyDropColumnClauseContext() *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropColumnClause
	return p
}

func InitEmptyDropColumnClauseContext(p *DropColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropColumnClause
}

func (*DropColumnClauseContext) IsDropColumnClauseContext() {}

func NewDropColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropColumnClause

	return p
}

func (s *DropColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropColumnClause() (localctx IDropColumnClauseContext) {
	localctx = NewDropColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, StarRocksParserRULE_dropColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2995)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2996)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2997)
		p.Identifier()
	}
	p.SetState(3000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(2998)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2999)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3002)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyColumnClauseContext is an interface to support dynamic dispatch.
type IModifyColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsModifyColumnClauseContext differentiates from other interfaces.
	IsModifyColumnClauseContext()
}

type ModifyColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyModifyColumnClauseContext() *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyColumnClause
	return p
}

func InitEmptyModifyColumnClauseContext(p *ModifyColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyColumnClause
}

func (*ModifyColumnClauseContext) IsModifyColumnClauseContext() {}

func NewModifyColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyColumnClause

	return p
}

func (s *ModifyColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ModifyColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *ModifyColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *ModifyColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *ModifyColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifyColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ModifyColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyColumnClause() (localctx IModifyColumnClauseContext) {
	localctx = NewModifyColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, StarRocksParserRULE_modifyColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3005)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3006)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3007)
		p.ColumnDesc()
	}
	p.SetState(3011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFIRST:
		{
			p.SetState(3008)
			p.Match(StarRocksParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAFTER:
		{
			p.SetState(3009)
			p.Match(StarRocksParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3010)
			p.Identifier()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserFROM, StarRocksParserPROPERTIES, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(3015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3013)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3014)

			var _x = p.Identifier()

			localctx.(*ModifyColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3017)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRenameClauseContext is an interface to support dynamic dispatch.
type IColumnRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOldColumn returns the oldColumn rule contexts.
	GetOldColumn() IIdentifierContext

	// GetNewColumn returns the newColumn rule contexts.
	GetNewColumn() IIdentifierContext

	// SetOldColumn sets the oldColumn rule contexts.
	SetOldColumn(IIdentifierContext)

	// SetNewColumn sets the newColumn rule contexts.
	SetNewColumn(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnRenameClauseContext differentiates from other interfaces.
	IsColumnRenameClauseContext()
}

type ColumnRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	oldColumn IIdentifierContext
	newColumn IIdentifierContext
}

func NewEmptyColumnRenameClauseContext() *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnRenameClause
	return p
}

func InitEmptyColumnRenameClauseContext(p *ColumnRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnRenameClause
}

func (*ColumnRenameClauseContext) IsColumnRenameClauseContext() {}

func NewColumnRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnRenameClause

	return p
}

func (s *ColumnRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRenameClauseContext) GetOldColumn() IIdentifierContext { return s.oldColumn }

func (s *ColumnRenameClauseContext) GetNewColumn() IIdentifierContext { return s.newColumn }

func (s *ColumnRenameClauseContext) SetOldColumn(v IIdentifierContext) { s.oldColumn = v }

func (s *ColumnRenameClauseContext) SetNewColumn(v IIdentifierContext) { s.newColumn = v }

func (s *ColumnRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *ColumnRenameClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *ColumnRenameClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ColumnRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnRenameClause(s)
	}
}

func (s *ColumnRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnRenameClause(s)
	}
}

func (s *ColumnRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnRenameClause() (localctx IColumnRenameClauseContext) {
	localctx = NewColumnRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, StarRocksParserRULE_columnRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3020)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3021)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3022)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).oldColumn = _x
	}
	{
		p.SetState(3023)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3024)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).newColumn = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReorderColumnsClauseContext is an interface to support dynamic dispatch.
type IReorderColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsReorderColumnsClauseContext differentiates from other interfaces.
	IsReorderColumnsClauseContext()
}

type ReorderColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyReorderColumnsClauseContext() *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_reorderColumnsClause
	return p
}

func InitEmptyReorderColumnsClauseContext(p *ReorderColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_reorderColumnsClause
}

func (*ReorderColumnsClauseContext) IsReorderColumnsClauseContext() {}

func NewReorderColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_reorderColumnsClause

	return p
}

func (s *ReorderColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReorderColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ReorderColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ReorderColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReorderColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReorderColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitReorderColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ReorderColumnsClause() (localctx IReorderColumnsClauseContext) {
	localctx = NewReorderColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, StarRocksParserRULE_reorderColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3026)
		p.Match(StarRocksParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3027)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3028)
		p.IdentifierList()
	}
	p.SetState(3031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3029)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3030)

			var _x = p.Identifier()

			localctx.(*ReorderColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(3034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3033)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupRenameClauseContext is an interface to support dynamic dispatch.
type IRollupRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetNewRollupName returns the newRollupName rule contexts.
	GetNewRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetNewRollupName sets the newRollupName rule contexts.
	SetNewRollupName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsRollupRenameClauseContext differentiates from other interfaces.
	IsRollupRenameClauseContext()
}

type RollupRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rollupName    IIdentifierContext
	newRollupName IIdentifierContext
}

func NewEmptyRollupRenameClauseContext() *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupRenameClause
	return p
}

func InitEmptyRollupRenameClauseContext(p *RollupRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupRenameClause
}

func (*RollupRenameClauseContext) IsRollupRenameClauseContext() {}

func NewRollupRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollupRenameClause

	return p
}

func (s *RollupRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupRenameClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupRenameClauseContext) GetNewRollupName() IIdentifierContext { return s.newRollupName }

func (s *RollupRenameClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupRenameClauseContext) SetNewRollupName(v IIdentifierContext) { s.newRollupName = v }

func (s *RollupRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *RollupRenameClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *RollupRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RollupRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollupRenameClause(s)
	}
}

func (s *RollupRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollupRenameClause(s)
	}
}

func (s *RollupRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRollupRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RollupRenameClause() (localctx IRollupRenameClauseContext) {
	localctx = NewRollupRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, StarRocksParserRULE_rollupRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3036)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3037)
		p.Match(StarRocksParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3038)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).rollupName = _x
	}
	{
		p.SetState(3039)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).newRollupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompactionClauseContext is an interface to support dynamic dispatch.
type ICompactionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPACT() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	BASE() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode

	// IsCompactionClauseContext differentiates from other interfaces.
	IsCompactionClauseContext()
}

type CompactionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompactionClauseContext() *CompactionClauseContext {
	var p = new(CompactionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_compactionClause
	return p
}

func InitEmptyCompactionClauseContext(p *CompactionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_compactionClause
}

func (*CompactionClauseContext) IsCompactionClauseContext() {}

func NewCompactionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionClauseContext {
	var p = new(CompactionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_compactionClause

	return p
}

func (s *CompactionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionClauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPACT, 0)
}

func (s *CompactionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CompactionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CompactionClauseContext) BASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASE, 0)
}

func (s *CompactionClauseContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUMULATIVE, 0)
}

func (s *CompactionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompactionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCompactionClause(s)
	}
}

func (s *CompactionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCompactionClause(s)
	}
}

func (s *CompactionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCompactionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CompactionClause() (localctx ICompactionClauseContext) {
	localctx = NewCompactionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, StarRocksParserRULE_compactionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBASE || _la == StarRocksParserCUMULATIVE {
		{
			p.SetState(3041)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserBASE || _la == StarRocksParserCUMULATIVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3044)
		p.Match(StarRocksParserCOMPACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(3045)
			p.Identifier()
		}

	case StarRocksParserT__1:
		{
			p.SetState(3046)
			p.IdentifierList()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldNameContext is an interface to support dynamic dispatch.
type ISubfieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ARRAY_ELEMENT() antlr.TerminalNode

	// IsSubfieldNameContext differentiates from other interfaces.
	IsSubfieldNameContext()
}

type SubfieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldNameContext() *SubfieldNameContext {
	var p = new(SubfieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldName
	return p
}

func InitEmptySubfieldNameContext(p *SubfieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldName
}

func (*SubfieldNameContext) IsSubfieldNameContext() {}

func NewSubfieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldNameContext {
	var p = new(SubfieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subfieldName

	return p
}

func (s *SubfieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldNameContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_ELEMENT, 0)
}

func (s *SubfieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubfieldName(s)
	}
}

func (s *SubfieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubfieldName(s)
	}
}

func (s *SubfieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSubfieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SubfieldName() (localctx ISubfieldNameContext) {
	localctx = NewSubfieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, StarRocksParserRULE_subfieldName)
	p.SetState(3051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3049)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3050)
			p.Match(StarRocksParserARRAY_ELEMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedFieldNameContext is an interface to support dynamic dispatch.
type INestedFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldName() []ISubfieldNameContext
	SubfieldName(i int) ISubfieldNameContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsNestedFieldNameContext differentiates from other interfaces.
	IsNestedFieldNameContext()
}

type NestedFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedFieldNameContext() *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nestedFieldName
	return p
}

func InitEmptyNestedFieldNameContext(p *NestedFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nestedFieldName
}

func (*NestedFieldNameContext) IsNestedFieldNameContext() {}

func NewNestedFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_nestedFieldName

	return p
}

func (s *NestedFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedFieldNameContext) AllSubfieldName() []ISubfieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldNameContext); ok {
			tst[i] = t.(ISubfieldNameContext)
			i++
		}
	}

	return tst
}

func (s *NestedFieldNameContext) SubfieldName(i int) ISubfieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldNameContext)
}

func (s *NestedFieldNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserDOT_IDENTIFIER)
}

func (s *NestedFieldNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOT_IDENTIFIER, i)
}

func (s *NestedFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNestedFieldName(s)
	}
}

func (s *NestedFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNestedFieldName(s)
	}
}

func (s *NestedFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitNestedFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) NestedFieldName() (localctx INestedFieldNameContext) {
	localctx = NewNestedFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, StarRocksParserRULE_nestedFieldName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3053)
		p.SubfieldName()
	}
	p.SetState(3059)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__0 || _la == StarRocksParserDOT_IDENTIFIER {
		p.SetState(3057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserDOT_IDENTIFIER:
			{
				p.SetState(3054)
				p.Match(StarRocksParserDOT_IDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserT__0:
			{
				p.SetState(3055)
				p.Match(StarRocksParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3056)
				p.SubfieldName()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFieldClauseContext is an interface to support dynamic dispatch.
type IAddFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ADD() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	SubfieldDesc() ISubfieldDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAddFieldClauseContext differentiates from other interfaces.
	IsAddFieldClauseContext()
}

type AddFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFieldClauseContext() *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFieldClause
	return p
}

func InitEmptyAddFieldClauseContext(p *AddFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFieldClause
}

func (*AddFieldClauseContext) IsAddFieldClauseContext() {}

func NewAddFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addFieldClause

	return p
}

func (s *AddFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *AddFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *AddFieldClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddFieldClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddFieldClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELD, 0)
}

func (s *AddFieldClauseContext) SubfieldDesc() ISubfieldDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *AddFieldClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *AddFieldClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *AddFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddFieldClause(s)
	}
}

func (s *AddFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddFieldClause(s)
	}
}

func (s *AddFieldClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddFieldClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddFieldClause() (localctx IAddFieldClauseContext) {
	localctx = NewAddFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, StarRocksParserRULE_addFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3062)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3063)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3064)
		p.Identifier()
	}
	{
		p.SetState(3065)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3066)
		p.Match(StarRocksParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3067)
		p.SubfieldDesc()
	}
	p.SetState(3071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFIRST:
		{
			p.SetState(3068)
			p.Match(StarRocksParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAFTER:
		{
			p.SetState(3069)
			p.Match(StarRocksParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3070)
			p.Identifier()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserPROPERTIES, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(3074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3073)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFieldClauseContext is an interface to support dynamic dispatch.
type IDropFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	Identifier() IIdentifierContext
	DROP() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	NestedFieldName() INestedFieldNameContext
	Properties() IPropertiesContext

	// IsDropFieldClauseContext differentiates from other interfaces.
	IsDropFieldClauseContext()
}

type DropFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFieldClauseContext() *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFieldClause
	return p
}

func InitEmptyDropFieldClauseContext(p *DropFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFieldClause
}

func (*DropFieldClauseContext) IsDropFieldClauseContext() {}

func NewDropFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFieldClause

	return p
}

func (s *DropFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *DropFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *DropFieldClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFieldClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELD, 0)
}

func (s *DropFieldClauseContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *DropFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFieldClause(s)
	}
}

func (s *DropFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFieldClause(s)
	}
}

func (s *DropFieldClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropFieldClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropFieldClause() (localctx IDropFieldClauseContext) {
	localctx = NewDropFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, StarRocksParserRULE_dropFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3076)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3077)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3078)
		p.Identifier()
	}
	{
		p.SetState(3079)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3080)
		p.Match(StarRocksParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3081)
		p.NestedFieldName()
	}
	p.SetState(3083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3082)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceTagClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	TagOptions() ITagOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceTagClauseContext differentiates from other interfaces.
	IsCreateOrReplaceTagClauseContext()
}

type CreateOrReplaceTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceTagClauseContext() *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceTagClause
	return p
}

func InitEmptyCreateOrReplaceTagClauseContext(p *CreateOrReplaceTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceTagClause
}

func (*CreateOrReplaceTagClauseContext) IsCreateOrReplaceTagClauseContext() {}

func NewCreateOrReplaceTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createOrReplaceTagClause

	return p
}

func (s *CreateOrReplaceTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceTagClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateOrReplaceTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTAG, 0)
}

func (s *CreateOrReplaceTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceTagClauseContext) TagOptions() ITagOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagOptionsContext)
}

func (s *CreateOrReplaceTagClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateOrReplaceTagClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateOrReplaceTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateOrReplaceTagClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateOrReplaceTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateOrReplaceTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateOrReplaceTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateOrReplaceTagClause() (localctx ICreateOrReplaceTagClauseContext) {
	localctx = NewCreateOrReplaceTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, StarRocksParserRULE_createOrReplaceTagClause)
	var _la int

	p.SetState(3104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCREATE {
			{
				p.SetState(3085)
				p.Match(StarRocksParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3086)
				p.Match(StarRocksParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3089)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3090)
			p.Match(StarRocksParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3091)
			p.Identifier()
		}
		{
			p.SetState(3092)
			p.TagOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3094)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3095)
			p.Match(StarRocksParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3096)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3097)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3098)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3101)
			p.Identifier()
		}
		{
			p.SetState(3102)
			p.TagOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceBranchClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	BranchOptions() IBranchOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceBranchClauseContext differentiates from other interfaces.
	IsCreateOrReplaceBranchClauseContext()
}

type CreateOrReplaceBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceBranchClauseContext() *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceBranchClause
	return p
}

func InitEmptyCreateOrReplaceBranchClauseContext(p *CreateOrReplaceBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceBranchClause
}

func (*CreateOrReplaceBranchClauseContext) IsCreateOrReplaceBranchClauseContext() {}

func NewCreateOrReplaceBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createOrReplaceBranchClause

	return p
}

func (s *CreateOrReplaceBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceBranchClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBRANCH, 0)
}

func (s *CreateOrReplaceBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceBranchClauseContext) BranchOptions() IBranchOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchOptionsContext)
}

func (s *CreateOrReplaceBranchClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateOrReplaceBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateOrReplaceBranchClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateOrReplaceBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateOrReplaceBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateOrReplaceBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateOrReplaceBranchClause() (localctx ICreateOrReplaceBranchClauseContext) {
	localctx = NewCreateOrReplaceBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, StarRocksParserRULE_createOrReplaceBranchClause)
	var _la int

	p.SetState(3125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCREATE {
			{
				p.SetState(3106)
				p.Match(StarRocksParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3107)
				p.Match(StarRocksParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3110)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3111)
			p.Match(StarRocksParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3112)
			p.Identifier()
		}
		{
			p.SetState(3113)
			p.BranchOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3115)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.Match(StarRocksParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3117)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3118)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3119)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3122)
			p.Identifier()
		}
		{
			p.SetState(3123)
			p.BranchOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBranchClauseContext is an interface to support dynamic dispatch.
type IDropBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropBranchClauseContext differentiates from other interfaces.
	IsDropBranchClauseContext()
}

type DropBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBranchClauseContext() *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBranchClause
	return p
}

func InitEmptyDropBranchClauseContext(p *DropBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBranchClause
}

func (*DropBranchClauseContext) IsDropBranchClauseContext() {}

func NewDropBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropBranchClause

	return p
}

func (s *DropBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBranchClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBRANCH, 0)
}

func (s *DropBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropBranchClause(s)
	}
}

func (s *DropBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropBranchClause(s)
	}
}

func (s *DropBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropBranchClause() (localctx IDropBranchClauseContext) {
	localctx = NewDropBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, StarRocksParserRULE_dropBranchClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3127)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3128)
		p.Match(StarRocksParserBRANCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(3129)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3130)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3133)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTagClauseContext is an interface to support dynamic dispatch.
type IDropTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropTagClauseContext differentiates from other interfaces.
	IsDropTagClauseContext()
}

type DropTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTagClauseContext() *DropTagClauseContext {
	var p = new(DropTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTagClause
	return p
}

func InitEmptyDropTagClauseContext(p *DropTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTagClause
}

func (*DropTagClauseContext) IsDropTagClauseContext() {}

func NewDropTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTagClauseContext {
	var p = new(DropTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropTagClause

	return p
}

func (s *DropTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTagClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTAG, 0)
}

func (s *DropTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropTagClause(s)
	}
}

func (s *DropTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropTagClause(s)
	}
}

func (s *DropTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropTagClause() (localctx IDropTagClauseContext) {
	localctx = NewDropTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, StarRocksParserRULE_dropTagClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3135)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3136)
		p.Match(StarRocksParserTAG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(3137)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3138)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3141)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOperationClauseContext is an interface to support dynamic dispatch.
type ITableOperationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	FunctionCall() IFunctionCallContext

	// IsTableOperationClauseContext differentiates from other interfaces.
	IsTableOperationClauseContext()
}

type TableOperationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOperationClauseContext() *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableOperationClause
	return p
}

func InitEmptyTableOperationClauseContext(p *TableOperationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableOperationClause
}

func (*TableOperationClauseContext) IsTableOperationClauseContext() {}

func NewTableOperationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableOperationClause

	return p
}

func (s *TableOperationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOperationClauseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *TableOperationClauseContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *TableOperationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOperationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOperationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableOperationClause(s)
	}
}

func (s *TableOperationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableOperationClause(s)
	}
}

func (s *TableOperationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTableOperationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TableOperationClause() (localctx ITableOperationClauseContext) {
	localctx = NewTableOperationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, StarRocksParserRULE_tableOperationClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3143)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3144)
		p.FunctionCall()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagOptionsContext is an interface to support dynamic dispatch.
type ITagOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext

	// IsTagOptionsContext differentiates from other interfaces.
	IsTagOptionsContext()
}

type TagOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagOptionsContext() *TagOptionsContext {
	var p = new(TagOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tagOptions
	return p
}

func InitEmptyTagOptionsContext(p *TagOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tagOptions
}

func (*TagOptionsContext) IsTagOptionsContext() {}

func NewTagOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagOptionsContext {
	var p = new(TagOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tagOptions

	return p
}

func (s *TagOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TagOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *TagOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *TagOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *TagOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *TagOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *TagOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTagOptions(s)
	}
}

func (s *TagOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTagOptions(s)
	}
}

func (s *TagOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTagOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TagOptions() (localctx ITagOptionsContext) {
	localctx = NewTagOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, StarRocksParserRULE_tagOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(3146)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3147)
			p.Match(StarRocksParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3148)
			p.Match(StarRocksParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3149)
			p.SnapshotId()
		}

	}
	p.SetState(3153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserRETAIN {
		{
			p.SetState(3152)
			p.RefRetain()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchOptionsContext is an interface to support dynamic dispatch.
type IBranchOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext
	SnapshotRetention() ISnapshotRetentionContext

	// IsBranchOptionsContext differentiates from other interfaces.
	IsBranchOptionsContext()
}

type BranchOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchOptionsContext() *BranchOptionsContext {
	var p = new(BranchOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_branchOptions
	return p
}

func InitEmptyBranchOptionsContext(p *BranchOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_branchOptions
}

func (*BranchOptionsContext) IsBranchOptionsContext() {}

func NewBranchOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchOptionsContext {
	var p = new(BranchOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_branchOptions

	return p
}

func (s *BranchOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *BranchOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *BranchOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *BranchOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *BranchOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *BranchOptionsContext) SnapshotRetention() ISnapshotRetentionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotRetentionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotRetentionContext)
}

func (s *BranchOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBranchOptions(s)
	}
}

func (s *BranchOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBranchOptions(s)
	}
}

func (s *BranchOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBranchOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BranchOptions() (localctx IBranchOptionsContext) {
	localctx = NewBranchOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, StarRocksParserRULE_branchOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(3155)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3156)
			p.Match(StarRocksParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3157)
			p.Match(StarRocksParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3158)
			p.SnapshotId()
		}

	}
	p.SetState(3162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserRETAIN {
		{
			p.SetState(3161)
			p.RefRetain()
		}

	}
	p.SetState(3165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3164)
			p.SnapshotRetention()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotRetentionContext is an interface to support dynamic dispatch.
type ISnapshotRetentionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	MinSnapshotsToKeep() IMinSnapshotsToKeepContext
	MaxSnapshotAge() IMaxSnapshotAgeContext

	// IsSnapshotRetentionContext differentiates from other interfaces.
	IsSnapshotRetentionContext()
}

type SnapshotRetentionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotRetentionContext() *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotRetention
	return p
}

func InitEmptySnapshotRetentionContext(p *SnapshotRetentionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotRetention
}

func (*SnapshotRetentionContext) IsSnapshotRetentionContext() {}

func NewSnapshotRetentionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_snapshotRetention

	return p
}

func (s *SnapshotRetentionContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotRetentionContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *SnapshotRetentionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *SnapshotRetentionContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETENTION, 0)
}

func (s *SnapshotRetentionContext) MinSnapshotsToKeep() IMinSnapshotsToKeepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinSnapshotsToKeepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinSnapshotsToKeepContext)
}

func (s *SnapshotRetentionContext) MaxSnapshotAge() IMaxSnapshotAgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxSnapshotAgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxSnapshotAgeContext)
}

func (s *SnapshotRetentionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotRetentionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotRetentionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSnapshotRetention(s)
	}
}

func (s *SnapshotRetentionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSnapshotRetention(s)
	}
}

func (s *SnapshotRetentionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSnapshotRetention(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SnapshotRetention() (localctx ISnapshotRetentionContext) {
	localctx = NewSnapshotRetentionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, StarRocksParserRULE_snapshotRetention)
	p.SetState(3181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3167)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3168)
			p.Match(StarRocksParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3169)
			p.Match(StarRocksParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3170)
			p.MinSnapshotsToKeep()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3171)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3172)
			p.Match(StarRocksParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3173)
			p.Match(StarRocksParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3174)
			p.MaxSnapshotAge()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3175)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3176)
			p.Match(StarRocksParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3177)
			p.Match(StarRocksParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3178)
			p.MinSnapshotsToKeep()
		}
		{
			p.SetState(3179)
			p.MaxSnapshotAge()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefRetainContext is an interface to support dynamic dispatch.
type IRefRetainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN() antlr.TerminalNode
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsRefRetainContext differentiates from other interfaces.
	IsRefRetainContext()
}

type RefRetainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefRetainContext() *RefRetainContext {
	var p = new(RefRetainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refRetain
	return p
}

func InitEmptyRefRetainContext(p *RefRetainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refRetain
}

func (*RefRetainContext) IsRefRetainContext() {}

func NewRefRetainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefRetainContext {
	var p = new(RefRetainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refRetain

	return p
}

func (s *RefRetainContext) GetParser() antlr.Parser { return s.parser }

func (s *RefRetainContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETAIN, 0)
}

func (s *RefRetainContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RefRetainContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *RefRetainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefRetainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefRetainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefRetain(s)
	}
}

func (s *RefRetainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefRetain(s)
	}
}

func (s *RefRetainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRefRetain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RefRetain() (localctx IRefRetainContext) {
	localctx = NewRefRetainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, StarRocksParserRULE_refRetain)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3183)
		p.Match(StarRocksParserRETAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3184)
		p.Number()
	}
	{
		p.SetState(3185)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaxSnapshotAgeContext is an interface to support dynamic dispatch.
type IMaxSnapshotAgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsMaxSnapshotAgeContext differentiates from other interfaces.
	IsMaxSnapshotAgeContext()
}

type MaxSnapshotAgeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaxSnapshotAgeContext() *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_maxSnapshotAge
	return p
}

func InitEmptyMaxSnapshotAgeContext(p *MaxSnapshotAgeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_maxSnapshotAge
}

func (*MaxSnapshotAgeContext) IsMaxSnapshotAgeContext() {}

func NewMaxSnapshotAgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_maxSnapshotAge

	return p
}

func (s *MaxSnapshotAgeContext) GetParser() antlr.Parser { return s.parser }

func (s *MaxSnapshotAgeContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MaxSnapshotAgeContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *MaxSnapshotAgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaxSnapshotAgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaxSnapshotAgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMaxSnapshotAge(s)
	}
}

func (s *MaxSnapshotAgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMaxSnapshotAge(s)
	}
}

func (s *MaxSnapshotAgeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMaxSnapshotAge(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MaxSnapshotAge() (localctx IMaxSnapshotAgeContext) {
	localctx = NewMaxSnapshotAgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, StarRocksParserRULE_maxSnapshotAge)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3187)
		p.Number()
	}
	{
		p.SetState(3188)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinSnapshotsToKeepContext is an interface to support dynamic dispatch.
type IMinSnapshotsToKeepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	SNAPSHOTS() antlr.TerminalNode

	// IsMinSnapshotsToKeepContext differentiates from other interfaces.
	IsMinSnapshotsToKeepContext()
}

type MinSnapshotsToKeepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinSnapshotsToKeepContext() *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_minSnapshotsToKeep
	return p
}

func InitEmptyMinSnapshotsToKeepContext(p *MinSnapshotsToKeepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_minSnapshotsToKeep
}

func (*MinSnapshotsToKeepContext) IsMinSnapshotsToKeepContext() {}

func NewMinSnapshotsToKeepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_minSnapshotsToKeep

	return p
}

func (s *MinSnapshotsToKeepContext) GetParser() antlr.Parser { return s.parser }

func (s *MinSnapshotsToKeepContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MinSnapshotsToKeepContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOTS, 0)
}

func (s *MinSnapshotsToKeepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinSnapshotsToKeepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinSnapshotsToKeepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMinSnapshotsToKeep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MinSnapshotsToKeep() (localctx IMinSnapshotsToKeepContext) {
	localctx = NewMinSnapshotsToKeepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, StarRocksParserRULE_minSnapshotsToKeep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3190)
		p.Number()
	}
	{
		p.SetState(3191)
		p.Match(StarRocksParserSNAPSHOTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotIdContext is an interface to support dynamic dispatch.
type ISnapshotIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsSnapshotIdContext differentiates from other interfaces.
	IsSnapshotIdContext()
}

type SnapshotIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotIdContext() *SnapshotIdContext {
	var p = new(SnapshotIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotId
	return p
}

func InitEmptySnapshotIdContext(p *SnapshotIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotId
}

func (*SnapshotIdContext) IsSnapshotIdContext() {}

func NewSnapshotIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotIdContext {
	var p = new(SnapshotIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_snapshotId

	return p
}

func (s *SnapshotIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotIdContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SnapshotIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSnapshotId(s)
	}
}

func (s *SnapshotIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSnapshotId(s)
	}
}

func (s *SnapshotIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSnapshotId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SnapshotId() (localctx ISnapshotIdContext) {
	localctx = NewSnapshotIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, StarRocksParserRULE_snapshotId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3193)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeUnitContext is an interface to support dynamic dispatch.
type ITimeUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode

	// IsTimeUnitContext differentiates from other interfaces.
	IsTimeUnitContext()
}

type TimeUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeUnitContext() *TimeUnitContext {
	var p = new(TimeUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_timeUnit
	return p
}

func InitEmptyTimeUnitContext(p *TimeUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_timeUnit
}

func (*TimeUnitContext) IsTimeUnitContext() {}

func NewTimeUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeUnitContext {
	var p = new(TimeUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_timeUnit

	return p
}

func (s *TimeUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAYS, 0)
}

func (s *TimeUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOURS, 0)
}

func (s *TimeUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTES, 0)
}

func (s *TimeUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTimeUnit(s)
	}
}

func (s *TimeUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTimeUnit(s)
	}
}

func (s *TimeUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTimeUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TimeUnit() (localctx ITimeUnitContext) {
	localctx = NewTimeUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, StarRocksParserRULE_timeUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3195)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDAYS || _la == StarRocksParserHOURS || _la == StarRocksParserMINUTES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInteger_listContext is an interface to support dynamic dispatch.
type IInteger_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsInteger_listContext differentiates from other interfaces.
	IsInteger_listContext()
}

type Integer_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_listContext() *Integer_listContext {
	var p = new(Integer_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_integer_list
	return p
}

func InitEmptyInteger_listContext(p *Integer_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_integer_list
}

func (*Integer_listContext) IsInteger_listContext() {}

func NewInteger_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_listContext {
	var p = new(Integer_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_integer_list

	return p
}

func (s *Integer_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_listContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *Integer_listContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *Integer_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInteger_list(s)
	}
}

func (s *Integer_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInteger_list(s)
	}
}

func (s *Integer_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInteger_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Integer_list() (localctx IInteger_listContext) {
	localctx = NewInteger_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, StarRocksParserRULE_integer_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3197)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3198)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3199)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3200)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3206)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPersistentIndexClauseContext is an interface to support dynamic dispatch.
type IDropPersistentIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	Integer_list() IInteger_listContext

	// IsDropPersistentIndexClauseContext differentiates from other interfaces.
	IsDropPersistentIndexClauseContext()
}

type DropPersistentIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPersistentIndexClauseContext() *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPersistentIndexClause
	return p
}

func InitEmptyDropPersistentIndexClauseContext(p *DropPersistentIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPersistentIndexClause
}

func (*DropPersistentIndexClauseContext) IsDropPersistentIndexClauseContext() {}

func NewDropPersistentIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropPersistentIndexClause

	return p
}

func (s *DropPersistentIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPersistentIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropPersistentIndexClauseContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERSISTENT, 0)
}

func (s *DropPersistentIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *DropPersistentIndexClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DropPersistentIndexClauseContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLETS, 0)
}

func (s *DropPersistentIndexClauseContext) Integer_list() IInteger_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_listContext)
}

func (s *DropPersistentIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPersistentIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPersistentIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropPersistentIndexClause(s)
	}
}

func (s *DropPersistentIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropPersistentIndexClause(s)
	}
}

func (s *DropPersistentIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropPersistentIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropPersistentIndexClause() (localctx IDropPersistentIndexClauseContext) {
	localctx = NewDropPersistentIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, StarRocksParserRULE_dropPersistentIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3208)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3209)
		p.Match(StarRocksParserPERSISTENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3210)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3211)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3212)
		p.Match(StarRocksParserTABLETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3213)
		p.Integer_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddPartitionClauseContext is an interface to support dynamic dispatch.
type IAddPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SingleRangePartition() ISingleRangePartitionContext
	PARTITIONS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	TEMPORARY() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsAddPartitionClauseContext differentiates from other interfaces.
	IsAddPartitionClauseContext()
}

type AddPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddPartitionClauseContext() *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addPartitionClause
	return p
}

func InitEmptyAddPartitionClauseContext(p *AddPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addPartitionClause
}

func (*AddPartitionClauseContext) IsAddPartitionClauseContext() {}

func NewAddPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addPartitionClause

	return p
}

func (s *AddPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddPartitionClauseContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *AddPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *AddPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *AddPartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddPartitionClauseContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddPartitionClause() (localctx IAddPartitionClauseContext) {
	localctx = NewAddPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, StarRocksParserRULE_addPartitionClause)
	var _la int

	p.SetState(3244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3215)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3216)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserPARTITION:
			{
				p.SetState(3219)
				p.SingleRangePartition()
			}

		case StarRocksParserPARTITIONS:
			{
				p.SetState(3220)
				p.Match(StarRocksParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3221)
				p.MultiRangePartition()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserDISTRIBUTED {
			{
				p.SetState(3224)
				p.DistributionDesc()
			}

		}
		p.SetState(3228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3227)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3230)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3231)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3234)
				p.SingleItemListPartitionDesc()
			}

		case 2:
			{
				p.SetState(3235)
				p.MultiItemListPartitionDesc()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserDISTRIBUTED {
			{
				p.SetState(3238)
				p.DistributionDesc()
			}

		}
		p.SetState(3242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3241)
				p.Properties()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPartitionClauseContext is an interface to support dynamic dispatch.
type IDropPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ALL() antlr.TerminalNode

	// IsDropPartitionClauseContext differentiates from other interfaces.
	IsDropPartitionClauseContext()
}

type DropPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDropPartitionClauseContext() *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPartitionClause
	return p
}

func InitEmptyDropPartitionClauseContext(p *DropPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPartitionClause
}

func (*DropPartitionClauseContext) IsDropPartitionClauseContext() {}

func NewDropPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropPartitionClause

	return p
}

func (s *DropPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPartitionClauseContext) GetWhere() IExpressionContext { return s.where }

func (s *DropPartitionClauseContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *DropPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *DropPartitionClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DropPartitionClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DropPartitionClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropPartitionClause() (localctx IDropPartitionClauseContext) {
	localctx = NewDropPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, StarRocksParserRULE_dropPartitionClause)
	var _la int

	p.SetState(3301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3246)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3247)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserPARTITION:
			{
				p.SetState(3250)
				p.Match(StarRocksParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIF {
				{
					p.SetState(3251)
					p.Match(StarRocksParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3252)
					p.Match(StarRocksParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3255)
				p.Identifier()
			}

		case StarRocksParserPARTITIONS:
			{
				p.SetState(3256)
				p.Match(StarRocksParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3259)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIF {
				{
					p.SetState(3257)
					p.Match(StarRocksParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3258)
					p.Match(StarRocksParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3261)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3264)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3267)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3268)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3271)
			p.Match(StarRocksParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3272)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3273)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3276)
			p.MultiRangePartition()
		}
		p.SetState(3278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3277)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3280)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3281)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3284)
			p.Match(StarRocksParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3287)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3285)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3286)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3289)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3290)

			var _x = p.expression(0)

			localctx.(*DropPartitionClauseContext).where = _x
		}
		p.SetState(3292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3291)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3294)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3295)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3296)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3297)
			p.Match(StarRocksParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3298)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePartitionClauseContext is an interface to support dynamic dispatch.
type ITruncatePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext

	// IsTruncatePartitionClauseContext differentiates from other interfaces.
	IsTruncatePartitionClauseContext()
}

type TruncatePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePartitionClauseContext() *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePartitionClause
	return p
}

func InitEmptyTruncatePartitionClauseContext(p *TruncatePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePartitionClause
}

func (*TruncatePartitionClauseContext) IsTruncatePartitionClauseContext() {}

func NewTruncatePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_truncatePartitionClause

	return p
}

func (s *TruncatePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePartitionClauseContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *TruncatePartitionClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncatePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTruncatePartitionClause(s)
	}
}

func (s *TruncatePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTruncatePartitionClause(s)
	}
}

func (s *TruncatePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTruncatePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TruncatePartitionClause() (localctx ITruncatePartitionClauseContext) {
	localctx = NewTruncatePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, StarRocksParserRULE_truncatePartitionClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3303)
		p.Match(StarRocksParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3304)
		p.PartitionNames()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPartitionClauseContext is an interface to support dynamic dispatch.
type IModifyPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ASTERISK_SYMBOL() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext

	// IsModifyPartitionClauseContext differentiates from other interfaces.
	IsModifyPartitionClauseContext()
}

type ModifyPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPartitionClauseContext() *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPartitionClause
	return p
}

func InitEmptyModifyPartitionClauseContext(p *ModifyPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPartitionClause
}

func (*ModifyPartitionClauseContext) IsModifyPartitionClauseContext() {}

func NewModifyPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyPartitionClause

	return p
}

func (s *ModifyPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyPartitionClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *ModifyPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitModifyPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ModifyPartitionClause() (localctx IModifyPartitionClauseContext) {
	localctx = NewModifyPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, StarRocksParserRULE_modifyPartitionClause)
	p.SetState(3320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3306)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3307)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3308)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3309)
				p.IdentifierList()
			}

		case 3:
			{
				p.SetState(3310)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3311)
				p.Match(StarRocksParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3312)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3315)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3316)
			p.PropertyList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3317)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3318)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3319)
			p.DistributionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePartitionClauseContext is an interface to support dynamic dispatch.
type IReplacePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IPartitionNamesContext

	// GetTempParName returns the tempParName rule contexts.
	GetTempParName() IPartitionNamesContext

	// SetParName sets the parName rule contexts.
	SetParName(IPartitionNamesContext)

	// SetTempParName sets the tempParName rule contexts.
	SetTempParName(IPartitionNamesContext)

	// Getter signatures
	REPLACE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllPartitionNames() []IPartitionNamesContext
	PartitionNames(i int) IPartitionNamesContext
	Properties() IPropertiesContext

	// IsReplacePartitionClauseContext differentiates from other interfaces.
	IsReplacePartitionClauseContext()
}

type ReplacePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	parName     IPartitionNamesContext
	tempParName IPartitionNamesContext
}

func NewEmptyReplacePartitionClauseContext() *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replacePartitionClause
	return p
}

func InitEmptyReplacePartitionClauseContext(p *ReplacePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replacePartitionClause
}

func (*ReplacePartitionClauseContext) IsReplacePartitionClauseContext() {}

func NewReplacePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_replacePartitionClause

	return p
}

func (s *ReplacePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePartitionClauseContext) GetParName() IPartitionNamesContext { return s.parName }

func (s *ReplacePartitionClauseContext) GetTempParName() IPartitionNamesContext { return s.tempParName }

func (s *ReplacePartitionClauseContext) SetParName(v IPartitionNamesContext) { s.parName = v }

func (s *ReplacePartitionClauseContext) SetTempParName(v IPartitionNamesContext) { s.tempParName = v }

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionNames() []IPartitionNamesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			len++
		}
	}

	tst := make([]IPartitionNamesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionNamesContext); ok {
			tst[i] = t.(IPartitionNamesContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionNames(i int) IPartitionNamesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ReplacePartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitReplacePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ReplacePartitionClause() (localctx IReplacePartitionClauseContext) {
	localctx = NewReplacePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, StarRocksParserRULE_replacePartitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3322)
		p.Match(StarRocksParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3323)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).parName = _x
	}
	{
		p.SetState(3324)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3325)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).tempParName = _x
	}
	p.SetState(3327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3326)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRenameClauseContext is an interface to support dynamic dispatch.
type IPartitionRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IIdentifierContext

	// GetNewParName returns the newParName rule contexts.
	GetNewParName() IIdentifierContext

	// SetParName sets the parName rule contexts.
	SetParName(IIdentifierContext)

	// SetNewParName sets the newParName rule contexts.
	SetNewParName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsPartitionRenameClauseContext differentiates from other interfaces.
	IsPartitionRenameClauseContext()
}

type PartitionRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	parName    IIdentifierContext
	newParName IIdentifierContext
}

func NewEmptyPartitionRenameClauseContext() *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRenameClause
	return p
}

func InitEmptyPartitionRenameClauseContext(p *PartitionRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRenameClause
}

func (*PartitionRenameClauseContext) IsPartitionRenameClauseContext() {}

func NewPartitionRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionRenameClause

	return p
}

func (s *PartitionRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRenameClauseContext) GetParName() IIdentifierContext { return s.parName }

func (s *PartitionRenameClauseContext) GetNewParName() IIdentifierContext { return s.newParName }

func (s *PartitionRenameClauseContext) SetParName(v IIdentifierContext) { s.parName = v }

func (s *PartitionRenameClauseContext) SetNewParName(v IIdentifierContext) { s.newParName = v }

func (s *PartitionRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *PartitionRenameClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *PartitionRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionRenameClause(s)
	}
}

func (s *PartitionRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionRenameClause(s)
	}
}

func (s *PartitionRenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionRenameClause() (localctx IPartitionRenameClauseContext) {
	localctx = NewPartitionRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, StarRocksParserRULE_partitionRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3329)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3330)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3331)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).parName = _x
	}
	{
		p.SetState(3332)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).newParName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	QueryStatement() IQueryStatementContext
	ExplainDesc() IExplainDescContext
	AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext
	InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext
	Properties() IPropertiesContext
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	BLACKHOLE() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	AllExpressionsWithDefault() []IExpressionsWithDefaultContext
	ExpressionsWithDefault(i int) IExpressionsWithDefaultContext
	WriteBranch() IWriteBranchContext
	PartitionNames() IPartitionNamesContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSERT, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *InsertStatementContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOVERWRITE, 0)
}

func (s *InsertStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *InsertStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *InsertStatementContext) AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			len++
		}
	}

	tst := make([]IInsertLabelOrColumnAliasesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			tst[i] = t.(IInsertLabelOrColumnAliasesContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertLabelOrColumnAliasesContext)
}

func (s *InsertStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InsertStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILES, 0)
}

func (s *InsertStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *InsertStatementContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKHOLE, 0)
}

func (s *InsertStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *InsertStatementContext) AllExpressionsWithDefault() []IExpressionsWithDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultContext); ok {
			tst[i] = t.(IExpressionsWithDefaultContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) ExpressionsWithDefault(i int) IExpressionsWithDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultContext)
}

func (s *InsertStatementContext) WriteBranch() IWriteBranchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteBranchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteBranchContext)
}

func (s *InsertStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, StarRocksParserRULE_insertStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3334)
			p.ExplainDesc()
		}

	}
	{
		p.SetState(3337)
		p.Match(StarRocksParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3338)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserINTO || _la == StarRocksParserOVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3339)
			p.QualifiedName()
		}
		p.SetState(3341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR || _la == StarRocksParserVERSION {
			{
				p.SetState(3340)
				p.WriteBranch()
			}

		}
		p.SetState(3344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3343)
				p.PartitionNames()
			}

		}

	case 2:
		{
			p.SetState(3346)
			p.Match(StarRocksParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3347)
			p.PropertyList()
		}

	case 3:
		{
			p.SetState(3348)
			p.Match(StarRocksParserBLACKHOLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3349)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3350)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3353)
				p.InsertLabelOrColumnAliases()
			}

		}
		p.SetState(3358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3359)
			p.Properties()
		}

	}
	p.SetState(3372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserEXPLAIN, StarRocksParserSELECT, StarRocksParserTRACE, StarRocksParserWITH:
		{
			p.SetState(3362)
			p.QueryStatement()
		}

	case StarRocksParserVALUES:
		{
			p.SetState(3363)
			p.Match(StarRocksParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3364)
			p.ExpressionsWithDefault()
		}
		p.SetState(3369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3365)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3366)
				p.ExpressionsWithDefault()
			}

			p.SetState(3371)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertLabelOrColumnAliasesContext is an interface to support dynamic dispatch.
type IInsertLabelOrColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	ColumnAliasesOrByName() IColumnAliasesOrByNameContext
	WITH() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsInsertLabelOrColumnAliasesContext differentiates from other interfaces.
	IsInsertLabelOrColumnAliasesContext()
}

type InsertLabelOrColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	label  IIdentifierContext
}

func NewEmptyInsertLabelOrColumnAliasesContext() *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertLabelOrColumnAliases
	return p
}

func InitEmptyInsertLabelOrColumnAliasesContext(p *InsertLabelOrColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertLabelOrColumnAliases
}

func (*InsertLabelOrColumnAliasesContext) IsInsertLabelOrColumnAliasesContext() {}

func NewInsertLabelOrColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_insertLabelOrColumnAliases

	return p
}

func (s *InsertLabelOrColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertLabelOrColumnAliasesContext) GetLabel() IIdentifierContext { return s.label }

func (s *InsertLabelOrColumnAliasesContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *InsertLabelOrColumnAliasesContext) ColumnAliasesOrByName() IColumnAliasesOrByNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesOrByNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesOrByNameContext)
}

func (s *InsertLabelOrColumnAliasesContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *InsertLabelOrColumnAliasesContext) LABEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLABEL, 0)
}

func (s *InsertLabelOrColumnAliasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertLabelOrColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertLabelOrColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertLabelOrColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInsertLabelOrColumnAliases(s)
	}
}

func (s *InsertLabelOrColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInsertLabelOrColumnAliases(s)
	}
}

func (s *InsertLabelOrColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInsertLabelOrColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) InsertLabelOrColumnAliases() (localctx IInsertLabelOrColumnAliasesContext) {
	localctx = NewInsertLabelOrColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, StarRocksParserRULE_insertLabelOrColumnAliases)
	p.SetState(3378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserBY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3374)
			p.ColumnAliasesOrByName()
		}

	case StarRocksParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3375)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3376)
			p.Match(StarRocksParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3377)

			var _x = p.Identifier()

			localctx.(*InsertLabelOrColumnAliasesContext).label = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesOrByNameContext is an interface to support dynamic dispatch.
type IColumnAliasesOrByNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnAliases() IColumnAliasesContext
	BY() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsColumnAliasesOrByNameContext differentiates from other interfaces.
	IsColumnAliasesOrByNameContext()
}

type ColumnAliasesOrByNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesOrByNameContext() *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliasesOrByName
	return p
}

func InitEmptyColumnAliasesOrByNameContext(p *ColumnAliasesOrByNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliasesOrByName
}

func (*ColumnAliasesOrByNameContext) IsColumnAliasesOrByNameContext() {}

func NewColumnAliasesOrByNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnAliasesOrByName

	return p
}

func (s *ColumnAliasesOrByNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesOrByNameContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ColumnAliasesOrByNameContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ColumnAliasesOrByNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAME, 0)
}

func (s *ColumnAliasesOrByNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesOrByNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesOrByNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnAliasesOrByName(s)
	}
}

func (s *ColumnAliasesOrByNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnAliasesOrByName(s)
	}
}

func (s *ColumnAliasesOrByNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnAliasesOrByName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnAliasesOrByName() (localctx IColumnAliasesOrByNameContext) {
	localctx = NewColumnAliasesOrByNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, StarRocksParserRULE_columnAliasesOrByName)
	p.SetState(3383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3380)
			p.ColumnAliases()
		}

	case StarRocksParserBY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3381)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3382)
			p.Match(StarRocksParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	SET() antlr.TerminalNode
	AssignmentList() IAssignmentListContext
	FromClause() IFromClauseContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *UpdateStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUPDATE, 0)
}

func (s *UpdateStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *UpdateStatementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *UpdateStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *UpdateStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *UpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *UpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, StarRocksParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3385)
			p.ExplainDesc()
		}

	}
	p.SetState(3389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3388)
			p.WithClause()
		}

	}
	{
		p.SetState(3391)
		p.Match(StarRocksParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3392)
		p.QualifiedName()
	}
	{
		p.SetState(3393)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3394)
		p.AssignmentList()
	}
	{
		p.SetState(3395)
		p.FromClause()
	}
	p.SetState(3398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3396)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3397)

			var _x = p.expression(0)

			localctx.(*UpdateStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUsing returns the using rule contexts.
	GetUsing() IRelationsContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetUsing sets the using rule contexts.
	SetUsing(IRelationsContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	PartitionNames() IPartitionNamesContext
	USING() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Relations() IRelationsContext
	Expression() IExpressionContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	using  IRelationsContext
	where  IExpressionContext
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) GetUsing() IRelationsContext { return s.using }

func (s *DeleteStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DeleteStatementContext) SetUsing(v IRelationsContext) { s.using = v }

func (s *DeleteStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *DeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *DeleteStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *DeleteStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *DeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DeleteStatementContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, StarRocksParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0 {
		{
			p.SetState(3400)
			p.ExplainDesc()
		}

	}
	p.SetState(3404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3403)
			p.WithClause()
		}

	}
	{
		p.SetState(3406)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3407)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3408)
		p.QualifiedName()
	}
	p.SetState(3410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(3409)
			p.PartitionNames()
		}

	}
	p.SetState(3414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(3412)
			p.Match(StarRocksParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3413)

			var _x = p.Relations()

			localctx.(*DeleteStatementContext).using = _x
		}

	}
	p.SetState(3418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3416)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3417)

			var _x = p.expression(0)

			localctx.(*DeleteStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type ICreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSourceProperties() IDataSourcePropertiesContext

	// IsCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsCreateRoutineLoadStatementContext()
}

type CreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
	table  IQualifiedNameContext
	source IIdentifierContext
}

func NewEmptyCreateRoutineLoadStatementContext() *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoutineLoadStatement
	return p
}

func InitEmptyCreateRoutineLoadStatementContext(p *CreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoutineLoadStatement
}

func (*CreateRoutineLoadStatementContext) IsCreateRoutineLoadStatementContext() {}

func NewCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createRoutineLoadStatement

	return p
}

func (s *CreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *CreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoutineLoadStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *CreateRoutineLoadStatementContext) GetSource() IIdentifierContext { return s.source }

func (s *CreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *CreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoutineLoadStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *CreateRoutineLoadStatementContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *CreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *CreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *CreateRoutineLoadStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CreateRoutineLoadStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateRoutineLoadStatement(s)
	}
}

func (s *CreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateRoutineLoadStatement(s)
	}
}

func (s *CreateRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateRoutineLoadStatement() (localctx ICreateRoutineLoadStatementContext) {
	localctx = NewCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, StarRocksParserRULE_createRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3420)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3421)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3422)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3426)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3423)

			var _x = p.QualifiedName()

			localctx.(*CreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3424)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3428)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).name = _x
	}
	{
		p.SetState(3429)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3430)

		var _x = p.QualifiedName()

		localctx.(*CreateRoutineLoadStatementContext).table = _x
	}
	p.SetState(3439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOLUMNS || _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserROWS || _la == StarRocksParserTEMPORARY || _la == StarRocksParserWHERE {
		{
			p.SetState(3431)
			p.LoadProperties()
		}
		p.SetState(3436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3432)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3433)
				p.LoadProperties()
			}

			p.SetState(3438)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3441)
			p.JobProperties()
		}

	}
	{
		p.SetState(3444)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3445)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).source = _x
	}
	p.SetState(3447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(3446)
			p.DataSourceProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IAlterRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSource() IDataSourceContext
	QualifiedName() IQualifiedNameContext

	// IsAlterRoutineLoadStatementContext differentiates from other interfaces.
	IsAlterRoutineLoadStatementContext()
}

type AlterRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterRoutineLoadStatementContext() *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoutineLoadStatement
	return p
}

func InitEmptyAlterRoutineLoadStatementContext(p *AlterRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoutineLoadStatement
}

func (*AlterRoutineLoadStatementContext) IsAlterRoutineLoadStatementContext() {}

func NewAlterRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterRoutineLoadStatement

	return p
}

func (s *AlterRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *AlterRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *AlterRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *AlterRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AlterRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) DataSource() IDataSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourceContext)
}

func (s *AlterRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterRoutineLoadStatement(s)
	}
}

func (s *AlterRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterRoutineLoadStatement(s)
	}
}

func (s *AlterRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterRoutineLoadStatement() (localctx IAlterRoutineLoadStatementContext) {
	localctx = NewAlterRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, StarRocksParserRULE_alterRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3449)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3450)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3451)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3452)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3456)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3453)

			var _x = p.QualifiedName()

			localctx.(*AlterRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3454)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3458)

		var _x = p.Identifier()

		localctx.(*AlterRoutineLoadStatementContext).name = _x
	}
	p.SetState(3467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOLUMNS || _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserROWS || _la == StarRocksParserTEMPORARY || _la == StarRocksParserWHERE {
		{
			p.SetState(3459)
			p.LoadProperties()
		}
		p.SetState(3464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3460)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3461)
				p.LoadProperties()
			}

			p.SetState(3466)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3469)
			p.JobProperties()
		}

	}
	p.SetState(3473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3472)
			p.DataSource()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourceContext is an interface to support dynamic dispatch.
type IDataSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	DataSourceProperties() IDataSourcePropertiesContext
	Identifier() IIdentifierContext

	// IsDataSourceContext differentiates from other interfaces.
	IsDataSourceContext()
}

type DataSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	source IIdentifierContext
}

func NewEmptyDataSourceContext() *DataSourceContext {
	var p = new(DataSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSource
	return p
}

func InitEmptyDataSourceContext(p *DataSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSource
}

func (*DataSourceContext) IsDataSourceContext() {}

func NewDataSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourceContext {
	var p = new(DataSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataSource

	return p
}

func (s *DataSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourceContext) GetSource() IIdentifierContext { return s.source }

func (s *DataSourceContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *DataSourceContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DataSourceContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *DataSourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataSource(s)
	}
}

func (s *DataSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataSource(s)
	}
}

func (s *DataSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDataSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DataSource() (localctx IDataSourceContext) {
	localctx = NewDataSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, StarRocksParserRULE_dataSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3475)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3476)

		var _x = p.Identifier()

		localctx.(*DataSourceContext).source = _x
	}
	{
		p.SetState(3477)
		p.DataSourceProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadPropertiesContext is an interface to support dynamic dispatch.
type ILoadPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColSeparatorProperty() IColSeparatorPropertyContext
	RowDelimiterProperty() IRowDelimiterPropertyContext
	ImportColumns() IImportColumnsContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	PartitionNames() IPartitionNamesContext

	// IsLoadPropertiesContext differentiates from other interfaces.
	IsLoadPropertiesContext()
}

type LoadPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadPropertiesContext() *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadProperties
	return p
}

func InitEmptyLoadPropertiesContext(p *LoadPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadProperties
}

func (*LoadPropertiesContext) IsLoadPropertiesContext() {}

func NewLoadPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_loadProperties

	return p
}

func (s *LoadPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadPropertiesContext) ColSeparatorProperty() IColSeparatorPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColSeparatorPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColSeparatorPropertyContext)
}

func (s *LoadPropertiesContext) RowDelimiterProperty() IRowDelimiterPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowDelimiterPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowDelimiterPropertyContext)
}

func (s *LoadPropertiesContext) ImportColumns() IImportColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnsContext)
}

func (s *LoadPropertiesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *LoadPropertiesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LoadPropertiesContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *LoadPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLoadProperties(s)
	}
}

func (s *LoadPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLoadProperties(s)
	}
}

func (s *LoadPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLoadProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LoadProperties() (localctx ILoadPropertiesContext) {
	localctx = NewLoadPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, StarRocksParserRULE_loadProperties)
	p.SetState(3485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3479)
			p.ColSeparatorProperty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3480)
			p.RowDelimiterProperty()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3481)
			p.ImportColumns()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3482)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3483)
			p.expression(0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3484)
			p.PartitionNames()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColSeparatorPropertyContext is an interface to support dynamic dispatch.
type IColSeparatorPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsColSeparatorPropertyContext differentiates from other interfaces.
	IsColSeparatorPropertyContext()
}

type ColSeparatorPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColSeparatorPropertyContext() *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_colSeparatorProperty
	return p
}

func InitEmptyColSeparatorPropertyContext(p *ColSeparatorPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_colSeparatorProperty
}

func (*ColSeparatorPropertyContext) IsColSeparatorPropertyContext() {}

func NewColSeparatorPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_colSeparatorProperty

	return p
}

func (s *ColSeparatorPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *ColSeparatorPropertyContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ColSeparatorPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTERMINATED, 0)
}

func (s *ColSeparatorPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ColSeparatorPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ColSeparatorPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColSeparatorPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColSeparatorPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColSeparatorProperty(s)
	}
}

func (s *ColSeparatorPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColSeparatorProperty(s)
	}
}

func (s *ColSeparatorPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColSeparatorProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColSeparatorProperty() (localctx IColSeparatorPropertyContext) {
	localctx = NewColSeparatorPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, StarRocksParserRULE_colSeparatorProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3487)
		p.Match(StarRocksParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3488)
		p.Match(StarRocksParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3489)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3490)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowDelimiterPropertyContext is an interface to support dynamic dispatch.
type IRowDelimiterPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsRowDelimiterPropertyContext differentiates from other interfaces.
	IsRowDelimiterPropertyContext()
}

type RowDelimiterPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowDelimiterPropertyContext() *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowDelimiterProperty
	return p
}

func InitEmptyRowDelimiterPropertyContext(p *RowDelimiterPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowDelimiterProperty
}

func (*RowDelimiterPropertyContext) IsRowDelimiterPropertyContext() {}

func NewRowDelimiterPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rowDelimiterProperty

	return p
}

func (s *RowDelimiterPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *RowDelimiterPropertyContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROWS, 0)
}

func (s *RowDelimiterPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTERMINATED, 0)
}

func (s *RowDelimiterPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *RowDelimiterPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RowDelimiterPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowDelimiterPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowDelimiterPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRowDelimiterProperty(s)
	}
}

func (s *RowDelimiterPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRowDelimiterProperty(s)
	}
}

func (s *RowDelimiterPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRowDelimiterProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RowDelimiterProperty() (localctx IRowDelimiterPropertyContext) {
	localctx = NewRowDelimiterPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, StarRocksParserRULE_rowDelimiterProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3492)
		p.Match(StarRocksParserROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3493)
		p.Match(StarRocksParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3494)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3495)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnsContext is an interface to support dynamic dispatch.
type IImportColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	ColumnProperties() IColumnPropertiesContext

	// IsImportColumnsContext differentiates from other interfaces.
	IsImportColumnsContext()
}

type ImportColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportColumnsContext() *ImportColumnsContext {
	var p = new(ImportColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_importColumns
	return p
}

func InitEmptyImportColumnsContext(p *ImportColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_importColumns
}

func (*ImportColumnsContext) IsImportColumnsContext() {}

func NewImportColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnsContext {
	var p = new(ImportColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_importColumns

	return p
}

func (s *ImportColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ImportColumnsContext) ColumnProperties() IColumnPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPropertiesContext)
}

func (s *ImportColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterImportColumns(s)
	}
}

func (s *ImportColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitImportColumns(s)
	}
}

func (s *ImportColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitImportColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ImportColumns() (localctx IImportColumnsContext) {
	localctx = NewImportColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, StarRocksParserRULE_importColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3497)
		p.Match(StarRocksParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3498)
		p.ColumnProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPropertiesContext is an interface to support dynamic dispatch.
type IColumnPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsColumnPropertiesContext differentiates from other interfaces.
	IsColumnPropertiesContext()
}

type ColumnPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnPropertiesContext() *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnProperties
	return p
}

func InitEmptyColumnPropertiesContext(p *ColumnPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnProperties
}

func (*ColumnPropertiesContext) IsColumnPropertiesContext() {}

func NewColumnPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnProperties

	return p
}

func (s *ColumnPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPropertiesContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ColumnPropertiesContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *ColumnPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnProperties(s)
	}
}

func (s *ColumnPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnProperties(s)
	}
}

func (s *ColumnPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnProperties() (localctx IColumnPropertiesContext) {
	localctx = NewColumnPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, StarRocksParserRULE_columnProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3500)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3501)
			p.QualifiedName()
		}

	case 2:
		{
			p.SetState(3502)
			p.Assignment()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3505)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3506)
				p.QualifiedName()
			}

		case 2:
			{
				p.SetState(3507)
				p.Assignment()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(3514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3515)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJobPropertiesContext is an interface to support dynamic dispatch.
type IJobPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext

	// IsJobPropertiesContext differentiates from other interfaces.
	IsJobPropertiesContext()
}

type JobPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJobPropertiesContext() *JobPropertiesContext {
	var p = new(JobPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_jobProperties
	return p
}

func InitEmptyJobPropertiesContext(p *JobPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_jobProperties
}

func (*JobPropertiesContext) IsJobPropertiesContext() {}

func NewJobPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JobPropertiesContext {
	var p = new(JobPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_jobProperties

	return p
}

func (s *JobPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *JobPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *JobPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JobPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JobPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterJobProperties(s)
	}
}

func (s *JobPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitJobProperties(s)
	}
}

func (s *JobPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitJobProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) JobProperties() (localctx IJobPropertiesContext) {
	localctx = NewJobPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, StarRocksParserRULE_jobProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3517)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourcePropertiesContext is an interface to support dynamic dispatch.
type IDataSourcePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyList() IPropertyListContext

	// IsDataSourcePropertiesContext differentiates from other interfaces.
	IsDataSourcePropertiesContext()
}

type DataSourcePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSourcePropertiesContext() *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSourceProperties
	return p
}

func InitEmptyDataSourcePropertiesContext(p *DataSourcePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSourceProperties
}

func (*DataSourcePropertiesContext) IsDataSourcePropertiesContext() {}

func NewDataSourcePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataSourceProperties

	return p
}

func (s *DataSourcePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourcePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DataSourcePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourcePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourcePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataSourceProperties(s)
	}
}

func (s *DataSourcePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataSourceProperties(s)
	}
}

func (s *DataSourcePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDataSourceProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DataSourceProperties() (localctx IDataSourcePropertiesContext) {
	localctx = NewDataSourcePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, StarRocksParserRULE_dataSourceProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3519)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IStopRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	STOP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsStopRoutineLoadStatementContext differentiates from other interfaces.
	IsStopRoutineLoadStatementContext()
}

type StopRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyStopRoutineLoadStatementContext() *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stopRoutineLoadStatement
	return p
}

func InitEmptyStopRoutineLoadStatementContext(p *StopRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stopRoutineLoadStatement
}

func (*StopRoutineLoadStatementContext) IsStopRoutineLoadStatementContext() {}

func NewStopRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_stopRoutineLoadStatement

	return p
}

func (s *StopRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StopRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *StopRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *StopRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *StopRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *StopRoutineLoadStatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTOP, 0)
}

func (s *StopRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *StopRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *StopRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *StopRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StopRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StopRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStopRoutineLoadStatement(s)
	}
}

func (s *StopRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStopRoutineLoadStatement(s)
	}
}

func (s *StopRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitStopRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) StopRoutineLoadStatement() (localctx IStopRoutineLoadStatementContext) {
	localctx = NewStopRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, StarRocksParserRULE_stopRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3521)
		p.Match(StarRocksParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3522)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3523)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3524)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3525)

			var _x = p.QualifiedName()

			localctx.(*StopRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3526)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3530)

		var _x = p.Identifier()

		localctx.(*StopRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IResumeRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	RESUME() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsResumeRoutineLoadStatementContext differentiates from other interfaces.
	IsResumeRoutineLoadStatementContext()
}

type ResumeRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyResumeRoutineLoadStatementContext() *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeRoutineLoadStatement
	return p
}

func InitEmptyResumeRoutineLoadStatementContext(p *ResumeRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeRoutineLoadStatement
}

func (*ResumeRoutineLoadStatementContext) IsResumeRoutineLoadStatementContext() {}

func NewResumeRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_resumeRoutineLoadStatement

	return p
}

func (s *ResumeRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ResumeRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ResumeRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ResumeRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ResumeRoutineLoadStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *ResumeRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ResumeRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ResumeRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ResumeRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResumeRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterResumeRoutineLoadStatement(s)
	}
}

func (s *ResumeRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitResumeRoutineLoadStatement(s)
	}
}

func (s *ResumeRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitResumeRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ResumeRoutineLoadStatement() (localctx IResumeRoutineLoadStatementContext) {
	localctx = NewResumeRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, StarRocksParserRULE_resumeRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3532)
		p.Match(StarRocksParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3533)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3534)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3535)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3539)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3536)

			var _x = p.QualifiedName()

			localctx.(*ResumeRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3537)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3541)

		var _x = p.Identifier()

		localctx.(*ResumeRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPauseRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IPauseRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	PAUSE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsPauseRoutineLoadStatementContext differentiates from other interfaces.
	IsPauseRoutineLoadStatementContext()
}

type PauseRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyPauseRoutineLoadStatementContext() *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pauseRoutineLoadStatement
	return p
}

func InitEmptyPauseRoutineLoadStatementContext(p *PauseRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pauseRoutineLoadStatement
}

func (*PauseRoutineLoadStatementContext) IsPauseRoutineLoadStatementContext() {}

func NewPauseRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pauseRoutineLoadStatement

	return p
}

func (s *PauseRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PauseRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *PauseRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *PauseRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *PauseRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PauseRoutineLoadStatementContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPAUSE, 0)
}

func (s *PauseRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *PauseRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *PauseRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *PauseRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PauseRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PauseRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PauseRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPauseRoutineLoadStatement(s)
	}
}

func (s *PauseRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPauseRoutineLoadStatement(s)
	}
}

func (s *PauseRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPauseRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PauseRoutineLoadStatement() (localctx IPauseRoutineLoadStatementContext) {
	localctx = NewPauseRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, StarRocksParserRULE_pauseRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3543)
		p.Match(StarRocksParserPAUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3544)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3545)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3546)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3550)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3547)

			var _x = p.QualifiedName()

			localctx.(*PauseRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3548)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3552)

		var _x = p.Identifier()

		localctx.(*PauseRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowRoutineLoadStatementContext differentiates from other interfaces.
	IsShowRoutineLoadStatementContext()
}

type ShowRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowRoutineLoadStatementContext() *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadStatement
	return p
}

func InitEmptyShowRoutineLoadStatementContext(p *ShowRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadStatement
}

func (*ShowRoutineLoadStatementContext) IsShowRoutineLoadStatementContext() {}

func NewShowRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadStatement

	return p
}

func (s *ShowRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ShowRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowRoutineLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowRoutineLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowRoutineLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowRoutineLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowRoutineLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowRoutineLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRoutineLoadStatement(s)
	}
}

func (s *ShowRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRoutineLoadStatement(s)
	}
}

func (s *ShowRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowRoutineLoadStatement() (localctx IShowRoutineLoadStatementContext) {
	localctx = NewShowRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, StarRocksParserRULE_showRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3554)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL {
		{
			p.SetState(3555)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3558)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3559)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(3560)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3564)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3561)

				var _x = p.QualifiedName()

				localctx.(*ShowRoutineLoadStatementContext).db = _x
			}
			{
				p.SetState(3562)
				p.Match(StarRocksParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3566)

			var _x = p.Identifier()

			localctx.(*ShowRoutineLoadStatementContext).name = _x
		}

	}
	p.SetState(3571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3569)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3570)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadStatementContext).db = _x
		}

	}
	p.SetState(3575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3573)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3574)
			p.expression(0)
		}

	}
	p.SetState(3587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3577)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3578)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3579)
			p.SortItem()
		}
		p.SetState(3584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3580)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3581)
				p.SortItem()
			}

			p.SetState(3586)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3589)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadTaskStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	TASK() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowRoutineLoadTaskStatementContext differentiates from other interfaces.
	IsShowRoutineLoadTaskStatementContext()
}

type ShowRoutineLoadTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowRoutineLoadTaskStatementContext() *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadTaskStatement
	return p
}

func InitEmptyShowRoutineLoadTaskStatementContext(p *ShowRoutineLoadTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadTaskStatement
}

func (*ShowRoutineLoadTaskStatementContext) IsShowRoutineLoadTaskStatementContext() {}

func NewShowRoutineLoadTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadTaskStatement

	return p
}

func (s *ShowRoutineLoadTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadTaskStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadTaskStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadTaskStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadTaskStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRoutineLoadTaskStatement(s)
	}
}

func (s *ShowRoutineLoadTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRoutineLoadTaskStatement(s)
	}
}

func (s *ShowRoutineLoadTaskStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowRoutineLoadTaskStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowRoutineLoadTaskStatement() (localctx IShowRoutineLoadTaskStatementContext) {
	localctx = NewShowRoutineLoadTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, StarRocksParserRULE_showRoutineLoadTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3592)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3593)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3594)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3595)
		p.Match(StarRocksParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3596)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3597)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadTaskStatementContext).db = _x
		}

	}
	{
		p.SetState(3600)
		p.Match(StarRocksParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3601)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowCreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsShowCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsShowCreateRoutineLoadStatementContext()
}

type ShowCreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowCreateRoutineLoadStatementContext() *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateRoutineLoadStatement
	return p
}

func InitEmptyShowCreateRoutineLoadStatementContext(p *ShowCreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateRoutineLoadStatement
}

func (*ShowCreateRoutineLoadStatementContext) IsShowCreateRoutineLoadStatementContext() {}

func NewShowCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateRoutineLoadStatement

	return p
}

func (s *ShowCreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowCreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowCreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCreateRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateRoutineLoadStatement(s)
	}
}

func (s *ShowCreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateRoutineLoadStatement(s)
	}
}

func (s *ShowCreateRoutineLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCreateRoutineLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCreateRoutineLoadStatement() (localctx IShowCreateRoutineLoadStatementContext) {
	localctx = NewShowCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, StarRocksParserRULE_showCreateRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3603)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3604)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3605)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3606)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3610)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3607)

			var _x = p.QualifiedName()

			localctx.(*ShowCreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3608)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3612)

		var _x = p.Identifier()

		localctx.(*ShowCreateRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStreamLoadStatementContext is an interface to support dynamic dispatch.
type IShowStreamLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowStreamLoadStatementContext differentiates from other interfaces.
	IsShowStreamLoadStatementContext()
}

type ShowStreamLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowStreamLoadStatementContext() *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStreamLoadStatement
	return p
}

func InitEmptyShowStreamLoadStatementContext(p *ShowStreamLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStreamLoadStatement
}

func (*ShowStreamLoadStatementContext) IsShowStreamLoadStatementContext() {}

func NewShowStreamLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStreamLoadStatement

	return p
}

func (s *ShowStreamLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStreamLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowStreamLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowStreamLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowStreamLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowStreamLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStreamLoadStatementContext) STREAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTREAM, 0)
}

func (s *ShowStreamLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowStreamLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowStreamLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowStreamLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowStreamLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowStreamLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStreamLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowStreamLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowStreamLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStreamLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStreamLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowStreamLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStreamLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStreamLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStreamLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStreamLoadStatement(s)
	}
}

func (s *ShowStreamLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStreamLoadStatement(s)
	}
}

func (s *ShowStreamLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowStreamLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowStreamLoadStatement() (localctx IShowStreamLoadStatementContext) {
	localctx = NewShowStreamLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, StarRocksParserRULE_showStreamLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3614)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL {
		{
			p.SetState(3615)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3618)
		p.Match(StarRocksParserSTREAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3619)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(3620)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3624)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3621)

				var _x = p.QualifiedName()

				localctx.(*ShowStreamLoadStatementContext).db = _x
			}
			{
				p.SetState(3622)
				p.Match(StarRocksParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3626)

			var _x = p.Identifier()

			localctx.(*ShowStreamLoadStatementContext).name = _x
		}

	}
	p.SetState(3631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3629)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3630)

			var _x = p.QualifiedName()

			localctx.(*ShowStreamLoadStatementContext).db = _x
		}

	}
	p.SetState(3635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3633)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3634)
			p.expression(0)
		}

	}
	p.SetState(3647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3637)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3638)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3639)
			p.SortItem()
		}
		p.SetState(3644)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3640)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3641)
				p.SortItem()
			}

			p.SetState(3646)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3649)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeStatementContext is an interface to support dynamic dispatch.
type IAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	PartitionNames() IPartitionNamesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeStatementContext differentiates from other interfaces.
	IsAnalyzeStatementContext()
}

type AnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeStatementContext() *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeStatement
	return p
}

func InitEmptyAnalyzeStatementContext(p *AnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeStatement
}

func (*AnalyzeStatementContext) IsAnalyzeStatementContext() {}

func NewAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeStatement

	return p
}

func (s *AnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *AnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AnalyzeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AnalyzeStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *AnalyzeStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AnalyzeStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AnalyzeStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *AnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *AnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *AnalyzeStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *AnalyzeStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *AnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AnalyzeStatement() (localctx IAnalyzeStatementContext) {
	localctx = NewAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, StarRocksParserRULE_analyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3652)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
		{
			p.SetState(3653)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3656)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3657)
		p.TableName()
	}
	p.SetState(3659)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3658)
			p.AnalyzeColumnClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(3661)
			p.PartitionNames()
		}

	}
	p.SetState(3667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3664)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3665)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3666)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3669)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeColumnClauseContext is an interface to support dynamic dispatch.
type IAnalyzeColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnalyzeColumnClauseContext differentiates from other interfaces.
	IsAnalyzeColumnClauseContext()
}

type AnalyzeColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeColumnClauseContext() *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeColumnClause
	return p
}

func InitEmptyAnalyzeColumnClauseContext(p *AnalyzeColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeColumnClause
}

func (*AnalyzeColumnClauseContext) IsAnalyzeColumnClauseContext() {}

func NewAnalyzeColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeColumnClause

	return p
}

func (s *AnalyzeColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeColumnClauseContext) CopyAll(ctx *AnalyzeColumnClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AnalyzeColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PredicateColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewPredicateColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateColumnsContext {
	var p = new(PredicateColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *PredicateColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateColumnsContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREDICATE, 0)
}

func (s *PredicateColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *PredicateColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPredicateColumns(s)
	}
}

func (s *PredicateColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPredicateColumns(s)
	}
}

func (s *PredicateColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPredicateColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type RegularColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewRegularColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularColumnsContext {
	var p = new(RegularColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *RegularColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularColumnsContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RegularColumnsContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RegularColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRegularColumns(s)
	}
}

func (s *RegularColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRegularColumns(s)
	}
}

func (s *RegularColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRegularColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type AllColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewAllColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AllColumnsContext {
	var p = new(AllColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *AllColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllColumnsContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AllColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *AllColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAllColumns(s)
	}
}

func (s *AllColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAllColumns(s)
	}
}

func (s *AllColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAllColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiColumnSetContext struct {
	AnalyzeColumnClauseContext
}

func NewMultiColumnSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiColumnSetContext {
	var p = new(MultiColumnSetContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *MultiColumnSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiColumnSetContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *MultiColumnSetContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *MultiColumnSetContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *MultiColumnSetContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *MultiColumnSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiColumnSet(s)
	}
}

func (s *MultiColumnSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiColumnSet(s)
	}
}

func (s *MultiColumnSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMultiColumnSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AnalyzeColumnClause() (localctx IAnalyzeColumnClauseContext) {
	localctx = NewAnalyzeColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, StarRocksParserRULE_analyzeColumnClause)
	var _la int

	p.SetState(3708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3672)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3673)
			p.QualifiedName()
		}
		p.SetState(3678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3674)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3675)
				p.QualifiedName()
			}

			p.SetState(3680)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3681)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3683)
			p.QualifiedName()
		}
		p.SetState(3688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3684)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3685)
				p.QualifiedName()
			}

			p.SetState(3690)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewAllColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3691)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3692)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewPredicateColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3693)
			p.Match(StarRocksParserPREDICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3694)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewMultiColumnSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3695)
			p.Match(StarRocksParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3696)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3697)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3698)
			p.QualifiedName()
		}
		p.SetState(3703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3699)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3700)
				p.QualifiedName()
			}

			p.SetState(3705)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3706)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStatsStatementContext is an interface to support dynamic dispatch.
type IDropStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	STATS() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsDropStatsStatementContext differentiates from other interfaces.
	IsDropStatsStatementContext()
}

type DropStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStatsStatementContext() *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStatsStatement
	return p
}

func InitEmptyDropStatsStatementContext(p *DropStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStatsStatement
}

func (*DropStatsStatementContext) IsDropStatsStatementContext() {}

func NewDropStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropStatsStatement

	return p
}

func (s *DropStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStatsStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropStatsStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATS, 0)
}

func (s *DropStatsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropStatsStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *DropStatsStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *DropStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStatsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropStatsStatement(s)
	}
}

func (s *DropStatsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropStatsStatement(s)
	}
}

func (s *DropStatsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropStatsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropStatsStatement() (localctx IDropStatsStatementContext) {
	localctx = NewDropStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, StarRocksParserRULE_dropStatsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3710)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserMULTIPLE {
		{
			p.SetState(3711)
			p.Match(StarRocksParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3712)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3715)
		p.Match(StarRocksParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3716)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHistogramStatementContext is an interface to support dynamic dispatch.
type IHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBucket returns the bucket token.
	GetBucket() antlr.Token

	// SetBucket sets the bucket token.
	SetBucket(antlr.Token)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	UPDATE() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	WITH() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	Properties() IPropertiesContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsHistogramStatementContext differentiates from other interfaces.
	IsHistogramStatementContext()
}

type HistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	bucket antlr.Token
}

func NewEmptyHistogramStatementContext() *HistogramStatementContext {
	var p = new(HistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_histogramStatement
	return p
}

func InitEmptyHistogramStatementContext(p *HistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_histogramStatement
}

func (*HistogramStatementContext) IsHistogramStatementContext() {}

func NewHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistogramStatementContext {
	var p = new(HistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_histogramStatement

	return p
}

func (s *HistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HistogramStatementContext) GetBucket() antlr.Token { return s.bucket }

func (s *HistogramStatementContext) SetBucket(v antlr.Token) { s.bucket = v }

func (s *HistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *HistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *HistogramStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HistogramStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUPDATE, 0)
}

func (s *HistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *HistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *HistogramStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *HistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *HistogramStatementContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *HistogramStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *HistogramStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *HistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterHistogramStatement(s)
	}
}

func (s *HistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitHistogramStatement(s)
	}
}

func (s *HistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) HistogramStatement() (localctx IHistogramStatementContext) {
	localctx = NewHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, StarRocksParserRULE_histogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3718)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3719)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3720)
		p.TableName()
	}
	{
		p.SetState(3721)
		p.Match(StarRocksParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3722)
		p.Match(StarRocksParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3723)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3724)
		p.AnalyzeColumnClause()
	}
	p.SetState(3728)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3725)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3726)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*HistogramStatementContext).bucket = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3727)
			p.Match(StarRocksParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3730)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeHistogramStatementContext is an interface to support dynamic dispatch.
type IAnalyzeHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HistogramStatement() IHistogramStatementContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeHistogramStatementContext differentiates from other interfaces.
	IsAnalyzeHistogramStatementContext()
}

type AnalyzeHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeHistogramStatementContext() *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeHistogramStatement
	return p
}

func InitEmptyAnalyzeHistogramStatementContext(p *AnalyzeHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeHistogramStatement
}

func (*AnalyzeHistogramStatementContext) IsAnalyzeHistogramStatementContext() {}

func NewAnalyzeHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeHistogramStatement

	return p
}

func (s *AnalyzeHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeHistogramStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *AnalyzeHistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AnalyzeHistogramStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *AnalyzeHistogramStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAnalyzeHistogramStatement(s)
	}
}

func (s *AnalyzeHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAnalyzeHistogramStatement(s)
	}
}

func (s *AnalyzeHistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAnalyzeHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AnalyzeHistogramStatement() (localctx IAnalyzeHistogramStatementContext) {
	localctx = NewAnalyzeHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, StarRocksParserRULE_analyzeHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3733)
		p.HistogramStatement()
	}
	p.SetState(3737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3734)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3735)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3736)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropHistogramStatementContext is an interface to support dynamic dispatch.
type IDropHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	DROP() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode

	// IsDropHistogramStatementContext differentiates from other interfaces.
	IsDropHistogramStatementContext()
}

type DropHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropHistogramStatementContext() *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropHistogramStatement
	return p
}

func InitEmptyDropHistogramStatementContext(p *DropHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropHistogramStatement
}

func (*DropHistogramStatementContext) IsDropHistogramStatementContext() {}

func NewDropHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropHistogramStatement

	return p
}

func (s *DropHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropHistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *DropHistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *DropHistogramStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *DropHistogramStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropHistogramStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropHistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *DropHistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DropHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropHistogramStatement(s)
	}
}

func (s *DropHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropHistogramStatement(s)
	}
}

func (s *DropHistogramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropHistogramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropHistogramStatement() (localctx IDropHistogramStatementContext) {
	localctx = NewDropHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, StarRocksParserRULE_dropHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3739)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3740)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3741)
		p.QualifiedName()
	}
	{
		p.SetState(3742)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3743)
		p.Match(StarRocksParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3744)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3745)
		p.QualifiedName()
	}
	p.SetState(3750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3746)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3747)
			p.QualifiedName()
		}

		p.SetState(3752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateAnalyzeStatementContext is an interface to support dynamic dispatch.
type ICreateAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	HistogramStatement() IHistogramStatementContext

	// IsCreateAnalyzeStatementContext differentiates from other interfaces.
	IsCreateAnalyzeStatementContext()
}

type CreateAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
}

func NewEmptyCreateAnalyzeStatementContext() *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createAnalyzeStatement
	return p
}

func InitEmptyCreateAnalyzeStatementContext(p *CreateAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createAnalyzeStatement
}

func (*CreateAnalyzeStatementContext) IsCreateAnalyzeStatementContext() {}

func NewCreateAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createAnalyzeStatement

	return p
}

func (s *CreateAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateAnalyzeStatementContext) GetDb() IIdentifierContext { return s.db }

func (s *CreateAnalyzeStatementContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *CreateAnalyzeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *CreateAnalyzeStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *CreateAnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateAnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *CreateAnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *CreateAnalyzeStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *CreateAnalyzeStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateAnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateAnalyzeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateAnalyzeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateAnalyzeStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *CreateAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateAnalyzeStatement(s)
	}
}

func (s *CreateAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateAnalyzeStatement(s)
	}
}

func (s *CreateAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateAnalyzeStatement() (localctx ICreateAnalyzeStatementContext) {
	localctx = NewCreateAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, StarRocksParserRULE_createAnalyzeStatement)
	var _la int

	p.SetState(3797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3753)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3754)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
			{
				p.SetState(3755)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3758)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3759)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3762)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3763)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
			{
				p.SetState(3764)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3767)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3768)

			var _x = p.Identifier()

			localctx.(*CreateAnalyzeStatementContext).db = _x
		}
		p.SetState(3770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3769)
				p.Properties()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3772)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3773)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
			{
				p.SetState(3774)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3777)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3778)
			p.QualifiedName()
		}
		p.SetState(3790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(3779)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3780)
				p.QualifiedName()
			}
			p.SetState(3785)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(3781)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3782)
					p.QualifiedName()
				}

				p.SetState(3787)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3788)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3792)
				p.Properties()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3795)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3796)
			p.HistogramStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropAnalyzeJobStatementContext is an interface to support dynamic dispatch.
type IDropAnalyzeJobStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	JOB() antlr.TerminalNode

	// IsDropAnalyzeJobStatementContext differentiates from other interfaces.
	IsDropAnalyzeJobStatementContext()
}

type DropAnalyzeJobStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropAnalyzeJobStatementContext() *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropAnalyzeJobStatement
	return p
}

func InitEmptyDropAnalyzeJobStatementContext(p *DropAnalyzeJobStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropAnalyzeJobStatement
}

func (*DropAnalyzeJobStatementContext) IsDropAnalyzeJobStatementContext() {}

func NewDropAnalyzeJobStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropAnalyzeJobStatement

	return p
}

func (s *DropAnalyzeJobStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropAnalyzeJobStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropAnalyzeJobStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *DropAnalyzeJobStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DropAnalyzeJobStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *DropAnalyzeJobStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOB, 0)
}

func (s *DropAnalyzeJobStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAnalyzeJobStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropAnalyzeJobStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropAnalyzeJobStatement(s)
	}
}

func (s *DropAnalyzeJobStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropAnalyzeJobStatement(s)
	}
}

func (s *DropAnalyzeJobStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropAnalyzeJobStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropAnalyzeJobStatement() (localctx IDropAnalyzeJobStatementContext) {
	localctx = NewDropAnalyzeJobStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, StarRocksParserRULE_dropAnalyzeJobStatement)
	p.SetState(3806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3799)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3800)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3801)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3802)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3803)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3804)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3805)
			p.Match(StarRocksParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAnalyzeStatementContext is an interface to support dynamic dispatch.
type IShowAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	JOB() antlr.TerminalNode
	STATUS() antlr.TerminalNode

	// IsShowAnalyzeStatementContext differentiates from other interfaces.
	IsShowAnalyzeStatementContext()
}

type ShowAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAnalyzeStatementContext() *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAnalyzeStatement
	return p
}

func InitEmptyShowAnalyzeStatementContext(p *ShowAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAnalyzeStatement
}

func (*ShowAnalyzeStatementContext) IsShowAnalyzeStatementContext() {}

func NewShowAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAnalyzeStatement

	return p
}

func (s *ShowAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAnalyzeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *ShowAnalyzeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowAnalyzeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAnalyzeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowAnalyzeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowAnalyzeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAnalyzeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAnalyzeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAnalyzeStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOB, 0)
}

func (s *ShowAnalyzeStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAnalyzeStatement(s)
	}
}

func (s *ShowAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAnalyzeStatement(s)
	}
}

func (s *ShowAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowAnalyzeStatement() (localctx IShowAnalyzeStatementContext) {
	localctx = NewShowAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, StarRocksParserRULE_showAnalyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3808)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3809)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserJOB || _la == StarRocksParserSTATUS {
		{
			p.SetState(3810)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserJOB || _la == StarRocksParserSTATUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3813)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3814)
			p.expression(0)
		}

	}
	p.SetState(3827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3817)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3818)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3819)
			p.SortItem()
		}
		p.SetState(3824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3820)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3821)
				p.SortItem()
			}

			p.SetState(3826)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3829)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatsMetaStatementContext is an interface to support dynamic dispatch.
type IShowStatsMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATS() antlr.TerminalNode
	META() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowStatsMetaStatementContext differentiates from other interfaces.
	IsShowStatsMetaStatementContext()
}

type ShowStatsMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatsMetaStatementContext() *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatsMetaStatement
	return p
}

func InitEmptyShowStatsMetaStatementContext(p *ShowStatsMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatsMetaStatement
}

func (*ShowStatsMetaStatementContext) IsShowStatsMetaStatementContext() {}

func NewShowStatsMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStatsMetaStatement

	return p
}

func (s *ShowStatsMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatsMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStatsMetaStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATS, 0)
}

func (s *ShowStatsMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMETA, 0)
}

func (s *ShowStatsMetaStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *ShowStatsMetaStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ShowStatsMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowStatsMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatsMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowStatsMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowStatsMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStatsMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStatsMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStatsMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatsMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStatsMetaStatement(s)
	}
}

func (s *ShowStatsMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStatsMetaStatement(s)
	}
}

func (s *ShowStatsMetaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowStatsMetaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowStatsMetaStatement() (localctx IShowStatsMetaStatementContext) {
	localctx = NewShowStatsMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, StarRocksParserRULE_showStatsMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3832)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserMULTIPLE {
		{
			p.SetState(3833)
			p.Match(StarRocksParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3834)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3837)
		p.Match(StarRocksParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3838)
		p.Match(StarRocksParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3839)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3840)
			p.expression(0)
		}

	}
	p.SetState(3853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3843)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3844)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3845)
			p.SortItem()
		}
		p.SetState(3850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3846)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3847)
				p.SortItem()
			}

			p.SetState(3852)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3855)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowHistogramMetaStatementContext is an interface to support dynamic dispatch.
type IShowHistogramMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	META() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowHistogramMetaStatementContext differentiates from other interfaces.
	IsShowHistogramMetaStatementContext()
}

type ShowHistogramMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowHistogramMetaStatementContext() *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showHistogramMetaStatement
	return p
}

func InitEmptyShowHistogramMetaStatementContext(p *ShowHistogramMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showHistogramMetaStatement
}

func (*ShowHistogramMetaStatementContext) IsShowHistogramMetaStatementContext() {}

func NewShowHistogramMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showHistogramMetaStatement

	return p
}

func (s *ShowHistogramMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowHistogramMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowHistogramMetaStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *ShowHistogramMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMETA, 0)
}

func (s *ShowHistogramMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowHistogramMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowHistogramMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowHistogramMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowHistogramMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowHistogramMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowHistogramMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowHistogramMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowHistogramMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowHistogramMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowHistogramMetaStatement(s)
	}
}

func (s *ShowHistogramMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowHistogramMetaStatement(s)
	}
}

func (s *ShowHistogramMetaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowHistogramMetaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowHistogramMetaStatement() (localctx IShowHistogramMetaStatementContext) {
	localctx = NewShowHistogramMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, StarRocksParserRULE_showHistogramMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3858)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3859)
		p.Match(StarRocksParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3860)
		p.Match(StarRocksParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3861)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3862)
			p.expression(0)
		}

	}
	p.SetState(3875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3865)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3866)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3867)
			p.SortItem()
		}
		p.SetState(3872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3868)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3869)
				p.SortItem()
			}

			p.SetState(3874)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3877)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillAnalyzeStatementContext is an interface to support dynamic dispatch.
type IKillAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KILL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsKillAnalyzeStatementContext differentiates from other interfaces.
	IsKillAnalyzeStatementContext()
}

type KillAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillAnalyzeStatementContext() *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killAnalyzeStatement
	return p
}

func InitEmptyKillAnalyzeStatementContext(p *KillAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killAnalyzeStatement
}

func (*KillAnalyzeStatementContext) IsKillAnalyzeStatementContext() {}

func NewKillAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_killAnalyzeStatement

	return p
}

func (s *KillAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillAnalyzeStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKILL, 0)
}

func (s *KillAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *KillAnalyzeStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *KillAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKillAnalyzeStatement(s)
	}
}

func (s *KillAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKillAnalyzeStatement(s)
	}
}

func (s *KillAnalyzeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitKillAnalyzeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) KillAnalyzeStatement() (localctx IKillAnalyzeStatementContext) {
	localctx = NewKillAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, StarRocksParserRULE_killAnalyzeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3880)
		p.Match(StarRocksParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3881)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3882)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeProfileStatementContext is an interface to support dynamic dispatch.
type IAnalyzeProfileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	String_() IStringContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAnalyzeProfileStatementContext differentiates from other interfaces.
	IsAnalyzeProfileStatementContext()
}

type AnalyzeProfileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeProfileStatementContext() *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeProfileStatement
	return p
}

func InitEmptyAnalyzeProfileStatementContext(p *AnalyzeProfileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeProfileStatement
}

func (*AnalyzeProfileStatementContext) IsAnalyzeProfileStatementContext() {}

func NewAnalyzeProfileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeProfileStatement

	return p
}

func (s *AnalyzeProfileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeProfileStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *AnalyzeProfileStatementContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILE, 0)
}

func (s *AnalyzeProfileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *AnalyzeProfileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AnalyzeProfileStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AnalyzeProfileStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AnalyzeProfileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeProfileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeProfileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAnalyzeProfileStatement(s)
	}
}

func (s *AnalyzeProfileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAnalyzeProfileStatement(s)
	}
}

func (s *AnalyzeProfileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAnalyzeProfileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AnalyzeProfileStatement() (localctx IAnalyzeProfileStatementContext) {
	localctx = NewAnalyzeProfileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, StarRocksParserRULE_analyzeProfileStatement)
	var _la int

	p.SetState(3901)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3884)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3885)
			p.Match(StarRocksParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3886)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3887)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3888)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3889)
			p.Match(StarRocksParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3890)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3891)
			p.String_()
		}
		{
			p.SetState(3892)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3893)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3894)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3895)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3900)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateBaselinePlanStatementContext is an interface to support dynamic dispatch.
type ICreateBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	USING() antlr.TerminalNode
	AllQueryRelation() []IQueryRelationContext
	QueryRelation(i int) IQueryRelationContext
	GLOBAL() antlr.TerminalNode
	ON() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateBaselinePlanStatementContext differentiates from other interfaces.
	IsCreateBaselinePlanStatementContext()
}

type CreateBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateBaselinePlanStatementContext() *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createBaselinePlanStatement
	return p
}

func InitEmptyCreateBaselinePlanStatementContext(p *CreateBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createBaselinePlanStatement
}

func (*CreateBaselinePlanStatementContext) IsCreateBaselinePlanStatementContext() {}

func NewCreateBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createBaselinePlanStatement

	return p
}

func (s *CreateBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateBaselinePlanStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *CreateBaselinePlanStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *CreateBaselinePlanStatementContext) AllQueryRelation() []IQueryRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryRelationContext); ok {
			len++
		}
	}

	tst := make([]IQueryRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryRelationContext); ok {
			tst[i] = t.(IQueryRelationContext)
			i++
		}
	}

	return tst
}

func (s *CreateBaselinePlanStatementContext) QueryRelation(i int) IQueryRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CreateBaselinePlanStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *CreateBaselinePlanStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateBaselinePlanStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateBaselinePlanStatement(s)
	}
}

func (s *CreateBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateBaselinePlanStatement(s)
	}
}

func (s *CreateBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateBaselinePlanStatement() (localctx ICreateBaselinePlanStatementContext) {
	localctx = NewCreateBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, StarRocksParserRULE_createBaselinePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3903)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL {
		{
			p.SetState(3904)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3907)
		p.Match(StarRocksParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(3908)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3909)
			p.QueryRelation()
		}

	}
	{
		p.SetState(3912)
		p.Match(StarRocksParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3913)
		p.QueryRelation()
	}
	p.SetState(3915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3914)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IDropBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDropBaselinePlanStatementContext differentiates from other interfaces.
	IsDropBaselinePlanStatementContext()
}

type DropBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBaselinePlanStatementContext() *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBaselinePlanStatement
	return p
}

func InitEmptyDropBaselinePlanStatementContext(p *DropBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBaselinePlanStatement
}

func (*DropBaselinePlanStatementContext) IsDropBaselinePlanStatementContext() {}

func NewDropBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropBaselinePlanStatement

	return p
}

func (s *DropBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBaselinePlanStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *DropBaselinePlanStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DropBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropBaselinePlanStatement(s)
	}
}

func (s *DropBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropBaselinePlanStatement(s)
	}
}

func (s *DropBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropBaselinePlanStatement() (localctx IDropBaselinePlanStatementContext) {
	localctx = NewDropBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, StarRocksParserRULE_dropBaselinePlanStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3917)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3918)
		p.Match(StarRocksParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3919)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IShowBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BASELINE() antlr.TerminalNode

	// IsShowBaselinePlanStatementContext differentiates from other interfaces.
	IsShowBaselinePlanStatementContext()
}

type ShowBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBaselinePlanStatementContext() *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBaselinePlanStatement
	return p
}

func InitEmptyShowBaselinePlanStatementContext(p *ShowBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBaselinePlanStatement
}

func (*ShowBaselinePlanStatementContext) IsShowBaselinePlanStatementContext() {}

func NewShowBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBaselinePlanStatement

	return p
}

func (s *ShowBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBaselinePlanStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *ShowBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBaselinePlanStatement(s)
	}
}

func (s *ShowBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBaselinePlanStatement(s)
	}
}

func (s *ShowBaselinePlanStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowBaselinePlanStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowBaselinePlanStatement() (localctx IShowBaselinePlanStatementContext) {
	localctx = NewShowBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, StarRocksParserRULE_showBaselinePlanStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3921)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3922)
		p.Match(StarRocksParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceGroupStatementContext is an interface to support dynamic dispatch.
type ICreateResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext

	// IsCreateResourceGroupStatementContext differentiates from other interfaces.
	IsCreateResourceGroupStatementContext()
}

type CreateResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateResourceGroupStatementContext() *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceGroupStatement
	return p
}

func InitEmptyCreateResourceGroupStatementContext(p *CreateResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceGroupStatement
}

func (*CreateResourceGroupStatementContext) IsCreateResourceGroupStatementContext() {}

func NewCreateResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createResourceGroupStatement

	return p
}

func (s *CreateResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceGroupStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *CreateResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *CreateResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *CreateResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *CreateResourceGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateResourceGroupStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateResourceGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateResourceGroupStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateResourceGroupStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateResourceGroupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *CreateResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *CreateResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateResourceGroupStatement(s)
	}
}

func (s *CreateResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateResourceGroupStatement(s)
	}
}

func (s *CreateResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateResourceGroupStatement() (localctx ICreateResourceGroupStatementContext) {
	localctx = NewCreateResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, StarRocksParserRULE_createResourceGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3924)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3925)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3926)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(3927)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3928)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3929)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserOR {
		{
			p.SetState(3932)
			p.Match(StarRocksParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3933)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3936)
		p.Identifier()
	}
	p.SetState(3946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTO {
		{
			p.SetState(3937)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3938)
			p.Classifier()
		}
		p.SetState(3943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3939)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3940)
				p.Classifier()
			}

			p.SetState(3945)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3948)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3949)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3950)
		p.Property()
	}
	p.SetState(3955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3951)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3952)
			p.Property()
		}

		p.SetState(3957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3958)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceGroupStatementContext is an interface to support dynamic dispatch.
type IDropResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropResourceGroupStatementContext differentiates from other interfaces.
	IsDropResourceGroupStatementContext()
}

type DropResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropResourceGroupStatementContext() *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceGroupStatement
	return p
}

func InitEmptyDropResourceGroupStatementContext(p *DropResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceGroupStatement
}

func (*DropResourceGroupStatementContext) IsDropResourceGroupStatementContext() {}

func NewDropResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropResourceGroupStatement

	return p
}

func (s *DropResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *DropResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *DropResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropResourceGroupStatement(s)
	}
}

func (s *DropResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropResourceGroupStatement(s)
	}
}

func (s *DropResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropResourceGroupStatement() (localctx IDropResourceGroupStatementContext) {
	localctx = NewDropResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, StarRocksParserRULE_dropResourceGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3960)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3961)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3962)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3963)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceGroupStatementContext is an interface to support dynamic dispatch.
type IAlterResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext
	DROP() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ALL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsAlterResourceGroupStatementContext differentiates from other interfaces.
	IsAlterResourceGroupStatementContext()
}

type AlterResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterResourceGroupStatementContext() *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceGroupStatement
	return p
}

func InitEmptyAlterResourceGroupStatementContext(p *AlterResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceGroupStatement
}

func (*AlterResourceGroupStatementContext) IsAlterResourceGroupStatementContext() {}

func NewAlterResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterResourceGroupStatement

	return p
}

func (s *AlterResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *AlterResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *AlterResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterResourceGroupStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *AlterResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *AlterResourceGroupStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AlterResourceGroupStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AlterResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AlterResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AlterResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AlterResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterResourceGroupStatement(s)
	}
}

func (s *AlterResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterResourceGroupStatement(s)
	}
}

func (s *AlterResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterResourceGroupStatement() (localctx IAlterResourceGroupStatementContext) {
	localctx = NewAlterResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, StarRocksParserRULE_alterResourceGroupStatement)
	var _la int

	p.SetState(4017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 395, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3965)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3966)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3967)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3968)
			p.Identifier()
		}
		{
			p.SetState(3969)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3970)
			p.Classifier()
		}
		p.SetState(3975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3971)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3972)
				p.Classifier()
			}

			p.SetState(3977)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3978)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3979)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3980)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3981)
			p.Identifier()
		}
		{
			p.SetState(3982)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3983)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3984)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3985)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3986)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3991)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3992)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3994)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3995)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3996)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3997)
			p.Identifier()
		}
		{
			p.SetState(3998)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3999)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4001)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4002)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4003)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4004)
			p.Identifier()
		}
		{
			p.SetState(4005)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4006)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4007)
			p.Property()
		}
		p.SetState(4012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4008)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4009)
				p.Property()
			}

			p.SetState(4014)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4015)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	VERBOSE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsShowResourceGroupStatementContext differentiates from other interfaces.
	IsShowResourceGroupStatementContext()
}

type ShowResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupStatementContext() *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupStatement
	return p
}

func InitEmptyShowResourceGroupStatementContext(p *ShowResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupStatement
}

func (*ShowResourceGroupStatementContext) IsShowResourceGroupStatementContext() {}

func NewShowResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showResourceGroupStatement

	return p
}

func (s *ShowResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupStatementContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPS, 0)
}

func (s *ShowResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowResourceGroupStatement(s)
	}
}

func (s *ShowResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowResourceGroupStatement(s)
	}
}

func (s *ShowResourceGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowResourceGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowResourceGroupStatement() (localctx IShowResourceGroupStatementContext) {
	localctx = NewShowResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, StarRocksParserRULE_showResourceGroupStatement)
	var _la int

	p.SetState(4035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4019)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserVERBOSE {
			{
				p.SetState(4020)
				p.Match(StarRocksParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4023)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4024)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4025)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4026)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserVERBOSE {
			{
				p.SetState(4027)
				p.Match(StarRocksParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4030)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4031)
			p.Match(StarRocksParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL {
			{
				p.SetState(4032)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupUsageStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupUsageStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	GROUPS() antlr.TerminalNode

	// IsShowResourceGroupUsageStatementContext differentiates from other interfaces.
	IsShowResourceGroupUsageStatementContext()
}

type ShowResourceGroupUsageStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupUsageStatementContext() *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupUsageStatement
	return p
}

func InitEmptyShowResourceGroupUsageStatementContext(p *ShowResourceGroupUsageStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupUsageStatement
}

func (*ShowResourceGroupUsageStatementContext) IsShowResourceGroupUsageStatementContext() {}

func NewShowResourceGroupUsageStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showResourceGroupUsageStatement

	return p
}

func (s *ShowResourceGroupUsageStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupUsageStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowResourceGroupUsageStatementContext) USAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSAGE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowResourceGroupUsageStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupUsageStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPS, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupUsageStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupUsageStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowResourceGroupUsageStatement(s)
	}
}

func (s *ShowResourceGroupUsageStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowResourceGroupUsageStatement(s)
	}
}

func (s *ShowResourceGroupUsageStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowResourceGroupUsageStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowResourceGroupUsageStatement() (localctx IShowResourceGroupUsageStatementContext) {
	localctx = NewShowResourceGroupUsageStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, StarRocksParserRULE_showResourceGroupUsageStatement)
	p.SetState(4046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4037)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4038)
			p.Match(StarRocksParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4039)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4040)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4041)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4042)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4043)
			p.Match(StarRocksParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4044)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4045)
			p.Match(StarRocksParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceStatementContext is an interface to support dynamic dispatch.
type ICreateResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	EXTERNAL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateResourceStatementContext differentiates from other interfaces.
	IsCreateResourceStatementContext()
}

type CreateResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyCreateResourceStatementContext() *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceStatement
	return p
}

func InitEmptyCreateResourceStatementContext(p *CreateResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceStatement
}

func (*CreateResourceStatementContext) IsCreateResourceStatementContext() {}

func NewCreateResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createResourceStatement

	return p
}

func (s *CreateResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *CreateResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *CreateResourceStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *CreateResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateResourceStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateResourceStatement(s)
	}
}

func (s *CreateResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateResourceStatement(s)
	}
}

func (s *CreateResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateResourceStatement() (localctx ICreateResourceStatementContext) {
	localctx = NewCreateResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, StarRocksParserRULE_createResourceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4048)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEXTERNAL {
		{
			p.SetState(4049)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4052)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4053)

		var _x = p.IdentifierOrString()

		localctx.(*CreateResourceStatementContext).resourceName = _x
	}
	p.SetState(4055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(4054)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceStatementContext is an interface to support dynamic dispatch.
type IAlterResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	SET() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterResourceStatementContext differentiates from other interfaces.
	IsAlterResourceStatementContext()
}

type AlterResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyAlterResourceStatementContext() *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceStatement
	return p
}

func InitEmptyAlterResourceStatementContext(p *AlterResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceStatement
}

func (*AlterResourceStatementContext) IsAlterResourceStatementContext() {}

func NewAlterResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterResourceStatement

	return p
}

func (s *AlterResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *AlterResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *AlterResourceStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *AlterResourceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterResourceStatement(s)
	}
}

func (s *AlterResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterResourceStatement(s)
	}
}

func (s *AlterResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterResourceStatement() (localctx IAlterResourceStatementContext) {
	localctx = NewAlterResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, StarRocksParserRULE_alterResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4057)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4058)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4059)

		var _x = p.IdentifierOrString()

		localctx.(*AlterResourceStatementContext).resourceName = _x
	}
	{
		p.SetState(4060)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4061)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceStatementContext is an interface to support dynamic dispatch.
type IDropResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsDropResourceStatementContext differentiates from other interfaces.
	IsDropResourceStatementContext()
}

type DropResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyDropResourceStatementContext() *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceStatement
	return p
}

func InitEmptyDropResourceStatementContext(p *DropResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceStatement
}

func (*DropResourceStatementContext) IsDropResourceStatementContext() {}

func NewDropResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropResourceStatement

	return p
}

func (s *DropResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *DropResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *DropResourceStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *DropResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropResourceStatement(s)
	}
}

func (s *DropResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropResourceStatement(s)
	}
}

func (s *DropResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropResourceStatement() (localctx IDropResourceStatementContext) {
	localctx = NewDropResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, StarRocksParserRULE_dropResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4063)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4064)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4065)

		var _x = p.IdentifierOrString()

		localctx.(*DropResourceStatementContext).resourceName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceStatementContext is an interface to support dynamic dispatch.
type IShowResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode

	// IsShowResourceStatementContext differentiates from other interfaces.
	IsShowResourceStatementContext()
}

type ShowResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceStatementContext() *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceStatement
	return p
}

func InitEmptyShowResourceStatementContext(p *ShowResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceStatement
}

func (*ShowResourceStatementContext) IsShowResourceStatementContext() {}

func NewShowResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showResourceStatement

	return p
}

func (s *ShowResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowResourceStatementContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCES, 0)
}

func (s *ShowResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowResourceStatement(s)
	}
}

func (s *ShowResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowResourceStatement(s)
	}
}

func (s *ShowResourceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowResourceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowResourceStatement() (localctx IShowResourceStatementContext) {
	localctx = NewShowResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, StarRocksParserRULE_showResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4067)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4068)
		p.Match(StarRocksParserRESOURCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassifierContext is an interface to support dynamic dispatch.
type IClassifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsClassifierContext differentiates from other interfaces.
	IsClassifierContext()
}

type ClassifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassifierContext() *ClassifierContext {
	var p = new(ClassifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_classifier
	return p
}

func InitEmptyClassifierContext(p *ClassifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_classifier
}

func (*ClassifierContext) IsClassifierContext() {}

func NewClassifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassifierContext {
	var p = new(ClassifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_classifier

	return p
}

func (s *ClassifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassifierContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ClassifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterClassifier(s)
	}
}

func (s *ClassifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitClassifier(s)
	}
}

func (s *ClassifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitClassifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Classifier() (localctx IClassifierContext) {
	localctx = NewClassifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, StarRocksParserRULE_classifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4070)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4071)
		p.ExpressionList()
	}
	{
		p.SetState(4072)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFunctionsStatementContext is an interface to support dynamic dispatch.
type IShowFunctionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowFunctionsStatementContext differentiates from other interfaces.
	IsShowFunctionsStatementContext()
}

type ShowFunctionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowFunctionsStatementContext() *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFunctionsStatement
	return p
}

func InitEmptyShowFunctionsStatementContext(p *ShowFunctionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFunctionsStatement
}

func (*ShowFunctionsStatementContext) IsShowFunctionsStatementContext() {}

func NewShowFunctionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showFunctionsStatement

	return p
}

func (s *ShowFunctionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFunctionsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowFunctionsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFunctionsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowFunctionsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFunctionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowFunctionsStatementContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *ShowFunctionsStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowFunctionsStatementContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUILTIN, 0)
}

func (s *ShowFunctionsStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *ShowFunctionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowFunctionsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowFunctionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowFunctionsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowFunctionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowFunctionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFunctionsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFunctionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFunctionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowFunctionsStatement(s)
	}
}

func (s *ShowFunctionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowFunctionsStatement(s)
	}
}

func (s *ShowFunctionsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowFunctionsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowFunctionsStatement() (localctx IShowFunctionsStatementContext) {
	localctx = NewShowFunctionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, StarRocksParserRULE_showFunctionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4074)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(4075)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4079)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBUILTIN || _la == StarRocksParserGLOBAL {
		{
			p.SetState(4078)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserBUILTIN || _la == StarRocksParserGLOBAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4081)
		p.Match(StarRocksParserFUNCTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4082)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4083)

			var _x = p.QualifiedName()

			localctx.(*ShowFunctionsStatementContext).db = _x
		}

	}
	p.SetState(4090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4086)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4087)

			var _x = p.String_()

			localctx.(*ShowFunctionsStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4088)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4089)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionStatementContext is an interface to support dynamic dispatch.
type IDropFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	GLOBAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropFunctionStatementContext differentiates from other interfaces.
	IsDropFunctionStatementContext()
}

type DropFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionStatementContext() *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFunctionStatement
	return p
}

func InitEmptyDropFunctionStatementContext(p *DropFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFunctionStatement
}

func (*DropFunctionStatementContext) IsDropFunctionStatementContext() {}

func NewDropFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFunctionStatement

	return p
}

func (s *DropFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *DropFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *DropFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *DropFunctionStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropFunctionStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropFunctionStatement() (localctx IDropFunctionStatementContext) {
	localctx = NewDropFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, StarRocksParserRULE_dropFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4092)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL {
		{
			p.SetState(4093)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4096)
		p.Match(StarRocksParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4097)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4098)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4101)
		p.QualifiedName()
	}
	{
		p.SetState(4102)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4103)
		p.TypeList()
	}
	{
		p.SetState(4104)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionStatementContext is an interface to support dynamic dispatch.
type ICreateFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionType returns the functionType token.
	GetFunctionType() antlr.Token

	// SetFunctionType sets the functionType token.
	SetFunctionType(antlr.Token)

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeContext

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	FUNCTION() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	RETURNS() antlr.TerminalNode
	Type_() ITypeContext
	GLOBAL() antlr.TerminalNode
	Properties() IPropertiesContext
	InlineProperties() IInlinePropertiesContext
	InlineFunction() IInlineFunctionContext
	TABLE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode

	// IsCreateFunctionStatementContext differentiates from other interfaces.
	IsCreateFunctionStatementContext()
}

type CreateFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionType antlr.Token
	returnType   ITypeContext
}

func NewEmptyCreateFunctionStatementContext() *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFunctionStatement
	return p
}

func InitEmptyCreateFunctionStatementContext(p *CreateFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFunctionStatement
}

func (*CreateFunctionStatementContext) IsCreateFunctionStatementContext() {}

func NewCreateFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createFunctionStatement

	return p
}

func (s *CreateFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionStatementContext) GetFunctionType() antlr.Token { return s.functionType }

func (s *CreateFunctionStatementContext) SetFunctionType(v antlr.Token) { s.functionType = v }

func (s *CreateFunctionStatementContext) GetReturnType() ITypeContext { return s.returnType }

func (s *CreateFunctionStatementContext) SetReturnType(v ITypeContext) { s.returnType = v }

func (s *CreateFunctionStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateFunctionStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *CreateFunctionStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *CreateFunctionStatementContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETURNS, 0)
}

func (s *CreateFunctionStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CreateFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *CreateFunctionStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineProperties() IInlinePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineFunction() IInlineFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFunctionContext)
}

func (s *CreateFunctionStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateFunctionStatementContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAGGREGATE, 0)
}

func (s *CreateFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateFunctionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateFunctionStatement() (localctx ICreateFunctionStatementContext) {
	localctx = NewCreateFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, StarRocksParserRULE_createFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4106)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4107)
		p.OrReplace()
	}
	p.SetState(4109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL {
		{
			p.SetState(4108)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserTABLE {
		{
			p.SetState(4111)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateFunctionStatementContext).functionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserAGGREGATE || _la == StarRocksParserTABLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateFunctionStatementContext).functionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4114)
		p.Match(StarRocksParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4115)
		p.IfNotExists()
	}
	{
		p.SetState(4116)
		p.QualifiedName()
	}
	{
		p.SetState(4117)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4118)
		p.TypeList()
	}
	{
		p.SetState(4119)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4120)
		p.Match(StarRocksParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4121)

		var _x = p.Type_()

		localctx.(*CreateFunctionStatementContext).returnType = _x
	}
	p.SetState(4124)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 1+1 {
		{
			p.SetState(4122)
			p.Properties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) == 2+1 {
		{
			p.SetState(4123)
			p.InlineProperties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(4126)
			p.InlineFunction()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineFunctionContext is an interface to support dynamic dispatch.
type IInlineFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	ATTACHMENT() antlr.TerminalNode

	// IsInlineFunctionContext differentiates from other interfaces.
	IsInlineFunctionContext()
}

type InlineFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFunctionContext() *InlineFunctionContext {
	var p = new(InlineFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineFunction
	return p
}

func InitEmptyInlineFunctionContext(p *InlineFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineFunction
}

func (*InlineFunctionContext) IsInlineFunctionContext() {}

func NewInlineFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFunctionContext {
	var p = new(InlineFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_inlineFunction

	return p
}

func (s *InlineFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *InlineFunctionContext) ATTACHMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserATTACHMENT, 0)
}

func (s *InlineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineFunction(s)
	}
}

func (s *InlineFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineFunction(s)
	}
}

func (s *InlineFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInlineFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) InlineFunction() (localctx IInlineFunctionContext) {
	localctx = NewInlineFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, StarRocksParserRULE_inlineFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4129)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4130)
		p.Match(StarRocksParserATTACHMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	DOTDOTDOT() antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeListContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOTDOTDOT, 0)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, StarRocksParserRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&1099547017217) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&144115188109411299) != 0) || ((int64((_la-190)) & ^0x3f) == 0 && ((int64(1)<<(_la-190))&4611690485199667201) != 0) || ((int64((_la-284)) & ^0x3f) == 0 && ((int64(1)<<(_la-284))&67108867) != 0) || ((int64((_la-399)) & ^0x3f) == 0 && ((int64(1)<<(_la-399))&72058160982048777) != 0) || _la == StarRocksParserVARBINARY || _la == StarRocksParserVARCHAR {
		{
			p.SetState(4132)
			p.Type_()
		}

	}
	p.SetState(4139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4135)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4136)
				p.Type_()
			}

		}
		p.SetState(4141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__2 {
		{
			p.SetState(4142)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4143)
			p.Match(StarRocksParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadStatementContext is an interface to support dynamic dispatch.
type ILoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() ILabelNameContext

	// GetData returns the data rule contexts.
	GetData() IDataDescListContext

	// GetBroker returns the broker rule contexts.
	GetBroker() IBrokerDescContext

	// GetSystem returns the system rule contexts.
	GetSystem() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetResource returns the resource rule contexts.
	GetResource() IResourceDescContext

	// SetLabel sets the label rule contexts.
	SetLabel(ILabelNameContext)

	// SetData sets the data rule contexts.
	SetData(IDataDescListContext)

	// SetBroker sets the broker rule contexts.
	SetBroker(IBrokerDescContext)

	// SetSystem sets the system rule contexts.
	SetSystem(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetResource sets the resource rule contexts.
	SetResource(IResourceDescContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LabelName() ILabelNameContext
	BY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	DataDescList() IDataDescListContext
	BrokerDesc() IBrokerDescContext
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext
	ResourceDesc() IResourceDescContext

	// IsLoadStatementContext differentiates from other interfaces.
	IsLoadStatementContext()
}

type LoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	label    ILabelNameContext
	data     IDataDescListContext
	broker   IBrokerDescContext
	system   IIdentifierOrStringContext
	props    IPropertyListContext
	resource IResourceDescContext
}

func NewEmptyLoadStatementContext() *LoadStatementContext {
	var p = new(LoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadStatement
	return p
}

func InitEmptyLoadStatementContext(p *LoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadStatement
}

func (*LoadStatementContext) IsLoadStatementContext() {}

func NewLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStatementContext {
	var p = new(LoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_loadStatement

	return p
}

func (s *LoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStatementContext) GetLabel() ILabelNameContext { return s.label }

func (s *LoadStatementContext) GetData() IDataDescListContext { return s.data }

func (s *LoadStatementContext) GetBroker() IBrokerDescContext { return s.broker }

func (s *LoadStatementContext) GetSystem() IIdentifierOrStringContext { return s.system }

func (s *LoadStatementContext) GetProps() IPropertyListContext { return s.props }

func (s *LoadStatementContext) GetResource() IResourceDescContext { return s.resource }

func (s *LoadStatementContext) SetLabel(v ILabelNameContext) { s.label = v }

func (s *LoadStatementContext) SetData(v IDataDescListContext) { s.data = v }

func (s *LoadStatementContext) SetBroker(v IBrokerDescContext) { s.broker = v }

func (s *LoadStatementContext) SetSystem(v IIdentifierOrStringContext) { s.system = v }

func (s *LoadStatementContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *LoadStatementContext) SetResource(v IResourceDescContext) { s.resource = v }

func (s *LoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *LoadStatementContext) LABEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLABEL, 0)
}

func (s *LoadStatementContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *LoadStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *LoadStatementContext) DataDescList() IDataDescListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescListContext)
}

func (s *LoadStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *LoadStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *LoadStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *LoadStatementContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *LoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLoadStatement(s)
	}
}

func (s *LoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLoadStatement(s)
	}
}

func (s *LoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LoadStatement() (localctx ILoadStatementContext) {
	localctx = NewLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, StarRocksParserRULE_loadStatement)
	var _la int

	p.SetState(4174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4146)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4147)
			p.Match(StarRocksParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4148)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4149)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		p.SetState(4153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4152)

				var _x = p.BrokerDesc()

				localctx.(*LoadStatementContext).broker = _x
			}

		}
		p.SetState(4157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBY {
			{
				p.SetState(4155)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4156)

				var _x = p.IdentifierOrString()

				localctx.(*LoadStatementContext).system = _x
			}

		}
		p.SetState(4161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(4159)
				p.Match(StarRocksParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4160)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4163)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4164)
			p.Match(StarRocksParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4165)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4166)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		{
			p.SetState(4169)

			var _x = p.ResourceDesc()

			localctx.(*LoadStatementContext).resource = _x
		}
		p.SetState(4172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(4170)
				p.Match(StarRocksParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4171)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
	label  IIdentifierContext
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_labelName
	return p
}

func InitEmptyLabelNameContext(p *LabelNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_labelName
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) GetDb() IIdentifierContext { return s.db }

func (s *LabelNameContext) GetLabel() IIdentifierContext { return s.label }

func (s *LabelNameContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *LabelNameContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *LabelNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LabelNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (s *LabelNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLabelName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LabelName() (localctx ILabelNameContext) {
	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, StarRocksParserRULE_labelName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4179)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4176)

			var _x = p.Identifier()

			localctx.(*LabelNameContext).db = _x
		}
		{
			p.SetState(4177)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4181)

		var _x = p.Identifier()

		localctx.(*LabelNameContext).label = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescListContext is an interface to support dynamic dispatch.
type IDataDescListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataDesc() []IDataDescContext
	DataDesc(i int) IDataDescContext

	// IsDataDescListContext differentiates from other interfaces.
	IsDataDescListContext()
}

type DataDescListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescListContext() *DataDescListContext {
	var p = new(DataDescListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDescList
	return p
}

func InitEmptyDataDescListContext(p *DataDescListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDescList
}

func (*DataDescListContext) IsDataDescListContext() {}

func NewDataDescListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescListContext {
	var p = new(DataDescListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataDescList

	return p
}

func (s *DataDescListContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescListContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *DataDescListContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *DataDescListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataDescList(s)
	}
}

func (s *DataDescListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataDescList(s)
	}
}

func (s *DataDescListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDataDescList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DataDescList() (localctx IDataDescListContext) {
	localctx = NewDataDescListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, StarRocksParserRULE_dataDescList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4183)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4184)
		p.DataDesc()
	}
	p.SetState(4189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(4185)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4186)
			p.DataDesc()
		}

		p.SetState(4191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4192)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSrcFiles returns the srcFiles rule contexts.
	GetSrcFiles() IStringListContext

	// GetDstTableName returns the dstTableName rule contexts.
	GetDstTableName() IIdentifierContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionNamesContext

	// GetColSep returns the colSep rule contexts.
	GetColSep() IStringContext

	// GetRowSep returns the rowSep rule contexts.
	GetRowSep() IStringContext

	// GetFormat returns the format rule contexts.
	GetFormat() IFileFormatContext

	// GetFormatPropsField returns the formatPropsField rule contexts.
	GetFormatPropsField() IFormatPropsContext

	// GetColList returns the colList rule contexts.
	GetColList() IColumnAliasesContext

	// GetColFromPath returns the colFromPath rule contexts.
	GetColFromPath() IIdentifierListContext

	// GetColMappingList returns the colMappingList rule contexts.
	GetColMappingList() IClassifierContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetSrcTableName returns the srcTableName rule contexts.
	GetSrcTableName() IIdentifierContext

	// SetSrcFiles sets the srcFiles rule contexts.
	SetSrcFiles(IStringListContext)

	// SetDstTableName sets the dstTableName rule contexts.
	SetDstTableName(IIdentifierContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionNamesContext)

	// SetColSep sets the colSep rule contexts.
	SetColSep(IStringContext)

	// SetRowSep sets the rowSep rule contexts.
	SetRowSep(IStringContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IFileFormatContext)

	// SetFormatPropsField sets the formatPropsField rule contexts.
	SetFormatPropsField(IFormatPropsContext)

	// SetColList sets the colList rule contexts.
	SetColList(IColumnAliasesContext)

	// SetColFromPath sets the colFromPath rule contexts.
	SetColFromPath(IIdentifierListContext)

	// SetColMappingList sets the colMappingList rule contexts.
	SetColMappingList(IClassifierContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetSrcTableName sets the srcTableName rule contexts.
	SetSrcTableName(IIdentifierContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	StringList() IStringListContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	NEGATIVE() antlr.TerminalNode
	AllCOLUMNS() []antlr.TerminalNode
	COLUMNS(i int) antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ROWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	SET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	FileFormat() IFileFormatContext
	FormatProps() IFormatPropsContext
	ColumnAliases() IColumnAliasesContext
	IdentifierList() IIdentifierListContext
	Classifier() IClassifierContext
	Expression() IExpressionContext

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	srcFiles         IStringListContext
	dstTableName     IIdentifierContext
	partitions       IPartitionNamesContext
	colSep           IStringContext
	rowSep           IStringContext
	format           IFileFormatContext
	formatPropsField IFormatPropsContext
	colList          IColumnAliasesContext
	colFromPath      IIdentifierListContext
	colMappingList   IClassifierContext
	where            IExpressionContext
	srcTableName     IIdentifierContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) GetSrcFiles() IStringListContext { return s.srcFiles }

func (s *DataDescContext) GetDstTableName() IIdentifierContext { return s.dstTableName }

func (s *DataDescContext) GetPartitions() IPartitionNamesContext { return s.partitions }

func (s *DataDescContext) GetColSep() IStringContext { return s.colSep }

func (s *DataDescContext) GetRowSep() IStringContext { return s.rowSep }

func (s *DataDescContext) GetFormat() IFileFormatContext { return s.format }

func (s *DataDescContext) GetFormatPropsField() IFormatPropsContext { return s.formatPropsField }

func (s *DataDescContext) GetColList() IColumnAliasesContext { return s.colList }

func (s *DataDescContext) GetColFromPath() IIdentifierListContext { return s.colFromPath }

func (s *DataDescContext) GetColMappingList() IClassifierContext { return s.colMappingList }

func (s *DataDescContext) GetWhere() IExpressionContext { return s.where }

func (s *DataDescContext) GetSrcTableName() IIdentifierContext { return s.srcTableName }

func (s *DataDescContext) SetSrcFiles(v IStringListContext) { s.srcFiles = v }

func (s *DataDescContext) SetDstTableName(v IIdentifierContext) { s.dstTableName = v }

func (s *DataDescContext) SetPartitions(v IPartitionNamesContext) { s.partitions = v }

func (s *DataDescContext) SetColSep(v IStringContext) { s.colSep = v }

func (s *DataDescContext) SetRowSep(v IStringContext) { s.rowSep = v }

func (s *DataDescContext) SetFormat(v IFileFormatContext) { s.format = v }

func (s *DataDescContext) SetFormatPropsField(v IFormatPropsContext) { s.formatPropsField = v }

func (s *DataDescContext) SetColList(v IColumnAliasesContext) { s.colList = v }

func (s *DataDescContext) SetColFromPath(v IIdentifierListContext) { s.colFromPath = v }

func (s *DataDescContext) SetColMappingList(v IClassifierContext) { s.colMappingList = v }

func (s *DataDescContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataDescContext) SetSrcTableName(v IIdentifierContext) { s.srcTableName = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINFILE, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, i)
}

func (s *DataDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *DataDescContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataDescContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNEGATIVE, 0)
}

func (s *DataDescContext) AllCOLUMNS() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserCOLUMNS)
}

func (s *DataDescContext) COLUMNS(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, i)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, i)
}

func (s *DataDescContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROWS, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DataDescContext) PATH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPATH, 0)
}

func (s *DataDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *DataDescContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *DataDescContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DataDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DataDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DataDescContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *DataDescContext) FormatProps() IFormatPropsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatPropsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatPropsContext)
}

func (s *DataDescContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *DataDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) Classifier() IClassifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *DataDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataDesc(s)
	}
}

func (s *DataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataDesc(s)
	}
}

func (s *DataDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDataDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, StarRocksParserRULE_dataDesc)
	var _la int

	p.SetState(4263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4194)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4195)
			p.Match(StarRocksParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4196)

			var _x = p.StringList()

			localctx.(*DataDescContext).srcFiles = _x
		}
		p.SetState(4198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNEGATIVE {
			{
				p.SetState(4197)
				p.Match(StarRocksParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4200)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4201)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4202)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(4203)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4210)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4206)
				p.Match(StarRocksParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4207)
				p.Match(StarRocksParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4208)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4209)

				var _x = p.String_()

				localctx.(*DataDescContext).colSep = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserROWS {
			{
				p.SetState(4212)
				p.Match(StarRocksParserROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4213)
				p.Match(StarRocksParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4214)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4215)

				var _x = p.String_()

				localctx.(*DataDescContext).rowSep = _x
			}

		}
		p.SetState(4219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORMAT {
			{
				p.SetState(4218)

				var _x = p.FileFormat()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(4222)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4221)

				var _x = p.FormatProps()

				localctx.(*DataDescContext).formatPropsField = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4224)

				var _x = p.ColumnAliases()

				localctx.(*DataDescContext).colList = _x
			}

		}
		p.SetState(4232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCOLUMNS {
			{
				p.SetState(4227)
				p.Match(StarRocksParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4228)
				p.Match(StarRocksParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4229)
				p.Match(StarRocksParserPATH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4230)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4231)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).colFromPath = _x
			}

		}
		p.SetState(4236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSET {
			{
				p.SetState(4234)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4235)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4238)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4239)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4242)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4243)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4244)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4245)

			var _x = p.Identifier()

			localctx.(*DataDescContext).srcTableName = _x
		}
		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNEGATIVE {
			{
				p.SetState(4246)
				p.Match(StarRocksParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4249)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4250)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4251)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4253)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(4252)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSET {
			{
				p.SetState(4255)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4256)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4259)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4260)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatPropsContext is an interface to support dynamic dispatch.
type IFormatPropsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEncloseCharacter returns the encloseCharacter rule contexts.
	GetEncloseCharacter() IStringContext

	// GetEscapeCharacter returns the escapeCharacter rule contexts.
	GetEscapeCharacter() IStringContext

	// SetEncloseCharacter sets the encloseCharacter rule contexts.
	SetEncloseCharacter(IStringContext)

	// SetEscapeCharacter sets the escapeCharacter rule contexts.
	SetEscapeCharacter(IStringContext)

	// Getter signatures
	SKIP_HEADER() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsFormatPropsContext differentiates from other interfaces.
	IsFormatPropsContext()
}

type FormatPropsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	encloseCharacter IStringContext
	escapeCharacter  IStringContext
}

func NewEmptyFormatPropsContext() *FormatPropsContext {
	var p = new(FormatPropsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_formatProps
	return p
}

func InitEmptyFormatPropsContext(p *FormatPropsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_formatProps
}

func (*FormatPropsContext) IsFormatPropsContext() {}

func NewFormatPropsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatPropsContext {
	var p = new(FormatPropsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_formatProps

	return p
}

func (s *FormatPropsContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatPropsContext) GetEncloseCharacter() IStringContext { return s.encloseCharacter }

func (s *FormatPropsContext) GetEscapeCharacter() IStringContext { return s.escapeCharacter }

func (s *FormatPropsContext) SetEncloseCharacter(v IStringContext) { s.encloseCharacter = v }

func (s *FormatPropsContext) SetEscapeCharacter(v IStringContext) { s.escapeCharacter = v }

func (s *FormatPropsContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSKIP_HEADER, 0)
}

func (s *FormatPropsContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserEQ)
}

func (s *FormatPropsContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, i)
}

func (s *FormatPropsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *FormatPropsContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIM_SPACE, 0)
}

func (s *FormatPropsContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *FormatPropsContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENCLOSE, 0)
}

func (s *FormatPropsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserESCAPE, 0)
}

func (s *FormatPropsContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *FormatPropsContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FormatPropsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatPropsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatPropsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFormatProps(s)
	}
}

func (s *FormatPropsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFormatProps(s)
	}
}

func (s *FormatPropsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitFormatProps(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) FormatProps() (localctx IFormatPropsContext) {
	localctx = NewFormatPropsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, StarRocksParserRULE_formatProps)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4265)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSKIP_HEADER {
		{
			p.SetState(4266)
			p.Match(StarRocksParserSKIP_HEADER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4267)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4268)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTRIM_SPACE {
		{
			p.SetState(4271)
			p.Match(StarRocksParserTRIM_SPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4272)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4273)
			p.BooleanValue()
		}

	}
	p.SetState(4279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserENCLOSE {
		{
			p.SetState(4276)
			p.Match(StarRocksParserENCLOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4277)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4278)

			var _x = p.String_()

			localctx.(*FormatPropsContext).encloseCharacter = _x
		}

	}
	p.SetState(4284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserESCAPE {
		{
			p.SetState(4281)
			p.Match(StarRocksParserESCAPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4282)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4283)

			var _x = p.String_()

			localctx.(*FormatPropsContext).escapeCharacter = _x
		}

	}
	{
		p.SetState(4286)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBrokerDescContext is an interface to support dynamic dispatch.
type IBrokerDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsBrokerDescContext differentiates from other interfaces.
	IsBrokerDescContext()
}

type BrokerDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	props  IPropertyListContext
	name   IIdentifierOrStringContext
}

func NewEmptyBrokerDescContext() *BrokerDescContext {
	var p = new(BrokerDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_brokerDesc
	return p
}

func InitEmptyBrokerDescContext(p *BrokerDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_brokerDesc
}

func (*BrokerDescContext) IsBrokerDescContext() {}

func NewBrokerDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BrokerDescContext {
	var p = new(BrokerDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_brokerDesc

	return p
}

func (s *BrokerDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BrokerDescContext) GetProps() IPropertyListContext { return s.props }

func (s *BrokerDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *BrokerDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *BrokerDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *BrokerDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *BrokerDescContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *BrokerDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BrokerDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *BrokerDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BrokerDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BrokerDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBrokerDesc(s)
	}
}

func (s *BrokerDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBrokerDesc(s)
	}
}

func (s *BrokerDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBrokerDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BrokerDesc() (localctx IBrokerDescContext) {
	localctx = NewBrokerDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, StarRocksParserRULE_brokerDesc)
	var _la int

	p.SetState(4299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4288)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4289)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4290)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4293)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4294)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4295)

			var _x = p.IdentifierOrString()

			localctx.(*BrokerDescContext).name = _x
		}
		p.SetState(4297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4296)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierOrStringContext
	props  IPropertyListContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *ResourceDescContext) GetProps() IPropertyListContext { return s.props }

func (s *ResourceDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *ResourceDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ResourceDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterResourceDesc(s)
	}
}

func (s *ResourceDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitResourceDesc(s)
	}
}

func (s *ResourceDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitResourceDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, StarRocksParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4301)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4302)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4303)

		var _x = p.IdentifierOrString()

		localctx.(*ResourceDescContext).name = _x
	}
	p.SetState(4305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(4304)

			var _x = p.PropertyList()

			localctx.(*ResourceDescContext).props = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadStatementContext is an interface to support dynamic dispatch.
type IShowLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowLoadStatementContext differentiates from other interfaces.
	IsShowLoadStatementContext()
}

type ShowLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadStatementContext() *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadStatement
	return p
}

func InitEmptyShowLoadStatementContext(p *ShowLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadStatement
}

func (*ShowLoadStatementContext) IsShowLoadStatementContext() {}

func NewShowLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showLoadStatement

	return p
}

func (s *ShowLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowLoadStatement(s)
	}
}

func (s *ShowLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowLoadStatement(s)
	}
}

func (s *ShowLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowLoadStatement() (localctx IShowLoadStatementContext) {
	localctx = NewShowLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, StarRocksParserRULE_showLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4307)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4308)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL {
		{
			p.SetState(4309)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(4312)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4313)
			p.Identifier()
		}

	}
	p.SetState(4318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(4316)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4317)
			p.expression(0)
		}

	}
	p.SetState(4330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(4320)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4321)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4322)
			p.SortItem()
		}
		p.SetState(4327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4323)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4324)
				p.SortItem()
			}

			p.SetState(4329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4332)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadWarningsStatementContext is an interface to support dynamic dispatch.
type IShowLoadWarningsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LimitElement() ILimitElementContext
	ON() antlr.TerminalNode
	String_() IStringContext

	// IsShowLoadWarningsStatementContext differentiates from other interfaces.
	IsShowLoadWarningsStatementContext()
}

type ShowLoadWarningsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadWarningsStatementContext() *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadWarningsStatement
	return p
}

func InitEmptyShowLoadWarningsStatementContext(p *ShowLoadWarningsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadWarningsStatement
}

func (*ShowLoadWarningsStatementContext) IsShowLoadWarningsStatementContext() {}

func NewShowLoadWarningsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showLoadWarningsStatement

	return p
}

func (s *ShowLoadWarningsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadWarningsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowLoadWarningsStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowLoadWarningsStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWARNINGS, 0)
}

func (s *ShowLoadWarningsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowLoadWarningsStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadWarningsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowLoadWarningsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadWarningsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadWarningsStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ShowLoadWarningsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowLoadWarningsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadWarningsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadWarningsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowLoadWarningsStatement(s)
	}
}

func (s *ShowLoadWarningsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowLoadWarningsStatement(s)
	}
}

func (s *ShowLoadWarningsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowLoadWarningsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowLoadWarningsStatement() (localctx IShowLoadWarningsStatementContext) {
	localctx = NewShowLoadWarningsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, StarRocksParserRULE_showLoadWarningsStatement)
	var _la int

	p.SetState(4354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 457, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4335)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4336)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4337)
			p.Match(StarRocksParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM {
			{
				p.SetState(4338)
				p.Match(StarRocksParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4339)
				p.Identifier()
			}

		}
		p.SetState(4344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4342)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4343)
				p.expression(0)
			}

		}
		p.SetState(4347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(4346)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4349)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4350)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4351)
			p.Match(StarRocksParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4352)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4353)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelLoadStatementContext is an interface to support dynamic dispatch.
type ICancelLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelLoadStatementContext differentiates from other interfaces.
	IsCancelLoadStatementContext()
}

type CancelLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelLoadStatementContext() *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelLoadStatement
	return p
}

func InitEmptyCancelLoadStatementContext(p *CancelLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelLoadStatement
}

func (*CancelLoadStatementContext) IsCancelLoadStatementContext() {}

func NewCancelLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelLoadStatement

	return p
}

func (s *CancelLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelLoadStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *CancelLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CancelLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelLoadStatement(s)
	}
}

func (s *CancelLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelLoadStatement(s)
	}
}

func (s *CancelLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelLoadStatement() (localctx ICancelLoadStatementContext) {
	localctx = NewCancelLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, StarRocksParserRULE_cancelLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4356)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4357)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(4358)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4359)
			p.Identifier()
		}

	}
	p.SetState(4364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(4362)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4363)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadStatementContext is an interface to support dynamic dispatch.
type IAlterLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	JobProperties() IJobPropertiesContext
	QualifiedName() IQualifiedNameContext

	// IsAlterLoadStatementContext differentiates from other interfaces.
	IsAlterLoadStatementContext()
}

type AlterLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterLoadStatementContext() *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadStatement
	return p
}

func InitEmptyAlterLoadStatementContext(p *AlterLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadStatement
}

func (*AlterLoadStatementContext) IsAlterLoadStatementContext() {}

func NewAlterLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterLoadStatement

	return p
}

func (s *AlterLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *AlterLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *AlterLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterLoadStatement(s)
	}
}

func (s *AlterLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterLoadStatement(s)
	}
}

func (s *AlterLoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterLoadStatement() (localctx IAlterLoadStatementContext) {
	localctx = NewAlterLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, StarRocksParserRULE_alterLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4366)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4367)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4368)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4372)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 460, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4369)

			var _x = p.QualifiedName()

			localctx.(*AlterLoadStatementContext).db = _x
		}
		{
			p.SetState(4370)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4374)

		var _x = p.Identifier()

		localctx.(*AlterLoadStatementContext).name = _x
	}
	p.SetState(4376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(4375)
			p.JobProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelCompactionStatementContext is an interface to support dynamic dispatch.
type ICancelCompactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	COMPACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelCompactionStatementContext differentiates from other interfaces.
	IsCancelCompactionStatementContext()
}

type CancelCompactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelCompactionStatementContext() *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelCompactionStatement
	return p
}

func InitEmptyCancelCompactionStatementContext(p *CancelCompactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelCompactionStatement
}

func (*CancelCompactionStatementContext) IsCancelCompactionStatementContext() {}

func NewCancelCompactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelCompactionStatement

	return p
}

func (s *CancelCompactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelCompactionStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelCompactionStatementContext) COMPACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPACTION, 0)
}

func (s *CancelCompactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CancelCompactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelCompactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelCompactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelCompactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelCompactionStatement(s)
	}
}

func (s *CancelCompactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelCompactionStatement(s)
	}
}

func (s *CancelCompactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelCompactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelCompactionStatement() (localctx ICancelCompactionStatementContext) {
	localctx = NewCancelCompactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, StarRocksParserRULE_cancelCompactionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4378)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4379)
		p.Match(StarRocksParserCOMPACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4380)
		p.Match(StarRocksParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4381)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthorStatementContext is an interface to support dynamic dispatch.
type IShowAuthorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode

	// IsShowAuthorStatementContext differentiates from other interfaces.
	IsShowAuthorStatementContext()
}

type ShowAuthorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthorStatementContext() *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthorStatement
	return p
}

func InitEmptyShowAuthorStatementContext(p *ShowAuthorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthorStatement
}

func (*ShowAuthorStatementContext) IsShowAuthorStatementContext() {}

func NewShowAuthorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAuthorStatement

	return p
}

func (s *ShowAuthorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAuthorStatementContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHORS, 0)
}

func (s *ShowAuthorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAuthorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAuthorStatement(s)
	}
}

func (s *ShowAuthorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAuthorStatement(s)
	}
}

func (s *ShowAuthorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowAuthorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowAuthorStatement() (localctx IShowAuthorStatementContext) {
	localctx = NewShowAuthorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, StarRocksParserRULE_showAuthorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4383)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4384)
		p.Match(StarRocksParserAUTHORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendsStatementContext is an interface to support dynamic dispatch.
type IShowBackendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode

	// IsShowBackendsStatementContext differentiates from other interfaces.
	IsShowBackendsStatementContext()
}

type ShowBackendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendsStatementContext() *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendsStatement
	return p
}

func InitEmptyShowBackendsStatementContext(p *ShowBackendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendsStatement
}

func (*ShowBackendsStatementContext) IsShowBackendsStatementContext() {}

func NewShowBackendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBackendsStatement

	return p
}

func (s *ShowBackendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBackendsStatementContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKENDS, 0)
}

func (s *ShowBackendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBackendsStatement(s)
	}
}

func (s *ShowBackendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBackendsStatement(s)
	}
}

func (s *ShowBackendsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowBackendsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowBackendsStatement() (localctx IShowBackendsStatementContext) {
	localctx = NewShowBackendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, StarRocksParserRULE_showBackendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4386)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4387)
		p.Match(StarRocksParserBACKENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBrokerStatementContext is an interface to support dynamic dispatch.
type IShowBrokerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BROKER() antlr.TerminalNode

	// IsShowBrokerStatementContext differentiates from other interfaces.
	IsShowBrokerStatementContext()
}

type ShowBrokerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBrokerStatementContext() *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBrokerStatement
	return p
}

func InitEmptyShowBrokerStatementContext(p *ShowBrokerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBrokerStatement
}

func (*ShowBrokerStatementContext) IsShowBrokerStatementContext() {}

func NewShowBrokerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBrokerStatement

	return p
}

func (s *ShowBrokerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBrokerStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBrokerStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *ShowBrokerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBrokerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBrokerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBrokerStatement(s)
	}
}

func (s *ShowBrokerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBrokerStatement(s)
	}
}

func (s *ShowBrokerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowBrokerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowBrokerStatement() (localctx IShowBrokerStatementContext) {
	localctx = NewShowBrokerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, StarRocksParserRULE_showBrokerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4389)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4390)
		p.Match(StarRocksParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCharsetStatementContext is an interface to support dynamic dispatch.
type IShowCharsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCharsetStatementContext differentiates from other interfaces.
	IsShowCharsetStatementContext()
}

type ShowCharsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCharsetStatementContext() *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCharsetStatement
	return p
}

func InitEmptyShowCharsetStatementContext(p *ShowCharsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCharsetStatement
}

func (*ShowCharsetStatementContext) IsShowCharsetStatementContext() {}

func NewShowCharsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCharsetStatement

	return p
}

func (s *ShowCharsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCharsetStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCharsetStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCharsetStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCharsetStatementContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *ShowCharsetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ShowCharsetStatementContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *ShowCharsetStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *ShowCharsetStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowCharsetStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowCharsetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCharsetStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCharsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCharsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCharsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCharsetStatement(s)
	}
}

func (s *ShowCharsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCharsetStatement(s)
	}
}

func (s *ShowCharsetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCharsetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCharsetStatement() (localctx IShowCharsetStatementContext) {
	localctx = NewShowCharsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, StarRocksParserRULE_showCharsetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4392)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		{
			p.SetState(4393)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4394)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARSET:
		{
			p.SetState(4395)
			p.Match(StarRocksParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARACTER:
		{
			p.SetState(4396)
			p.Match(StarRocksParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4397)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4400)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4401)

			var _x = p.String_()

			localctx.(*ShowCharsetStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4402)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4403)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCollationStatementContext is an interface to support dynamic dispatch.
type IShowCollationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCollationStatementContext differentiates from other interfaces.
	IsShowCollationStatementContext()
}

type ShowCollationStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCollationStatementContext() *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCollationStatement
	return p
}

func InitEmptyShowCollationStatementContext(p *ShowCollationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCollationStatement
}

func (*ShowCollationStatementContext) IsShowCollationStatementContext() {}

func NewShowCollationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCollationStatement

	return p
}

func (s *ShowCollationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCollationStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCollationStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCollationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCollationStatementContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATION, 0)
}

func (s *ShowCollationStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowCollationStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowCollationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCollationStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCollationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCollationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCollationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCollationStatement(s)
	}
}

func (s *ShowCollationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCollationStatement(s)
	}
}

func (s *ShowCollationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCollationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCollationStatement() (localctx IShowCollationStatementContext) {
	localctx = NewShowCollationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, StarRocksParserRULE_showCollationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4406)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4407)
		p.Match(StarRocksParserCOLLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4408)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4409)

			var _x = p.String_()

			localctx.(*ShowCollationStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4410)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4411)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDeleteStatementContext is an interface to support dynamic dispatch.
type IShowDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDeleteStatementContext differentiates from other interfaces.
	IsShowDeleteStatementContext()
}

type ShowDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDeleteStatementContext() *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDeleteStatement
	return p
}

func InitEmptyShowDeleteStatementContext(p *ShowDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDeleteStatement
}

func (*ShowDeleteStatementContext) IsShowDeleteStatementContext() {}

func NewShowDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDeleteStatement

	return p
}

func (s *ShowDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDeleteStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDeleteStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDeleteStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *ShowDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDeleteStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowDeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDeleteStatement(s)
	}
}

func (s *ShowDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDeleteStatement(s)
	}
}

func (s *ShowDeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowDeleteStatement() (localctx IShowDeleteStatementContext) {
	localctx = NewShowDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, StarRocksParserRULE_showDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4414)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4415)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4416)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4417)

			var _x = p.QualifiedName()

			localctx.(*ShowDeleteStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDynamicPartitionStatementContext is an interface to support dynamic dispatch.
type IShowDynamicPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDynamicPartitionStatementContext differentiates from other interfaces.
	IsShowDynamicPartitionStatementContext()
}

type ShowDynamicPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDynamicPartitionStatementContext() *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDynamicPartitionStatement
	return p
}

func InitEmptyShowDynamicPartitionStatementContext(p *ShowDynamicPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDynamicPartitionStatement
}

func (*ShowDynamicPartitionStatementContext) IsShowDynamicPartitionStatementContext() {}

func NewShowDynamicPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDynamicPartitionStatement

	return p
}

func (s *ShowDynamicPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDynamicPartitionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDynamicPartitionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDynamicPartitionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDynamicPartitionStatementContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDYNAMIC, 0)
}

func (s *ShowDynamicPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *ShowDynamicPartitionStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowDynamicPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDynamicPartitionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowDynamicPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDynamicPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDynamicPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDynamicPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDynamicPartitionStatement(s)
	}
}

func (s *ShowDynamicPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDynamicPartitionStatement(s)
	}
}

func (s *ShowDynamicPartitionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowDynamicPartitionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowDynamicPartitionStatement() (localctx IShowDynamicPartitionStatementContext) {
	localctx = NewShowDynamicPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, StarRocksParserRULE_showDynamicPartitionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4420)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4421)
		p.Match(StarRocksParserDYNAMIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4422)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4423)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4424)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4425)

			var _x = p.QualifiedName()

			localctx.(*ShowDynamicPartitionStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEventsStatementContext is an interface to support dynamic dispatch.
type IShowEventsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowEventsStatementContext differentiates from other interfaces.
	IsShowEventsStatementContext()
}

type ShowEventsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowEventsStatementContext() *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEventsStatement
	return p
}

func InitEmptyShowEventsStatementContext(p *ShowEventsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEventsStatement
}

func (*ShowEventsStatementContext) IsShowEventsStatementContext() {}

func NewShowEventsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showEventsStatement

	return p
}

func (s *ShowEventsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEventsStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowEventsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowEventsStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowEventsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowEventsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowEventsStatementContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVENTS, 0)
}

func (s *ShowEventsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowEventsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowEventsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowEventsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowEventsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowEventsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowEventsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowEventsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEventsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEventsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowEventsStatement(s)
	}
}

func (s *ShowEventsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowEventsStatement(s)
	}
}

func (s *ShowEventsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowEventsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowEventsStatement() (localctx IShowEventsStatementContext) {
	localctx = NewShowEventsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, StarRocksParserRULE_showEventsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4428)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4429)
		p.Match(StarRocksParserEVENTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4430)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4431)

			var _x = p.QualifiedName()

			localctx.(*ShowEventsStatementContext).catalog = _x
		}

	}
	p.SetState(4438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4434)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4435)

			var _x = p.String_()

			localctx.(*ShowEventsStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4436)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4437)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEnginesStatementContext is an interface to support dynamic dispatch.
type IShowEnginesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ENGINES() antlr.TerminalNode

	// IsShowEnginesStatementContext differentiates from other interfaces.
	IsShowEnginesStatementContext()
}

type ShowEnginesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowEnginesStatementContext() *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEnginesStatement
	return p
}

func InitEmptyShowEnginesStatementContext(p *ShowEnginesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEnginesStatement
}

func (*ShowEnginesStatementContext) IsShowEnginesStatementContext() {}

func NewShowEnginesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showEnginesStatement

	return p
}

func (s *ShowEnginesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEnginesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowEnginesStatementContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINES, 0)
}

func (s *ShowEnginesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEnginesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEnginesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowEnginesStatement(s)
	}
}

func (s *ShowEnginesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowEnginesStatement(s)
	}
}

func (s *ShowEnginesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowEnginesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowEnginesStatement() (localctx IShowEnginesStatementContext) {
	localctx = NewShowEnginesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, StarRocksParserRULE_showEnginesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4440)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4441)
		p.Match(StarRocksParserENGINES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFrontendsStatementContext is an interface to support dynamic dispatch.
type IShowFrontendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode

	// IsShowFrontendsStatementContext differentiates from other interfaces.
	IsShowFrontendsStatementContext()
}

type ShowFrontendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFrontendsStatementContext() *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFrontendsStatement
	return p
}

func InitEmptyShowFrontendsStatementContext(p *ShowFrontendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFrontendsStatement
}

func (*ShowFrontendsStatementContext) IsShowFrontendsStatementContext() {}

func NewShowFrontendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showFrontendsStatement

	return p
}

func (s *ShowFrontendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFrontendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowFrontendsStatementContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTENDS, 0)
}

func (s *ShowFrontendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFrontendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFrontendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowFrontendsStatement(s)
	}
}

func (s *ShowFrontendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowFrontendsStatement(s)
	}
}

func (s *ShowFrontendsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowFrontendsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowFrontendsStatement() (localctx IShowFrontendsStatementContext) {
	localctx = NewShowFrontendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, StarRocksParserRULE_showFrontendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4443)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4444)
		p.Match(StarRocksParserFRONTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPluginsStatementContext is an interface to support dynamic dispatch.
type IShowPluginsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode

	// IsShowPluginsStatementContext differentiates from other interfaces.
	IsShowPluginsStatementContext()
}

type ShowPluginsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPluginsStatementContext() *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPluginsStatement
	return p
}

func InitEmptyShowPluginsStatementContext(p *ShowPluginsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPluginsStatement
}

func (*ShowPluginsStatementContext) IsShowPluginsStatementContext() {}

func NewShowPluginsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPluginsStatement

	return p
}

func (s *ShowPluginsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPluginsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPluginsStatementContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGINS, 0)
}

func (s *ShowPluginsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPluginsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPluginsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPluginsStatement(s)
	}
}

func (s *ShowPluginsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPluginsStatement(s)
	}
}

func (s *ShowPluginsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowPluginsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowPluginsStatement() (localctx IShowPluginsStatementContext) {
	localctx = NewShowPluginsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, StarRocksParserRULE_showPluginsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4446)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4447)
		p.Match(StarRocksParserPLUGINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRepositoriesStatementContext is an interface to support dynamic dispatch.
type IShowRepositoriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode

	// IsShowRepositoriesStatementContext differentiates from other interfaces.
	IsShowRepositoriesStatementContext()
}

type ShowRepositoriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRepositoriesStatementContext() *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRepositoriesStatement
	return p
}

func InitEmptyShowRepositoriesStatementContext(p *ShowRepositoriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRepositoriesStatement
}

func (*ShowRepositoriesStatementContext) IsShowRepositoriesStatementContext() {}

func NewShowRepositoriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRepositoriesStatement

	return p
}

func (s *ShowRepositoriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRepositoriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRepositoriesStatementContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORIES, 0)
}

func (s *ShowRepositoriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRepositoriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRepositoriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRepositoriesStatement(s)
	}
}

func (s *ShowRepositoriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRepositoriesStatement(s)
	}
}

func (s *ShowRepositoriesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowRepositoriesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowRepositoriesStatement() (localctx IShowRepositoriesStatementContext) {
	localctx = NewShowRepositoriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, StarRocksParserRULE_showRepositoriesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4449)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4450)
		p.Match(StarRocksParserREPOSITORIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowOpenTableStatementContext is an interface to support dynamic dispatch.
type IShowOpenTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsShowOpenTableStatementContext differentiates from other interfaces.
	IsShowOpenTableStatementContext()
}

type ShowOpenTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowOpenTableStatementContext() *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showOpenTableStatement
	return p
}

func InitEmptyShowOpenTableStatementContext(p *ShowOpenTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showOpenTableStatement
}

func (*ShowOpenTableStatementContext) IsShowOpenTableStatementContext() {}

func NewShowOpenTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showOpenTableStatement

	return p
}

func (s *ShowOpenTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowOpenTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowOpenTableStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPEN, 0)
}

func (s *ShowOpenTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowOpenTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowOpenTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowOpenTableStatement(s)
	}
}

func (s *ShowOpenTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowOpenTableStatement(s)
	}
}

func (s *ShowOpenTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowOpenTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowOpenTableStatement() (localctx IShowOpenTableStatementContext) {
	localctx = NewShowOpenTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, StarRocksParserRULE_showOpenTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4452)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4453)
		p.Match(StarRocksParserOPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4454)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPrivilegesStatementContext is an interface to support dynamic dispatch.
type IShowPrivilegesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsShowPrivilegesStatementContext differentiates from other interfaces.
	IsShowPrivilegesStatementContext()
}

type ShowPrivilegesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPrivilegesStatementContext() *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPrivilegesStatement
	return p
}

func InitEmptyShowPrivilegesStatementContext(p *ShowPrivilegesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPrivilegesStatement
}

func (*ShowPrivilegesStatementContext) IsShowPrivilegesStatementContext() {}

func NewShowPrivilegesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPrivilegesStatement

	return p
}

func (s *ShowPrivilegesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPrivilegesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPrivilegesStatementContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPrivilegesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPrivilegesStatement(s)
	}
}

func (s *ShowPrivilegesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPrivilegesStatement(s)
	}
}

func (s *ShowPrivilegesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowPrivilegesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowPrivilegesStatement() (localctx IShowPrivilegesStatementContext) {
	localctx = NewShowPrivilegesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, StarRocksParserRULE_showPrivilegesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4456)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4457)
		p.Match(StarRocksParserPRIVILEGES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcedureStatementContext is an interface to support dynamic dispatch.
type IShowProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	String_() IStringContext
	Expression() IExpressionContext

	// IsShowProcedureStatementContext differentiates from other interfaces.
	IsShowProcedureStatementContext()
}

type ShowProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
	where   IExpressionContext
}

func NewEmptyShowProcedureStatementContext() *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcedureStatement
	return p
}

func InitEmptyShowProcedureStatementContext(p *ShowProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcedureStatement
}

func (*ShowProcedureStatementContext) IsShowProcedureStatementContext() {}

func NewShowProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProcedureStatement

	return p
}

func (s *ShowProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcedureStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowProcedureStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowProcedureStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowProcedureStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowProcedureStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProcedureStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowProcedureStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROCEDURE, 0)
}

func (s *ShowProcedureStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *ShowProcedureStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowProcedureStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowProcedureStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcedureStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProcedureStatement(s)
	}
}

func (s *ShowProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProcedureStatement(s)
	}
}

func (s *ShowProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowProcedureStatement() (localctx IShowProcedureStatementContext) {
	localctx = NewShowProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, StarRocksParserRULE_showProcedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4459)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4460)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFUNCTION || _la == StarRocksParserPROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4461)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4462)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4463)

			var _x = p.String_()

			localctx.(*ShowProcedureStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4464)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4465)

			var _x = p.expression(0)

			localctx.(*ShowProcedureStatementContext).where = _x
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcStatementContext is an interface to support dynamic dispatch.
type IShowProcStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path rule contexts.
	GetPath() IStringContext

	// SetPath sets the path rule contexts.
	SetPath(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROC() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcStatementContext differentiates from other interfaces.
	IsShowProcStatementContext()
}

type ShowProcStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	path   IStringContext
}

func NewEmptyShowProcStatementContext() *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcStatement
	return p
}

func InitEmptyShowProcStatementContext(p *ShowProcStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcStatement
}

func (*ShowProcStatementContext) IsShowProcStatementContext() {}

func NewShowProcStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProcStatement

	return p
}

func (s *ShowProcStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcStatementContext) GetPath() IStringContext { return s.path }

func (s *ShowProcStatementContext) SetPath(v IStringContext) { s.path = v }

func (s *ShowProcStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProcStatementContext) PROC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROC, 0)
}

func (s *ShowProcStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProcStatement(s)
	}
}

func (s *ShowProcStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProcStatement(s)
	}
}

func (s *ShowProcStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowProcStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowProcStatement() (localctx IShowProcStatementContext) {
	localctx = NewShowProcStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, StarRocksParserRULE_showProcStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4468)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4469)
		p.Match(StarRocksParserPROC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4470)

		var _x = p.String_()

		localctx.(*ShowProcStatementContext).path = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcesslistStatementContext is an interface to support dynamic dispatch.
type IShowProcesslistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcesslistStatementContext differentiates from other interfaces.
	IsShowProcesslistStatementContext()
}

type ShowProcesslistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProcesslistStatementContext() *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcesslistStatement
	return p
}

func InitEmptyShowProcesslistStatementContext(p *ShowProcesslistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcesslistStatement
}

func (*ShowProcesslistStatementContext) IsShowProcesslistStatementContext() {}

func NewShowProcesslistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProcesslistStatement

	return p
}

func (s *ShowProcesslistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcesslistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProcesslistStatementContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROCESSLIST, 0)
}

func (s *ShowProcesslistStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowProcesslistStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowProcesslistStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcesslistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcesslistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcesslistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProcesslistStatement(s)
	}
}

func (s *ShowProcesslistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProcesslistStatement(s)
	}
}

func (s *ShowProcesslistStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowProcesslistStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowProcesslistStatement() (localctx IShowProcesslistStatementContext) {
	localctx = NewShowProcesslistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, StarRocksParserRULE_showProcesslistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4472)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(4473)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4476)
		p.Match(StarRocksParserPROCESSLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(4477)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4478)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProfilelistStatementContext is an interface to support dynamic dispatch.
type IShowProfilelistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowProfilelistStatementContext differentiates from other interfaces.
	IsShowProfilelistStatementContext()
}

type ShowProfilelistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowProfilelistStatementContext() *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProfilelistStatement
	return p
}

func InitEmptyShowProfilelistStatementContext(p *ShowProfilelistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProfilelistStatement
}

func (*ShowProfilelistStatementContext) IsShowProfilelistStatementContext() {}

func NewShowProfilelistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProfilelistStatement

	return p
}

func (s *ShowProfilelistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfilelistStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowProfilelistStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowProfilelistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProfilelistStatementContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILELIST, 0)
}

func (s *ShowProfilelistStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIMIT, 0)
}

func (s *ShowProfilelistStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ShowProfilelistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfilelistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProfilelistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProfilelistStatement(s)
	}
}

func (s *ShowProfilelistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProfilelistStatement(s)
	}
}

func (s *ShowProfilelistStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowProfilelistStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowProfilelistStatement() (localctx IShowProfilelistStatementContext) {
	localctx = NewShowProfilelistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, StarRocksParserRULE_showProfilelistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4481)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4482)
		p.Match(StarRocksParserPROFILELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4483)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4484)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*ShowProfilelistStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRunningQueriesStatementContext is an interface to support dynamic dispatch.
type IShowRunningQueriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowRunningQueriesStatementContext differentiates from other interfaces.
	IsShowRunningQueriesStatementContext()
}

type ShowRunningQueriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowRunningQueriesStatementContext() *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRunningQueriesStatement
	return p
}

func InitEmptyShowRunningQueriesStatementContext(p *ShowRunningQueriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRunningQueriesStatement
}

func (*ShowRunningQueriesStatementContext) IsShowRunningQueriesStatementContext() {}

func NewShowRunningQueriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRunningQueriesStatement

	return p
}

func (s *ShowRunningQueriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRunningQueriesStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowRunningQueriesStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowRunningQueriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRunningQueriesStatementContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRUNNING, 0)
}

func (s *ShowRunningQueriesStatementContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERIES, 0)
}

func (s *ShowRunningQueriesStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIMIT, 0)
}

func (s *ShowRunningQueriesStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ShowRunningQueriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRunningQueriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRunningQueriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRunningQueriesStatement(s)
	}
}

func (s *ShowRunningQueriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRunningQueriesStatement(s)
	}
}

func (s *ShowRunningQueriesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowRunningQueriesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowRunningQueriesStatement() (localctx IShowRunningQueriesStatementContext) {
	localctx = NewShowRunningQueriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, StarRocksParserRULE_showRunningQueriesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4487)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4488)
		p.Match(StarRocksParserRUNNING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4489)
		p.Match(StarRocksParserQUERIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4490)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4491)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*ShowRunningQueriesStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatusStatementContext is an interface to support dynamic dispatch.
type IShowStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowStatusStatementContext differentiates from other interfaces.
	IsShowStatusStatementContext()
}

type ShowStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStatusStatementContext() *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatusStatement
	return p
}

func InitEmptyShowStatusStatementContext(p *ShowStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatusStatement
}

func (*ShowStatusStatementContext) IsShowStatusStatementContext() {}

func NewShowStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStatusStatement

	return p
}

func (s *ShowStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowStatusStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStatusStatement(s)
	}
}

func (s *ShowStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStatusStatement(s)
	}
}

func (s *ShowStatusStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowStatusStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowStatusStatement() (localctx IShowStatusStatementContext) {
	localctx = NewShowStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, StarRocksParserRULE_showStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4494)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE {
		{
			p.SetState(4495)
			p.VarType()
		}

	}
	{
		p.SetState(4498)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4499)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4500)

			var _x = p.String_()

			localctx.(*ShowStatusStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4501)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4502)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTabletStatementContext is an interface to support dynamic dispatch.
type IShowTabletStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLETS() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowTabletStatementContext differentiates from other interfaces.
	IsShowTabletStatementContext()
}

type ShowTabletStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowTabletStatementContext() *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTabletStatement
	return p
}

func InitEmptyShowTabletStatementContext(p *ShowTabletStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTabletStatement
}

func (*ShowTabletStatementContext) IsShowTabletStatementContext() {}

func NewShowTabletStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTabletStatement

	return p
}

func (s *ShowTabletStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTabletStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTabletStatementContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *ShowTabletStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ShowTabletStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTabletStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTabletStatementContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLETS, 0)
}

func (s *ShowTabletStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowTabletStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTabletStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTabletStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowTabletStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowTabletStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowTabletStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowTabletStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowTabletStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTabletStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTabletStatement(s)
	}
}

func (s *ShowTabletStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTabletStatement(s)
	}
}

func (s *ShowTabletStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowTabletStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowTabletStatement() (localctx IShowTabletStatementContext) {
	localctx = NewShowTabletStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, StarRocksParserRULE_showTabletStatement)
	var _la int

	p.SetState(4534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4505)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4506)
			p.Match(StarRocksParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4507)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4508)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4509)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserTABLET || _la == StarRocksParserTABLETS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4510)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4511)
			p.QualifiedName()
		}
		p.SetState(4513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(4512)
				p.PartitionNames()
			}

		}
		p.SetState(4517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4515)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4516)
				p.expression(0)
			}

		}
		p.SetState(4529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(4519)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4520)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4521)
				p.SortItem()
			}
			p.SetState(4526)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(4522)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4523)
					p.SortItem()
				}

				p.SetState(4528)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(4532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(4531)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTransactionStatementContext is an interface to support dynamic dispatch.
type IShowTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowTransactionStatementContext differentiates from other interfaces.
	IsShowTransactionStatementContext()
}

type ShowTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowTransactionStatementContext() *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTransactionStatement
	return p
}

func InitEmptyShowTransactionStatementContext(p *ShowTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTransactionStatement
}

func (*ShowTransactionStatementContext) IsShowTransactionStatementContext() {}

func NewShowTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTransactionStatement

	return p
}

func (s *ShowTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTransactionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTransactionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTransactionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *ShowTransactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTransactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTransactionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTransactionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTransactionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTransactionStatement(s)
	}
}

func (s *ShowTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTransactionStatement(s)
	}
}

func (s *ShowTransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowTransactionStatement() (localctx IShowTransactionStatementContext) {
	localctx = NewShowTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, StarRocksParserRULE_showTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4536)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4537)
		p.Match(StarRocksParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4538)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4539)

			var _x = p.QualifiedName()

			localctx.(*ShowTransactionStatementContext).db = _x
		}

	}
	p.SetState(4544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(4542)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4543)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTriggersStatementContext is an interface to support dynamic dispatch.
type IShowTriggersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTriggersStatementContext differentiates from other interfaces.
	IsShowTriggersStatementContext()
}

type ShowTriggersStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTriggersStatementContext() *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTriggersStatement
	return p
}

func InitEmptyShowTriggersStatementContext(p *ShowTriggersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTriggersStatement
}

func (*ShowTriggersStatementContext) IsShowTriggersStatementContext() {}

func NewShowTriggersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTriggersStatement

	return p
}

func (s *ShowTriggersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTriggersStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowTriggersStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTriggersStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowTriggersStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTriggersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTriggersStatementContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIGGERS, 0)
}

func (s *ShowTriggersStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowTriggersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTriggersStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTriggersStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTriggersStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTriggersStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTriggersStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTriggersStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTriggersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTriggersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTriggersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTriggersStatement(s)
	}
}

func (s *ShowTriggersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTriggersStatement(s)
	}
}

func (s *ShowTriggersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowTriggersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowTriggersStatement() (localctx IShowTriggersStatementContext) {
	localctx = NewShowTriggersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, StarRocksParserRULE_showTriggersStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4546)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(4547)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4550)
		p.Match(StarRocksParserTRIGGERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4551)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4552)

			var _x = p.QualifiedName()

			localctx.(*ShowTriggersStatementContext).catalog = _x
		}

	}
	p.SetState(4559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4555)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4556)

			var _x = p.String_()

			localctx.(*ShowTriggersStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4557)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4558)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserPropertyStatementContext is an interface to support dynamic dispatch.
type IShowUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode

	// IsShowUserPropertyStatementContext differentiates from other interfaces.
	IsShowUserPropertyStatementContext()
}

type ShowUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserPropertyStatementContext() *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserPropertyStatement
	return p
}

func InitEmptyShowUserPropertyStatementContext(p *ShowUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserPropertyStatement
}

func (*ShowUserPropertyStatementContext) IsShowUserPropertyStatementContext() {}

func NewShowUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showUserPropertyStatement

	return p
}

func (s *ShowUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserPropertyStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTY, 0)
}

func (s *ShowUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowUserPropertyStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowUserPropertyStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowUserPropertyStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *ShowUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowUserPropertyStatement(s)
	}
}

func (s *ShowUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowUserPropertyStatement(s)
	}
}

func (s *ShowUserPropertyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowUserPropertyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowUserPropertyStatement() (localctx IShowUserPropertyStatementContext) {
	localctx = NewShowUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, StarRocksParserRULE_showUserPropertyStatement)
	var _la int

	p.SetState(4581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4561)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4562)
			p.Match(StarRocksParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(4563)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4564)
				p.String_()
			}

		}
		p.SetState(4569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIKE {
			{
				p.SetState(4567)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4568)
				p.String_()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4571)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4572)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(4573)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4574)
				p.String_()
			}

		}
		p.SetState(4579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIKE {
			{
				p.SetState(4577)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4578)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowVariablesStatementContext is an interface to support dynamic dispatch.
type IShowVariablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowVariablesStatementContext differentiates from other interfaces.
	IsShowVariablesStatementContext()
}

type ShowVariablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowVariablesStatementContext() *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showVariablesStatement
	return p
}

func InitEmptyShowVariablesStatementContext(p *ShowVariablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showVariablesStatement
}

func (*ShowVariablesStatementContext) IsShowVariablesStatementContext() {}

func NewShowVariablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showVariablesStatement

	return p
}

func (s *ShowVariablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowVariablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowVariablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowVariablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowVariablesStatementContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARIABLES, 0)
}

func (s *ShowVariablesStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowVariablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowVariablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowVariablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowVariablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowVariablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowVariablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowVariablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowVariablesStatement(s)
	}
}

func (s *ShowVariablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowVariablesStatement(s)
	}
}

func (s *ShowVariablesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowVariablesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowVariablesStatement() (localctx IShowVariablesStatementContext) {
	localctx = NewShowVariablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, StarRocksParserRULE_showVariablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4583)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE {
		{
			p.SetState(4584)
			p.VarType()
		}

	}
	{
		p.SetState(4587)
		p.Match(StarRocksParserVARIABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4588)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4589)

			var _x = p.String_()

			localctx.(*ShowVariablesStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4590)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4591)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarningStatementContext is an interface to support dynamic dispatch.
type IShowWarningStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	LimitElement() ILimitElementContext

	// IsShowWarningStatementContext differentiates from other interfaces.
	IsShowWarningStatementContext()
}

type ShowWarningStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWarningStatementContext() *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarningStatement
	return p
}

func InitEmptyShowWarningStatementContext(p *ShowWarningStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarningStatement
}

func (*ShowWarningStatementContext) IsShowWarningStatementContext() {}

func NewShowWarningStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showWarningStatement

	return p
}

func (s *ShowWarningStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarningStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowWarningStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWARNINGS, 0)
}

func (s *ShowWarningStatementContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserERRORS, 0)
}

func (s *ShowWarningStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowWarningStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarningStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowWarningStatement(s)
	}
}

func (s *ShowWarningStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowWarningStatement(s)
	}
}

func (s *ShowWarningStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowWarningStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowWarningStatement() (localctx IShowWarningStatementContext) {
	localctx = NewShowWarningStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, StarRocksParserRULE_showWarningStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4594)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4595)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserERRORS || _la == StarRocksParserWARNINGS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4596)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_helpStatement
	return p
}

func InitEmptyHelpStatementContext(p *HelpStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_helpStatement
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHELP, 0)
}

func (s *HelpStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (s *HelpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitHelpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) HelpStatement() (localctx IHelpStatementContext) {
	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, StarRocksParserRULE_helpStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4599)
		p.Match(StarRocksParserHELP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4600)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserStatementContext is an interface to support dynamic dispatch.
type ICreateUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AuthOption() IAuthOptionContext
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	Properties() IPropertiesContext

	// IsCreateUserStatementContext differentiates from other interfaces.
	IsCreateUserStatementContext()
}

type CreateUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserStatementContext() *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createUserStatement
	return p
}

func InitEmptyCreateUserStatementContext(p *CreateUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createUserStatement
}

func (*CreateUserStatementContext) IsCreateUserStatementContext() {}

func NewCreateUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createUserStatement

	return p
}

func (s *CreateUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *CreateUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateUserStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *CreateUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *CreateUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *CreateUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateUserStatement(s)
	}
}

func (s *CreateUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateUserStatement(s)
	}
}

func (s *CreateUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateUserStatement() (localctx ICreateUserStatementContext) {
	localctx = NewCreateUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, StarRocksParserRULE_createUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4602)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4603)
		p.Match(StarRocksParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4604)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4605)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4606)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4609)
		p.User()
	}
	p.SetState(4611)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIDENTIFIED {
		{
			p.SetState(4610)
			p.AuthOption()
		}

	}
	p.SetState(4616)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFAULT {
		{
			p.SetState(4613)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4614)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4615)
			p.RoleList()
		}

	}
	p.SetState(4619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(4618)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserStatementContext is an interface to support dynamic dispatch.
type IDropUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropUserStatementContext differentiates from other interfaces.
	IsDropUserStatementContext()
}

type DropUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserStatementContext() *DropUserStatementContext {
	var p = new(DropUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropUserStatement
	return p
}

func InitEmptyDropUserStatementContext(p *DropUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropUserStatement
}

func (*DropUserStatementContext) IsDropUserStatementContext() {}

func NewDropUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserStatementContext {
	var p = new(DropUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropUserStatement

	return p
}

func (s *DropUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *DropUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DropUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropUserStatement(s)
	}
}

func (s *DropUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropUserStatement(s)
	}
}

func (s *DropUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropUserStatement() (localctx IDropUserStatementContext) {
	localctx = NewDropUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, StarRocksParserRULE_dropUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4621)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4622)
		p.Match(StarRocksParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4623)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4624)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4627)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserStatementContext is an interface to support dynamic dispatch.
type IAlterUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	AuthOption() IAuthOptionContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterUserStatementContext differentiates from other interfaces.
	IsAlterUserStatementContext()
}

type AlterUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserStatementContext() *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterUserStatement
	return p
}

func InitEmptyAlterUserStatementContext(p *AlterUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterUserStatement
}

func (*AlterUserStatementContext) IsAlterUserStatementContext() {}

func NewAlterUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterUserStatement

	return p
}

func (s *AlterUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *AlterUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *AlterUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *AlterUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *AlterUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *AlterUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *AlterUserStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *AlterUserStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AlterUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterUserStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterUserStatement(s)
	}
}

func (s *AlterUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterUserStatement(s)
	}
}

func (s *AlterUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterUserStatement() (localctx IAlterUserStatementContext) {
	localctx = NewAlterUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, StarRocksParserRULE_alterUserStatement)
	var _la int

	p.SetState(4662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4629)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4630)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(4631)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4632)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4635)
			p.User()
		}
		{
			p.SetState(4636)
			p.AuthOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4638)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4639)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(4640)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4641)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4644)
			p.User()
		}
		{
			p.SetState(4645)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4646)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 502, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4647)
				p.Match(StarRocksParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(4648)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(4649)
				p.RoleList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4652)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4653)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(4654)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4655)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4658)
			p.User()
		}
		{
			p.SetState(4659)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4660)
			p.Properties()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserStatementContext is an interface to support dynamic dispatch.
type IShowUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode

	// IsShowUserStatementContext differentiates from other interfaces.
	IsShowUserStatementContext()
}

type ShowUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserStatementContext() *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserStatement
	return p
}

func InitEmptyShowUserStatementContext(p *ShowUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserStatement
}

func (*ShowUserStatementContext) IsShowUserStatementContext() {}

func NewShowUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showUserStatement

	return p
}

func (s *ShowUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *ShowUserStatementContext) USERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSERS, 0)
}

func (s *ShowUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowUserStatement(s)
	}
}

func (s *ShowUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowUserStatement(s)
	}
}

func (s *ShowUserStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowUserStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowUserStatement() (localctx IShowUserStatementContext) {
	localctx = NewShowUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, StarRocksParserRULE_showUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4664)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4665)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserUSER || _la == StarRocksParserUSERS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthenticationStatementContext is an interface to support dynamic dispatch.
type IShowAuthenticationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowAuthenticationStatementContext differentiates from other interfaces.
	IsShowAuthenticationStatementContext()
}

type ShowAuthenticationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthenticationStatementContext() *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthenticationStatement
	return p
}

func InitEmptyShowAuthenticationStatementContext(p *ShowAuthenticationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthenticationStatement
}

func (*ShowAuthenticationStatementContext) IsShowAuthenticationStatementContext() {}

func NewShowAuthenticationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAuthenticationStatement

	return p
}

func (s *ShowAuthenticationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthenticationStatementContext) CopyAll(ctx *ShowAuthenticationStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowAuthenticationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowAllAuthenticationContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAllAuthenticationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAllAuthenticationContext {
	var p = new(ShowAllAuthenticationContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAllAuthenticationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAllAuthenticationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAllAuthenticationContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowAllAuthenticationContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHENTICATION, 0)
}

func (s *ShowAllAuthenticationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAllAuthentication(s)
	}
}

func (s *ShowAllAuthenticationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAllAuthentication(s)
	}
}

func (s *ShowAllAuthenticationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowAllAuthentication(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAuthenticationForUserContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAuthenticationForUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAuthenticationForUserContext {
	var p = new(ShowAuthenticationForUserContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAuthenticationForUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationForUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAuthenticationForUserContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHENTICATION, 0)
}

func (s *ShowAuthenticationForUserContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowAuthenticationForUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowAuthenticationForUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAuthenticationForUser(s)
	}
}

func (s *ShowAuthenticationForUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAuthenticationForUser(s)
	}
}

func (s *ShowAuthenticationForUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowAuthenticationForUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowAuthenticationStatement() (localctx IShowAuthenticationStatementContext) {
	localctx = NewShowAuthenticationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, StarRocksParserRULE_showAuthenticationStatement)
	var _la int

	p.SetState(4676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowAllAuthenticationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4667)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4668)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4669)
			p.Match(StarRocksParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewShowAuthenticationForUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4670)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4671)
			p.Match(StarRocksParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(4672)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4673)
				p.User()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteAsStatementContext is an interface to support dynamic dispatch.
type IExecuteAsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	AS() antlr.TerminalNode
	User() IUserContext
	WITH() antlr.TerminalNode
	NO() antlr.TerminalNode
	REVERT() antlr.TerminalNode

	// IsExecuteAsStatementContext differentiates from other interfaces.
	IsExecuteAsStatementContext()
}

type ExecuteAsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteAsStatementContext() *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeAsStatement
	return p
}

func InitEmptyExecuteAsStatementContext(p *ExecuteAsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeAsStatement
}

func (*ExecuteAsStatementContext) IsExecuteAsStatementContext() {}

func NewExecuteAsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_executeAsStatement

	return p
}

func (s *ExecuteAsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteAsStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *ExecuteAsStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *ExecuteAsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ExecuteAsStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ExecuteAsStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, 0)
}

func (s *ExecuteAsStatementContext) REVERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVERT, 0)
}

func (s *ExecuteAsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteAsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteAsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExecuteAsStatement(s)
	}
}

func (s *ExecuteAsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExecuteAsStatement(s)
	}
}

func (s *ExecuteAsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExecuteAsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExecuteAsStatement() (localctx IExecuteAsStatementContext) {
	localctx = NewExecuteAsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, StarRocksParserRULE_executeAsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4678)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4679)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4680)
		p.User()
	}
	p.SetState(4684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(4681)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4682)
			p.Match(StarRocksParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4683)
			p.Match(StarRocksParserREVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleStatementContext is an interface to support dynamic dispatch.
type ICreateRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateRoleStatementContext differentiates from other interfaces.
	IsCreateRoleStatementContext()
}

type CreateRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleStatementContext() *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoleStatement
	return p
}

func InitEmptyCreateRoleStatementContext(p *CreateRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoleStatement
}

func (*CreateRoleStatementContext) IsCreateRoleStatementContext() {}

func NewCreateRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createRoleStatement

	return p
}

func (s *CreateRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *CreateRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateRoleStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateRoleStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateRoleStatement() (localctx ICreateRoleStatementContext) {
	localctx = NewCreateRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, StarRocksParserRULE_createRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4686)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4687)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4688)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4689)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4690)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4693)
		p.RoleList()
	}
	p.SetState(4695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(4694)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoleStatementContext is an interface to support dynamic dispatch.
type IAlterRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsAlterRoleStatementContext differentiates from other interfaces.
	IsAlterRoleStatementContext()
}

type AlterRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoleStatementContext() *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoleStatement
	return p
}

func InitEmptyAlterRoleStatementContext(p *AlterRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoleStatement
}

func (*AlterRoleStatementContext) IsAlterRoleStatementContext() {}

func NewAlterRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterRoleStatement

	return p
}

func (s *AlterRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoleStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *AlterRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterRoleStatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *AlterRoleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *AlterRoleStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *AlterRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *AlterRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterRoleStatement(s)
	}
}

func (s *AlterRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterRoleStatement(s)
	}
}

func (s *AlterRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterRoleStatement() (localctx IAlterRoleStatementContext) {
	localctx = NewAlterRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, StarRocksParserRULE_alterRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4697)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4698)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4699)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4700)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4703)
		p.RoleList()
	}
	{
		p.SetState(4704)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4705)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4706)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4707)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleStatementContext is an interface to support dynamic dispatch.
type IDropRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropRoleStatementContext differentiates from other interfaces.
	IsDropRoleStatementContext()
}

type DropRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleStatementContext() *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRoleStatement
	return p
}

func InitEmptyDropRoleStatementContext(p *DropRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRoleStatement
}

func (*DropRoleStatementContext) IsDropRoleStatementContext() {}

func NewDropRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropRoleStatement

	return p
}

func (s *DropRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *DropRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *DropRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropRoleStatement() (localctx IDropRoleStatementContext) {
	localctx = NewDropRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, StarRocksParserRULE_dropRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4709)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4710)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4711)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4712)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4715)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRolesStatementContext is an interface to support dynamic dispatch.
type IShowRolesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROLES() antlr.TerminalNode

	// IsShowRolesStatementContext differentiates from other interfaces.
	IsShowRolesStatementContext()
}

type ShowRolesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRolesStatementContext() *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRolesStatement
	return p
}

func InitEmptyShowRolesStatementContext(p *ShowRolesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRolesStatement
}

func (*ShowRolesStatementContext) IsShowRolesStatementContext() {}

func NewShowRolesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRolesStatement

	return p
}

func (s *ShowRolesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRolesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRolesStatementContext) ROLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLES, 0)
}

func (s *ShowRolesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRolesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRolesStatement(s)
	}
}

func (s *ShowRolesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRolesStatement(s)
	}
}

func (s *ShowRolesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowRolesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowRolesStatement() (localctx IShowRolesStatementContext) {
	localctx = NewShowRolesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, StarRocksParserRULE_showRolesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4717)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4718)
		p.Match(StarRocksParserROLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRoleStatementContext is an interface to support dynamic dispatch.
type IGrantRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantRoleStatementContext differentiates from other interfaces.
	IsGrantRoleStatementContext()
}

type GrantRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRoleStatementContext() *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRoleStatement
	return p
}

func InitEmptyGrantRoleStatementContext(p *GrantRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRoleStatement
}

func (*GrantRoleStatementContext) IsGrantRoleStatementContext() {}

func NewGrantRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_grantRoleStatement

	return p
}

func (s *GrantRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRoleStatementContext) CopyAll(ctx *GrantRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantRoleToUserContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToUserContext {
	var p = new(GrantRoleToUserContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToUserContext) GRANT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, 0)
}

func (s *GrantRoleToUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToUserContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantRoleToUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRoleToUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *GrantRoleToUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantRoleToUser(s)
	}
}

func (s *GrantRoleToUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantRoleToUser(s)
	}
}

func (s *GrantRoleToUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantRoleToUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantRoleToRoleContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToRoleContext {
	var p = new(GrantRoleToRoleContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantRoleToRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRoleToRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantRoleToRole(s)
	}
}

func (s *GrantRoleToRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantRoleToRole(s)
	}
}

func (s *GrantRoleToRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantRoleToRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) GrantRoleStatement() (localctx IGrantRoleStatementContext) {
	localctx = NewGrantRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, StarRocksParserRULE_grantRoleStatement)
	p.SetState(4734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 513, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantRoleToUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4720)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4721)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4722)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4724)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 512, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4723)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4726)
			p.User()
		}

	case 2:
		localctx = NewGrantRoleToRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4728)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4729)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4730)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4731)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4732)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeRoleStatementContext is an interface to support dynamic dispatch.
type IRevokeRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeRoleStatementContext differentiates from other interfaces.
	IsRevokeRoleStatementContext()
}

type RevokeRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeRoleStatementContext() *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokeRoleStatement
	return p
}

func InitEmptyRevokeRoleStatementContext(p *RevokeRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokeRoleStatement
}

func (*RevokeRoleStatementContext) IsRevokeRoleStatementContext() {}

func NewRevokeRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_revokeRoleStatement

	return p
}

func (s *RevokeRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeRoleStatementContext) CopyAll(ctx *RevokeRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokeRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeRoleFromUserContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromUserContext {
	var p = new(RevokeRoleFromUserContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeRoleFromUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeRoleFromUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeRoleFromUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *RevokeRoleFromUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeRoleFromUser(s)
	}
}

func (s *RevokeRoleFromUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeRoleFromUser(s)
	}
}

func (s *RevokeRoleFromUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeRoleFromUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeRoleFromRoleContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromRoleContext {
	var p = new(RevokeRoleFromRoleContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeRoleFromRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeRoleFromRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeRoleFromRole(s)
	}
}

func (s *RevokeRoleFromRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeRoleFromRole(s)
	}
}

func (s *RevokeRoleFromRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeRoleFromRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RevokeRoleStatement() (localctx IRevokeRoleStatementContext) {
	localctx = NewRevokeRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, StarRocksParserRULE_revokeRoleStatement)
	p.SetState(4750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeRoleFromUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4736)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4737)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4738)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4740)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4739)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4742)
			p.User()
		}

	case 2:
		localctx = NewRevokeRoleFromRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4744)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4745)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4746)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4747)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4748)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleStatementContext is an interface to support dynamic dispatch.
type ISetRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetRoleStatementContext differentiates from other interfaces.
	IsSetRoleStatementContext()
}

type SetRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleStatementContext() *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setRoleStatement
	return p
}

func InitEmptySetRoleStatementContext(p *SetRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setRoleStatement
}

func (*SetRoleStatementContext) IsSetRoleStatementContext() {}

func NewSetRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setRoleStatement

	return p
}

func (s *SetRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *SetRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *SetRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetRoleStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCEPT, 0)
}

func (s *SetRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetRoleStatement(s)
	}
}

func (s *SetRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetRoleStatement(s)
	}
}

func (s *SetRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetRoleStatement() (localctx ISetRoleStatementContext) {
	localctx = NewSetRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, StarRocksParserRULE_setRoleStatement)
	var _la int

	p.SetState(4768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4752)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4753)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4754)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4755)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4756)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4757)
			p.Match(StarRocksParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4758)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4759)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4760)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserEXCEPT {
			{
				p.SetState(4761)
				p.Match(StarRocksParserEXCEPT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4762)
				p.RoleList()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4765)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4766)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4767)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultRoleStatementContext is an interface to support dynamic dispatch.
type ISetDefaultRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	User() IUserContext
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetDefaultRoleStatementContext differentiates from other interfaces.
	IsSetDefaultRoleStatementContext()
}

type SetDefaultRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultRoleStatementContext() *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultRoleStatement
	return p
}

func InitEmptySetDefaultRoleStatementContext(p *SetDefaultRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultRoleStatement
}

func (*SetDefaultRoleStatementContext) IsSetDefaultRoleStatementContext() {}

func NewSetDefaultRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setDefaultRoleStatement

	return p
}

func (s *SetDefaultRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetDefaultRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetDefaultRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *SetDefaultRoleStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *SetDefaultRoleStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetDefaultRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *SetDefaultRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetDefaultRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetDefaultRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetDefaultRoleStatement(s)
	}
}

func (s *SetDefaultRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetDefaultRoleStatement(s)
	}
}

func (s *SetDefaultRoleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetDefaultRoleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetDefaultRoleStatement() (localctx ISetDefaultRoleStatementContext) {
	localctx = NewSetDefaultRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, StarRocksParserRULE_setDefaultRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4770)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4771)
		p.Match(StarRocksParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4772)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4776)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4773)
			p.Match(StarRocksParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4774)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4775)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4778)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4779)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRevokeClauseContext is an interface to support dynamic dispatch.
type IGrantRevokeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	USER() antlr.TerminalNode

	// IsGrantRevokeClauseContext differentiates from other interfaces.
	IsGrantRevokeClauseContext()
}

type GrantRevokeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRevokeClauseContext() *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRevokeClause
	return p
}

func InitEmptyGrantRevokeClauseContext(p *GrantRevokeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRevokeClause
}

func (*GrantRevokeClauseContext) IsGrantRevokeClauseContext() {}

func NewGrantRevokeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_grantRevokeClause

	return p
}

func (s *GrantRevokeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRevokeClauseContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRevokeClauseContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *GrantRevokeClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRevokeClauseContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *GrantRevokeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRevokeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantRevokeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantRevokeClause(s)
	}
}

func (s *GrantRevokeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantRevokeClause(s)
	}
}

func (s *GrantRevokeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantRevokeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) GrantRevokeClause() (localctx IGrantRevokeClauseContext) {
	localctx = NewGrantRevokeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, StarRocksParserRULE_grantRevokeClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4782)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4781)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4784)
			p.User()
		}

	case 2:
		{
			p.SetState(4785)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4786)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantPrivilegeStatementContext is an interface to support dynamic dispatch.
type IGrantPrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantPrivilegeStatementContext differentiates from other interfaces.
	IsGrantPrivilegeStatementContext()
}

type GrantPrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantPrivilegeStatementContext() *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantPrivilegeStatement
	return p
}

func InitEmptyGrantPrivilegeStatementContext(p *GrantPrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantPrivilegeStatement
}

func (*GrantPrivilegeStatementContext) IsGrantPrivilegeStatementContext() {}

func NewGrantPrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_grantPrivilegeStatement

	return p
}

func (s *GrantPrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantPrivilegeStatementContext) CopyAll(ctx *GrantPrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantPrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantPrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantOnAllContext struct {
	GrantPrivilegeStatementContext
	isAll antlr.Token
}

func NewGrantOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnAllContext {
	var p = new(GrantOnAllContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *GrantOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *GrantOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnAllContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnAllContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserALL)
}

func (s *GrantOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, i)
}

func (s *GrantOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *GrantOnAllContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *GrantOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *GrantOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *GrantOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantOnAllContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnAllContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnAll(s)
	}
}

func (s *GrantOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnAll(s)
	}
}

func (s *GrantOnAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantOnAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnFuncContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnFuncContext {
	var p = new(GrantOnFuncContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnFuncContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnFuncContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *GrantOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *GrantOnFuncContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *GrantOnFuncContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnFuncContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnFunc(s)
	}
}

func (s *GrantOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnFunc(s)
	}
}

func (s *GrantOnFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantOnFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnPrimaryObjContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnPrimaryObjContext {
	var p = new(GrantOnPrimaryObjContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnPrimaryObjContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnPrimaryObjContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *GrantOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnPrimaryObjContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnPrimaryObjContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnPrimaryObjContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnPrimaryObj(s)
	}
}

func (s *GrantOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnPrimaryObj(s)
	}
}

func (s *GrantOnPrimaryObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantOnPrimaryObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnTableBriefContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnTableBriefContext {
	var p = new(GrantOnTableBriefContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnTableBriefContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnTableBriefContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnTableBriefContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnTableBriefContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnTableBriefContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnTableBrief(s)
	}
}

func (s *GrantOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnTableBrief(s)
	}
}

func (s *GrantOnTableBriefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantOnTableBrief(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnUserContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnUserContext {
	var p = new(GrantOnUserContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnUserContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnUserContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *GrantOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *GrantOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *GrantOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantOnUserContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnUserContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnUserContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnUser(s)
	}
}

func (s *GrantOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnUser(s)
	}
}

func (s *GrantOnUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantOnUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantOnSystemContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnSystemContext {
	var p = new(GrantOnSystemContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnSystemContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnSystemContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *GrantOnSystemContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnSystemContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnSystem(s)
	}
}

func (s *GrantOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnSystem(s)
	}
}

func (s *GrantOnSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGrantOnSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) GrantPrivilegeStatement() (localctx IGrantPrivilegeStatementContext) {
	localctx = NewGrantPrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, StarRocksParserRULE_grantPrivilegeStatement)
	var _la int

	p.SetState(4877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 530, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4789)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4790)
			p.Match(StarRocksParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4791)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4792)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4793)
			p.User()
		}
		p.SetState(4798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4794)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4795)
				p.User()
			}

			p.SetState(4800)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4801)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4802)
			p.GrantRevokeClause()
		}
		p.SetState(4806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4803)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4804)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4805)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewGrantOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4808)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4809)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4810)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4811)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4812)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4813)
			p.GrantRevokeClause()
		}
		p.SetState(4817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4814)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4815)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4816)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewGrantOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4819)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4820)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4821)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserGLOBAL {
			{
				p.SetState(4822)
				p.Match(StarRocksParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4825)
			p.Match(StarRocksParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4826)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4827)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4828)
			p.GrantRevokeClause()
		}
		p.SetState(4832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4829)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4830)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4831)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewGrantOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4834)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4835)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4836)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4837)
			p.Match(StarRocksParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4838)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4839)
			p.GrantRevokeClause()
		}
		p.SetState(4843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4840)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4841)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4842)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewGrantOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4845)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4846)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4847)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4848)
			p.PrivObjectType()
		}
		{
			p.SetState(4849)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4850)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4851)
			p.GrantRevokeClause()
		}
		p.SetState(4855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4852)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4853)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4854)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewGrantOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4857)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4858)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4859)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4860)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4861)
			p.PrivObjectTypePlural()
		}
		p.SetState(4868)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4862)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4863)

				var _m = p.Match(StarRocksParserALL)

				localctx.(*GrantOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4864)
				p.Match(StarRocksParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 528, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4865)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4866)
				p.Match(StarRocksParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4867)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4870)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4871)
			p.GrantRevokeClause()
		}
		p.SetState(4875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4872)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4873)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4874)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokePrivilegeStatementContext is an interface to support dynamic dispatch.
type IRevokePrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokePrivilegeStatementContext differentiates from other interfaces.
	IsRevokePrivilegeStatementContext()
}

type RevokePrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokePrivilegeStatementContext() *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokePrivilegeStatement
	return p
}

func InitEmptyRevokePrivilegeStatementContext(p *RevokePrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokePrivilegeStatement
}

func (*RevokePrivilegeStatementContext) IsRevokePrivilegeStatementContext() {}

func NewRevokePrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_revokePrivilegeStatement

	return p
}

func (s *RevokePrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokePrivilegeStatementContext) CopyAll(ctx *RevokePrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokePrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokePrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeOnPrimaryObjContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnPrimaryObjContext {
	var p = new(RevokeOnPrimaryObjContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnPrimaryObjContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnPrimaryObjContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnPrimaryObj(s)
	}
}

func (s *RevokeOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnPrimaryObj(s)
	}
}

func (s *RevokeOnPrimaryObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeOnPrimaryObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnTableBriefContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnTableBriefContext {
	var p = new(RevokeOnTableBriefContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnTableBriefContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnTableBriefContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnTableBrief(s)
	}
}

func (s *RevokeOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnTableBrief(s)
	}
}

func (s *RevokeOnTableBriefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeOnTableBrief(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnAllContext struct {
	RevokePrivilegeStatementContext
	isAll antlr.Token
}

func NewRevokeOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnAllContext {
	var p = new(RevokeOnAllContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *RevokeOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *RevokeOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnAllContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserALL)
}

func (s *RevokeOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, i)
}

func (s *RevokeOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *RevokeOnAllContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *RevokeOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *RevokeOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *RevokeOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnAll(s)
	}
}

func (s *RevokeOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnAll(s)
	}
}

func (s *RevokeOnAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeOnAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnUserContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnUserContext {
	var p = new(RevokeOnUserContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *RevokeOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *RevokeOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *RevokeOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeOnUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnUser(s)
	}
}

func (s *RevokeOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnUser(s)
	}
}

func (s *RevokeOnUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeOnUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnFuncContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnFuncContext {
	var p = new(RevokeOnFuncContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnFuncContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *RevokeOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *RevokeOnFuncContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *RevokeOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnFunc(s)
	}
}

func (s *RevokeOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnFunc(s)
	}
}

func (s *RevokeOnFuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeOnFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeOnSystemContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnSystemContext {
	var p = new(RevokeOnSystemContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnSystemContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *RevokeOnSystemContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnSystem(s)
	}
}

func (s *RevokeOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnSystem(s)
	}
}

func (s *RevokeOnSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRevokeOnSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RevokePrivilegeStatement() (localctx IRevokePrivilegeStatementContext) {
	localctx = NewRevokePrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, StarRocksParserRULE_revokePrivilegeStatement)
	var _la int

	p.SetState(4943)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4879)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4880)
			p.Match(StarRocksParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4881)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4882)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4883)
			p.User()
		}
		p.SetState(4888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4884)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4885)
				p.User()
			}

			p.SetState(4890)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4891)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4892)
			p.GrantRevokeClause()
		}

	case 2:
		localctx = NewRevokeOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4894)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4895)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4896)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4897)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4898)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4899)
			p.GrantRevokeClause()
		}

	case 3:
		localctx = NewRevokeOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4901)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4902)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4903)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserGLOBAL {
			{
				p.SetState(4904)
				p.Match(StarRocksParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4907)
			p.Match(StarRocksParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4908)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4909)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4910)
			p.GrantRevokeClause()
		}

	case 4:
		localctx = NewRevokeOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4912)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4913)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4914)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4915)
			p.Match(StarRocksParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4916)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4917)
			p.GrantRevokeClause()
		}

	case 5:
		localctx = NewRevokeOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4919)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4920)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4921)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4922)
			p.PrivObjectType()
		}
		{
			p.SetState(4923)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4924)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4925)
			p.GrantRevokeClause()
		}

	case 6:
		localctx = NewRevokeOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4927)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4928)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4929)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4930)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4931)
			p.PrivObjectTypePlural()
		}
		p.SetState(4938)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4932)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4933)

				var _m = p.Match(StarRocksParserALL)

				localctx.(*RevokeOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4934)
				p.Match(StarRocksParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 533, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4935)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4936)
				p.Match(StarRocksParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4937)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4940)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4941)
			p.GrantRevokeClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGrantsStatementContext is an interface to support dynamic dispatch.
type IShowGrantsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	FOR() antlr.TerminalNode
	User() IUserContext
	USER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowGrantsStatementContext differentiates from other interfaces.
	IsShowGrantsStatementContext()
}

type ShowGrantsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGrantsStatementContext() *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGrantsStatement
	return p
}

func InitEmptyShowGrantsStatementContext(p *ShowGrantsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGrantsStatement
}

func (*ShowGrantsStatementContext) IsShowGrantsStatementContext() {}

func NewShowGrantsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showGrantsStatement

	return p
}

func (s *ShowGrantsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGrantsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowGrantsStatementContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANTS, 0)
}

func (s *ShowGrantsStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowGrantsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowGrantsStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *ShowGrantsStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *ShowGrantsStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowGrantsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGrantsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowGrantsStatement(s)
	}
}

func (s *ShowGrantsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowGrantsStatement(s)
	}
}

func (s *ShowGrantsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowGrantsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowGrantsStatement() (localctx IShowGrantsStatementContext) {
	localctx = NewShowGrantsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, StarRocksParserRULE_showGrantsStatement)
	p.SetState(4959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4945)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4946)
			p.Match(StarRocksParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4947)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4948)
			p.Match(StarRocksParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4949)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4951)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4950)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4953)
			p.User()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4954)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4955)
			p.Match(StarRocksParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4956)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4957)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4958)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthOptionContext is an interface to support dynamic dispatch.
type IAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthOptionContext differentiates from other interfaces.
	IsAuthOptionContext()
}

type AuthOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthOptionContext() *AuthOptionContext {
	var p = new(AuthOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_authOption
	return p
}

func InitEmptyAuthOptionContext(p *AuthOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_authOption
}

func (*AuthOptionContext) IsAuthOptionContext() {}

func NewAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthOptionContext {
	var p = new(AuthOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_authOption

	return p
}

func (s *AuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthOptionContext) CopyAll(ctx *AuthOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AuthWithPluginContext struct {
	AuthOptionContext
}

func NewAuthWithPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithPluginContext {
	var p = new(AuthWithPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIDENTIFIED, 0)
}

func (s *AuthWithPluginContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AuthWithPluginContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AuthWithPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *AuthWithPluginContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *AuthWithPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAuthWithPlugin(s)
	}
}

func (s *AuthWithPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAuthWithPlugin(s)
	}
}

func (s *AuthWithPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAuthWithPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

type AuthWithoutPluginContext struct {
	AuthOptionContext
}

func NewAuthWithoutPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithoutPluginContext {
	var p = new(AuthWithoutPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithoutPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithoutPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIDENTIFIED, 0)
}

func (s *AuthWithoutPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *AuthWithoutPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithoutPluginContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, 0)
}

func (s *AuthWithoutPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAuthWithoutPlugin(s)
	}
}

func (s *AuthWithoutPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAuthWithoutPlugin(s)
	}
}

func (s *AuthWithoutPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAuthWithoutPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AuthOption() (localctx IAuthOptionContext) {
	localctx = NewAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, StarRocksParserRULE_authOption)
	var _la int

	p.SetState(4974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAuthWithoutPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4961)
			p.Match(StarRocksParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4962)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPASSWORD {
			{
				p.SetState(4963)
				p.Match(StarRocksParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4966)
			p.String_()
		}

	case 2:
		localctx = NewAuthWithPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4967)
			p.Match(StarRocksParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4968)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4969)
			p.IdentifierOrString()
		}
		p.SetState(4972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS || _la == StarRocksParserBY {
			{
				p.SetState(4970)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserAS || _la == StarRocksParserBY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4971)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameContext is an interface to support dynamic dispatch.
type IPrivObjectNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsPrivObjectNameContext differentiates from other interfaces.
	IsPrivObjectNameContext()
}

type PrivObjectNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameContext() *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectName
	return p
}

func InitEmptyPrivObjectNameContext(p *PrivObjectNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectName
}

func (*PrivObjectNameContext) IsPrivObjectNameContext() {}

func NewPrivObjectNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectName

	return p
}

func (s *PrivObjectNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *PrivObjectNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectName(s)
	}
}

func (s *PrivObjectNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectName(s)
	}
}

func (s *PrivObjectNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrivObjectName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrivObjectName() (localctx IPrivObjectNameContext) {
	localctx = NewPrivObjectNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, StarRocksParserRULE_privObjectName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4976)
		p.IdentifierOrStringOrStar()
	}
	p.SetState(4979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__0 {
		{
			p.SetState(4977)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4978)
			p.IdentifierOrStringOrStar()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameListContext is an interface to support dynamic dispatch.
type IPrivObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivObjectName() []IPrivObjectNameContext
	PrivObjectName(i int) IPrivObjectNameContext

	// IsPrivObjectNameListContext differentiates from other interfaces.
	IsPrivObjectNameListContext()
}

type PrivObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameListContext() *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectNameList
	return p
}

func InitEmptyPrivObjectNameListContext(p *PrivObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectNameList
}

func (*PrivObjectNameListContext) IsPrivObjectNameListContext() {}

func NewPrivObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectNameList

	return p
}

func (s *PrivObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameListContext) AllPrivObjectName() []IPrivObjectNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			len++
		}
	}

	tst := make([]IPrivObjectNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivObjectNameContext); ok {
			tst[i] = t.(IPrivObjectNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameListContext) PrivObjectName(i int) IPrivObjectNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameContext)
}

func (s *PrivObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectNameList(s)
	}
}

func (s *PrivObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectNameList(s)
	}
}

func (s *PrivObjectNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrivObjectNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrivObjectNameList() (localctx IPrivObjectNameListContext) {
	localctx = NewPrivObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, StarRocksParserRULE_privObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4981)
		p.PrivObjectName()
	}
	p.SetState(4986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(4982)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4983)
			p.PrivObjectName()
		}

		p.SetState(4988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivFunctionObjectNameListContext is an interface to support dynamic dispatch.
type IPrivFunctionObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllTypeList() []ITypeListContext
	TypeList(i int) ITypeListContext

	// IsPrivFunctionObjectNameListContext differentiates from other interfaces.
	IsPrivFunctionObjectNameListContext()
}

type PrivFunctionObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivFunctionObjectNameListContext() *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privFunctionObjectNameList
	return p
}

func InitEmptyPrivFunctionObjectNameListContext(p *PrivFunctionObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privFunctionObjectNameList
}

func (*PrivFunctionObjectNameListContext) IsPrivFunctionObjectNameListContext() {}

func NewPrivFunctionObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privFunctionObjectNameList

	return p
}

func (s *PrivFunctionObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivFunctionObjectNameListContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PrivFunctionObjectNameListContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *PrivFunctionObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivFunctionObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivFunctionObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivFunctionObjectNameList(s)
	}
}

func (s *PrivFunctionObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivFunctionObjectNameList(s)
	}
}

func (s *PrivFunctionObjectNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrivFunctionObjectNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrivFunctionObjectNameList() (localctx IPrivFunctionObjectNameListContext) {
	localctx = NewPrivFunctionObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, StarRocksParserRULE_privFunctionObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4989)
		p.QualifiedName()
	}
	{
		p.SetState(4990)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4991)
		p.TypeList()
	}
	{
		p.SetState(4992)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(4993)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4994)
			p.QualifiedName()
		}
		{
			p.SetState(4995)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4996)
			p.TypeList()
		}
		{
			p.SetState(4997)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeListContext is an interface to support dynamic dispatch.
type IPrivilegeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilegeType() []IPrivilegeTypeContext
	PrivilegeType(i int) IPrivilegeTypeContext

	// IsPrivilegeTypeListContext differentiates from other interfaces.
	IsPrivilegeTypeListContext()
}

type PrivilegeTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeListContext() *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeTypeList
	return p
}

func InitEmptyPrivilegeTypeListContext(p *PrivilegeTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeTypeList
}

func (*PrivilegeTypeListContext) IsPrivilegeTypeListContext() {}

func NewPrivilegeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privilegeTypeList

	return p
}

func (s *PrivilegeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeListContext) AllPrivilegeType() []IPrivilegeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeTypeContext); ok {
			tst[i] = t.(IPrivilegeTypeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeTypeListContext) PrivilegeType(i int) IPrivilegeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *PrivilegeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivilegeTypeList(s)
	}
}

func (s *PrivilegeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivilegeTypeList(s)
	}
}

func (s *PrivilegeTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrivilegeTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrivilegeTypeList() (localctx IPrivilegeTypeListContext) {
	localctx = NewPrivilegeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, StarRocksParserRULE_privilegeTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5004)
		p.PrivilegeType()
	}
	p.SetState(5009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5005)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5006)
			p.PrivilegeType()
		}

		p.SetState(5011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeContext is an interface to support dynamic dispatch.
type IPrivilegeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FILE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	NODE() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode

	// IsPrivilegeTypeContext differentiates from other interfaces.
	IsPrivilegeTypeContext()
}

type PrivilegeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeContext() *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeType
	return p
}

func InitEmptyPrivilegeTypeContext(p *PrivilegeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeType
}

func (*PrivilegeTypeContext) IsPrivilegeTypeContext() {}

func NewPrivilegeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privilegeType

	return p
}

func (s *PrivilegeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *PrivilegeTypeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIVILEGES, 0)
}

func (s *PrivilegeTypeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *PrivilegeTypeContext) APPLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAPPLY, 0)
}

func (s *PrivilegeTypeContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *PrivilegeTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *PrivilegeTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *PrivilegeTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *PrivilegeTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *PrivilegeTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *PrivilegeTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *PrivilegeTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *PrivilegeTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *PrivilegeTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *PrivilegeTypeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *PrivilegeTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *PrivilegeTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *PrivilegeTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *PrivilegeTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *PrivilegeTypeContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *PrivilegeTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *PrivilegeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *PrivilegeTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *PrivilegeTypeContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *PrivilegeTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *PrivilegeTypeContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *PrivilegeTypeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSERT, 0)
}

func (s *PrivilegeTypeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, 0)
}

func (s *PrivilegeTypeContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *PrivilegeTypeContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPERATE, 0)
}

func (s *PrivilegeTypeContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *PrivilegeTypeContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *PrivilegeTypeContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *PrivilegeTypeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSELECT, 0)
}

func (s *PrivilegeTypeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUPDATE, 0)
}

func (s *PrivilegeTypeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSAGE, 0)
}

func (s *PrivilegeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrivilegeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrivilegeType() (localctx IPrivilegeTypeContext) {
	localctx = NewPrivilegeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, StarRocksParserRULE_privilegeType)
	var _la int

	p.SetState(5055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5012)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPRIVILEGES {
			{
				p.SetState(5013)
				p.Match(StarRocksParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5016)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAPPLY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5017)
			p.Match(StarRocksParserAPPLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserBLACKLIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5018)
			p.Match(StarRocksParserBLACKLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCREATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5019)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 545, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5020)
				p.Match(StarRocksParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5021)
				p.Match(StarRocksParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(5022)
				p.Match(StarRocksParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5023)
				p.Match(StarRocksParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5024)
				p.Match(StarRocksParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5025)
				p.Match(StarRocksParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(5026)
				p.Match(StarRocksParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5027)
				p.Match(StarRocksParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(5028)
				p.Match(StarRocksParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(5029)
				p.Match(StarRocksParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5030)
				p.Match(StarRocksParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(5031)
				p.Match(StarRocksParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5032)
				p.Match(StarRocksParserCATALOG)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 10:
			{
				p.SetState(5033)
				p.Match(StarRocksParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5034)
				p.Match(StarRocksParserVOLUME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 11:
			{
				p.SetState(5035)
				p.Match(StarRocksParserWAREHOUSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 12:
			{
				p.SetState(5036)
				p.Match(StarRocksParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 13:
			{
				p.SetState(5037)
				p.Match(StarRocksParserPIPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case StarRocksParserDELETE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5040)
			p.Match(StarRocksParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDROP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5041)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEXPORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5042)
			p.Match(StarRocksParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFILE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5043)
			p.Match(StarRocksParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserIMPERSONATE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5044)
			p.Match(StarRocksParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5045)
			p.Match(StarRocksParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserGRANT:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5046)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserNODE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5047)
			p.Match(StarRocksParserNODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserOPERATE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5048)
			p.Match(StarRocksParserOPERATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPLUGIN:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5049)
			p.Match(StarRocksParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREPOSITORY:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5050)
			p.Match(StarRocksParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREFRESH:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5051)
			p.Match(StarRocksParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSELECT:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5052)
			p.Match(StarRocksParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUPDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5053)
			p.Match(StarRocksParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUSAGE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5054)
			p.Match(StarRocksParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypeContext is an interface to support dynamic dispatch.
type IPrivObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	PIPE() antlr.TerminalNode

	// IsPrivObjectTypeContext differentiates from other interfaces.
	IsPrivObjectTypeContext()
}

type PrivObjectTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypeContext() *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectType
	return p
}

func InitEmptyPrivObjectTypeContext(p *PrivObjectTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectType
}

func (*PrivObjectTypeContext) IsPrivObjectTypeContext() {}

func NewPrivObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectType

	return p
}

func (s *PrivObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *PrivObjectTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *PrivObjectTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *PrivObjectTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *PrivObjectTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *PrivObjectTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *PrivObjectTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *PrivObjectTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *PrivObjectTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *PrivObjectTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *PrivObjectTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *PrivObjectTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *PrivObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectType(s)
	}
}

func (s *PrivObjectTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectType(s)
	}
}

func (s *PrivObjectTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrivObjectType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrivObjectType() (localctx IPrivObjectTypeContext) {
	localctx = NewPrivObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, StarRocksParserRULE_privObjectType)
	p.SetState(5071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5057)
			p.Match(StarRocksParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5058)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5059)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5060)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5061)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5062)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5063)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5064)
			p.Match(StarRocksParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5065)
			p.Match(StarRocksParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5066)
			p.Match(StarRocksParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5067)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5068)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5069)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5070)
			p.Match(StarRocksParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypePluralContext is an interface to support dynamic dispatch.
type IPrivObjectTypePluralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOGS() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	USERS() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	PIPES() antlr.TerminalNode

	// IsPrivObjectTypePluralContext differentiates from other interfaces.
	IsPrivObjectTypePluralContext()
}

type PrivObjectTypePluralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypePluralContext() *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectTypePlural
	return p
}

func InitEmptyPrivObjectTypePluralContext(p *PrivObjectTypePluralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectTypePlural
}

func (*PrivObjectTypePluralContext) IsPrivObjectTypePluralContext() {}

func NewPrivObjectTypePluralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectTypePlural

	return p
}

func (s *PrivObjectTypePluralContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypePluralContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *PrivObjectTypePluralContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *PrivObjectTypePluralContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *PrivObjectTypePluralContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *PrivObjectTypePluralContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *PrivObjectTypePluralContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *PrivObjectTypePluralContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPOLICIES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *PrivObjectTypePluralContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPS, 0)
}

func (s *PrivObjectTypePluralContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *PrivObjectTypePluralContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUMES, 0)
}

func (s *PrivObjectTypePluralContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *PrivObjectTypePluralContext) USERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSERS, 0)
}

func (s *PrivObjectTypePluralContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *PrivObjectTypePluralContext) PIPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPES, 0)
}

func (s *PrivObjectTypePluralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypePluralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypePluralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectTypePlural(s)
	}
}

func (s *PrivObjectTypePluralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectTypePlural(s)
	}
}

func (s *PrivObjectTypePluralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrivObjectTypePlural(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrivObjectTypePlural() (localctx IPrivObjectTypePluralContext) {
	localctx = NewPrivObjectTypePluralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, StarRocksParserRULE_privObjectTypePlural)
	p.SetState(5091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCATALOGS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5073)
			p.Match(StarRocksParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDATABASES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5074)
			p.Match(StarRocksParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFUNCTIONS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5075)
			p.Match(StarRocksParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserGLOBAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5076)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5077)
			p.Match(StarRocksParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMATERIALIZED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5078)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5079)
			p.Match(StarRocksParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPOLICIES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5080)
			p.Match(StarRocksParserPOLICIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRESOURCES:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5081)
			p.Match(StarRocksParserRESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRESOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5082)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5083)
			p.Match(StarRocksParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSTORAGE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5084)
			p.Match(StarRocksParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5085)
			p.Match(StarRocksParserVOLUMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserTABLES:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5086)
			p.Match(StarRocksParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUSERS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5087)
			p.Match(StarRocksParserUSERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserVIEWS:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5088)
			p.Match(StarRocksParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserWAREHOUSES:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5089)
			p.Match(StarRocksParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPIPES:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5090)
			p.Match(StarRocksParserPIPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type ICreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext

	// IsCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsCreateSecurityIntegrationStatementContext()
}

type CreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSecurityIntegrationStatementContext() *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createSecurityIntegrationStatement
	return p
}

func InitEmptyCreateSecurityIntegrationStatementContext(p *CreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createSecurityIntegrationStatement
}

func (*CreateSecurityIntegrationStatementContext) IsCreateSecurityIntegrationStatementContext() {}

func NewCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createSecurityIntegrationStatement

	return p
}

func (s *CreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *CreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *CreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSecurityIntegrationStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateSecurityIntegrationStatement(s)
	}
}

func (s *CreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateSecurityIntegrationStatement(s)
	}
}

func (s *CreateSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateSecurityIntegrationStatement() (localctx ICreateSecurityIntegrationStatementContext) {
	localctx = NewCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, StarRocksParserRULE_createSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5093)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5094)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5095)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5096)
		p.Identifier()
	}
	{
		p.SetState(5097)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IAlterSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterSecurityIntegrationStatementContext differentiates from other interfaces.
	IsAlterSecurityIntegrationStatementContext()
}

type AlterSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSecurityIntegrationStatementContext() *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSecurityIntegrationStatement
	return p
}

func InitEmptyAlterSecurityIntegrationStatementContext(p *AlterSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSecurityIntegrationStatement
}

func (*AlterSecurityIntegrationStatementContext) IsAlterSecurityIntegrationStatementContext() {}

func NewAlterSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterSecurityIntegrationStatement

	return p
}

func (s *AlterSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSecurityIntegrationStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *AlterSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *AlterSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSecurityIntegrationStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterSecurityIntegrationStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterSecurityIntegrationStatement(s)
	}
}

func (s *AlterSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterSecurityIntegrationStatement(s)
	}
}

func (s *AlterSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterSecurityIntegrationStatement() (localctx IAlterSecurityIntegrationStatementContext) {
	localctx = NewAlterSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, StarRocksParserRULE_alterSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5099)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5100)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5101)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5102)
		p.Identifier()
	}
	{
		p.SetState(5103)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5104)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IDropSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropSecurityIntegrationStatementContext differentiates from other interfaces.
	IsDropSecurityIntegrationStatementContext()
}

type DropSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSecurityIntegrationStatementContext() *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropSecurityIntegrationStatement
	return p
}

func InitEmptyDropSecurityIntegrationStatementContext(p *DropSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropSecurityIntegrationStatement
}

func (*DropSecurityIntegrationStatementContext) IsDropSecurityIntegrationStatementContext() {}

func NewDropSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropSecurityIntegrationStatement

	return p
}

func (s *DropSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSecurityIntegrationStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *DropSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *DropSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropSecurityIntegrationStatement(s)
	}
}

func (s *DropSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropSecurityIntegrationStatement(s)
	}
}

func (s *DropSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropSecurityIntegrationStatement() (localctx IDropSecurityIntegrationStatementContext) {
	localctx = NewDropSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, StarRocksParserRULE_dropSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5106)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5107)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5108)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5109)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode

	// IsShowSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowSecurityIntegrationStatementContext()
}

type ShowSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSecurityIntegrationStatementContext() *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSecurityIntegrationStatement
	return p
}

func InitEmptyShowSecurityIntegrationStatementContext(p *ShowSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSecurityIntegrationStatement
}

func (*ShowSecurityIntegrationStatementContext) IsShowSecurityIntegrationStatementContext() {}

func NewShowSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSecurityIntegrationStatement

	return p
}

func (s *ShowSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *ShowSecurityIntegrationStatementContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATIONS, 0)
}

func (s *ShowSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSecurityIntegrationStatement(s)
	}
}

func (s *ShowSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSecurityIntegrationStatement(s)
	}
}

func (s *ShowSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowSecurityIntegrationStatement() (localctx IShowSecurityIntegrationStatementContext) {
	localctx = NewShowSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, StarRocksParserRULE_showSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5111)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5112)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5113)
		p.Match(StarRocksParserINTEGRATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowCreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowCreateSecurityIntegrationStatementContext()
}

type ShowCreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateSecurityIntegrationStatementContext() *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateSecurityIntegrationStatement
	return p
}

func InitEmptyShowCreateSecurityIntegrationStatementContext(p *ShowCreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateSecurityIntegrationStatement
}

func (*ShowCreateSecurityIntegrationStatementContext) IsShowCreateSecurityIntegrationStatementContext() {
}

func NewShowCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateSecurityIntegrationStatement

	return p
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateSecurityIntegrationStatement(s)
	}
}

func (s *ShowCreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateSecurityIntegrationStatement(s)
	}
}

func (s *ShowCreateSecurityIntegrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCreateSecurityIntegrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCreateSecurityIntegrationStatement() (localctx IShowCreateSecurityIntegrationStatementContext) {
	localctx = NewShowCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, StarRocksParserRULE_showCreateSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5115)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5116)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5117)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5118)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5119)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type ICreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext

	// IsCreateGroupProviderStatementContext differentiates from other interfaces.
	IsCreateGroupProviderStatementContext()
}

type CreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateGroupProviderStatementContext() *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createGroupProviderStatement
	return p
}

func InitEmptyCreateGroupProviderStatementContext(p *CreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createGroupProviderStatement
}

func (*CreateGroupProviderStatementContext) IsCreateGroupProviderStatementContext() {}

func NewCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createGroupProviderStatement

	return p
}

func (s *CreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *CreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *CreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateGroupProviderStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateGroupProviderStatement(s)
	}
}

func (s *CreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateGroupProviderStatement(s)
	}
}

func (s *CreateGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateGroupProviderStatement() (localctx ICreateGroupProviderStatementContext) {
	localctx = NewCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, StarRocksParserRULE_createGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5121)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5122)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5123)
		p.Match(StarRocksParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5124)
		p.Identifier()
	}
	{
		p.SetState(5125)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropGroupProviderStatementContext is an interface to support dynamic dispatch.
type IDropGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropGroupProviderStatementContext differentiates from other interfaces.
	IsDropGroupProviderStatementContext()
}

type DropGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropGroupProviderStatementContext() *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropGroupProviderStatement
	return p
}

func InitEmptyDropGroupProviderStatementContext(p *DropGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropGroupProviderStatement
}

func (*DropGroupProviderStatementContext) IsDropGroupProviderStatementContext() {}

func NewDropGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropGroupProviderStatement

	return p
}

func (s *DropGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropGroupProviderStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *DropGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *DropGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropGroupProviderStatement(s)
	}
}

func (s *DropGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropGroupProviderStatement(s)
	}
}

func (s *DropGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropGroupProviderStatement() (localctx IDropGroupProviderStatementContext) {
	localctx = NewDropGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, StarRocksParserRULE_dropGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5127)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5128)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5129)
		p.Match(StarRocksParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5130)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGroupProvidersStatementContext is an interface to support dynamic dispatch.
type IShowGroupProvidersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode

	// IsShowGroupProvidersStatementContext differentiates from other interfaces.
	IsShowGroupProvidersStatementContext()
}

type ShowGroupProvidersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGroupProvidersStatementContext() *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGroupProvidersStatement
	return p
}

func InitEmptyShowGroupProvidersStatementContext(p *ShowGroupProvidersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGroupProvidersStatement
}

func (*ShowGroupProvidersStatementContext) IsShowGroupProvidersStatementContext() {}

func NewShowGroupProvidersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showGroupProvidersStatement

	return p
}

func (s *ShowGroupProvidersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGroupProvidersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowGroupProvidersStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowGroupProvidersStatementContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDERS, 0)
}

func (s *ShowGroupProvidersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGroupProvidersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGroupProvidersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowGroupProvidersStatement(s)
	}
}

func (s *ShowGroupProvidersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowGroupProvidersStatement(s)
	}
}

func (s *ShowGroupProvidersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowGroupProvidersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowGroupProvidersStatement() (localctx IShowGroupProvidersStatementContext) {
	localctx = NewShowGroupProvidersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, StarRocksParserRULE_showGroupProvidersStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5132)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5133)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5134)
		p.Match(StarRocksParserPROVIDERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type IShowCreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateGroupProviderStatementContext differentiates from other interfaces.
	IsShowCreateGroupProviderStatementContext()
}

type ShowCreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateGroupProviderStatementContext() *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateGroupProviderStatement
	return p
}

func InitEmptyShowCreateGroupProviderStatementContext(p *ShowCreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateGroupProviderStatement
}

func (*ShowCreateGroupProviderStatementContext) IsShowCreateGroupProviderStatementContext() {}

func NewShowCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateGroupProviderStatement

	return p
}

func (s *ShowCreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateGroupProviderStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowCreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *ShowCreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateGroupProviderStatement(s)
	}
}

func (s *ShowCreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateGroupProviderStatement(s)
	}
}

func (s *ShowCreateGroupProviderStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowCreateGroupProviderStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowCreateGroupProviderStatement() (localctx IShowCreateGroupProviderStatementContext) {
	localctx = NewShowCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, StarRocksParserRULE_showCreateGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5136)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5137)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5138)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5139)
		p.Match(StarRocksParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5140)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupStatementContext is an interface to support dynamic dispatch.
type IBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// Getter signatures
	BACKUP() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode

	// IsBackupStatementContext differentiates from other interfaces.
	IsBackupStatementContext()
}

type BackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbName   IIdentifierContext
	repoName IIdentifierContext
}

func NewEmptyBackupStatementContext() *BackupStatementContext {
	var p = new(BackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupStatement
	return p
}

func InitEmptyBackupStatementContext(p *BackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupStatement
}

func (*BackupStatementContext) IsBackupStatementContext() {}

func NewBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupStatementContext {
	var p = new(BackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_backupStatement

	return p
}

func (s *BackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *BackupStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *BackupStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *BackupStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *BackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *BackupStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *BackupStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *BackupStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *BackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *BackupStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *BackupStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *BackupStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *BackupStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *BackupStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *BackupStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *BackupStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *BackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackupStatement(s)
	}
}

func (s *BackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackupStatement(s)
	}
}

func (s *BackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BackupStatement() (localctx IBackupStatementContext) {
	localctx = NewBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, StarRocksParserRULE_backupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5142)
		p.Match(StarRocksParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserALL:
		{
			p.SetState(5143)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5144)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5145)
			p.Match(StarRocksParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEXTERNAL:
		{
			p.SetState(5146)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5147)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserCATALOG || _la == StarRocksParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5148)
			p.IdentifierList()
		}

	case StarRocksParserDATABASE, StarRocksParserSNAPSHOT:

	default:
	}
	p.SetState(5153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDATABASE {
		{
			p.SetState(5151)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5152)

			var _x = p.Identifier()

			localctx.(*BackupStatementContext).dbName = _x
		}

	}
	{
		p.SetState(5155)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5156)
		p.QualifiedName()
	}
	{
		p.SetState(5157)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5158)

		var _x = p.Identifier()

		localctx.(*BackupStatementContext).repoName = _x
	}
	p.SetState(5171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(5159)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5160)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5161)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5162)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5163)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5168)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5169)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5173)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5174)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelBackupStatementContext is an interface to support dynamic dispatch.
type ICancelBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelBackupStatementContext differentiates from other interfaces.
	IsCancelBackupStatementContext()
}

type CancelBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelBackupStatementContext() *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelBackupStatement
	return p
}

func InitEmptyCancelBackupStatementContext(p *CancelBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelBackupStatement
}

func (*CancelBackupStatementContext) IsCancelBackupStatementContext() {}

func NewCancelBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelBackupStatement

	return p
}

func (s *CancelBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelBackupStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *CancelBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelBackupStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *CancelBackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CancelBackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *CancelBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CancelBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelBackupStatement(s)
	}
}

func (s *CancelBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelBackupStatement(s)
	}
}

func (s *CancelBackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelBackupStatement() (localctx ICancelBackupStatementContext) {
	localctx = NewCancelBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, StarRocksParserRULE_cancelBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5177)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5178)
		p.Match(StarRocksParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFROM, StarRocksParserIN:
		{
			p.SetState(5179)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5180)
			p.Identifier()
		}

	case StarRocksParserFOR:
		{
			p.SetState(5181)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5182)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5183)
			p.Match(StarRocksParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackupStatementContext is an interface to support dynamic dispatch.
type IShowBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsShowBackupStatementContext differentiates from other interfaces.
	IsShowBackupStatementContext()
}

type ShowBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackupStatementContext() *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackupStatement
	return p
}

func InitEmptyShowBackupStatementContext(p *ShowBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackupStatement
}

func (*ShowBackupStatementContext) IsShowBackupStatementContext() {}

func NewShowBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBackupStatement

	return p
}

func (s *ShowBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *ShowBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBackupStatement(s)
	}
}

func (s *ShowBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBackupStatement(s)
	}
}

func (s *ShowBackupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowBackupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowBackupStatement() (localctx IShowBackupStatementContext) {
	localctx = NewShowBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, StarRocksParserRULE_showBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5186)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5187)
		p.Match(StarRocksParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5188)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5189)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestoreStatementContext is an interface to support dynamic dispatch.
type IRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetDbAlias returns the dbAlias rule contexts.
	GetDbAlias() IIdentifierContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetDbAlias sets the dbAlias rule contexts.
	SetDbAlias(IIdentifierContext)

	// Getter signatures
	RESTORE() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierWithAliasList() IIdentifierWithAliasListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsRestoreStatementContext differentiates from other interfaces.
	IsRestoreStatementContext()
}

type RestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	repoName IIdentifierContext
	dbName   IIdentifierContext
	dbAlias  IIdentifierContext
}

func NewEmptyRestoreStatementContext() *RestoreStatementContext {
	var p = new(RestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_restoreStatement
	return p
}

func InitEmptyRestoreStatementContext(p *RestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_restoreStatement
}

func (*RestoreStatementContext) IsRestoreStatementContext() {}

func NewRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestoreStatementContext {
	var p = new(RestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_restoreStatement

	return p
}

func (s *RestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RestoreStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *RestoreStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *RestoreStatementContext) GetDbAlias() IIdentifierContext { return s.dbAlias }

func (s *RestoreStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *RestoreStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *RestoreStatementContext) SetDbAlias(v IIdentifierContext) { s.dbAlias = v }

func (s *RestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *RestoreStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *RestoreStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RestoreStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RestoreStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *RestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *RestoreStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *RestoreStatementContext) IdentifierWithAliasList() IIdentifierWithAliasListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasListContext)
}

func (s *RestoreStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *RestoreStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RestoreStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *RestoreStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *RestoreStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *RestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *RestoreStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *RestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRestoreStatement(s)
	}
}

func (s *RestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRestoreStatement(s)
	}
}

func (s *RestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RestoreStatement() (localctx IRestoreStatementContext) {
	localctx = NewRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, StarRocksParserRULE_restoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5192)
		p.Match(StarRocksParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5193)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5194)
		p.QualifiedName()
	}
	{
		p.SetState(5195)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5196)

		var _x = p.Identifier()

		localctx.(*RestoreStatementContext).repoName = _x
	}
	p.SetState(5203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserALL:
		{
			p.SetState(5197)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5198)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5199)
			p.Match(StarRocksParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEXTERNAL:
		{
			p.SetState(5200)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5201)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserCATALOG || _la == StarRocksParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5202)
			p.IdentifierWithAliasList()
		}

	case StarRocksParserEOF, StarRocksParserDATABASE, StarRocksParserON, StarRocksParserPROPERTIES, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(5211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDATABASE {
		{
			p.SetState(5205)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5206)

			var _x = p.Identifier()

			localctx.(*RestoreStatementContext).dbName = _x
		}
		p.SetState(5209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(5207)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5208)

				var _x = p.Identifier()

				localctx.(*RestoreStatementContext).dbAlias = _x
			}

		}

	}
	p.SetState(5225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(5213)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5214)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5215)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5216)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5217)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5222)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5223)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5227)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5228)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRestoreStatementContext is an interface to support dynamic dispatch.
type ICancelRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelRestoreStatementContext differentiates from other interfaces.
	IsCancelRestoreStatementContext()
}

type CancelRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRestoreStatementContext() *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRestoreStatement
	return p
}

func InitEmptyCancelRestoreStatementContext(p *CancelRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRestoreStatement
}

func (*CancelRestoreStatementContext) IsCancelRestoreStatementContext() {}

func NewCancelRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelRestoreStatement

	return p
}

func (s *CancelRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRestoreStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *CancelRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelRestoreStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *CancelRestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CancelRestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *CancelRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CancelRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelRestoreStatement(s)
	}
}

func (s *CancelRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelRestoreStatement(s)
	}
}

func (s *CancelRestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelRestoreStatement() (localctx ICancelRestoreStatementContext) {
	localctx = NewCancelRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, StarRocksParserRULE_cancelRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5231)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5232)
		p.Match(StarRocksParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFROM, StarRocksParserIN:
		{
			p.SetState(5233)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5234)
			p.Identifier()
		}

	case StarRocksParserFOR:
		{
			p.SetState(5235)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5236)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5237)
			p.Match(StarRocksParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRestoreStatementContext is an interface to support dynamic dispatch.
type IShowRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowRestoreStatementContext differentiates from other interfaces.
	IsShowRestoreStatementContext()
}

type ShowRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyShowRestoreStatementContext() *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRestoreStatement
	return p
}

func InitEmptyShowRestoreStatementContext(p *ShowRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRestoreStatement
}

func (*ShowRestoreStatementContext) IsShowRestoreStatementContext() {}

func NewShowRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRestoreStatement

	return p
}

func (s *ShowRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRestoreStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowRestoreStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowRestoreStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *ShowRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRestoreStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowRestoreStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRestoreStatement(s)
	}
}

func (s *ShowRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRestoreStatement(s)
	}
}

func (s *ShowRestoreStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowRestoreStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowRestoreStatement() (localctx IShowRestoreStatementContext) {
	localctx = NewShowRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, StarRocksParserRULE_showRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5240)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5241)
		p.Match(StarRocksParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5242)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5243)
			p.Identifier()
		}

	}
	p.SetState(5248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5246)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5247)

			var _x = p.expression(0)

			localctx.(*ShowRestoreStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSnapshotStatementContext is an interface to support dynamic dispatch.
type IShowSnapshotStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowSnapshotStatementContext differentiates from other interfaces.
	IsShowSnapshotStatementContext()
}

type ShowSnapshotStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSnapshotStatementContext() *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSnapshotStatement
	return p
}

func InitEmptyShowSnapshotStatementContext(p *ShowSnapshotStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSnapshotStatement
}

func (*ShowSnapshotStatementContext) IsShowSnapshotStatementContext() {}

func NewShowSnapshotStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSnapshotStatement

	return p
}

func (s *ShowSnapshotStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSnapshotStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSnapshotStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *ShowSnapshotStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ShowSnapshotStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSnapshotStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowSnapshotStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowSnapshotStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSnapshotStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSnapshotStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSnapshotStatement(s)
	}
}

func (s *ShowSnapshotStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSnapshotStatement(s)
	}
}

func (s *ShowSnapshotStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowSnapshotStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowSnapshotStatement() (localctx IShowSnapshotStatementContext) {
	localctx = NewShowSnapshotStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, StarRocksParserRULE_showSnapshotStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5250)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5251)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5252)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5253)
		p.Identifier()
	}
	p.SetState(5256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5254)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5255)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRepositoryStatementContext is an interface to support dynamic dispatch.
type ICreateRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrStringContext

	// GetLocation returns the location rule contexts.
	GetLocation() IStringContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrStringContext)

	// SetLocation sets the location rule contexts.
	SetLocation(IStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsCreateRepositoryStatementContext differentiates from other interfaces.
	IsCreateRepositoryStatementContext()
}

type CreateRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	repoName   IIdentifierContext
	brokerName IIdentifierOrStringContext
	location   IStringContext
}

func NewEmptyCreateRepositoryStatementContext() *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRepositoryStatement
	return p
}

func InitEmptyCreateRepositoryStatementContext(p *CreateRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRepositoryStatement
}

func (*CreateRepositoryStatementContext) IsCreateRepositoryStatementContext() {}

func NewCreateRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createRepositoryStatement

	return p
}

func (s *CreateRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRepositoryStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *CreateRepositoryStatementContext) GetBrokerName() IIdentifierOrStringContext {
	return s.brokerName
}

func (s *CreateRepositoryStatementContext) GetLocation() IStringContext { return s.location }

func (s *CreateRepositoryStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *CreateRepositoryStatementContext) SetBrokerName(v IIdentifierOrStringContext) {
	s.brokerName = v
}

func (s *CreateRepositoryStatementContext) SetLocation(v IStringContext) { s.location = v }

func (s *CreateRepositoryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *CreateRepositoryStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *CreateRepositoryStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *CreateRepositoryStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateRepositoryStatementContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATION, 0)
}

func (s *CreateRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateRepositoryStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *CreateRepositoryStatementContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserONLY, 0)
}

func (s *CreateRepositoryStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *CreateRepositoryStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateRepositoryStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateRepositoryStatement(s)
	}
}

func (s *CreateRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateRepositoryStatement(s)
	}
}

func (s *CreateRepositoryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateRepositoryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateRepositoryStatement() (localctx ICreateRepositoryStatementContext) {
	localctx = NewCreateRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, StarRocksParserRULE_createRepositoryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5258)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserREAD {
		{
			p.SetState(5259)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5260)
			p.Match(StarRocksParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5263)
		p.Match(StarRocksParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5264)

		var _x = p.Identifier()

		localctx.(*CreateRepositoryStatementContext).repoName = _x
	}
	{
		p.SetState(5265)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5266)
		p.Match(StarRocksParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&4534550861405212027) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&141699191925459) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&4211) != 0) {
		{
			p.SetState(5267)

			var _x = p.IdentifierOrString()

			localctx.(*CreateRepositoryStatementContext).brokerName = _x
		}

	}
	{
		p.SetState(5270)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5271)
		p.Match(StarRocksParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5272)

		var _x = p.String_()

		localctx.(*CreateRepositoryStatementContext).location = _x
	}
	p.SetState(5275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5273)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5274)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRepositoryStatementContext is an interface to support dynamic dispatch.
type IDropRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropRepositoryStatementContext differentiates from other interfaces.
	IsDropRepositoryStatementContext()
}

type DropRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRepositoryStatementContext() *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRepositoryStatement
	return p
}

func InitEmptyDropRepositoryStatementContext(p *DropRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRepositoryStatement
}

func (*DropRepositoryStatementContext) IsDropRepositoryStatementContext() {}

func NewDropRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropRepositoryStatement

	return p
}

func (s *DropRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRepositoryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *DropRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropRepositoryStatement(s)
	}
}

func (s *DropRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropRepositoryStatement(s)
	}
}

func (s *DropRepositoryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropRepositoryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropRepositoryStatement() (localctx IDropRepositoryStatementContext) {
	localctx = NewDropRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, StarRocksParserRULE_dropRepositoryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5277)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5278)
		p.Match(StarRocksParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5279)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IAddSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	String_() IStringContext

	// IsAddSqlBlackListStatementContext differentiates from other interfaces.
	IsAddSqlBlackListStatementContext()
}

type AddSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddSqlBlackListStatementContext() *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addSqlBlackListStatement
	return p
}

func InitEmptyAddSqlBlackListStatementContext(p *AddSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addSqlBlackListStatement
}

func (*AddSqlBlackListStatementContext) IsAddSqlBlackListStatementContext() {}

func NewAddSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addSqlBlackListStatement

	return p
}

func (s *AddSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddSqlBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *AddSqlBlackListStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddSqlBlackListStatement(s)
	}
}

func (s *AddSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddSqlBlackListStatement(s)
	}
}

func (s *AddSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddSqlBlackListStatement() (localctx IAddSqlBlackListStatementContext) {
	localctx = NewAddSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, StarRocksParserRULE_addSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5281)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5282)
		p.Match(StarRocksParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5283)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IDelSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelSqlBlackListStatementContext differentiates from other interfaces.
	IsDelSqlBlackListStatementContext()
}

type DelSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelSqlBlackListStatementContext() *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delSqlBlackListStatement
	return p
}

func InitEmptyDelSqlBlackListStatementContext(p *DelSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delSqlBlackListStatement
}

func (*DelSqlBlackListStatementContext) IsDelSqlBlackListStatementContext() {}

func NewDelSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_delSqlBlackListStatement

	return p
}

func (s *DelSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelSqlBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *DelSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *DelSqlBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *DelSqlBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *DelSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDelSqlBlackListStatement(s)
	}
}

func (s *DelSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDelSqlBlackListStatement(s)
	}
}

func (s *DelSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDelSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DelSqlBlackListStatement() (localctx IDelSqlBlackListStatementContext) {
	localctx = NewDelSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, StarRocksParserRULE_delSqlBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5285)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5286)
		p.Match(StarRocksParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5287)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5288)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5289)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IShowSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode

	// IsShowSqlBlackListStatementContext differentiates from other interfaces.
	IsShowSqlBlackListStatementContext()
}

type ShowSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSqlBlackListStatementContext() *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSqlBlackListStatement
	return p
}

func InitEmptyShowSqlBlackListStatementContext(p *ShowSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSqlBlackListStatement
}

func (*ShowSqlBlackListStatementContext) IsShowSqlBlackListStatementContext() {}

func NewShowSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSqlBlackListStatement

	return p
}

func (s *ShowSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSqlBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *ShowSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSqlBlackListStatement(s)
	}
}

func (s *ShowSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSqlBlackListStatement(s)
	}
}

func (s *ShowSqlBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowSqlBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowSqlBlackListStatement() (localctx IShowSqlBlackListStatementContext) {
	localctx = NewShowSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, StarRocksParserRULE_showSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5295)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5296)
		p.Match(StarRocksParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWhiteListStatementContext is an interface to support dynamic dispatch.
type IShowWhiteListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode

	// IsShowWhiteListStatementContext differentiates from other interfaces.
	IsShowWhiteListStatementContext()
}

type ShowWhiteListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWhiteListStatementContext() *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWhiteListStatement
	return p
}

func InitEmptyShowWhiteListStatementContext(p *ShowWhiteListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWhiteListStatement
}

func (*ShowWhiteListStatementContext) IsShowWhiteListStatementContext() {}

func NewShowWhiteListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showWhiteListStatement

	return p
}

func (s *ShowWhiteListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWhiteListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowWhiteListStatementContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHITELIST, 0)
}

func (s *ShowWhiteListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWhiteListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWhiteListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowWhiteListStatement(s)
	}
}

func (s *ShowWhiteListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowWhiteListStatement(s)
	}
}

func (s *ShowWhiteListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowWhiteListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowWhiteListStatement() (localctx IShowWhiteListStatementContext) {
	localctx = NewShowWhiteListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, StarRocksParserRULE_showWhiteListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5298)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5299)
		p.Match(StarRocksParserWHITELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IAddBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAddBackendBlackListStatementContext differentiates from other interfaces.
	IsAddBackendBlackListStatementContext()
}

type AddBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddBackendBlackListStatementContext() *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendBlackListStatement
	return p
}

func InitEmptyAddBackendBlackListStatementContext(p *AddBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendBlackListStatement
}

func (*AddBackendBlackListStatementContext) IsAddBackendBlackListStatementContext() {}

func NewAddBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addBackendBlackListStatement

	return p
}

func (s *AddBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *AddBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *AddBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AddBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AddBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddBackendBlackListStatement(s)
	}
}

func (s *AddBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddBackendBlackListStatement(s)
	}
}

func (s *AddBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAddBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AddBackendBlackListStatement() (localctx IAddBackendBlackListStatementContext) {
	localctx = NewAddBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, StarRocksParserRULE_addBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5301)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5302)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5303)
		p.Match(StarRocksParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5304)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5305)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5306)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5311)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IDelBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelBackendBlackListStatementContext differentiates from other interfaces.
	IsDelBackendBlackListStatementContext()
}

type DelBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelBackendBlackListStatementContext() *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delBackendBlackListStatement
	return p
}

func InitEmptyDelBackendBlackListStatementContext(p *DelBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delBackendBlackListStatement
}

func (*DelBackendBlackListStatementContext) IsDelBackendBlackListStatementContext() {}

func NewDelBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_delBackendBlackListStatement

	return p
}

func (s *DelBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelBackendBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *DelBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DelBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *DelBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *DelBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *DelBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDelBackendBlackListStatement(s)
	}
}

func (s *DelBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDelBackendBlackListStatement(s)
	}
}

func (s *DelBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDelBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DelBackendBlackListStatement() (localctx IDelBackendBlackListStatementContext) {
	localctx = NewDelBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, StarRocksParserRULE_delBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5312)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5313)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5314)
		p.Match(StarRocksParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5315)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5316)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5317)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IShowBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode

	// IsShowBackendBlackListStatementContext differentiates from other interfaces.
	IsShowBackendBlackListStatementContext()
}

type ShowBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendBlackListStatementContext() *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendBlackListStatement
	return p
}

func InitEmptyShowBackendBlackListStatementContext(p *ShowBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendBlackListStatement
}

func (*ShowBackendBlackListStatementContext) IsShowBackendBlackListStatementContext() {}

func NewShowBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBackendBlackListStatement

	return p
}

func (s *ShowBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *ShowBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *ShowBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBackendBlackListStatement(s)
	}
}

func (s *ShowBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBackendBlackListStatement(s)
	}
}

func (s *ShowBackendBlackListStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowBackendBlackListStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowBackendBlackListStatement() (localctx IShowBackendBlackListStatementContext) {
	localctx = NewShowBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, StarRocksParserRULE_showBackendBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5323)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5324)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5325)
		p.Match(StarRocksParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheTargetContext is an interface to support dynamic dispatch.
type IDataCacheTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsDataCacheTargetContext differentiates from other interfaces.
	IsDataCacheTargetContext()
}

type DataCacheTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCacheTargetContext() *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheTarget
	return p
}

func InitEmptyDataCacheTargetContext(p *DataCacheTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheTarget
}

func (*DataCacheTargetContext) IsDataCacheTargetContext() {}

func NewDataCacheTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataCacheTarget

	return p
}

func (s *DataCacheTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheTargetContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheTargetContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *DataCacheTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataCacheTarget(s)
	}
}

func (s *DataCacheTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataCacheTarget(s)
	}
}

func (s *DataCacheTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDataCacheTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DataCacheTarget() (localctx IDataCacheTargetContext) {
	localctx = NewDataCacheTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, StarRocksParserRULE_dataCacheTarget)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5327)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5328)
		p.Match(StarRocksParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5329)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5330)
		p.Match(StarRocksParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5331)
		p.IdentifierOrStringOrStar()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type ICreateDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	DataCacheTarget() IDataCacheTargetContext
	PRIORITY() antlr.TerminalNode
	EQ() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	MINUS_SYMBOL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateDataCacheRuleStatementContext differentiates from other interfaces.
	IsCreateDataCacheRuleStatementContext()
}

type CreateDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDataCacheRuleStatementContext() *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDataCacheRuleStatement
	return p
}

func InitEmptyCreateDataCacheRuleStatementContext(p *CreateDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDataCacheRuleStatement
}

func (*CreateDataCacheRuleStatementContext) IsCreateDataCacheRuleStatementContext() {}

func NewCreateDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createDataCacheRuleStatement

	return p
}

func (s *CreateDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDataCacheRuleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *CreateDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DataCacheTarget() IDataCacheTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheTargetContext)
}

func (s *CreateDataCacheRuleStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIORITY, 0)
}

func (s *CreateDataCacheRuleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *CreateDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *CreateDataCacheRuleStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CreateDataCacheRuleStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateDataCacheRuleStatementContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS_SYMBOL, 0)
}

func (s *CreateDataCacheRuleStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateDataCacheRuleStatement(s)
	}
}

func (s *CreateDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateDataCacheRuleStatement(s)
	}
}

func (s *CreateDataCacheRuleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateDataCacheRuleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateDataCacheRuleStatement() (localctx ICreateDataCacheRuleStatementContext) {
	localctx = NewCreateDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, StarRocksParserRULE_createDataCacheRuleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5333)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5334)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5335)
		p.Match(StarRocksParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5336)
		p.DataCacheTarget()
	}
	p.SetState(5339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5337)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5338)
			p.expression(0)
		}

	}
	{
		p.SetState(5341)
		p.Match(StarRocksParserPRIORITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5342)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserMINUS_SYMBOL {
		{
			p.SetState(5343)
			p.Match(StarRocksParserMINUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5346)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5348)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5347)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IShowDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsShowDataCacheRulesStatementContext differentiates from other interfaces.
	IsShowDataCacheRulesStatementContext()
}

type ShowDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataCacheRulesStatementContext() *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataCacheRulesStatement
	return p
}

func InitEmptyShowDataCacheRulesStatementContext(p *ShowDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataCacheRulesStatement
}

func (*ShowDataCacheRulesStatementContext) IsShowDataCacheRulesStatementContext() {}

func NewShowDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDataCacheRulesStatement

	return p
}

func (s *ShowDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataCacheRulesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *ShowDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULES, 0)
}

func (s *ShowDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDataCacheRulesStatement(s)
	}
}

func (s *ShowDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDataCacheRulesStatement(s)
	}
}

func (s *ShowDataCacheRulesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowDataCacheRulesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowDataCacheRulesStatement() (localctx IShowDataCacheRulesStatementContext) {
	localctx = NewShowDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, StarRocksParserRULE_showDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5350)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5351)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5352)
		p.Match(StarRocksParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type IDropDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDropDataCacheRuleStatementContext differentiates from other interfaces.
	IsDropDataCacheRuleStatementContext()
}

type DropDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDataCacheRuleStatementContext() *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDataCacheRuleStatement
	return p
}

func InitEmptyDropDataCacheRuleStatementContext(p *DropDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDataCacheRuleStatement
}

func (*DropDataCacheRuleStatementContext) IsDropDataCacheRuleStatementContext() {}

func NewDropDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropDataCacheRuleStatement

	return p
}

func (s *DropDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDataCacheRuleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *DropDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULE, 0)
}

func (s *DropDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DropDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropDataCacheRuleStatement(s)
	}
}

func (s *DropDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropDataCacheRuleStatement(s)
	}
}

func (s *DropDataCacheRuleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropDataCacheRuleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropDataCacheRuleStatement() (localctx IDropDataCacheRuleStatementContext) {
	localctx = NewDropDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, StarRocksParserRULE_dropDataCacheRuleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5354)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5355)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5356)
		p.Match(StarRocksParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5357)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClearDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IClearDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAR() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsClearDataCacheRulesStatementContext differentiates from other interfaces.
	IsClearDataCacheRulesStatementContext()
}

type ClearDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClearDataCacheRulesStatementContext() *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_clearDataCacheRulesStatement
	return p
}

func InitEmptyClearDataCacheRulesStatementContext(p *ClearDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_clearDataCacheRulesStatement
}

func (*ClearDataCacheRulesStatementContext) IsClearDataCacheRulesStatementContext() {}

func NewClearDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_clearDataCacheRulesStatement

	return p
}

func (s *ClearDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClearDataCacheRulesStatementContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAR, 0)
}

func (s *ClearDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *ClearDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULES, 0)
}

func (s *ClearDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClearDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClearDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterClearDataCacheRulesStatement(s)
	}
}

func (s *ClearDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitClearDataCacheRulesStatement(s)
	}
}

func (s *ClearDataCacheRulesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitClearDataCacheRulesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ClearDataCacheRulesStatement() (localctx IClearDataCacheRulesStatementContext) {
	localctx = NewClearDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, StarRocksParserRULE_clearDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5359)
		p.Match(StarRocksParserCLEAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5360)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5361)
		p.Match(StarRocksParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheSelectStatementContext is an interface to support dynamic dispatch.
type IDataCacheSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	CACHE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	WHERE() antlr.TerminalNode
	Properties() IPropertiesContext
	Expression() IExpressionContext

	// IsDataCacheSelectStatementContext differentiates from other interfaces.
	IsDataCacheSelectStatementContext()
}

type DataCacheSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDataCacheSelectStatementContext() *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheSelectStatement
	return p
}

func InitEmptyDataCacheSelectStatementContext(p *DataCacheSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheSelectStatement
}

func (*DataCacheSelectStatementContext) IsDataCacheSelectStatementContext() {}

func NewDataCacheSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataCacheSelectStatement

	return p
}

func (s *DataCacheSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheSelectStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DataCacheSelectStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataCacheSelectStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCACHE, 0)
}

func (s *DataCacheSelectStatementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSELECT, 0)
}

func (s *DataCacheSelectStatementContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheSelectStatementContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *DataCacheSelectStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DataCacheSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DataCacheSelectStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DataCacheSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DataCacheSelectStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataCacheSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataCacheSelectStatement(s)
	}
}

func (s *DataCacheSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataCacheSelectStatement(s)
	}
}

func (s *DataCacheSelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDataCacheSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DataCacheSelectStatement() (localctx IDataCacheSelectStatementContext) {
	localctx = NewDataCacheSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, StarRocksParserRULE_dataCacheSelectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5363)
		p.Match(StarRocksParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5364)
		p.Match(StarRocksParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5365)
		p.SelectItem()
	}
	p.SetState(5370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5366)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5367)
			p.SelectItem()
		}

		p.SetState(5372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5373)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5374)
		p.QualifiedName()
	}
	p.SetState(5377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5375)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5376)

			var _x = p.expression(0)

			localctx.(*DataCacheSelectStatementContext).where = _x
		}

	}
	p.SetState(5380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5379)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableDesc() ITableDescContext
	TO() antlr.TerminalNode
	String_() IStringContext
	ColumnAliases() IColumnAliasesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	BrokerDesc() IBrokerDescContext
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *ExportStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ExportStatementContext) TableDesc() ITableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableDescContext)
}

func (s *ExportStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExportStatementContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ExportStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ExportStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *ExportStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExportStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *ExportStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *ExportStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (s *ExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, StarRocksParserRULE_exportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5382)
		p.Match(StarRocksParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5383)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5384)
		p.TableDesc()
	}
	p.SetState(5386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(5385)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(5388)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5389)
		p.String_()
	}
	p.SetState(5393)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5390)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5391)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5392)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5395)
			p.Properties()
		}

	}
	p.SetState(5399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(5398)
			p.BrokerDesc()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelExportStatementContext is an interface to support dynamic dispatch.
type ICancelExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsCancelExportStatementContext differentiates from other interfaces.
	IsCancelExportStatementContext()
}

type CancelExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyCancelExportStatementContext() *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelExportStatement
	return p
}

func InitEmptyCancelExportStatementContext(p *CancelExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelExportStatement
}

func (*CancelExportStatementContext) IsCancelExportStatementContext() {}

func NewCancelExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelExportStatement

	return p
}

func (s *CancelExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CancelExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *CancelExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CancelExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *CancelExportStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *CancelExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CancelExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *CancelExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CancelExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelExportStatement(s)
	}
}

func (s *CancelExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelExportStatement(s)
	}
}

func (s *CancelExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCancelExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CancelExportStatement() (localctx ICancelExportStatementContext) {
	localctx = NewCancelExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, StarRocksParserRULE_cancelExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5401)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5402)
		p.Match(StarRocksParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5403)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5404)

			var _x = p.QualifiedName()

			localctx.(*CancelExportStatementContext).catalog = _x
		}

	}
	p.SetState(5411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(5407)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5408)

			var _x = p.String_()

			localctx.(*CancelExportStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(5409)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5410)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowExportStatementContext is an interface to support dynamic dispatch.
type IShowExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowExportStatementContext differentiates from other interfaces.
	IsShowExportStatementContext()
}

type ShowExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowExportStatementContext() *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showExportStatement
	return p
}

func InitEmptyShowExportStatementContext(p *ShowExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showExportStatement
}

func (*ShowExportStatementContext) IsShowExportStatementContext() {}

func NewShowExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showExportStatement

	return p
}

func (s *ShowExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowExportStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *ShowExportStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowExportStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowExportStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowExportStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowExportStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowExportStatement(s)
	}
}

func (s *ShowExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowExportStatement(s)
	}
}

func (s *ShowExportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowExportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowExportStatement() (localctx IShowExportStatementContext) {
	localctx = NewShowExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, StarRocksParserRULE_showExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5413)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5414)
		p.Match(StarRocksParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5415)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5416)

			var _x = p.QualifiedName()

			localctx.(*ShowExportStatementContext).catalog = _x
		}

	}
	p.SetState(5423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(5419)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5420)

			var _x = p.String_()

			localctx.(*ShowExportStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(5421)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5422)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserLIMIT, StarRocksParserORDER, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(5435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(5425)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5426)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5427)
			p.SortItem()
		}
		p.SetState(5432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5428)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5429)
				p.SortItem()
			}

			p.SetState(5434)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(5437)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallPluginStatementContext is an interface to support dynamic dispatch.
type IInstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	Properties() IPropertiesContext

	// IsInstallPluginStatementContext differentiates from other interfaces.
	IsInstallPluginStatementContext()
}

type InstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginStatementContext() *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_installPluginStatement
	return p
}

func InitEmptyInstallPluginStatementContext(p *InstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_installPluginStatement
}

func (*InstallPluginStatementContext) IsInstallPluginStatementContext() {}

func NewInstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_installPluginStatement

	return p
}

func (s *InstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginStatementContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSTALL, 0)
}

func (s *InstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *InstallPluginStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *InstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *InstallPluginStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInstallPluginStatement(s)
	}
}

func (s *InstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInstallPluginStatement(s)
	}
}

func (s *InstallPluginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInstallPluginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) InstallPluginStatement() (localctx IInstallPluginStatementContext) {
	localctx = NewInstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, StarRocksParserRULE_installPluginStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5440)
		p.Match(StarRocksParserINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5441)
		p.Match(StarRocksParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5442)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5443)
		p.IdentifierOrString()
	}
	p.SetState(5445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5444)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUninstallPluginStatementContext is an interface to support dynamic dispatch.
type IUninstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUninstallPluginStatementContext differentiates from other interfaces.
	IsUninstallPluginStatementContext()
}

type UninstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginStatementContext() *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_uninstallPluginStatement
	return p
}

func InitEmptyUninstallPluginStatementContext(p *UninstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_uninstallPluginStatement
}

func (*UninstallPluginStatementContext) IsUninstallPluginStatementContext() {}

func NewUninstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_uninstallPluginStatement

	return p
}

func (s *UninstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginStatementContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNINSTALL, 0)
}

func (s *UninstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *UninstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UninstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UninstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUninstallPluginStatement(s)
	}
}

func (s *UninstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUninstallPluginStatement(s)
	}
}

func (s *UninstallPluginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUninstallPluginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UninstallPluginStatement() (localctx IUninstallPluginStatementContext) {
	localctx = NewUninstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, StarRocksParserRULE_uninstallPluginStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5447)
		p.Match(StarRocksParserUNINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5448)
		p.Match(StarRocksParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5449)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFileStatementContext is an interface to support dynamic dispatch.
type ICreateFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCreateFileStatementContext differentiates from other interfaces.
	IsCreateFileStatementContext()
}

type CreateFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyCreateFileStatementContext() *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFileStatement
	return p
}

func InitEmptyCreateFileStatementContext(p *CreateFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFileStatement
}

func (*CreateFileStatementContext) IsCreateFileStatementContext() {}

func NewCreateFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createFileStatement

	return p
}

func (s *CreateFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CreateFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CreateFileStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *CreateFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CreateFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CreateFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateFileStatement(s)
	}
}

func (s *CreateFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateFileStatement(s)
	}
}

func (s *CreateFileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateFileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateFileStatement() (localctx ICreateFileStatementContext) {
	localctx = NewCreateFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, StarRocksParserRULE_createFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5451)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5452)
		p.Match(StarRocksParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5453)
		p.String_()
	}
	p.SetState(5456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5454)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5455)

			var _x = p.QualifiedName()

			localctx.(*CreateFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5458)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFileStatementContext is an interface to support dynamic dispatch.
type IDropFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsDropFileStatementContext differentiates from other interfaces.
	IsDropFileStatementContext()
}

type DropFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyDropFileStatementContext() *DropFileStatementContext {
	var p = new(DropFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFileStatement
	return p
}

func InitEmptyDropFileStatementContext(p *DropFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFileStatement
}

func (*DropFileStatementContext) IsDropFileStatementContext() {}

func NewDropFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFileStatementContext {
	var p = new(DropFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFileStatement

	return p
}

func (s *DropFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *DropFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *DropFileStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *DropFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *DropFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFileStatement(s)
	}
}

func (s *DropFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFileStatement(s)
	}
}

func (s *DropFileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropFileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropFileStatement() (localctx IDropFileStatementContext) {
	localctx = NewDropFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, StarRocksParserRULE_dropFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5460)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5461)
		p.Match(StarRocksParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5462)
		p.String_()
	}
	p.SetState(5465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5463)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5464)

			var _x = p.QualifiedName()

			localctx.(*DropFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5467)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSmallFilesStatementContext is an interface to support dynamic dispatch.
type IShowSmallFilesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowSmallFilesStatementContext differentiates from other interfaces.
	IsShowSmallFilesStatementContext()
}

type ShowSmallFilesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyShowSmallFilesStatementContext() *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSmallFilesStatement
	return p
}

func InitEmptyShowSmallFilesStatementContext(p *ShowSmallFilesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSmallFilesStatement
}

func (*ShowSmallFilesStatementContext) IsShowSmallFilesStatementContext() {}

func NewShowSmallFilesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSmallFilesStatement

	return p
}

func (s *ShowSmallFilesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSmallFilesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowSmallFilesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowSmallFilesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSmallFilesStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *ShowSmallFilesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowSmallFilesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowSmallFilesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowSmallFilesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSmallFilesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSmallFilesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSmallFilesStatement(s)
	}
}

func (s *ShowSmallFilesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSmallFilesStatement(s)
	}
}

func (s *ShowSmallFilesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowSmallFilesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowSmallFilesStatement() (localctx IShowSmallFilesStatementContext) {
	localctx = NewShowSmallFilesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, StarRocksParserRULE_showSmallFilesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5469)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5470)
		p.Match(StarRocksParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5471)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5472)

			var _x = p.QualifiedName()

			localctx.(*ShowSmallFilesStatementContext).catalog = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatePipeStatementContext is an interface to support dynamic dispatch.
type ICreatePipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	PIPE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	InsertStatement() IInsertStatementContext
	Properties() IPropertiesContext

	// IsCreatePipeStatementContext differentiates from other interfaces.
	IsCreatePipeStatementContext()
}

type CreatePipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatePipeStatementContext() *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createPipeStatement
	return p
}

func InitEmptyCreatePipeStatementContext(p *CreatePipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createPipeStatement
}

func (*CreatePipeStatementContext) IsCreatePipeStatementContext() {}

func NewCreatePipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createPipeStatement

	return p
}

func (s *CreatePipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatePipeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreatePipeStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreatePipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *CreatePipeStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreatePipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreatePipeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreatePipeStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *CreatePipeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreatePipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatePipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreatePipeStatement(s)
	}
}

func (s *CreatePipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreatePipeStatement(s)
	}
}

func (s *CreatePipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreatePipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreatePipeStatement() (localctx ICreatePipeStatementContext) {
	localctx = NewCreatePipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, StarRocksParserRULE_createPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5475)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5476)
		p.OrReplace()
	}
	{
		p.SetState(5477)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5478)
		p.IfNotExists()
	}
	{
		p.SetState(5479)
		p.QualifiedName()
	}
	p.SetState(5481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5480)
			p.Properties()
		}

	}
	{
		p.SetState(5483)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5484)
		p.InsertStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPipeStatementContext is an interface to support dynamic dispatch.
type IDropPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropPipeStatementContext differentiates from other interfaces.
	IsDropPipeStatementContext()
}

type DropPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPipeStatementContext() *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPipeStatement
	return p
}

func InitEmptyDropPipeStatementContext(p *DropPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPipeStatement
}

func (*DropPipeStatementContext) IsDropPipeStatementContext() {}

func NewDropPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropPipeStatement

	return p
}

func (s *DropPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPipeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *DropPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropPipeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropPipeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropPipeStatement(s)
	}
}

func (s *DropPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropPipeStatement(s)
	}
}

func (s *DropPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropPipeStatement() (localctx IDropPipeStatementContext) {
	localctx = NewDropPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, StarRocksParserRULE_dropPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5486)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5487)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5488)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5489)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5492)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeClauseContext is an interface to support dynamic dispatch.
type IAlterPipeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileName returns the fileName rule contexts.
	GetFileName() IStringContext

	// SetFileName sets the fileName rule contexts.
	SetFileName(IStringContext)

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterPipeClauseContext differentiates from other interfaces.
	IsAlterPipeClauseContext()
}

type AlterPipeClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	fileName IStringContext
}

func NewEmptyAlterPipeClauseContext() *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeClause
	return p
}

func InitEmptyAlterPipeClauseContext(p *AlterPipeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeClause
}

func (*AlterPipeClauseContext) IsAlterPipeClauseContext() {}

func NewAlterPipeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPipeClause

	return p
}

func (s *AlterPipeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeClauseContext) GetFileName() IStringContext { return s.fileName }

func (s *AlterPipeClauseContext) SetFileName(v IStringContext) { s.fileName = v }

func (s *AlterPipeClauseContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUSPEND, 0)
}

func (s *AlterPipeClauseContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *AlterPipeClauseContext) RETRY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETRY, 0)
}

func (s *AlterPipeClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AlterPipeClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *AlterPipeClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPipeClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterPipeClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterPipeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPipeClause(s)
	}
}

func (s *AlterPipeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPipeClause(s)
	}
}

func (s *AlterPipeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterPipeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterPipeClause() (localctx IAlterPipeClauseContext) {
	localctx = NewAlterPipeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, StarRocksParserRULE_alterPipeClause)
	p.SetState(5503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5494)
			p.Match(StarRocksParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5495)
			p.Match(StarRocksParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5496)
			p.Match(StarRocksParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5497)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5498)
			p.Match(StarRocksParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5499)
			p.Match(StarRocksParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5500)

			var _x = p.String_()

			localctx.(*AlterPipeClauseContext).fileName = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5501)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5502)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeStatementContext is an interface to support dynamic dispatch.
type IAlterPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AlterPipeClause() IAlterPipeClauseContext

	// IsAlterPipeStatementContext differentiates from other interfaces.
	IsAlterPipeStatementContext()
}

type AlterPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPipeStatementContext() *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeStatement
	return p
}

func InitEmptyAlterPipeStatementContext(p *AlterPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeStatement
}

func (*AlterPipeStatementContext) IsAlterPipeStatementContext() {}

func NewAlterPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPipeStatement

	return p
}

func (s *AlterPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *AlterPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterPipeStatementContext) AlterPipeClause() IAlterPipeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeClauseContext)
}

func (s *AlterPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPipeStatement(s)
	}
}

func (s *AlterPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPipeStatement(s)
	}
}

func (s *AlterPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterPipeStatement() (localctx IAlterPipeStatementContext) {
	localctx = NewAlterPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, StarRocksParserRULE_alterPipeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5505)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5506)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5507)
		p.QualifiedName()
	}
	{
		p.SetState(5508)
		p.AlterPipeClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescPipeStatementContext is an interface to support dynamic dispatch.
type IDescPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescPipeStatementContext differentiates from other interfaces.
	IsDescPipeStatementContext()
}

type DescPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescPipeStatementContext() *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descPipeStatement
	return p
}

func InitEmptyDescPipeStatementContext(p *DescPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descPipeStatement
}

func (*DescPipeStatementContext) IsDescPipeStatementContext() {}

func NewDescPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_descPipeStatement

	return p
}

func (s *DescPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *DescPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescPipeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *DescPipeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *DescPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDescPipeStatement(s)
	}
}

func (s *DescPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDescPipeStatement(s)
	}
}

func (s *DescPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDescPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DescPipeStatement() (localctx IDescPipeStatementContext) {
	localctx = NewDescPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, StarRocksParserRULE_descPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5510)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDESC || _la == StarRocksParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5511)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5512)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPipeStatementContext is an interface to support dynamic dispatch.
type IShowPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	String_() IStringContext

	// IsShowPipeStatementContext differentiates from other interfaces.
	IsShowPipeStatementContext()
}

type ShowPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowPipeStatementContext() *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPipeStatement
	return p
}

func InitEmptyShowPipeStatementContext(p *ShowPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPipeStatement
}

func (*ShowPipeStatementContext) IsShowPipeStatementContext() {}

func NewShowPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPipeStatement

	return p
}

func (s *ShowPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPipeStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowPipeStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowPipeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPipeStatementContext) PIPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPES, 0)
}

func (s *ShowPipeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowPipeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowPipeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPipeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPipeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPipeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowPipeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowPipeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPipeStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPipeStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPipeStatement(s)
	}
}

func (s *ShowPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPipeStatement(s)
	}
}

func (s *ShowPipeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowPipeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowPipeStatement() (localctx IShowPipeStatementContext) {
	localctx = NewShowPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, StarRocksParserRULE_showPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5514)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5515)
		p.Match(StarRocksParserPIPES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(5516)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5517)

			var _x = p.String_()

			localctx.(*ShowPipeStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(5518)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5519)
			p.expression(0)
		}

	case StarRocksParserFROM:
		{
			p.SetState(5520)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5521)
			p.QualifiedName()
		}

	case StarRocksParserEOF, StarRocksParserLIMIT, StarRocksParserORDER, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(5534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(5524)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5525)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5526)
			p.SortItem()
		}
		p.SetState(5531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5527)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5528)
				p.SortItem()
			}

			p.SetState(5533)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(5536)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	AllSetVar() []ISetVarContext
	SetVar(i int) ISetVarContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetStatementContext) AllSetVar() []ISetVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetVarContext); ok {
			len++
		}
	}

	tst := make([]ISetVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetVarContext); ok {
			tst[i] = t.(ISetVarContext)
			i++
		}
	}

	return tst
}

func (s *SetStatementContext) SetVar(i int) ISetVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetVarContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, StarRocksParserRULE_setStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5539)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5540)
		p.SetVar()
	}
	p.SetState(5545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5541)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5542)
			p.SetVar()
		}

		p.SetState(5547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetVarContext is an interface to support dynamic dispatch.
type ISetVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetVarContext differentiates from other interfaces.
	IsSetVarContext()
}

type SetVarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVarContext() *SetVarContext {
	var p = new(SetVarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setVar
	return p
}

func InitEmptySetVarContext(p *SetVarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setVar
}

func (*SetVarContext) IsSetVarContext() {}

func NewSetVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVarContext {
	var p = new(SetVarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setVar

	return p
}

func (s *SetVarContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVarContext) CopyAll(ctx *SetVarContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SetVarContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *SetTransactionContext) Transaction_characteristics() ITransaction_characteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_characteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_characteristicsContext)
}

func (s *SetTransactionContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetNamesContext struct {
	SetVarContext
	charset IIdentifierOrStringContext
	collate IIdentifierOrStringContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetNamesContext) GetCharset() IIdentifierOrStringContext { return s.charset }

func (s *SetNamesContext) GetCollate() IIdentifierOrStringContext { return s.collate }

func (s *SetNamesContext) SetCharset(v IIdentifierOrStringContext) { s.charset = v }

func (s *SetNamesContext) SetCollate(v IIdentifierOrStringContext) { s.collate = v }

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetNamesContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *SetNamesContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *SetNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *SetNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetNamesContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserDEFAULT)
}

func (s *SetNamesContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, i)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAMES, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATE, 0)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetNames(s)
	}
}

func (s *SetNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetNames(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetPasswordContext struct {
	SetVarContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetPasswordContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *SetPasswordContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

func (s *SetPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetUserVarContext struct {
	SetVarContext
}

func NewSetUserVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVarContext {
	var p = new(SetUserVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetUserVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVarContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *SetUserVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetUserVarContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetUserVar(s)
	}
}

func (s *SetUserVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetUserVar(s)
	}
}

func (s *SetUserVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetUserVar(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSystemVarContext struct {
	SetVarContext
}

func NewSetSystemVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVarContext {
	var p = new(SetSystemVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetSystemVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetSystemVarContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *SetSystemVarContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetSystemVarContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SetSystemVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetSystemVar(s)
	}
}

func (s *SetSystemVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetSystemVar(s)
	}
}

func (s *SetSystemVarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetSystemVar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetVar() (localctx ISetVarContext) {
	localctx = NewSetVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, StarRocksParserRULE_setVar)
	var _la int

	p.SetState(5613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 610, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserCHAR:
			{
				p.SetState(5548)
				p.Match(StarRocksParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5549)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserCHARSET:
			{
				p.SetState(5550)
				p.Match(StarRocksParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserCHARACTER:
			{
				p.SetState(5551)
				p.Match(StarRocksParserCHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5552)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(5555)
				p.IdentifierOrString()
			}

		case StarRocksParserDEFAULT:
			{
				p.SetState(5556)
				p.Match(StarRocksParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5559)
			p.Match(StarRocksParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(5560)

				var _x = p.IdentifierOrString()

				localctx.(*SetNamesContext).charset = _x
			}

		case StarRocksParserDEFAULT:
			{
				p.SetState(5561)
				p.Match(StarRocksParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCOLLATE {
			{
				p.SetState(5564)
				p.Match(StarRocksParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5567)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
				{
					p.SetState(5565)

					var _x = p.IdentifierOrString()

					localctx.(*SetNamesContext).collate = _x
				}

			case StarRocksParserDEFAULT:
				{
					p.SetState(5566)
					p.Match(StarRocksParserDEFAULT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 3:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5571)
			p.Match(StarRocksParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5572)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5573)
				p.String_()
			}

		case StarRocksParserPASSWORD:
			{
				p.SetState(5574)
				p.Match(StarRocksParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5575)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5576)
				p.String_()
			}
			{
				p.SetState(5577)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5581)
			p.Match(StarRocksParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5582)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5583)
			p.User()
		}
		{
			p.SetState(5584)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5585)
				p.String_()
			}

		case StarRocksParserPASSWORD:
			{
				p.SetState(5586)
				p.Match(StarRocksParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5587)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5588)
				p.String_()
			}
			{
				p.SetState(5589)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetUserVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5593)
			p.UserVariable()
		}
		{
			p.SetState(5594)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5595)
			p.expression(0)
		}

	case 6:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(5598)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 608, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5597)
				p.VarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5600)
			p.Identifier()
		}
		{
			p.SetState(5601)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5602)
			p.SetExprOrDefault()
		}

	case 7:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5604)
			p.SystemVariable()
		}
		{
			p.SetState(5605)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5606)
			p.SetExprOrDefault()
		}

	case 8:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(5609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE {
			{
				p.SetState(5608)
				p.VarType()
			}

		}
		{
			p.SetState(5611)
			p.Match(StarRocksParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5612)
			p.Transaction_characteristics()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_characteristicsContext is an interface to support dynamic dispatch.
type ITransaction_characteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Transaction_access_mode() ITransaction_access_modeContext
	Isolation_level() IIsolation_levelContext

	// IsTransaction_characteristicsContext differentiates from other interfaces.
	IsTransaction_characteristicsContext()
}

type Transaction_characteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_characteristicsContext() *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_characteristics
	return p
}

func InitEmptyTransaction_characteristicsContext(p *Transaction_characteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_characteristics
}

func (*Transaction_characteristicsContext) IsTransaction_characteristicsContext() {}

func NewTransaction_characteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_transaction_characteristics

	return p
}

func (s *Transaction_characteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_characteristicsContext) Transaction_access_mode() ITransaction_access_modeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_access_modeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_access_modeContext)
}

func (s *Transaction_characteristicsContext) Isolation_level() IIsolation_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_levelContext)
}

func (s *Transaction_characteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_characteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_characteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTransaction_characteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Transaction_characteristics() (localctx ITransaction_characteristicsContext) {
	localctx = NewTransaction_characteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, StarRocksParserRULE_transaction_characteristics)
	p.SetState(5625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5615)
			p.Transaction_access_mode()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5616)
			p.Isolation_level()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5617)
			p.Transaction_access_mode()
		}
		{
			p.SetState(5618)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5619)
			p.Isolation_level()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5621)
			p.Isolation_level()
		}
		{
			p.SetState(5622)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5623)
			p.Transaction_access_mode()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_access_modeContext is an interface to support dynamic dispatch.
type ITransaction_access_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransaction_access_modeContext differentiates from other interfaces.
	IsTransaction_access_modeContext()
}

type Transaction_access_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_access_modeContext() *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_access_mode
	return p
}

func InitEmptyTransaction_access_modeContext(p *Transaction_access_modeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_access_mode
}

func (*Transaction_access_modeContext) IsTransaction_access_modeContext() {}

func NewTransaction_access_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_transaction_access_mode

	return p
}

func (s *Transaction_access_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_access_modeContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *Transaction_access_modeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserONLY, 0)
}

func (s *Transaction_access_modeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWRITE, 0)
}

func (s *Transaction_access_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_access_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_access_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTransaction_access_mode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Transaction_access_mode() (localctx ITransaction_access_modeContext) {
	localctx = NewTransaction_access_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, StarRocksParserRULE_transaction_access_mode)
	p.SetState(5631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5627)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5628)
			p.Match(StarRocksParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5629)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5630)
			p.Match(StarRocksParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_levelContext is an interface to support dynamic dispatch.
type IIsolation_levelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	Isolation_types() IIsolation_typesContext

	// IsIsolation_levelContext differentiates from other interfaces.
	IsIsolation_levelContext()
}

type Isolation_levelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_levelContext() *Isolation_levelContext {
	var p = new(Isolation_levelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_level
	return p
}

func InitEmptyIsolation_levelContext(p *Isolation_levelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_level
}

func (*Isolation_levelContext) IsIsolation_levelContext() {}

func NewIsolation_levelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_levelContext {
	var p = new(Isolation_levelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_isolation_level

	return p
}

func (s *Isolation_levelContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_levelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserISOLATION, 0)
}

func (s *Isolation_levelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEVEL, 0)
}

func (s *Isolation_levelContext) Isolation_types() IIsolation_typesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_typesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_typesContext)
}

func (s *Isolation_levelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_levelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_levelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIsolation_level(s)
	}
}

func (s *Isolation_levelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIsolation_level(s)
	}
}

func (s *Isolation_levelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIsolation_level(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Isolation_level() (localctx IIsolation_levelContext) {
	localctx = NewIsolation_levelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, StarRocksParserRULE_isolation_level)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5633)
		p.Match(StarRocksParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5634)
		p.Match(StarRocksParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5635)
		p.Isolation_types()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_typesContext is an interface to support dynamic dispatch.
type IIsolation_typesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolation_typesContext differentiates from other interfaces.
	IsIsolation_typesContext()
}

type Isolation_typesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_typesContext() *Isolation_typesContext {
	var p = new(Isolation_typesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_types
	return p
}

func InitEmptyIsolation_typesContext(p *Isolation_typesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_types
}

func (*Isolation_typesContext) IsIsolation_typesContext() {}

func NewIsolation_typesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_typesContext {
	var p = new(Isolation_typesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_isolation_types

	return p
}

func (s *Isolation_typesContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_typesContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *Isolation_typesContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNCOMMITTED, 0)
}

func (s *Isolation_typesContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMITTED, 0)
}

func (s *Isolation_typesContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPEATABLE, 0)
}

func (s *Isolation_typesContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSERIALIZABLE, 0)
}

func (s *Isolation_typesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_typesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_typesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIsolation_types(s)
	}
}

func (s *Isolation_typesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIsolation_types(s)
	}
}

func (s *Isolation_typesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIsolation_types(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Isolation_types() (localctx IIsolation_typesContext) {
	localctx = NewIsolation_typesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, StarRocksParserRULE_isolation_types)
	p.SetState(5644)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 613, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5637)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5638)
			p.Match(StarRocksParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5639)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5640)
			p.Match(StarRocksParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5641)
			p.Match(StarRocksParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5642)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5643)
			p.Match(StarRocksParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetExprOrDefaultContext is an interface to support dynamic dispatch.
type ISetExprOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSetExprOrDefaultContext differentiates from other interfaces.
	IsSetExprOrDefaultContext()
}

type SetExprOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExprOrDefaultContext() *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setExprOrDefault
	return p
}

func InitEmptySetExprOrDefaultContext(p *SetExprOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setExprOrDefault
}

func (*SetExprOrDefaultContext) IsSetExprOrDefaultContext() {}

func NewSetExprOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setExprOrDefault

	return p
}

func (s *SetExprOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExprOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetExprOrDefaultContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *SetExprOrDefaultContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetExprOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetExprOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExprOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExprOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetExprOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetExprOrDefault() (localctx ISetExprOrDefaultContext) {
	localctx = NewSetExprOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, StarRocksParserRULE_setExprOrDefault)
	p.SetState(5650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserDEFAULT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5646)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5647)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5648)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserT__1, StarRocksParserT__5, StarRocksParserT__8, StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCASE, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHAR, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCONVERT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserCURRENT_DATE, StarRocksParserCURRENT_GROUP, StarRocksParserCURRENT_ROLE, StarRocksParserCURRENT_TIME, StarRocksParserCURRENT_TIMESTAMP, StarRocksParserCURRENT_USER, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATABASE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDENSE_RANK, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserNTILE, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXISTS, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFALSE, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFIRST_VALUE, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUPING, StarRocksParserGROUPING_ID, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIF, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAG, StarRocksParserLAST, StarRocksParserLAST_VALUE, StarRocksParserLEAD, StarRocksParserLEFT, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIKE, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCALTIME, StarRocksParserLOCALTIMESTAMP, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMOD, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNOT, StarRocksParserNULL, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARAMETER, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREGEXP, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserRIGHT, StarRocksParserRLIKE, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserROW_NUMBER, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSCHEMA, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserPLUS_SYMBOL, StarRocksParserMINUS_SYMBOL, StarRocksParserLOGICAL_NOT, StarRocksParserBITNOT, StarRocksParserAT, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5649)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetUserPropertyStatementContext is an interface to support dynamic dispatch.
type ISetUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	UserPropertyList() IUserPropertyListContext
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsSetUserPropertyStatementContext differentiates from other interfaces.
	IsSetUserPropertyStatementContext()
}

type SetUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetUserPropertyStatementContext() *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setUserPropertyStatement
	return p
}

func InitEmptySetUserPropertyStatementContext(p *SetUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setUserPropertyStatement
}

func (*SetUserPropertyStatementContext) IsSetUserPropertyStatementContext() {}

func NewSetUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setUserPropertyStatement

	return p
}

func (s *SetUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetUserPropertyStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTY, 0)
}

func (s *SetUserPropertyStatementContext) UserPropertyList() IUserPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPropertyListContext)
}

func (s *SetUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *SetUserPropertyStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetUserPropertyStatement(s)
	}
}

func (s *SetUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetUserPropertyStatement(s)
	}
}

func (s *SetUserPropertyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetUserPropertyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetUserPropertyStatement() (localctx ISetUserPropertyStatementContext) {
	localctx = NewSetUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, StarRocksParserRULE_setUserPropertyStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5652)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5653)
		p.Match(StarRocksParserPROPERTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(5654)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5655)
			p.String_()
		}

	}
	{
		p.SetState(5658)
		p.UserPropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleListContext is an interface to support dynamic dispatch.
type IRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsRoleListContext differentiates from other interfaces.
	IsRoleListContext()
}

type RoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleListContext() *RoleListContext {
	var p = new(RoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_roleList
	return p
}

func InitEmptyRoleListContext(p *RoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_roleList
}

func (*RoleListContext) IsRoleListContext() {}

func NewRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleListContext {
	var p = new(RoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_roleList

	return p
}

func (s *RoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *RoleListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRoleList(s)
	}
}

func (s *RoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRoleList(s)
	}
}

func (s *RoleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRoleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RoleList() (localctx IRoleListContext) {
	localctx = NewRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, StarRocksParserRULE_roleList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5660)
		p.IdentifierOrString()
	}
	p.SetState(5665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5661)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5662)
			p.IdentifierOrString()
		}

		p.SetState(5667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteScriptStatementContext is an interface to support dynamic dispatch.
type IExecuteScriptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	ON() antlr.TerminalNode
	String_() IStringContext
	FRONTEND() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsExecuteScriptStatementContext differentiates from other interfaces.
	IsExecuteScriptStatementContext()
}

type ExecuteScriptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteScriptStatementContext() *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeScriptStatement
	return p
}

func InitEmptyExecuteScriptStatementContext(p *ExecuteScriptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeScriptStatement
}

func (*ExecuteScriptStatementContext) IsExecuteScriptStatementContext() {}

func NewExecuteScriptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_executeScriptStatement

	return p
}

func (s *ExecuteScriptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteScriptStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *ExecuteScriptStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *ExecuteScriptStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ExecuteScriptStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExecuteScriptStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *ExecuteScriptStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ExecuteScriptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteScriptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteScriptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExecuteScriptStatement(s)
	}
}

func (s *ExecuteScriptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExecuteScriptStatement(s)
	}
}

func (s *ExecuteScriptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExecuteScriptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExecuteScriptStatement() (localctx IExecuteScriptStatementContext) {
	localctx = NewExecuteScriptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, StarRocksParserRULE_executeScriptStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5668)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5669)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5670)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5671)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFRONTEND || _la == StarRocksParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5672)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllLock_item() []ILock_itemContext
	Lock_item(i int) ILock_itemContext
	UNLOCK() antlr.TerminalNode

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCK, 0)
}

func (s *UnsupportedStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *UnsupportedStatementContext) AllLock_item() []ILock_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILock_itemContext); ok {
			len++
		}
	}

	tst := make([]ILock_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILock_itemContext); ok {
			tst[i] = t.(ILock_itemContext)
			i++
		}
	}

	return tst
}

func (s *UnsupportedStatementContext) Lock_item(i int) ILock_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_itemContext)
}

func (s *UnsupportedStatementContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNLOCK, 0)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUnsupportedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, StarRocksParserRULE_unsupportedStatement)
	var _la int

	p.SetState(5686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5674)
			p.Match(StarRocksParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5675)
			p.Match(StarRocksParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5676)
			p.Lock_item()
		}
		p.SetState(5681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5677)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5678)
				p.Lock_item()
			}

			p.SetState(5683)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case StarRocksParserUNLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5684)
			p.Match(StarRocksParserUNLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5685)
			p.Match(StarRocksParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_itemContext is an interface to support dynamic dispatch.
type ILock_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Lock_type() ILock_typeContext
	AS() antlr.TerminalNode

	// IsLock_itemContext differentiates from other interfaces.
	IsLock_itemContext()
}

type Lock_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyLock_itemContext() *Lock_itemContext {
	var p = new(Lock_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_item
	return p
}

func InitEmptyLock_itemContext(p *Lock_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_item
}

func (*Lock_itemContext) IsLock_itemContext() {}

func NewLock_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_itemContext {
	var p = new(Lock_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_lock_item

	return p
}

func (s *Lock_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_itemContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Lock_itemContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Lock_itemContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Lock_itemContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Lock_itemContext) Lock_type() ILock_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_typeContext)
}

func (s *Lock_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *Lock_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLock_item(s)
	}
}

func (s *Lock_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLock_item(s)
	}
}

func (s *Lock_itemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLock_item(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Lock_item() (localctx ILock_itemContext) {
	localctx = NewLock_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, StarRocksParserRULE_lock_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5688)
		p.Identifier()
	}
	p.SetState(5693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) == 1 {
		p.SetState(5690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(5689)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5692)

			var _x = p.Identifier()

			localctx.(*Lock_itemContext).alias = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5695)
		p.Lock_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_typeContext is an interface to support dynamic dispatch.
type ILock_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLock_typeContext differentiates from other interfaces.
	IsLock_typeContext()
}

type Lock_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_typeContext() *Lock_typeContext {
	var p = new(Lock_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_type
	return p
}

func InitEmptyLock_typeContext(p *Lock_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_type
}

func (*Lock_typeContext) IsLock_typeContext() {}

func NewLock_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_typeContext {
	var p = new(Lock_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_lock_type

	return p
}

func (s *Lock_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_typeContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *Lock_typeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCAL, 0)
}

func (s *Lock_typeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWRITE, 0)
}

func (s *Lock_typeContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOW_PRIORITY, 0)
}

func (s *Lock_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLock_type(s)
	}
}

func (s *Lock_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLock_type(s)
	}
}

func (s *Lock_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLock_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Lock_type() (localctx ILock_typeContext) {
	localctx = NewLock_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, StarRocksParserRULE_lock_type)
	var _la int

	p.SetState(5705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5697)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLOCAL {
			{
				p.SetState(5698)
				p.Match(StarRocksParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserWRITE, StarRocksParserLOW_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLOW_PRIORITY {
			{
				p.SetState(5701)
				p.Match(StarRocksParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5704)
			p.Match(StarRocksParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorAddStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	ADD() antlr.TerminalNode
	QueryStatement() IQueryStatementContext

	// IsAlterPlanAdvisorAddStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorAddStatementContext()
}

type AlterPlanAdvisorAddStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorAddStatementContext() *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorAddStatement
	return p
}

func InitEmptyAlterPlanAdvisorAddStatementContext(p *AlterPlanAdvisorAddStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorAddStatement
}

func (*AlterPlanAdvisorAddStatementContext) IsAlterPlanAdvisorAddStatementContext() {}

func NewAlterPlanAdvisorAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorAddStatement

	return p
}

func (s *AlterPlanAdvisorAddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorAddStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterPlanAdvisorAddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorAddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorAddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPlanAdvisorAddStatement(s)
	}
}

func (s *AlterPlanAdvisorAddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPlanAdvisorAddStatement(s)
	}
}

func (s *AlterPlanAdvisorAddStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterPlanAdvisorAddStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterPlanAdvisorAddStatement() (localctx IAlterPlanAdvisorAddStatementContext) {
	localctx = NewAlterPlanAdvisorAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, StarRocksParserRULE_alterPlanAdvisorAddStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5707)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5708)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5709)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5710)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5711)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePlanAdvisorStatementContext is an interface to support dynamic dispatch.
type ITruncatePlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsTruncatePlanAdvisorStatementContext differentiates from other interfaces.
	IsTruncatePlanAdvisorStatementContext()
}

type TruncatePlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePlanAdvisorStatementContext() *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePlanAdvisorStatement
	return p
}

func InitEmptyTruncatePlanAdvisorStatementContext(p *TruncatePlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePlanAdvisorStatement
}

func (*TruncatePlanAdvisorStatementContext) IsTruncatePlanAdvisorStatementContext() {}

func NewTruncatePlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_truncatePlanAdvisorStatement

	return p
}

func (s *TruncatePlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePlanAdvisorStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *TruncatePlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *TruncatePlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *TruncatePlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTruncatePlanAdvisorStatement(s)
	}
}

func (s *TruncatePlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTruncatePlanAdvisorStatement(s)
	}
}

func (s *TruncatePlanAdvisorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTruncatePlanAdvisorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TruncatePlanAdvisorStatement() (localctx ITruncatePlanAdvisorStatementContext) {
	localctx = NewTruncatePlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, StarRocksParserRULE_truncatePlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5713)
		p.Match(StarRocksParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5714)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5715)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorDropStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	DROP() antlr.TerminalNode
	String_() IStringContext

	// IsAlterPlanAdvisorDropStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorDropStatementContext()
}

type AlterPlanAdvisorDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorDropStatementContext() *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorDropStatement
	return p
}

func InitEmptyAlterPlanAdvisorDropStatementContext(p *AlterPlanAdvisorDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorDropStatement
}

func (*AlterPlanAdvisorDropStatementContext) IsAlterPlanAdvisorDropStatementContext() {}

func NewAlterPlanAdvisorDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorDropStatement

	return p
}

func (s *AlterPlanAdvisorDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorDropStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPlanAdvisorDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorDropStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPlanAdvisorDropStatement(s)
	}
}

func (s *AlterPlanAdvisorDropStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPlanAdvisorDropStatement(s)
	}
}

func (s *AlterPlanAdvisorDropStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterPlanAdvisorDropStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterPlanAdvisorDropStatement() (localctx IAlterPlanAdvisorDropStatementContext) {
	localctx = NewAlterPlanAdvisorDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, StarRocksParserRULE_alterPlanAdvisorDropStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5717)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5718)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5719)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5720)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5721)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPlanAdvisorStatementContext is an interface to support dynamic dispatch.
type IShowPlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsShowPlanAdvisorStatementContext differentiates from other interfaces.
	IsShowPlanAdvisorStatementContext()
}

type ShowPlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPlanAdvisorStatementContext() *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPlanAdvisorStatement
	return p
}

func InitEmptyShowPlanAdvisorStatementContext(p *ShowPlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPlanAdvisorStatement
}

func (*ShowPlanAdvisorStatementContext) IsShowPlanAdvisorStatementContext() {}

func NewShowPlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPlanAdvisorStatement

	return p
}

func (s *ShowPlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPlanAdvisorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *ShowPlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *ShowPlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPlanAdvisorStatement(s)
	}
}

func (s *ShowPlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPlanAdvisorStatement(s)
	}
}

func (s *ShowPlanAdvisorStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowPlanAdvisorStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowPlanAdvisorStatement() (localctx IShowPlanAdvisorStatementContext) {
	localctx = NewShowPlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, StarRocksParserRULE_showPlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5723)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5724)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5725)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateWarehouseStatementContext is an interface to support dynamic dispatch.
type ICreateWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	WAREHOUSE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateWarehouseStatementContext differentiates from other interfaces.
	IsCreateWarehouseStatementContext()
}

type CreateWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyCreateWarehouseStatementContext() *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createWarehouseStatement
	return p
}

func InitEmptyCreateWarehouseStatementContext(p *CreateWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createWarehouseStatement
}

func (*CreateWarehouseStatementContext) IsCreateWarehouseStatementContext() {}

func NewCreateWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createWarehouseStatement

	return p
}

func (s *CreateWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *CreateWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *CreateWarehouseStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *CreateWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateWarehouseStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateWarehouseStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateWarehouseStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateWarehouseStatement(s)
	}
}

func (s *CreateWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateWarehouseStatement(s)
	}
}

func (s *CreateWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateWarehouseStatement() (localctx ICreateWarehouseStatementContext) {
	localctx = NewCreateWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, StarRocksParserRULE_createWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5727)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(5728)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(5732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5729)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5730)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5731)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5734)

		var _x = p.IdentifierOrString()

		localctx.(*CreateWarehouseStatementContext).warehouseName = _x
	}
	p.SetState(5736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(5735)
			p.Comment()
		}

	}
	p.SetState(5739)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5738)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropWarehouseStatementContext is an interface to support dynamic dispatch.
type IDropWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropWarehouseStatementContext differentiates from other interfaces.
	IsDropWarehouseStatementContext()
}

type DropWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyDropWarehouseStatementContext() *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropWarehouseStatement
	return p
}

func InitEmptyDropWarehouseStatementContext(p *DropWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropWarehouseStatement
}

func (*DropWarehouseStatementContext) IsDropWarehouseStatementContext() {}

func NewDropWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropWarehouseStatement

	return p
}

func (s *DropWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropWarehouseStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DropWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropWarehouseStatement(s)
	}
}

func (s *DropWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropWarehouseStatement(s)
	}
}

func (s *DropWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropWarehouseStatement() (localctx IDropWarehouseStatementContext) {
	localctx = NewDropWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, StarRocksParserRULE_dropWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5741)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5742)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5743)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5744)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5747)

		var _x = p.IdentifierOrString()

		localctx.(*DropWarehouseStatementContext).warehouseName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuspendWarehouseStatementContext is an interface to support dynamic dispatch.
type ISuspendWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsSuspendWarehouseStatementContext differentiates from other interfaces.
	IsSuspendWarehouseStatementContext()
}

type SuspendWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuspendWarehouseStatementContext() *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_suspendWarehouseStatement
	return p
}

func InitEmptySuspendWarehouseStatementContext(p *SuspendWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_suspendWarehouseStatement
}

func (*SuspendWarehouseStatementContext) IsSuspendWarehouseStatementContext() {}

func NewSuspendWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_suspendWarehouseStatement

	return p
}

func (s *SuspendWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SuspendWarehouseStatementContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUSPEND, 0)
}

func (s *SuspendWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *SuspendWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuspendWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SuspendWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *SuspendWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuspendWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuspendWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSuspendWarehouseStatement(s)
	}
}

func (s *SuspendWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSuspendWarehouseStatement(s)
	}
}

func (s *SuspendWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSuspendWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SuspendWarehouseStatement() (localctx ISuspendWarehouseStatementContext) {
	localctx = NewSuspendWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, StarRocksParserRULE_suspendWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5749)
		p.Match(StarRocksParserSUSPEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5750)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5751)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5752)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5755)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeWarehouseStatementContext is an interface to support dynamic dispatch.
type IResumeWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsResumeWarehouseStatementContext differentiates from other interfaces.
	IsResumeWarehouseStatementContext()
}

type ResumeWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResumeWarehouseStatementContext() *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeWarehouseStatement
	return p
}

func InitEmptyResumeWarehouseStatementContext(p *ResumeWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeWarehouseStatement
}

func (*ResumeWarehouseStatementContext) IsResumeWarehouseStatementContext() {}

func NewResumeWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_resumeWarehouseStatement

	return p
}

func (s *ResumeWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeWarehouseStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *ResumeWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *ResumeWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *ResumeWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *ResumeWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterResumeWarehouseStatement(s)
	}
}

func (s *ResumeWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitResumeWarehouseStatement(s)
	}
}

func (s *ResumeWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitResumeWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ResumeWarehouseStatement() (localctx IResumeWarehouseStatementContext) {
	localctx = NewResumeWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, StarRocksParserRULE_resumeWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5757)
		p.Match(StarRocksParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5758)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5759)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5760)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5763)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetWarehouseStatementContext is an interface to support dynamic dispatch.
type ISetWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	SESSION() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsSetWarehouseStatementContext differentiates from other interfaces.
	IsSetWarehouseStatementContext()
}

type SetWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetWarehouseStatementContext() *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setWarehouseStatement
	return p
}

func InitEmptySetWarehouseStatementContext(p *SetWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setWarehouseStatement
}

func (*SetWarehouseStatementContext) IsSetWarehouseStatementContext() {}

func NewSetWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setWarehouseStatement

	return p
}

func (s *SetWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetWarehouseStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *SetWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetWarehouseStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *SetWarehouseStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetWarehouseStatement(s)
	}
}

func (s *SetWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetWarehouseStatement(s)
	}
}

func (s *SetWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetWarehouseStatement() (localctx ISetWarehouseStatementContext) {
	localctx = NewSetWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, StarRocksParserRULE_setWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5765)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSESSION {
		{
			p.SetState(5766)
			p.Match(StarRocksParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5769)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEQ {
		{
			p.SetState(5770)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5773)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarehousesStatementContext is an interface to support dynamic dispatch.
type IShowWarehousesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowWarehousesStatementContext differentiates from other interfaces.
	IsShowWarehousesStatementContext()
}

type ShowWarehousesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowWarehousesStatementContext() *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarehousesStatement
	return p
}

func InitEmptyShowWarehousesStatementContext(p *ShowWarehousesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarehousesStatement
}

func (*ShowWarehousesStatementContext) IsShowWarehousesStatementContext() {}

func NewShowWarehousesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showWarehousesStatement

	return p
}

func (s *ShowWarehousesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarehousesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowWarehousesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowWarehousesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowWarehousesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *ShowWarehousesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowWarehousesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowWarehousesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarehousesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarehousesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowWarehousesStatement(s)
	}
}

func (s *ShowWarehousesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowWarehousesStatement(s)
	}
}

func (s *ShowWarehousesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowWarehousesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowWarehousesStatement() (localctx IShowWarehousesStatementContext) {
	localctx = NewShowWarehousesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, StarRocksParserRULE_showWarehousesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5775)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5776)
		p.Match(StarRocksParserWAREHOUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(5777)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5778)

			var _x = p.String_()

			localctx.(*ShowWarehousesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowClustersStatementContext is an interface to support dynamic dispatch.
type IShowClustersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	CLUSTERS() antlr.TerminalNode
	CNGROUPS() antlr.TerminalNode

	// IsShowClustersStatementContext differentiates from other interfaces.
	IsShowClustersStatementContext()
}

type ShowClustersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowClustersStatementContext() *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showClustersStatement
	return p
}

func InitEmptyShowClustersStatementContext(p *ShowClustersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showClustersStatement
}

func (*ShowClustersStatementContext) IsShowClustersStatementContext() {}

func NewShowClustersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showClustersStatement

	return p
}

func (s *ShowClustersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowClustersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowClustersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowClustersStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *ShowClustersStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowClustersStatementContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTERS, 0)
}

func (s *ShowClustersStatementContext) CNGROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUPS, 0)
}

func (s *ShowClustersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowClustersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowClustersStatement(s)
	}
}

func (s *ShowClustersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowClustersStatement(s)
	}
}

func (s *ShowClustersStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowClustersStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowClustersStatement() (localctx IShowClustersStatementContext) {
	localctx = NewShowClustersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, StarRocksParserRULE_showClustersStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5781)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5782)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserCLUSTERS || _la == StarRocksParserCNGROUPS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5783)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5784)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5785)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowNodesStatementContext is an interface to support dynamic dispatch.
type IShowNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	NODES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	CNGROUP() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowNodesStatementContext differentiates from other interfaces.
	IsShowNodesStatementContext()
}

type ShowNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	pattern     IStringContext
	cngroupName IIdentifierOrStringContext
}

func NewEmptyShowNodesStatementContext() *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showNodesStatement
	return p
}

func InitEmptyShowNodesStatementContext(p *ShowNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showNodesStatement
}

func (*ShowNodesStatementContext) IsShowNodesStatementContext() {}

func NewShowNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showNodesStatement

	return p
}

func (s *ShowNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowNodesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowNodesStatementContext) GetCngroupName() IIdentifierOrStringContext { return s.cngroupName }

func (s *ShowNodesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowNodesStatementContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *ShowNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODES, 0)
}

func (s *ShowNodesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowNodesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *ShowNodesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowNodesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowNodesStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *ShowNodesStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowNodesStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *ShowNodesStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowNodesStatement(s)
	}
}

func (s *ShowNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowNodesStatement(s)
	}
}

func (s *ShowNodesStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitShowNodesStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ShowNodesStatement() (localctx IShowNodesStatementContext) {
	localctx = NewShowNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, StarRocksParserRULE_showNodesStatement)
	var _la int

	p.SetState(5804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5787)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5788)
			p.Match(StarRocksParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5789)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5790)
			p.Match(StarRocksParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIKE {
			{
				p.SetState(5791)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5792)

				var _x = p.String_()

				localctx.(*ShowNodesStatementContext).pattern = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5795)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5796)
			p.Match(StarRocksParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5797)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5798)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5799)
			p.Identifier()
		}
		p.SetState(5802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCNGROUP {
			{
				p.SetState(5800)
				p.Match(StarRocksParserCNGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5801)

				var _x = p.IdentifierOrString()

				localctx.(*ShowNodesStatementContext).cngroupName = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterWarehouseStatementContext is an interface to support dynamic dispatch.
type IAlterWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterWarehouseStatementContext differentiates from other interfaces.
	IsAlterWarehouseStatementContext()
}

type AlterWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyAlterWarehouseStatementContext() *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterWarehouseStatement
	return p
}

func InitEmptyAlterWarehouseStatementContext(p *AlterWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterWarehouseStatement
}

func (*AlterWarehouseStatementContext) IsAlterWarehouseStatementContext() {}

func NewAlterWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterWarehouseStatement

	return p
}

func (s *AlterWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AlterWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AlterWarehouseStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *AlterWarehouseStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterWarehouseStatement(s)
	}
}

func (s *AlterWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterWarehouseStatement(s)
	}
}

func (s *AlterWarehouseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterWarehouseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterWarehouseStatement() (localctx IAlterWarehouseStatementContext) {
	localctx = NewAlterWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, StarRocksParserRULE_alterWarehouseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5806)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5807)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5808)

		var _x = p.IdentifierOrString()

		localctx.(*AlterWarehouseStatementContext).warehouseName = _x
	}
	{
		p.SetState(5809)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateCNGroupStatementContext is an interface to support dynamic dispatch.
type ICreateCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ADD() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateCNGroupStatementContext differentiates from other interfaces.
	IsCreateCNGroupStatementContext()
}

type CreateCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyCreateCNGroupStatementContext() *CreateCNGroupStatementContext {
	var p = new(CreateCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createCNGroupStatement
	return p
}

func InitEmptyCreateCNGroupStatementContext(p *CreateCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createCNGroupStatement
}

func (*CreateCNGroupStatementContext) IsCreateCNGroupStatementContext() {}

func NewCreateCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateCNGroupStatementContext {
	var p = new(CreateCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createCNGroupStatement

	return p
}

func (s *CreateCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *CreateCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *CreateCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *CreateCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *CreateCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *CreateCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *CreateCNGroupStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *CreateCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *CreateCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *CreateCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateCNGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateCNGroupStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateCNGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateCNGroupStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateCNGroupStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateCNGroupStatement(s)
	}
}

func (s *CreateCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateCNGroupStatement(s)
	}
}

func (s *CreateCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCreateCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CreateCNGroupStatement() (localctx ICreateCNGroupStatementContext) {
	localctx = NewCreateCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, StarRocksParserRULE_createCNGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5811)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5812)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5813)

		var _x = p.IdentifierOrString()

		localctx.(*CreateCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5814)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5815)
		p.Match(StarRocksParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5816)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5817)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5818)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5821)

		var _x = p.IdentifierOrString()

		localctx.(*CreateCNGroupStatementContext).cngroupName = _x
	}
	p.SetState(5823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(5822)
			p.Comment()
		}

	}
	p.SetState(5826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5825)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropCNGroupStatementContext is an interface to support dynamic dispatch.
type IDropCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropCNGroupStatementContext differentiates from other interfaces.
	IsDropCNGroupStatementContext()
}

type DropCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDropCNGroupStatementContext() *DropCNGroupStatementContext {
	var p = new(DropCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropCNGroupStatement
	return p
}

func InitEmptyDropCNGroupStatementContext(p *DropCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropCNGroupStatement
}

func (*DropCNGroupStatementContext) IsDropCNGroupStatementContext() {}

func NewDropCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropCNGroupStatementContext {
	var p = new(DropCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropCNGroupStatement

	return p
}

func (s *DropCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DropCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) { s.cngroupName = v }

func (s *DropCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *DropCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DropCNGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *DropCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DropCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropCNGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropCNGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropCNGroupStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropCNGroupStatement(s)
	}
}

func (s *DropCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropCNGroupStatement(s)
	}
}

func (s *DropCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDropCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DropCNGroupStatement() (localctx IDropCNGroupStatementContext) {
	localctx = NewDropCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, StarRocksParserRULE_dropCNGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5828)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5829)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5830)

		var _x = p.IdentifierOrString()

		localctx.(*DropCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5831)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5832)
		p.Match(StarRocksParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5833)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5834)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5837)

		var _x = p.IdentifierOrString()

		localctx.(*DropCNGroupStatementContext).cngroupName = _x
	}
	p.SetState(5839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(5838)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnableCNGroupStatementContext is an interface to support dynamic dispatch.
type IEnableCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsEnableCNGroupStatementContext differentiates from other interfaces.
	IsEnableCNGroupStatementContext()
}

type EnableCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyEnableCNGroupStatementContext() *EnableCNGroupStatementContext {
	var p = new(EnableCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_enableCNGroupStatement
	return p
}

func InitEmptyEnableCNGroupStatementContext(p *EnableCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_enableCNGroupStatement
}

func (*EnableCNGroupStatementContext) IsEnableCNGroupStatementContext() {}

func NewEnableCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableCNGroupStatementContext {
	var p = new(EnableCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_enableCNGroupStatement

	return p
}

func (s *EnableCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *EnableCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *EnableCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *EnableCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *EnableCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *EnableCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *EnableCNGroupStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENABLE, 0)
}

func (s *EnableCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *EnableCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *EnableCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *EnableCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterEnableCNGroupStatement(s)
	}
}

func (s *EnableCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitEnableCNGroupStatement(s)
	}
}

func (s *EnableCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitEnableCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) EnableCNGroupStatement() (localctx IEnableCNGroupStatementContext) {
	localctx = NewEnableCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, StarRocksParserRULE_enableCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5841)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5842)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5843)

		var _x = p.IdentifierOrString()

		localctx.(*EnableCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5844)
		p.Match(StarRocksParserENABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5845)
		p.Match(StarRocksParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5846)

		var _x = p.IdentifierOrString()

		localctx.(*EnableCNGroupStatementContext).cngroupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisableCNGroupStatementContext is an interface to support dynamic dispatch.
type IDisableCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsDisableCNGroupStatementContext differentiates from other interfaces.
	IsDisableCNGroupStatementContext()
}

type DisableCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyDisableCNGroupStatementContext() *DisableCNGroupStatementContext {
	var p = new(DisableCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_disableCNGroupStatement
	return p
}

func InitEmptyDisableCNGroupStatementContext(p *DisableCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_disableCNGroupStatement
}

func (*DisableCNGroupStatementContext) IsDisableCNGroupStatementContext() {}

func NewDisableCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableCNGroupStatementContext {
	var p = new(DisableCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_disableCNGroupStatement

	return p
}

func (s *DisableCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DisableCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *DisableCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DisableCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *DisableCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *DisableCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DisableCNGroupStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *DisableCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *DisableCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *DisableCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DisableCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDisableCNGroupStatement(s)
	}
}

func (s *DisableCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDisableCNGroupStatement(s)
	}
}

func (s *DisableCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDisableCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DisableCNGroupStatement() (localctx IDisableCNGroupStatementContext) {
	localctx = NewDisableCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, StarRocksParserRULE_disableCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5848)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5849)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5850)

		var _x = p.IdentifierOrString()

		localctx.(*DisableCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5851)
		p.Match(StarRocksParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5852)
		p.Match(StarRocksParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5853)

		var _x = p.IdentifierOrString()

		localctx.(*DisableCNGroupStatementContext).cngroupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCNGroupStatementContext is an interface to support dynamic dispatch.
type IAlterCNGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// GetCngroupName returns the cngroupName rule contexts.
	GetCngroupName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// SetCngroupName sets the cngroupName rule contexts.
	SetCngroupName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsAlterCNGroupStatementContext differentiates from other interfaces.
	IsAlterCNGroupStatementContext()
}

type AlterCNGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
	cngroupName   IIdentifierOrStringContext
}

func NewEmptyAlterCNGroupStatementContext() *AlterCNGroupStatementContext {
	var p = new(AlterCNGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterCNGroupStatement
	return p
}

func InitEmptyAlterCNGroupStatementContext(p *AlterCNGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterCNGroupStatement
}

func (*AlterCNGroupStatementContext) IsAlterCNGroupStatementContext() {}

func NewAlterCNGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCNGroupStatementContext {
	var p = new(AlterCNGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterCNGroupStatement

	return p
}

func (s *AlterCNGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCNGroupStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AlterCNGroupStatementContext) GetCngroupName() IIdentifierOrStringContext {
	return s.cngroupName
}

func (s *AlterCNGroupStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AlterCNGroupStatementContext) SetCngroupName(v IIdentifierOrStringContext) {
	s.cngroupName = v
}

func (s *AlterCNGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterCNGroupStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *AlterCNGroupStatementContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *AlterCNGroupStatementContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *AlterCNGroupStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterCNGroupStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *AlterCNGroupStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterCNGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCNGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCNGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterCNGroupStatement(s)
	}
}

func (s *AlterCNGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterCNGroupStatement(s)
	}
}

func (s *AlterCNGroupStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAlterCNGroupStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AlterCNGroupStatement() (localctx IAlterCNGroupStatementContext) {
	localctx = NewAlterCNGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, StarRocksParserRULE_alterCNGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5855)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5856)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5857)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCNGroupStatementContext).warehouseName = _x
	}
	{
		p.SetState(5858)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5859)
		p.Match(StarRocksParserCNGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5860)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCNGroupStatementContext).cngroupName = _x
	}
	{
		p.SetState(5861)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginStatementContext is an interface to support dynamic dispatch.
type IBeginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsBeginStatementContext differentiates from other interfaces.
	IsBeginStatementContext()
}

type BeginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginStatementContext() *BeginStatementContext {
	var p = new(BeginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_beginStatement
	return p
}

func InitEmptyBeginStatementContext(p *BeginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_beginStatement
}

func (*BeginStatementContext) IsBeginStatementContext() {}

func NewBeginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginStatementContext {
	var p = new(BeginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_beginStatement

	return p
}

func (s *BeginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginStatementContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *BeginStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *BeginStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *BeginStatementContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONSISTENT, 0)
}

func (s *BeginStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *BeginStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEGIN, 0)
}

func (s *BeginStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *BeginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBeginStatement(s)
	}
}

func (s *BeginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBeginStatement(s)
	}
}

func (s *BeginStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBeginStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BeginStatement() (localctx IBeginStatementContext) {
	localctx = NewBeginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, StarRocksParserRULE_beginStatement)
	var _la int

	p.SetState(5874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserSTART:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5863)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5864)
			p.Match(StarRocksParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(5865)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5866)
				p.Match(StarRocksParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5867)
				p.Match(StarRocksParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserBEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5870)
			p.Match(StarRocksParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWORK {
			{
				p.SetState(5871)
				p.Match(StarRocksParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitStatementContext is an interface to support dynamic dispatch.
type ICommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitStatementContext differentiates from other interfaces.
	IsCommitStatementContext()
}

type CommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitStatementContext() *CommitStatementContext {
	var p = new(CommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commitStatement
	return p
}

func InitEmptyCommitStatementContext(p *CommitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commitStatement
}

func (*CommitStatementContext) IsCommitStatementContext() {}

func NewCommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitStatementContext {
	var p = new(CommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_commitStatement

	return p
}

func (s *CommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitStatementContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMIT, 0)
}

func (s *CommitStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *CommitStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *CommitStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAIN, 0)
}

func (s *CommitStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRELEASE, 0)
}

func (s *CommitStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserNO)
}

func (s *CommitStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, i)
}

func (s *CommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCommitStatement(s)
	}
}

func (s *CommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCommitStatement(s)
	}
}

func (s *CommitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCommitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CommitStatement() (localctx ICommitStatementContext) {
	localctx = NewCommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, StarRocksParserRULE_commitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5876)
		p.Match(StarRocksParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWORK {
		{
			p.SetState(5877)
			p.Match(StarRocksParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAND {
		{
			p.SetState(5880)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5881)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5884)
			p.Match(StarRocksParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNO || _la == StarRocksParserRELEASE {
		p.SetState(5888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5887)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5890)
			p.Match(StarRocksParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLBACK, 0)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *RollbackStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *RollbackStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAIN, 0)
}

func (s *RollbackStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRELEASE, 0)
}

func (s *RollbackStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserNO)
}

func (s *RollbackStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, i)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRollbackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, StarRocksParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5893)
		p.Match(StarRocksParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWORK {
		{
			p.SetState(5894)
			p.Match(StarRocksParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAND {
		{
			p.SetState(5897)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5898)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5901)
			p.Match(StarRocksParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNO || _la == StarRocksParserRELEASE {
		p.SetState(5905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5904)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5907)
			p.Match(StarRocksParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateStatementContext is an interface to support dynamic dispatch.
type ITranslateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRANSLATE() antlr.TerminalNode
	Dialect() IDialectContext
	TranslateSQL() ITranslateSQLContext

	// IsTranslateStatementContext differentiates from other interfaces.
	IsTranslateStatementContext()
}

type TranslateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateStatementContext() *TranslateStatementContext {
	var p = new(TranslateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateStatement
	return p
}

func InitEmptyTranslateStatementContext(p *TranslateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateStatement
}

func (*TranslateStatementContext) IsTranslateStatementContext() {}

func NewTranslateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateStatementContext {
	var p = new(TranslateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_translateStatement

	return p
}

func (s *TranslateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslateStatementContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSLATE, 0)
}

func (s *TranslateStatementContext) Dialect() IDialectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDialectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDialectContext)
}

func (s *TranslateStatementContext) TranslateSQL() ITranslateSQLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateSQLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateSQLContext)
}

func (s *TranslateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTranslateStatement(s)
	}
}

func (s *TranslateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTranslateStatement(s)
	}
}

func (s *TranslateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTranslateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TranslateStatement() (localctx ITranslateStatementContext) {
	localctx = NewTranslateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, StarRocksParserRULE_translateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5910)
		p.Match(StarRocksParserTRANSLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5911)
		p.Dialect()
	}
	{
		p.SetState(5912)
		p.TranslateSQL()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDialectContext is an interface to support dynamic dispatch.
type IDialectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDialectContext differentiates from other interfaces.
	IsDialectContext()
}

type DialectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDialectContext() *DialectContext {
	var p = new(DialectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dialect
	return p
}

func InitEmptyDialectContext(p *DialectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dialect
}

func (*DialectContext) IsDialectContext() {}

func NewDialectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DialectContext {
	var p = new(DialectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dialect

	return p
}

func (s *DialectContext) GetParser() antlr.Parser { return s.parser }

func (s *DialectContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DialectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DialectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DialectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDialect(s)
	}
}

func (s *DialectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDialect(s)
	}
}

func (s *DialectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDialect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Dialect() (localctx IDialectContext) {
	localctx = NewDialectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, StarRocksParserRULE_dialect)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5914)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateSQLContext is an interface to support dynamic dispatch.
type ITranslateSQLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTranslateSQLContext differentiates from other interfaces.
	IsTranslateSQLContext()
}

type TranslateSQLContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateSQLContext() *TranslateSQLContext {
	var p = new(TranslateSQLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateSQL
	return p
}

func InitEmptyTranslateSQLContext(p *TranslateSQLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateSQL
}

func (*TranslateSQLContext) IsTranslateSQLContext() {}

func NewTranslateSQLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateSQLContext {
	var p = new(TranslateSQLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_translateSQL

	return p
}

func (s *TranslateSQLContext) GetParser() antlr.Parser { return s.parser }
func (s *TranslateSQLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateSQLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateSQLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTranslateSQL(s)
	}
}

func (s *TranslateSQLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTranslateSQL(s)
	}
}

func (s *TranslateSQLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTranslateSQL(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TranslateSQL() (localctx ITranslateSQLContext) {
	localctx = NewTranslateSQLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, StarRocksParserRULE_translateSQL)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(5916)
			p.MatchWildcard()

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5919)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 654, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryStatementContext is an interface to support dynamic dispatch.
type IQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext
	ExplainDesc() IExplainDescContext
	OptimizerTrace() IOptimizerTraceContext
	Outfile() IOutfileContext

	// IsQueryStatementContext differentiates from other interfaces.
	IsQueryStatementContext()
}

type QueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStatementContext() *QueryStatementContext {
	var p = new(QueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryStatement
	return p
}

func InitEmptyQueryStatementContext(p *QueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryStatement
}

func (*QueryStatementContext) IsQueryStatementContext() {}

func NewQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementContext {
	var p = new(QueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryStatement

	return p
}

func (s *QueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *QueryStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *QueryStatementContext) OptimizerTrace() IOptimizerTraceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizerTraceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizerTraceContext)
}

func (s *QueryStatementContext) Outfile() IOutfileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutfileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutfileContext)
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

func (s *QueryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQueryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) QueryStatement() (localctx IQueryStatementContext) {
	localctx = NewQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, StarRocksParserRULE_queryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserEXPLAIN:
		{
			p.SetState(5921)
			p.ExplainDesc()
		}

	case StarRocksParserTRACE:
		{
			p.SetState(5922)
			p.OptimizerTrace()
		}

	case StarRocksParserT__1, StarRocksParserSELECT, StarRocksParserWITH:

	default:
	}
	{
		p.SetState(5925)
		p.QueryRelation()
	}
	p.SetState(5927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserINTO {
		{
			p.SetState(5926)
			p.Outfile()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryRelationContext is an interface to support dynamic dispatch.
type IQueryRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryNoWith() IQueryNoWithContext
	WithClause() IWithClauseContext

	// IsQueryRelationContext differentiates from other interfaces.
	IsQueryRelationContext()
}

type QueryRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryRelationContext() *QueryRelationContext {
	var p = new(QueryRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryRelation
	return p
}

func InitEmptyQueryRelationContext(p *QueryRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryRelation
}

func (*QueryRelationContext) IsQueryRelationContext() {}

func NewQueryRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryRelationContext {
	var p = new(QueryRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryRelation

	return p
}

func (s *QueryRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryRelationContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryRelationContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryRelation(s)
	}
}

func (s *QueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryRelation(s)
	}
}

func (s *QueryRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQueryRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) QueryRelation() (localctx IQueryRelationContext) {
	localctx = NewQueryRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, StarRocksParserRULE_queryRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(5929)
			p.WithClause()
		}

	}
	{
		p.SetState(5932)
		p.QueryNoWith()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCommonTableExpression() []ICommonTableExpressionContext
	CommonTableExpression(i int) ICommonTableExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *WithClauseContext) AllCommonTableExpression() []ICommonTableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionContext); ok {
			tst[i] = t.(ICommonTableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CommonTableExpression(i int) ICommonTableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, StarRocksParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5934)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5935)
		p.CommonTableExpression()
	}
	p.SetState(5940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5936)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5937)
			p.CommonTableExpression()
		}

		p.SetState(5942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryPrimary() IQueryPrimaryContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryNoWith
	return p
}

func InitEmptyQueryNoWithContext(p *QueryNoWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryNoWith
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQueryNoWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, StarRocksParserRULE_queryNoWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5943)
		p.queryPrimary(0)
	}
	p.SetState(5954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(5944)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5945)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5946)
			p.SortItem()
		}
		p.SetState(5951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5947)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5948)
				p.SortItem()
			}

			p.SetState(5953)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(5956)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPeriodContext is an interface to support dynamic dispatch.
type IQueryPeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnd returns the end rule contexts.
	GetEnd() IExpressionContext

	// SetEnd sets the end rule contexts.
	SetEnd(IExpressionContext)

	// Getter signatures
	PeriodType() IPeriodTypeContext
	BETWEEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode

	// IsQueryPeriodContext differentiates from other interfaces.
	IsQueryPeriodContext()
}

type QueryPeriodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	end    IExpressionContext
}

func NewEmptyQueryPeriodContext() *QueryPeriodContext {
	var p = new(QueryPeriodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPeriod
	return p
}

func InitEmptyQueryPeriodContext(p *QueryPeriodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPeriod
}

func (*QueryPeriodContext) IsQueryPeriodContext() {}

func NewQueryPeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPeriodContext {
	var p = new(QueryPeriodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryPeriod

	return p
}

func (s *QueryPeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPeriodContext) GetEnd() IExpressionContext { return s.end }

func (s *QueryPeriodContext) SetEnd(v IExpressionContext) { s.end = v }

func (s *QueryPeriodContext) PeriodType() IPeriodTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPeriodTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPeriodTypeContext)
}

func (s *QueryPeriodContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *QueryPeriodContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QueryPeriodContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QueryPeriodContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *QueryPeriodContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *QueryPeriodContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *QueryPeriodContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *QueryPeriodContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *QueryPeriodContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *QueryPeriodContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *QueryPeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryPeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQueryPeriod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) QueryPeriod() (localctx IQueryPeriodContext) {
	localctx = NewQueryPeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, StarRocksParserRULE_queryPeriod)
	var _la int

	p.SetState(5991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 666, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5959)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5962)
			p.PeriodType()
		}
		{
			p.SetState(5963)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5964)
			p.expression(0)
		}
		{
			p.SetState(5965)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5966)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5968)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5971)
			p.PeriodType()
		}
		{
			p.SetState(5972)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5973)
			p.expression(0)
		}
		{
			p.SetState(5974)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5975)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5977)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5980)
			p.PeriodType()
		}
		{
			p.SetState(5981)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5983)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5986)
			p.PeriodType()
		}
		{
			p.SetState(5987)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5988)
			p.Match(StarRocksParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5989)

			var _x = p.expression(0)

			localctx.(*QueryPeriodContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPeriodTypeContext is an interface to support dynamic dispatch.
type IPeriodTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSTEM_TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	VERSION() antlr.TerminalNode

	// IsPeriodTypeContext differentiates from other interfaces.
	IsPeriodTypeContext()
}

type PeriodTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriodTypeContext() *PeriodTypeContext {
	var p = new(PeriodTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_periodType
	return p
}

func InitEmptyPeriodTypeContext(p *PeriodTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_periodType
}

func (*PeriodTypeContext) IsPeriodTypeContext() {}

func NewPeriodTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeriodTypeContext {
	var p = new(PeriodTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_periodType

	return p
}

func (s *PeriodTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PeriodTypeContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM_TIME, 0)
}

func (s *PeriodTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMP, 0)
}

func (s *PeriodTypeContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *PeriodTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeriodTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeriodTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPeriodType(s)
	}
}

func (s *PeriodTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPeriodType(s)
	}
}

func (s *PeriodTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPeriodType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PeriodType() (localctx IPeriodTypeContext) {
	localctx = NewPeriodTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, StarRocksParserRULE_periodType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5993)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-420)) & ^0x3f) == 0 && ((int64(1)<<(_la-420))&562949953454081) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryWithParenthesesContext struct {
	QueryPrimaryContext
}

func NewQueryWithParenthesesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryWithParenthesesContext {
	var p = new(QueryWithParenthesesContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryWithParenthesesContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *QueryWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryWithParentheses(s)
	}
}

func (s *QueryWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryWithParentheses(s)
	}
}

func (s *QueryWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQueryWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	QueryPrimaryContext
	left     IQueryPrimaryContext
	operator antlr.Token
	right    IQueryPrimaryContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryPrimaryContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryPrimaryContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryPrimaryContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryPrimaryContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryPrimary() []IQueryPrimaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			len++
		}
	}

	tst := make([]IQueryPrimaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryPrimaryContext); ok {
			tst[i] = t.(IQueryPrimaryContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryPrimary(i int) IQueryPrimaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	return p.queryPrimary(0)
}

func (p *StarRocksParser) queryPrimary(_p int) (localctx IQueryPrimaryContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 762
	p.EnterRecursionRule(localctx, 762, StarRocksParserRULE_queryPrimary, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5998)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5996)
			p.QuerySpecification()
		}

	case StarRocksParserT__1:
		localctx = NewQueryWithParenthesesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5997)
			p.Subquery()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6012)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 670, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_queryPrimary)
				p.SetState(6000)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6001)

					var _m = p.Match(StarRocksParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6003)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
					{
						p.SetState(6002)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(6005)

					var _x = p.queryPrimary(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_queryPrimary)
				p.SetState(6006)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6007)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserEXCEPT || _la == StarRocksParserMINUS || _la == StarRocksParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(6009)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
					{
						p.SetState(6008)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(6011)

					var _x = p.queryPrimary(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 671, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subquery
	return p
}

func InitEmptySubqueryContext(p *SubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subquery
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, StarRocksParserRULE_subquery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6017)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6018)
		p.QueryRelation()
	}
	{
		p.SetState(6019)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, StarRocksParserRULE_rowConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6021)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6022)
		p.ExpressionList()
	}
	{
		p.SetState(6023)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, StarRocksParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6025)
		p.expression(0)
	}
	p.SetState(6027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserASC || _la == StarRocksParserDESC {
		{
			p.SetState(6026)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASC || _la == StarRocksParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(6031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNULLS {
		{
			p.SetState(6029)
			p.Match(StarRocksParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6030)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFIRST || _la == StarRocksParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitConstExprContext is an interface to support dynamic dispatch.
type ILimitConstExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	UserVariable() IUserVariableContext

	// IsLimitConstExprContext differentiates from other interfaces.
	IsLimitConstExprContext()
}

type LimitConstExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitConstExprContext() *LimitConstExprContext {
	var p = new(LimitConstExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitConstExpr
	return p
}

func InitEmptyLimitConstExprContext(p *LimitConstExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitConstExpr
}

func (*LimitConstExprContext) IsLimitConstExprContext() {}

func NewLimitConstExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitConstExprContext {
	var p = new(LimitConstExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_limitConstExpr

	return p
}

func (s *LimitConstExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitConstExprContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *LimitConstExprContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARAMETER, 0)
}

func (s *LimitConstExprContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *LimitConstExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitConstExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitConstExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLimitConstExpr(s)
	}
}

func (s *LimitConstExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLimitConstExpr(s)
	}
}

func (s *LimitConstExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLimitConstExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LimitConstExpr() (localctx ILimitConstExprContext) {
	localctx = NewLimitConstExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, StarRocksParserRULE_limitConstExpr)
	p.SetState(6036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6033)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPARAMETER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6034)
			p.Match(StarRocksParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6035)
			p.UserVariable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitElementContext is an interface to support dynamic dispatch.
type ILimitElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitConstExprContext

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitConstExprContext

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitConstExprContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitConstExprContext)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllLimitConstExpr() []ILimitConstExprContext
	LimitConstExpr(i int) ILimitConstExprContext
	OFFSET() antlr.TerminalNode

	// IsLimitElementContext differentiates from other interfaces.
	IsLimitElementContext()
}

type LimitElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  ILimitConstExprContext
	offset ILimitConstExprContext
}

func NewEmptyLimitElementContext() *LimitElementContext {
	var p = new(LimitElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitElement
	return p
}

func InitEmptyLimitElementContext(p *LimitElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitElement
}

func (*LimitElementContext) IsLimitElementContext() {}

func NewLimitElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitElementContext {
	var p = new(LimitElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_limitElement

	return p
}

func (s *LimitElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitElementContext) GetLimit() ILimitConstExprContext { return s.limit }

func (s *LimitElementContext) GetOffset() ILimitConstExprContext { return s.offset }

func (s *LimitElementContext) SetLimit(v ILimitConstExprContext) { s.limit = v }

func (s *LimitElementContext) SetOffset(v ILimitConstExprContext) { s.offset = v }

func (s *LimitElementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIMIT, 0)
}

func (s *LimitElementContext) AllLimitConstExpr() []ILimitConstExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			len++
		}
	}

	tst := make([]ILimitConstExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitConstExprContext); ok {
			tst[i] = t.(ILimitConstExprContext)
			i++
		}
	}

	return tst
}

func (s *LimitElementContext) LimitConstExpr(i int) ILimitConstExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitConstExprContext)
}

func (s *LimitElementContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFFSET, 0)
}

func (s *LimitElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLimitElement(s)
	}
}

func (s *LimitElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLimitElement(s)
	}
}

func (s *LimitElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLimitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LimitElement() (localctx ILimitElementContext) {
	localctx = NewLimitElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, StarRocksParserRULE_limitElement)
	var _la int

	p.SetState(6049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 676, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6038)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6039)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}
		p.SetState(6042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserOFFSET {
			{
				p.SetState(6040)
				p.Match(StarRocksParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6041)

				var _x = p.LimitConstExpr()

				localctx.(*LimitElementContext).offset = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6044)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6045)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).offset = _x
		}
		{
			p.SetState(6046)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6047)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IExpressionContext

	// GetQualifyFunction returns the qualifyFunction rule contexts.
	GetQualifyFunction() ISelectItemContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IExpressionContext)

	// SetQualifyFunction sets the qualifyFunction rule contexts.
	SetQualifyFunction(ISelectItemContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FromClause() IFromClauseContext
	SetQuantifier() ISetQuantifierContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext
	HAVING() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	ComparisonOperator() IComparisonOperatorContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	where           IExpressionContext
	having          IExpressionContext
	qualifyFunction ISelectItemContext
	limit           antlr.Token
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetLimit() antlr.Token { return s.limit }

func (s *QuerySpecificationContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QuerySpecificationContext) GetWhere() IExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IExpressionContext { return s.having }

func (s *QuerySpecificationContext) GetQualifyFunction() ISelectItemContext { return s.qualifyFunction }

func (s *QuerySpecificationContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SetQualifyFunction(v ISelectItemContext) { s.qualifyFunction = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *QuerySpecificationContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHAVING, 0)
}

func (s *QuerySpecificationContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUALIFY, 0)
}

func (s *QuerySpecificationContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuerySpecificationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QuerySpecificationContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, StarRocksParserRULE_querySpecification)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6051)
		p.Match(StarRocksParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
		{
			p.SetState(6052)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(6055)
		p.SelectItem()
	}
	p.SetState(6060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6056)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6057)
				p.SelectItem()
			}

		}
		p.SetState(6062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(6063)
		p.FromClause()
	}

	p.SetState(6066)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6064)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6065)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6071)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6068)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6069)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6070)
			p.GroupingElement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6075)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6073)
			p.Match(StarRocksParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6074)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6082)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6077)
			p.Match(StarRocksParserQUALIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6078)

			var _x = p.SelectItem()

			localctx.(*QuerySpecificationContext).qualifyFunction = _x
		}
		{
			p.SetState(6079)
			p.ComparisonOperator()
		}
		{
			p.SetState(6080)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*QuerySpecificationContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) CopyAll(ctx *FromClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DualContext struct {
	FromClauseContext
}

func NewDualContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DualContext {
	var p = new(DualContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *DualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DualContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DualContext) DUAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUAL, 0)
}

func (s *DualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDual(s)
	}
}

func (s *DualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDual(s)
	}
}

func (s *DualContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDual(s)

	default:
		return t.VisitChildren(s)
	}
}

type FromContext struct {
	FromClauseContext
}

func NewFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FromContext {
	var p = new(FromContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *FromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *FromContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *FromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFrom(s)
	}
}

func (s *FromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFrom(s)
	}
}

func (s *FromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, StarRocksParserRULE_fromClause)
	p.SetState(6093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 685, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6089)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 684, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6084)
				p.Match(StarRocksParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6085)
				p.Relations()
			}
			p.SetState(6087)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6086)
					p.PivotClause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewDualContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6091)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6092)
			p.Match(StarRocksParserDUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyAll(ctx *GroupingElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMultipleGroupingSets(s)

	default:
		return t.VisitChildren(s)
	}
}

type SingleGroupingSetContext struct {
	GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSingleGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type CubeContext struct {
	GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUBE, 0)
}

func (s *CubeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCube(s)
	}
}

func (s *CubeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCube(s)

	default:
		return t.VisitChildren(s)
	}
}

type RollupContext struct {
	GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *RollupContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (s *RollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, StarRocksParserRULE_groupingElement)
	var _la int

	p.SetState(6121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 689, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6095)
			p.Match(StarRocksParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6096)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6097)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6100)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6101)
			p.Match(StarRocksParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6102)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6103)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6106)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6107)
			p.Match(StarRocksParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6108)
			p.Match(StarRocksParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6109)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6110)
			p.GroupingSet()
		}
		p.SetState(6115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6111)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6112)
				p.GroupingSet()
			}

			p.SetState(6117)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6118)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6120)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (s *GroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, StarRocksParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6123)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
		{
			p.SetState(6124)
			p.expression(0)
		}

	}
	p.SetState(6131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6127)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6128)
			p.expression(0)
		}

		p.SetState(6133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6134)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionContext is an interface to support dynamic dispatch.
type ICommonTableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext

	// IsCommonTableExpressionContext differentiates from other interfaces.
	IsCommonTableExpressionContext()
}

type CommonTableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyCommonTableExpressionContext() *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commonTableExpression
	return p
}

func InitEmptyCommonTableExpressionContext(p *CommonTableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commonTableExpression
}

func (*CommonTableExpressionContext) IsCommonTableExpressionContext() {}

func NewCommonTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_commonTableExpression

	return p
}

func (s *CommonTableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionContext) GetName() IIdentifierContext { return s.name }

func (s *CommonTableExpressionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CommonTableExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CommonTableExpressionContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CommonTableExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommonTableExpressionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CommonTableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCommonTableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CommonTableExpression() (localctx ICommonTableExpressionContext) {
	localctx = NewCommonTableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, StarRocksParserRULE_commonTableExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6136)

		var _x = p.Identifier()

		localctx.(*CommonTableExpressionContext).name = _x
	}
	p.SetState(6138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(6137)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(6140)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6141)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6142)
		p.QueryRelation()
	}
	{
		p.SetState(6143)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, StarRocksParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6145)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserALL || _la == StarRocksParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyAll(ctx *SelectItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *SelectAllContext) ExcludeClause() IExcludeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExcludeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExcludeClauseContext)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

func (s *SelectAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSelectAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectSingleContext struct {
	SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (s *SelectSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSelectSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, StarRocksParserRULE_selectItem)
	var _la int

	p.SetState(6167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6147)
			p.expression(0)
		}
		p.SetState(6155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext()) == 1 {
			p.SetState(6149)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6148)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(6153)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
				{
					p.SetState(6151)
					p.Identifier()
				}

			case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
				{
					p.SetState(6152)
					p.String_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6157)
			p.QualifiedName()
		}
		{
			p.SetState(6158)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6159)
			p.Match(StarRocksParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6161)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6160)
				p.ExcludeClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6163)
			p.Match(StarRocksParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6165)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6164)
				p.ExcludeClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExcludeClauseContext is an interface to support dynamic dispatch.
type IExcludeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	EXCEPT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode

	// IsExcludeClauseContext differentiates from other interfaces.
	IsExcludeClauseContext()
}

type ExcludeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcludeClauseContext() *ExcludeClauseContext {
	var p = new(ExcludeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_excludeClause
	return p
}

func InitEmptyExcludeClauseContext(p *ExcludeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_excludeClause
}

func (*ExcludeClauseContext) IsExcludeClauseContext() {}

func NewExcludeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExcludeClauseContext {
	var p = new(ExcludeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_excludeClause

	return p
}

func (s *ExcludeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExcludeClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ExcludeClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExcludeClauseContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCEPT, 0)
}

func (s *ExcludeClauseContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCLUDE, 0)
}

func (s *ExcludeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExcludeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExcludeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExcludeClause(s)
	}
}

func (s *ExcludeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExcludeClause(s)
	}
}

func (s *ExcludeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExcludeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExcludeClause() (localctx IExcludeClauseContext) {
	localctx = NewExcludeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, StarRocksParserRULE_excludeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6169)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserEXCEPT || _la == StarRocksParserEXCLUDE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6170)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6171)
		p.Identifier()
	}
	p.SetState(6176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6172)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6173)
			p.Identifier()
		}

		p.SetState(6178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6179)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllLATERAL() []antlr.TerminalNode
	LATERAL(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllLATERAL() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserLATERAL)
}

func (s *RelationsContext) LATERAL(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserLATERAL, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRelations(s)
	}
}

func (s *RelationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRelations(s)
	}
}

func (s *RelationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRelations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, StarRocksParserRULE_relations)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6181)
		p.Relation()
	}
	p.SetState(6189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6182)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6184)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserLATERAL {
				{
					p.SetState(6183)
					p.Match(StarRocksParserLATERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6186)
				p.Relation()
			}

		}
		p.SetState(6191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (s *RelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, StarRocksParserRULE_relation)
	var _la int

	var _alt int

	p.SetState(6209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6192)
			p.RelationPrimary()
		}
		p.SetState(6196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6193)
					p.JoinRelation()
				}

			}
			p.SetState(6198)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6199)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6200)
			p.RelationPrimary()
		}
		p.SetState(6204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserCROSS || ((int64((_la-175)) & ^0x3f) == 0 && ((int64(1)<<(_la-175))&4612811926924165121) != 0) || _la == StarRocksParserRIGHT {
			{
				p.SetState(6201)
				p.JoinRelation()
			}

			p.SetState(6206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6207)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryWithAliasContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewSubqueryWithAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryWithAliasContext {
	var p = new(SubqueryWithAliasContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *SubqueryWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *SubqueryWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryWithAliasContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryWithAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubqueryWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SubqueryWithAliasContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *SubqueryWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubqueryWithAlias(s)
	}
}

func (s *SubqueryWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubqueryWithAlias(s)
	}
}

func (s *SubqueryWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSubqueryWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type NormalizedTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewNormalizedTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizedTableFunctionContext {
	var p = new(NormalizedTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *NormalizedTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *NormalizedTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *NormalizedTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizedTableFunctionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *NormalizedTableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *NormalizedTableFunctionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *NormalizedTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NormalizedTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *NormalizedTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NormalizedTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNormalizedTableFunction(s)
	}
}

func (s *NormalizedTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNormalizedTableFunction(s)
	}
}

func (s *NormalizedTableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitNormalizedTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFunctionContext {
	var p = new(TableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableFunctionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *TableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *TableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *TableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableFunction(s)
	}
}

func (s *TableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableFunction(s)
	}
}

func (s *TableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedRelationContext struct {
	RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitParenthesizedRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

type FileTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewFileTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FileTableFunctionContext {
	var p = new(FileTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *FileTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *FileTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *FileTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTableFunctionContext) FILES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILES, 0)
}

func (s *FileTableFunctionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *FileTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *FileTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *FileTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFileTableFunction(s)
	}
}

func (s *FileTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFileTableFunction(s)
	}
}

func (s *FileTableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitFileTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableAtomContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
	ts    IStringContext
}

func NewTableAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableAtomContext {
	var p = new(TableAtomContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableAtomContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableAtomContext) GetTs() IStringContext { return s.ts }

func (s *TableAtomContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableAtomContext) SetTs(v IStringContext) { s.ts = v }

func (s *TableAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAtomContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableAtomContext) QueryPeriod() IQueryPeriodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPeriodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPeriodContext)
}

func (s *TableAtomContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableAtomContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableAtomContext) ReplicaList() IReplicaListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicaListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicaListContext)
}

func (s *TableAtomContext) SampleClause() ISampleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleClauseContext)
}

func (s *TableAtomContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *TableAtomContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEFORE, 0)
}

func (s *TableAtomContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableAtomContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TableAtomContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *TableAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableAtom(s)
	}
}

func (s *TableAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableAtom(s)
	}
}

func (s *TableAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTableAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type InlineTableContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *InlineTableContext) GetAlias() IIdentifierContext { return s.alias }

func (s *InlineTableContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlineTableContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *InlineTableContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, StarRocksParserRULE_relationPrimary)
	var _la int

	p.SetState(6314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6211)
			p.QualifiedName()
		}
		p.SetState(6213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 705, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6212)
				p.QueryPeriod()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6216)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6215)
				p.PartitionNames()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6219)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 707, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6218)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6222)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6221)
				p.ReplicaList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6224)
				p.SampleClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6231)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) == 1 {
			p.SetState(6228)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6227)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6230)

				var _x = p.Identifier()

				localctx.(*TableAtomContext).alias = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6234)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6233)
				p.BracketHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6238)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 713, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6236)
				p.Match(StarRocksParserBEFORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6237)

				var _x = p.String_()

				localctx.(*TableAtomContext).ts = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6240)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6241)
			p.Match(StarRocksParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6242)
			p.RowConstructor()
		}
		p.SetState(6247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6243)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6244)
				p.RowConstructor()
			}

			p.SetState(6249)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6250)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6258)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
			p.SetState(6252)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6251)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6254)

				var _x = p.Identifier()

				localctx.(*InlineTableContext).alias = _x
			}
			p.SetState(6256)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6255)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSubqueryWithAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6260)
			p.Subquery()
		}
		p.SetState(6268)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 720, p.GetParserRuleContext()) == 1 {
			p.SetState(6262)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6261)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6264)

				var _x = p.Identifier()

				localctx.(*SubqueryWithAliasContext).alias = _x
			}
			p.SetState(6266)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 719, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6265)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6270)
			p.QualifiedName()
		}
		{
			p.SetState(6271)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6272)
			p.ExpressionList()
		}
		{
			p.SetState(6273)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6281)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
			p.SetState(6275)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6274)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6277)

				var _x = p.Identifier()

				localctx.(*TableFunctionContext).alias = _x
			}
			p.SetState(6279)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 722, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6278)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewNormalizedTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6283)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6284)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6285)
			p.QualifiedName()
		}
		{
			p.SetState(6286)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6287)
			p.ArgumentList()
		}
		{
			p.SetState(6288)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6289)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 726, p.GetParserRuleContext()) == 1 {
			p.SetState(6291)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6290)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6293)

				var _x = p.Identifier()

				localctx.(*NormalizedTableFunctionContext).alias = _x
			}
			p.SetState(6295)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6294)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewFileTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6299)
			p.Match(StarRocksParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6300)
			p.PropertyList()
		}
		p.SetState(6308)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext()) == 1 {
			p.SetState(6302)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6301)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6304)

				var _x = p.Identifier()

				localctx.(*FileTableFunctionContext).alias = _x
			}
			p.SetState(6306)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 728, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6305)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6310)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6311)
			p.Relations()
		}
		{
			p.SetState(6312)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotClauseContext is an interface to support dynamic dispatch.
type IPivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIVOT() antlr.TerminalNode
	AllPivotAggregationExpression() []IPivotAggregationExpressionContext
	PivotAggregationExpression(i int) IPivotAggregationExpressionContext
	FOR() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPivotValue() []IPivotValueContext
	PivotValue(i int) IPivotValueContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext

	// IsPivotClauseContext differentiates from other interfaces.
	IsPivotClauseContext()
}

type PivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotClauseContext() *PivotClauseContext {
	var p = new(PivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotClause
	return p
}

func InitEmptyPivotClauseContext(p *PivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotClause
}

func (*PivotClauseContext) IsPivotClauseContext() {}

func NewPivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotClauseContext {
	var p = new(PivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pivotClause

	return p
}

func (s *PivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotClauseContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIVOT, 0)
}

func (s *PivotClauseContext) AllPivotAggregationExpression() []IPivotAggregationExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPivotAggregationExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotAggregationExpressionContext); ok {
			tst[i] = t.(IPivotAggregationExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotAggregationExpression(i int) IPivotAggregationExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotAggregationExpressionContext)
}

func (s *PivotClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *PivotClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *PivotClauseContext) AllPivotValue() []IPivotValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotValueContext); ok {
			len++
		}
	}

	tst := make([]IPivotValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotValueContext); ok {
			tst[i] = t.(IPivotValueContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotValue(i int) IPivotValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotValueContext)
}

func (s *PivotClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPivotClause(s)
	}
}

func (s *PivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPivotClause(s)
	}
}

func (s *PivotClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPivotClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PivotClause() (localctx IPivotClauseContext) {
	localctx = NewPivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, StarRocksParserRULE_pivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6316)
		p.Match(StarRocksParserPIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6317)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6318)
		p.PivotAggregationExpression()
	}
	p.SetState(6323)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6319)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6320)
			p.PivotAggregationExpression()
		}

		p.SetState(6325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6326)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(6327)
			p.Identifier()
		}

	case StarRocksParserT__1:
		{
			p.SetState(6328)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(6331)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6332)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6333)
		p.PivotValue()
	}
	p.SetState(6338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6334)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6335)
			p.PivotValue()
		}

		p.SetState(6340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6341)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6342)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotAggregationExpressionContext is an interface to support dynamic dispatch.
type IPivotAggregationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotAggregationExpressionContext differentiates from other interfaces.
	IsPivotAggregationExpressionContext()
}

type PivotAggregationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotAggregationExpressionContext() *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotAggregationExpression
	return p
}

func InitEmptyPivotAggregationExpressionContext(p *PivotAggregationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotAggregationExpression
}

func (*PivotAggregationExpressionContext) IsPivotAggregationExpressionContext() {}

func NewPivotAggregationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pivotAggregationExpression

	return p
}

func (s *PivotAggregationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotAggregationExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PivotAggregationExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotAggregationExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotAggregationExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *PivotAggregationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotAggregationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotAggregationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPivotAggregationExpression(s)
	}
}

func (s *PivotAggregationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPivotAggregationExpression(s)
	}
}

func (s *PivotAggregationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPivotAggregationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PivotAggregationExpression() (localctx IPivotAggregationExpressionContext) {
	localctx = NewPivotAggregationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, StarRocksParserRULE_pivotAggregationExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6344)
		p.FunctionCall()
	}
	p.SetState(6352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&4534550861405212027) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&141699191925459) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&4211) != 0) {
		p.SetState(6346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(6345)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6350)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(6348)
				p.Identifier()
			}

		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6349)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotValueContext is an interface to support dynamic dispatch.
type IPivotValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralExpression() ILiteralExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotValueContext differentiates from other interfaces.
	IsPivotValueContext()
}

type PivotValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotValueContext() *PivotValueContext {
	var p = new(PivotValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotValue
	return p
}

func InitEmptyPivotValueContext(p *PivotValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotValue
}

func (*PivotValueContext) IsPivotValueContext() {}

func NewPivotValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotValueContext {
	var p = new(PivotValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pivotValue

	return p
}

func (s *PivotValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotValueContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *PivotValueContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *PivotValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotValueContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *PivotValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPivotValue(s)
	}
}

func (s *PivotValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPivotValue(s)
	}
}

func (s *PivotValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPivotValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PivotValue() (localctx IPivotValueContext) {
	localctx = NewPivotValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, StarRocksParserRULE_pivotValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCEIL, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserFALSE, StarRocksParserFLOOR, StarRocksParserINTERVAL, StarRocksParserNULL, StarRocksParserPARAMETER, StarRocksParserTRUE, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT:
		{
			p.SetState(6354)
			p.LiteralExpression()
		}

	case StarRocksParserT__1:
		{
			p.SetState(6355)
			p.LiteralExpressionList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&4534550861405212027) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&141699191925459) != 0) || ((int64((_la-522)) & ^0x3f) == 0 && ((int64(1)<<(_la-522))&4211) != 0) {
		p.SetState(6359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(6358)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(6361)
				p.Identifier()
			}

		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6362)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleClauseContext is an interface to support dynamic dispatch.
type ISampleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSampleClauseContext differentiates from other interfaces.
	IsSampleClauseContext()
}

type SampleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleClauseContext() *SampleClauseContext {
	var p = new(SampleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sampleClause
	return p
}

func InitEmptySampleClauseContext(p *SampleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sampleClause
}

func (*SampleClauseContext) IsSampleClauseContext() {}

func NewSampleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleClauseContext {
	var p = new(SampleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_sampleClause

	return p
}

func (s *SampleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *SampleClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SampleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSampleClause(s)
	}
}

func (s *SampleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSampleClause(s)
	}
}

func (s *SampleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSampleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SampleClause() (localctx ISampleClauseContext) {
	localctx = NewSampleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, StarRocksParserRULE_sampleClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6367)
		p.Match(StarRocksParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6369)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6368)
			p.PropertyList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext
	NamedArgumentList() INamedArgumentListContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentListContext) NamedArgumentList() INamedArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentListContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, StarRocksParserRULE_argumentList)
	p.SetState(6373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 742, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6371)
			p.ExpressionList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6372)
			p.NamedArgumentList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentListContext is an interface to support dynamic dispatch.
type INamedArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedArgument() []INamedArgumentContext
	NamedArgument(i int) INamedArgumentContext

	// IsNamedArgumentListContext differentiates from other interfaces.
	IsNamedArgumentListContext()
}

type NamedArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentListContext() *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgumentList
	return p
}

func InitEmptyNamedArgumentListContext(p *NamedArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgumentList
}

func (*NamedArgumentListContext) IsNamedArgumentListContext() {}

func NewNamedArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_namedArgumentList

	return p
}

func (s *NamedArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentListContext) AllNamedArgument() []INamedArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedArgumentContext); ok {
			len++
		}
	}

	tst := make([]INamedArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedArgumentContext); ok {
			tst[i] = t.(INamedArgumentContext)
			i++
		}
	}

	return tst
}

func (s *NamedArgumentListContext) NamedArgument(i int) INamedArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *NamedArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNamedArgumentList(s)
	}
}

func (s *NamedArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNamedArgumentList(s)
	}
}

func (s *NamedArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitNamedArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) NamedArgumentList() (localctx INamedArgumentListContext) {
	localctx = NewNamedArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, StarRocksParserRULE_namedArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6375)
		p.NamedArgument()
	}
	p.SetState(6380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6376)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6377)
			p.NamedArgument()
		}

		p.SetState(6382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentContext is an interface to support dynamic dispatch.
type INamedArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamedArgumentContext differentiates from other interfaces.
	IsNamedArgumentContext()
}

type NamedArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentContext() *NamedArgumentContext {
	var p = new(NamedArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgument
	return p
}

func InitEmptyNamedArgumentContext(p *NamedArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgument
}

func (*NamedArgumentContext) IsNamedArgumentContext() {}

func NewNamedArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_namedArgument

	return p
}

func (s *NamedArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentContext) CopyAll(ctx *NamedArgumentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NamedArgumentsContext struct {
	NamedArgumentContext
}

func NewNamedArgumentsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentsContext {
	var p = new(NamedArgumentsContext)

	InitEmptyNamedArgumentContext(&p.NamedArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedArgumentContext))

	return p
}

func (s *NamedArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNamedArguments(s)
	}
}

func (s *NamedArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNamedArguments(s)
	}
}

func (s *NamedArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitNamedArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) NamedArgument() (localctx INamedArgumentContext) {
	localctx = NewNamedArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, StarRocksParserRULE_namedArgument)
	localctx = NewNamedArgumentsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6383)
		p.Identifier()
	}
	{
		p.SetState(6384)
		p.Match(StarRocksParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6385)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRightRelation returns the rightRelation rule contexts.
	GetRightRelation() IRelationPrimaryContext

	// SetRightRelation sets the rightRelation rule contexts.
	SetRightRelation(IRelationPrimaryContext)

	// Getter signatures
	CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext
	RelationPrimary() IRelationPrimaryContext
	BracketHint() IBracketHintContext
	LATERAL() antlr.TerminalNode
	JoinCriteria() IJoinCriteriaContext
	OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rightRelation IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRightRelation() IRelationPrimaryContext { return s.rightRelation }

func (s *JoinRelationContext) SetRightRelation(v IRelationPrimaryContext) { s.rightRelation = v }

func (s *JoinRelationContext) CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrossOrInnerJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrossOrInnerJoinTypeContext)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *JoinRelationContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLATERAL, 0)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuterAndSemiJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuterAndSemiJoinTypeContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, StarRocksParserRULE_joinRelation)
	var _la int

	p.SetState(6408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCROSS, StarRocksParserINNER, StarRocksParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6387)
			p.CrossOrInnerJoinType()
		}
		p.SetState(6389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__5 {
			{
				p.SetState(6388)
				p.BracketHint()
			}

		}
		p.SetState(6392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLATERAL {
			{
				p.SetState(6391)
				p.Match(StarRocksParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6394)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		p.SetState(6396)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6395)
				p.JoinCriteria()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserFULL, StarRocksParserLEFT, StarRocksParserRIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6398)
			p.OuterAndSemiJoinType()
		}
		p.SetState(6400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__5 {
			{
				p.SetState(6399)
				p.BracketHint()
			}

		}
		p.SetState(6403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLATERAL {
			{
				p.SetState(6402)
				p.Match(StarRocksParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6405)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		{
			p.SetState(6406)
			p.JoinCriteria()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICrossOrInnerJoinTypeContext is an interface to support dynamic dispatch.
type ICrossOrInnerJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode

	// IsCrossOrInnerJoinTypeContext differentiates from other interfaces.
	IsCrossOrInnerJoinTypeContext()
}

type CrossOrInnerJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrossOrInnerJoinTypeContext() *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_crossOrInnerJoinType
	return p
}

func InitEmptyCrossOrInnerJoinTypeContext(p *CrossOrInnerJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_crossOrInnerJoinType
}

func (*CrossOrInnerJoinTypeContext) IsCrossOrInnerJoinTypeContext() {}

func NewCrossOrInnerJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_crossOrInnerJoinType

	return p
}

func (s *CrossOrInnerJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CrossOrInnerJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOIN, 0)
}

func (s *CrossOrInnerJoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINNER, 0)
}

func (s *CrossOrInnerJoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCROSS, 0)
}

func (s *CrossOrInnerJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrossOrInnerJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrossOrInnerJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCrossOrInnerJoinType(s)
	}
}

func (s *CrossOrInnerJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCrossOrInnerJoinType(s)
	}
}

func (s *CrossOrInnerJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCrossOrInnerJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) CrossOrInnerJoinType() (localctx ICrossOrInnerJoinTypeContext) {
	localctx = NewCrossOrInnerJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, StarRocksParserRULE_crossOrInnerJoinType)
	p.SetState(6416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 750, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6410)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6411)
			p.Match(StarRocksParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6412)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6413)
			p.Match(StarRocksParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6414)
			p.Match(StarRocksParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6415)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOuterAndSemiJoinTypeContext is an interface to support dynamic dispatch.
type IOuterAndSemiJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsOuterAndSemiJoinTypeContext differentiates from other interfaces.
	IsOuterAndSemiJoinTypeContext()
}

type OuterAndSemiJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOuterAndSemiJoinTypeContext() *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outerAndSemiJoinType
	return p
}

func InitEmptyOuterAndSemiJoinTypeContext(p *OuterAndSemiJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outerAndSemiJoinType
}

func (*OuterAndSemiJoinTypeContext) IsOuterAndSemiJoinTypeContext() {}

func NewOuterAndSemiJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_outerAndSemiJoinType

	return p
}

func (s *OuterAndSemiJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OuterAndSemiJoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEFT, 0)
}

func (s *OuterAndSemiJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOIN, 0)
}

func (s *OuterAndSemiJoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRIGHT, 0)
}

func (s *OuterAndSemiJoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *OuterAndSemiJoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOUTER, 0)
}

func (s *OuterAndSemiJoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMI, 0)
}

func (s *OuterAndSemiJoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANTI, 0)
}

func (s *OuterAndSemiJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterAndSemiJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OuterAndSemiJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOuterAndSemiJoinType(s)
	}
}

func (s *OuterAndSemiJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOuterAndSemiJoinType(s)
	}
}

func (s *OuterAndSemiJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOuterAndSemiJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) OuterAndSemiJoinType() (localctx IOuterAndSemiJoinTypeContext) {
	localctx = NewOuterAndSemiJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, StarRocksParserRULE_outerAndSemiJoinType)
	p.SetState(6445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 751, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6418)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6419)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6420)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6421)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6422)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6423)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6424)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6425)
			p.Match(StarRocksParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6426)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6427)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6428)
			p.Match(StarRocksParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6429)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6430)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6431)
			p.Match(StarRocksParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6432)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6433)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6434)
			p.Match(StarRocksParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6435)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6436)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6437)
			p.Match(StarRocksParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6438)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6439)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6440)
			p.Match(StarRocksParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6441)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6442)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6443)
			p.Match(StarRocksParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6444)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBracketHintContext is an interface to support dynamic dispatch.
type IBracketHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BITOR() antlr.TerminalNode
	PrimaryExpression() IPrimaryExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext

	// IsBracketHintContext differentiates from other interfaces.
	IsBracketHintContext()
}

type BracketHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBracketHintContext() *BracketHintContext {
	var p = new(BracketHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_bracketHint
	return p
}

func InitEmptyBracketHintContext(p *BracketHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_bracketHint
}

func (*BracketHintContext) IsBracketHintContext() {}

func NewBracketHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BracketHintContext {
	var p = new(BracketHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_bracketHint

	return p
}

func (s *BracketHintContext) GetParser() antlr.Parser { return s.parser }

func (s *BracketHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketHintContext) BITOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITOR, 0)
}

func (s *BracketHintContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *BracketHintContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *BracketHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BracketHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBracketHint(s)
	}
}

func (s *BracketHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBracketHint(s)
	}
}

func (s *BracketHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBracketHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BracketHint() (localctx IBracketHintContext) {
	localctx = NewBracketHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, StarRocksParserRULE_bracketHint)
	var _la int

	p.SetState(6465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6447)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6448)
			p.Identifier()
		}
		p.SetState(6453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6449)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6450)
				p.Identifier()
			}

			p.SetState(6455)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6456)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6458)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6459)
			p.Identifier()
		}
		{
			p.SetState(6460)
			p.Match(StarRocksParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6461)
			p.primaryExpression(0)
		}
		{
			p.SetState(6462)
			p.LiteralExpressionList()
		}
		{
			p.SetState(6463)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintMapContext is an interface to support dynamic dispatch.
type IHintMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IIdentifierOrStringContext

	// GetV returns the v rule contexts.
	GetV() ILiteralExpressionContext

	// SetK sets the k rule contexts.
	SetK(IIdentifierOrStringContext)

	// SetV sets the v rule contexts.
	SetV(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	LiteralExpression() ILiteralExpressionContext

	// IsHintMapContext differentiates from other interfaces.
	IsHintMapContext()
}

type HintMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IIdentifierOrStringContext
	v      ILiteralExpressionContext
}

func NewEmptyHintMapContext() *HintMapContext {
	var p = new(HintMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_hintMap
	return p
}

func InitEmptyHintMapContext(p *HintMapContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_hintMap
}

func (*HintMapContext) IsHintMapContext() {}

func NewHintMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintMapContext {
	var p = new(HintMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_hintMap

	return p
}

func (s *HintMapContext) GetParser() antlr.Parser { return s.parser }

func (s *HintMapContext) GetK() IIdentifierOrStringContext { return s.k }

func (s *HintMapContext) GetV() ILiteralExpressionContext { return s.v }

func (s *HintMapContext) SetK(v IIdentifierOrStringContext) { s.k = v }

func (s *HintMapContext) SetV(v ILiteralExpressionContext) { s.v = v }

func (s *HintMapContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *HintMapContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HintMapContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *HintMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterHintMap(s)
	}
}

func (s *HintMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitHintMap(s)
	}
}

func (s *HintMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitHintMap(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) HintMap() (localctx IHintMapContext) {
	localctx = NewHintMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, StarRocksParserRULE_hintMap)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6467)

		var _x = p.IdentifierOrString()

		localctx.(*HintMapContext).k = _x
	}
	{
		p.SetState(6468)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6469)

		var _x = p.LiteralExpression()

		localctx.(*HintMapContext).v = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	USING() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *JoinCriteriaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, StarRocksParserRULE_joinCriteria)
	var _la int

	p.SetState(6485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6471)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6472)
			p.expression(0)
		}

	case StarRocksParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6473)
			p.Match(StarRocksParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6474)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6475)
			p.Identifier()
		}
		p.SetState(6480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6476)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6477)
				p.Identifier()
			}

			p.SetState(6482)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6483)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, StarRocksParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6487)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6488)
		p.Identifier()
	}
	p.SetState(6493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6489)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6490)
			p.Identifier()
		}

		p.SetState(6495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6496)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionNamesContext is an interface to support dynamic dispatch.
type IPartitionNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	KeyPartitions() IKeyPartitionsContext

	// IsPartitionNamesContext differentiates from other interfaces.
	IsPartitionNamesContext()
}

type PartitionNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionNamesContext() *PartitionNamesContext {
	var p = new(PartitionNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionNames
	return p
}

func InitEmptyPartitionNamesContext(p *PartitionNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionNames
}

func (*PartitionNamesContext) IsPartitionNamesContext() {}

func NewPartitionNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionNamesContext {
	var p = new(PartitionNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionNames

	return p
}

func (s *PartitionNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *PartitionNamesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *PartitionNamesContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *PartitionNamesContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *PartitionNamesContext) KeyPartitions() IKeyPartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionsContext)
}

func (s *PartitionNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionNames(s)
	}
}

func (s *PartitionNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionNames(s)
	}
}

func (s *PartitionNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionNames() (localctx IPartitionNamesContext) {
	localctx = NewPartitionNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, StarRocksParserRULE_partitionNames)
	var _la int

	p.SetState(6519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 760, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(6498)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6501)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6502)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6503)
			p.IdentifierOrString()
		}
		p.SetState(6508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6504)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6505)
				p.IdentifierOrString()
			}

			p.SetState(6510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6511)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(6513)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6516)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6517)
			p.IdentifierOrString()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6518)
			p.KeyPartitions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionsContext is an interface to support dynamic dispatch.
type IKeyPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeyPartitionsContext differentiates from other interfaces.
	IsKeyPartitionsContext()
}

type KeyPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartitionsContext() *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartitions
	return p
}

func InitEmptyKeyPartitionsContext(p *KeyPartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartitions
}

func (*KeyPartitionsContext) IsKeyPartitionsContext() {}

func NewKeyPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_keyPartitions

	return p
}

func (s *KeyPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionsContext) CopyAll(ctx *KeyPartitionsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *KeyPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KeyPartitionListContext struct {
	KeyPartitionsContext
}

func NewKeyPartitionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KeyPartitionListContext {
	var p = new(KeyPartitionListContext)

	InitEmptyKeyPartitionsContext(&p.KeyPartitionsContext)
	p.parser = parser
	p.CopyAll(ctx.(*KeyPartitionsContext))

	return p
}

func (s *KeyPartitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionListContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *KeyPartitionListContext) AllKeyPartition() []IKeyPartitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartitionContext); ok {
			tst[i] = t.(IKeyPartitionContext)
			i++
		}
	}

	return tst
}

func (s *KeyPartitionListContext) KeyPartition(i int) IKeyPartitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionContext)
}

func (s *KeyPartitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKeyPartitionList(s)
	}
}

func (s *KeyPartitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKeyPartitionList(s)
	}
}

func (s *KeyPartitionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitKeyPartitionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) KeyPartitions() (localctx IKeyPartitionsContext) {
	localctx = NewKeyPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, StarRocksParserRULE_keyPartitions)
	var _la int

	localctx = NewKeyPartitionListContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6521)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6522)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6523)
		p.KeyPartition()
	}
	p.SetState(6528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6524)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6525)
			p.KeyPartition()
		}

		p.SetState(6530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6531)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLET() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTabletList(s)
	}
}

func (s *TabletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTabletList(s)
	}
}

func (s *TabletListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTabletList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, StarRocksParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6533)
		p.Match(StarRocksParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6534)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6535)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6536)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6537)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6543)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	PrepareSql() IPrepareSqlContext

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREPARE, 0)
}

func (s *PrepareStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *PrepareStatementContext) PrepareSql() IPrepareSqlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareSqlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareSqlContext)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrepareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, StarRocksParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6545)
		p.Match(StarRocksParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6546)
		p.Identifier()
	}
	{
		p.SetState(6547)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6548)
		p.PrepareSql()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareSqlContext is an interface to support dynamic dispatch.
type IPrepareSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SINGLE_QUOTED_TEXT() antlr.TerminalNode

	// IsPrepareSqlContext differentiates from other interfaces.
	IsPrepareSqlContext()
}

type PrepareSqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareSqlContext() *PrepareSqlContext {
	var p = new(PrepareSqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareSql
	return p
}

func InitEmptyPrepareSqlContext(p *PrepareSqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareSql
}

func (*PrepareSqlContext) IsPrepareSqlContext() {}

func NewPrepareSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareSqlContext {
	var p = new(PrepareSqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_prepareSql

	return p
}

func (s *PrepareSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareSqlContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareSqlContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSINGLE_QUOTED_TEXT, 0)
}

func (s *PrepareSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrepareSql(s)
	}
}

func (s *PrepareSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrepareSql(s)
	}
}

func (s *PrepareSqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPrepareSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrepareSql() (localctx IPrepareSqlContext) {
	localctx = NewPrepareSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, StarRocksParserRULE_prepareSql)
	p.SetState(6552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserADD, StarRocksParserADMIN, StarRocksParserALTER, StarRocksParserANALYZE, StarRocksParserBACKUP, StarRocksParserBEGIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCOMMIT, StarRocksParserCREATE, StarRocksParserDEALLOCATE, StarRocksParserDELETE, StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserDROP, StarRocksParserEXECUTE, StarRocksParserEXPLAIN, StarRocksParserEXPORT, StarRocksParserGRANT, StarRocksParserHELP, StarRocksParserINSTALL, StarRocksParserINSERT, StarRocksParserKILL, StarRocksParserLOAD, StarRocksParserPAUSE, StarRocksParserPREPARE, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserREVOKE, StarRocksParserROLLBACK, StarRocksParserSELECT, StarRocksParserSET, StarRocksParserSHOW, StarRocksParserSTART, StarRocksParserSTOP, StarRocksParserSUBMIT, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRUNCATE, StarRocksParserUNINSTALL, StarRocksParserUPDATE, StarRocksParserUSE, StarRocksParserWITH, StarRocksParserLOCK, StarRocksParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6550)
			p.Statement()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6551)
			p.Match(StarRocksParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Identifier() IIdentifierContext
	USING() antlr.TerminalNode
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *ExecuteStatementContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserAT)
}

func (s *ExecuteStatementContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, i)
}

func (s *ExecuteStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, StarRocksParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6554)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6555)
		p.Identifier()
	}
	p.SetState(6567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(6556)
			p.Match(StarRocksParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6557)
			p.Match(StarRocksParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6558)
			p.IdentifierOrString()
		}
		p.SetState(6564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6559)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6560)
				p.Match(StarRocksParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6561)
				p.IdentifierOrString()
			}

			p.SetState(6566)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocateStatementContext is an interface to support dynamic dispatch.
type IDeallocateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocateStatementContext differentiates from other interfaces.
	IsDeallocateStatementContext()
}

type DeallocateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeallocateStatementContext() *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deallocateStatement
	return p
}

func InitEmptyDeallocateStatementContext(p *DeallocateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deallocateStatement
}

func (*DeallocateStatementContext) IsDeallocateStatementContext() {}

func NewDeallocateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_deallocateStatement

	return p
}

func (s *DeallocateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocateStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREPARE, 0)
}

func (s *DeallocateStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateStatementContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEALLOCATE, 0)
}

func (s *DeallocateStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DeallocateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeallocateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDeallocateStatement(s)
	}
}

func (s *DeallocateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDeallocateStatement(s)
	}
}

func (s *DeallocateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDeallocateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DeallocateStatement() (localctx IDeallocateStatementContext) {
	localctx = NewDeallocateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, StarRocksParserRULE_deallocateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6569)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDEALLOCATE || _la == StarRocksParserDROP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6570)
		p.Match(StarRocksParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6571)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicaListContext is an interface to support dynamic dispatch.
type IReplicaListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLICA() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsReplicaListContext differentiates from other interfaces.
	IsReplicaListContext()
}

type ReplicaListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicaListContext() *ReplicaListContext {
	var p = new(ReplicaListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replicaList
	return p
}

func InitEmptyReplicaListContext(p *ReplicaListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replicaList
}

func (*ReplicaListContext) IsReplicaListContext() {}

func NewReplicaListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicaListContext {
	var p = new(ReplicaListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_replicaList

	return p
}

func (s *ReplicaListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicaListContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *ReplicaListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *ReplicaListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *ReplicaListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicaListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicaListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterReplicaList(s)
	}
}

func (s *ReplicaListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitReplicaList(s)
	}
}

func (s *ReplicaListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitReplicaList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ReplicaList() (localctx IReplicaListContext) {
	localctx = NewReplicaListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, StarRocksParserRULE_replicaList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6573)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6574)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6575)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6576)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6577)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6583)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsWithDefaultContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext

	// IsExpressionsWithDefaultContext differentiates from other interfaces.
	IsExpressionsWithDefaultContext()
}

type ExpressionsWithDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultContext() *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionsWithDefault
	return p
}

func InitEmptyExpressionsWithDefaultContext(p *ExpressionsWithDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionsWithDefault
}

func (*ExpressionsWithDefaultContext) IsExpressionsWithDefaultContext() {}

func NewExpressionsWithDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionsWithDefault

	return p
}

func (s *ExpressionsWithDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsWithDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionsWithDefault(s)
	}
}

func (s *ExpressionsWithDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionsWithDefault(s)
	}
}

func (s *ExpressionsWithDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExpressionsWithDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExpressionsWithDefault() (localctx IExpressionsWithDefaultContext) {
	localctx = NewExpressionsWithDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, StarRocksParserRULE_expressionsWithDefault)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6585)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6586)
		p.ExpressionOrDefault()
	}
	p.SetState(6591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6587)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6588)
			p.ExpressionOrDefault()
		}

		p.SetState(6593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6594)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExpressionOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, StarRocksParserRULE_expressionOrDefault)
	p.SetState(6598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserT__5, StarRocksParserT__8, StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCASE, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHAR, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCONVERT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserCURRENT_DATE, StarRocksParserCURRENT_GROUP, StarRocksParserCURRENT_ROLE, StarRocksParserCURRENT_TIME, StarRocksParserCURRENT_TIMESTAMP, StarRocksParserCURRENT_USER, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATABASE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDENSE_RANK, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserNTILE, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXISTS, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFALSE, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFIRST_VALUE, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUPING, StarRocksParserGROUPING_ID, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIF, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAG, StarRocksParserLAST, StarRocksParserLAST_VALUE, StarRocksParserLEAD, StarRocksParserLEFT, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIKE, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCALTIME, StarRocksParserLOCALTIMESTAMP, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMOD, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNOT, StarRocksParserNULL, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARAMETER, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREGEXP, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserRIGHT, StarRocksParserRLIKE, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserROW_NUMBER, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSCHEMA, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserPLUS_SYMBOL, StarRocksParserMINUS_SYMBOL, StarRocksParserLOGICAL_NOT, StarRocksParserBITNOT, StarRocksParserAT, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6596)
			p.expression(0)
		}

	case StarRocksParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6597)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionListContext is an interface to support dynamic dispatch.
type IMapExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapExpression() []IMapExpressionContext
	MapExpression(i int) IMapExpressionContext

	// IsMapExpressionListContext differentiates from other interfaces.
	IsMapExpressionListContext()
}

type MapExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExpressionListContext() *MapExpressionListContext {
	var p = new(MapExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpressionList
	return p
}

func InitEmptyMapExpressionListContext(p *MapExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpressionList
}

func (*MapExpressionListContext) IsMapExpressionListContext() {}

func NewMapExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionListContext {
	var p = new(MapExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mapExpressionList

	return p
}

func (s *MapExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionListContext) AllMapExpression() []IMapExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMapExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapExpressionContext); ok {
			tst[i] = t.(IMapExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionListContext) MapExpression(i int) IMapExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionContext)
}

func (s *MapExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapExpressionList(s)
	}
}

func (s *MapExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapExpressionList(s)
	}
}

func (s *MapExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMapExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MapExpressionList() (localctx IMapExpressionListContext) {
	localctx = NewMapExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, StarRocksParserRULE_mapExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6600)
		p.MapExpression()
	}
	p.SetState(6605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6601)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6602)
			p.MapExpression()
		}

		p.SetState(6607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionContext is an interface to support dynamic dispatch.
type IMapExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IExpressionContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetKey sets the key rule contexts.
	SetKey(IExpressionContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsMapExpressionContext differentiates from other interfaces.
	IsMapExpressionContext()
}

type MapExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IExpressionContext
	value  IExpressionContext
}

func NewEmptyMapExpressionContext() *MapExpressionContext {
	var p = new(MapExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpression
	return p
}

func InitEmptyMapExpressionContext(p *MapExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpression
}

func (*MapExpressionContext) IsMapExpressionContext() {}

func NewMapExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionContext {
	var p = new(MapExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mapExpression

	return p
}

func (s *MapExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionContext) GetKey() IExpressionContext { return s.key }

func (s *MapExpressionContext) GetValue() IExpressionContext { return s.value }

func (s *MapExpressionContext) SetKey(v IExpressionContext) { s.key = v }

func (s *MapExpressionContext) SetValue(v IExpressionContext) { s.value = v }

func (s *MapExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapExpression(s)
	}
}

func (s *MapExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapExpression(s)
	}
}

func (s *MapExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMapExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MapExpression() (localctx IMapExpressionContext) {
	localctx = NewMapExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, StarRocksParserRULE_mapExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6608)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).key = _x
	}
	{
		p.SetState(6609)
		p.Match(StarRocksParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6610)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSingletonContext is an interface to support dynamic dispatch.
type IExpressionSingletonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	EOF() antlr.TerminalNode

	// IsExpressionSingletonContext differentiates from other interfaces.
	IsExpressionSingletonContext()
}

type ExpressionSingletonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSingletonContext() *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionSingleton
	return p
}

func InitEmptyExpressionSingletonContext(p *ExpressionSingletonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionSingleton
}

func (*ExpressionSingletonContext) IsExpressionSingletonContext() {}

func NewExpressionSingletonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionSingleton

	return p
}

func (s *ExpressionSingletonContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSingletonContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionSingletonContext) EOF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEOF, 0)
}

func (s *ExpressionSingletonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSingletonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSingletonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionSingleton(s)
	}
}

func (s *ExpressionSingletonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionSingleton(s)
	}
}

func (s *ExpressionSingletonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExpressionSingleton(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExpressionSingleton() (localctx IExpressionSingletonContext) {
	localctx = NewExpressionSingletonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, StarRocksParserRULE_expressionSingleton)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6612)
		p.expression(0)
	}
	{
		p.SetState(6613)
		p.Match(StarRocksParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExpressionDefaultContext struct {
	ExpressionContext
}

func NewExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionDefaultContext {
	var p = new(ExpressionDefaultContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionDefaultContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionDefaultContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY, 0)
}

func (s *ExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionDefault(s)
	}
}

func (s *ExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionDefault(s)
	}
}

func (s *ExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalNotContext struct {
	ExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *LogicalNotContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalBinaryContext struct {
	ExpressionContext
	left     IExpressionContext
	operator antlr.Token
	right    IExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICAL_AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL_AND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *LogicalBinaryContext) LOGICAL_OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL_OR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLogicalBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *StarRocksParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 850
	p.EnterRecursionRule(localctx, 850, StarRocksParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserT__5, StarRocksParserT__8, StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCASE, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHAR, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCONVERT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserCURRENT_DATE, StarRocksParserCURRENT_GROUP, StarRocksParserCURRENT_ROLE, StarRocksParserCURRENT_TIME, StarRocksParserCURRENT_TIMESTAMP, StarRocksParserCURRENT_USER, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATABASE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDENSE_RANK, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserNTILE, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXISTS, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFALSE, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFIRST_VALUE, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUPING, StarRocksParserGROUPING_ID, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIF, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAG, StarRocksParserLAST, StarRocksParserLAST_VALUE, StarRocksParserLEAD, StarRocksParserLEFT, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIKE, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCALTIME, StarRocksParserLOCALTIMESTAMP, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMOD, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULL, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARAMETER, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREGEXP, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserRIGHT, StarRocksParserRLIKE, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserROW_NUMBER, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSCHEMA, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserPLUS_SYMBOL, StarRocksParserMINUS_SYMBOL, StarRocksParserLOGICAL_NOT, StarRocksParserBITNOT, StarRocksParserAT, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		localctx = NewExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		p.SetState(6617)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 770, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6616)
				p.Match(StarRocksParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6619)
			p.booleanExpression(0)
		}

	case StarRocksParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6620)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6621)
			p.expression(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_expression)
				p.SetState(6624)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6625)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserAND || _la == StarRocksParserLOGICAL_AND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6626)

					var _x = p.expression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_expression)
				p.SetState(6627)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6628)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserOR || _la == StarRocksParserLOGICAL_OR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6629)

					var _x = p.expression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6634)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, StarRocksParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6635)
		p.expression(0)
	}
	p.SetState(6640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6636)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6637)
				p.expression(0)
			}

		}
		p.SetState(6642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	BooleanExpressionContext
	left  IBooleanExpressionContext
	right IPredicateContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IPredicateContext { return s.right }

func (s *ComparisonContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IPredicateContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ComparisonContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitComparison(s)
	}
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanExpressionDefaultContext struct {
	BooleanExpressionContext
}

func NewBooleanExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanExpressionDefaultContext {
	var p = new(BooleanExpressionDefaultContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionDefaultContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BooleanExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBooleanExpressionDefault(s)
	}
}

func (s *BooleanExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBooleanExpressionDefault(s)
	}
}

func (s *BooleanExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBooleanExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsNullContext struct {
	BooleanExpressionContext
}

func NewIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullContext {
	var p = new(IsNullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *IsNullContext) IS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIS, 0)
}

func (s *IsNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *IsNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *IsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIsNull(s)
	}
}

func (s *IsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIsNull(s)
	}
}

func (s *IsNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIsNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarSubqueryContext struct {
	BooleanExpressionContext
}

func NewScalarSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarSubqueryContext {
	var p = new(ScalarSubqueryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ScalarSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarSubqueryContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ScalarSubqueryContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ScalarSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ScalarSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterScalarSubquery(s)
	}
}

func (s *ScalarSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitScalarSubquery(s)
	}
}

func (s *ScalarSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitScalarSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *StarRocksParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 854
	p.EnterRecursionRule(localctx, 854, StarRocksParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewBooleanExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6644)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6662)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 776, p.GetParserRuleContext()) {
			case 1:
				localctx = NewIsNullContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_booleanExpression)
				p.SetState(6646)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6647)
					p.Match(StarRocksParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6649)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserNOT {
					{
						p.SetState(6648)
						p.Match(StarRocksParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6651)
					p.Match(StarRocksParserNULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewComparisonContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_booleanExpression)
				p.SetState(6652)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6653)
					p.ComparisonOperator()
				}
				{
					p.SetState(6654)

					var _x = p.Predicate()

					localctx.(*ComparisonContext).right = _x
				}

			case 3:
				localctx = NewScalarSubqueryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_booleanExpression)
				p.SetState(6656)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6657)
					p.ComparisonOperator()
				}
				{
					p.SetState(6658)
					p.Match(StarRocksParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6659)
					p.QueryRelation()
				}
				{
					p.SetState(6660)
					p.Match(StarRocksParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// Getter signatures
	ValueExpression() IValueExpressionContext
	PredicateOperations() IPredicateOperationsContext
	TupleInSubquery() ITupleInSubqueryContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicateContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicateContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) PredicateOperations() IPredicateOperationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateOperationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateOperationsContext)
}

func (s *PredicateContext) TupleInSubquery() ITupleInSubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleInSubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleInSubqueryContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, StarRocksParserRULE_predicate)
	p.SetState(6672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 779, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6667)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext)._valueExpression = _x
		}
		p.SetState(6669)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 778, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6668)
				p.PredicateOperations(localctx.(*PredicateContext).Get_valueExpression())
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6671)
			p.TupleInSubquery()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleInSubqueryContext is an interface to support dynamic dispatch.
type ITupleInSubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	IN() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	NOT() antlr.TerminalNode

	// IsTupleInSubqueryContext differentiates from other interfaces.
	IsTupleInSubqueryContext()
}

type TupleInSubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleInSubqueryContext() *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tupleInSubquery
	return p
}

func InitEmptyTupleInSubqueryContext(p *TupleInSubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tupleInSubquery
}

func (*TupleInSubqueryContext) IsTupleInSubqueryContext() {}

func NewTupleInSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tupleInSubquery

	return p
}

func (s *TupleInSubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleInSubqueryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleInSubqueryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleInSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *TupleInSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *TupleInSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *TupleInSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleInSubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleInSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTupleInSubquery(s)
	}
}

func (s *TupleInSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTupleInSubquery(s)
	}
}

func (s *TupleInSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTupleInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TupleInSubquery() (localctx ITupleInSubqueryContext) {
	localctx = NewTupleInSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, StarRocksParserRULE_tupleInSubquery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6674)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6675)
		p.expression(0)
	}
	p.SetState(6678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == StarRocksParserT__2 {
		{
			p.SetState(6676)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6677)
			p.expression(0)
		}

		p.SetState(6680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6682)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNOT {
		{
			p.SetState(6683)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6686)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6687)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6688)
		p.QueryRelation()
	}
	{
		p.SetState(6689)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateOperationsContext is an interface to support dynamic dispatch.
type IPredicateOperationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateOperationsContext differentiates from other interfaces.
	IsPredicateOperationsContext()
}

type PredicateOperationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateOperationsContext() *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicateOperations
	return p
}

func InitEmptyPredicateOperationsContext(p *PredicateOperationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicateOperations
}

func (*PredicateOperationsContext) IsPredicateOperationsContext() {}

func NewPredicateOperationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_predicateOperations

	p.value = value

	return p
}

func (s *PredicateOperationsContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateOperationsContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateOperationsContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateOperationsContext) CopyAll(ctx *PredicateOperationsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateOperationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateOperationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LikeContext struct {
	PredicateOperationsContext
	pattern IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *LikeContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRLIKE, 0)
}

func (s *LikeContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREGEXP, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLike(s)
	}
}

func (s *LikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type InSubqueryContext struct {
	PredicateOperationsContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *InSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

func (s *InSubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type InListContext struct {
	PredicateOperationsContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *InListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInList(s)
	}
}

func (s *InListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInList(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenContext struct {
	PredicateOperationsContext
	lower IValueExpressionContext
	upper IPredicateContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IPredicateContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IPredicateContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *BetweenContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (s *BetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PredicateOperations(value antlr.ParserRuleContext) (localctx IPredicateOperationsContext) {
	localctx = NewPredicateOperationsContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 860, StarRocksParserRULE_predicateOperations)
	var _la int

	p.SetState(6720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 786, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6691)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6694)
			p.Match(StarRocksParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6695)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6696)
			p.QueryRelation()
		}
		{
			p.SetState(6697)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6699)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6702)
			p.Match(StarRocksParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6703)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6704)
			p.ExpressionList()
		}
		{
			p.SetState(6705)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6707)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6710)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6711)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(6712)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6713)

			var _x = p.Predicate()

			localctx.(*BetweenContext).upper = _x
		}

	case 4:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(6716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6715)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6718)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserLIKE || _la == StarRocksParserREGEXP || _la == StarRocksParserRLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6719)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITXOR, 0)
}

func (s *ArithmeticBinaryContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) SLASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSLASH_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) PERCENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENT_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) INT_DIV() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINT_DIV, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMOD, 0)
}

func (s *ArithmeticBinaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) BITAND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITAND, 0)
}

func (s *ArithmeticBinaryContext) BITOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITOR, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_LEFT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIT_SHIFT_LEFT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIT_SHIFT_RIGHT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT_LOGICAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIT_SHIFT_RIGHT_LOGICAL, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *StarRocksParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 862
	p.EnterRecursionRule(localctx, 862, StarRocksParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewValueExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6723)
		p.primaryExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6749)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 787, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6725)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(6726)

					var _m = p.Match(StarRocksParserBITXOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6727)

					var _x = p.valueExpression(9)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6728)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(6729)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserMOD || ((int64((_la-503)) & ^0x3f) == 0 && ((int64(1)<<(_la-503))&71) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6730)

					var _x = p.valueExpression(8)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6731)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6732)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserPLUS_SYMBOL || _la == StarRocksParserMINUS_SYMBOL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6733)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6734)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6735)

					var _m = p.Match(StarRocksParserBITAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6736)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6737)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6738)

					var _m = p.Match(StarRocksParserBITOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6739)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6740)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6741)

					var _m = p.Match(StarRocksParserBIT_SHIFT_LEFT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6742)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 7:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6743)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6744)

					var _m = p.Match(StarRocksParserBIT_SHIFT_RIGHT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6745)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 8:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6746)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6747)

					var _m = p.Match(StarRocksParserBIT_SHIFT_RIGHT_LOGICAL)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6748)

					var _x = p.valueExpression(2)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 788, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) DOT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOT_IDENTIFIER, 0)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDereference(s)
	}
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type OdbcFunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewOdbcFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OdbcFunctionCallExpressionContext {
	var p = new(OdbcFunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *OdbcFunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OdbcFunctionCallExpressionContext) FN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFN, 0)
}

func (s *OdbcFunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *OdbcFunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOdbcFunctionCallExpression(s)
	}
}

func (s *OdbcFunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOdbcFunctionCallExpression(s)
	}
}

func (s *OdbcFunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOdbcFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MatchExprContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewMatchExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MatchExprContext {
	var p = new(MatchExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MatchExprContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *MatchExprContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *MatchExprContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *MatchExprContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATCH, 0)
}

func (s *MatchExprContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MatchExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnRefContext struct {
	PrimaryExpressionContext
}

func NewColumnRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnRefContext {
	var p = new(ColumnRefContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ColumnReference() IColumnReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnReferenceContext)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

func (s *ColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertContext struct {
	PrimaryExpressionContext
}

func NewConvertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertContext {
	var p = new(ConvertContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONVERT, 0)
}

func (s *ConvertContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterConvert(s)
	}
}

func (s *ConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitConvert(s)
	}
}

func (s *ConvertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitConvert(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollectionSubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewCollectionSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionSubscriptContext {
	var p = new(CollectionSubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollectionSubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *CollectionSubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *CollectionSubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *CollectionSubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *CollectionSubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionSubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollectionSubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CollectionSubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCollectionSubscript(s)
	}
}

func (s *CollectionSubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCollectionSubscript(s)
	}
}

func (s *CollectionSubscriptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCollectionSubscript(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralContext struct {
	PrimaryExpressionContext
}

func NewLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralContext {
	var p = new(LiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCast(s)
	}
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewUserVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableExpressionContext {
	var p = new(UserVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableExpressionContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *UserVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserVariableExpression(s)
	}
}

func (s *UserVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserVariableExpression(s)
	}
}

func (s *UserVariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUserVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	caseExpr       IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetCaseExpr() IExpressionContext { return s.caseExpr }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetCaseExpr(v IExpressionContext) { s.caseExpr = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrowExpressionContext struct {
	PrimaryExpressionContext
}

func NewArrowExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowExpressionContext {
	var p = new(ArrowExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArrowExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARROW, 0)
}

func (s *ArrowExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ArrowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitArrowExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type SystemVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewSystemVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableExpressionContext {
	var p = new(SystemVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableExpressionContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SystemVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSystemVariableExpression(s)
	}
}

func (s *SystemVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSystemVariableExpression(s)
	}
}

func (s *SystemVariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSystemVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConcatContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewConcatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatContext {
	var p = new(ConcatContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConcatContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *ConcatContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *ConcatContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *ConcatContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *ConcatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONCAT, 0)
}

func (s *ConcatContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ConcatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterConcat(s)
	}
}

func (s *ConcatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitConcat(s)
	}
}

func (s *ConcatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitConcat(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LambdaFunctionExprContext struct {
	PrimaryExpressionContext
}

func NewLambdaFunctionExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARROW, 0)
}

func (s *LambdaFunctionExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaFunctionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaFunctionExprContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *LambdaFunctionExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *LambdaFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLambdaFunctionExpr(s)
	}
}

func (s *LambdaFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLambdaFunctionExpr(s)
	}
}

func (s *LambdaFunctionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLambdaFunctionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type DictionaryGetExprContext struct {
	PrimaryExpressionContext
}

func NewDictionaryGetExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DictionaryGetExprContext {
	var p = new(DictionaryGetExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DictionaryGetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryGetExprContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY_GET, 0)
}

func (s *DictionaryGetExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DictionaryGetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDictionaryGetExpr(s)
	}
}

func (s *DictionaryGetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDictionaryGetExpr(s)
	}
}

func (s *DictionaryGetExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDictionaryGetExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCollate(s)
	}
}

func (s *CollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayConstructorContext struct {
	PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ArrayConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitArrayConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type MapConstructorContext struct {
	PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *MapConstructorContext) MapExpressionList() IMapExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionListContext)
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAP, 0)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

func (s *MapConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMapConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	start_ antlr.Token
	end    antlr.Token
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetStart_() antlr.Token { return s.start_ }

func (s *ArraySliceContext) GetEnd() antlr.Token { return s.end }

func (s *ArraySliceContext) SetStart_(v antlr.Token) { s.start_ = v }

func (s *ArraySliceContext) SetEnd(v antlr.Token) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *ArraySliceContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *ArraySliceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArraySlice(s)
	}
}

func (s *ArraySliceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArraySlice(s)
	}
}

func (s *ArraySliceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitArraySlice(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsContext struct {
	PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *ExistsContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExists(s)
	}
}

func (s *ExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExists(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	PrimaryExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITNOT, 0)
}

func (s *ArithmeticUnaryContext) LOGICAL_NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL_NOT, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *StarRocksParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 864
	p.EnterRecursionRule(localctx, 864, StarRocksParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 799, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(6755)
			p.UserVariable()
		}

	case 2:
		localctx = NewSystemVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6756)
			p.SystemVariable()
		}

	case 3:
		localctx = NewDictionaryGetExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6757)
			p.Match(StarRocksParserDICTIONARY_GET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6758)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6759)
			p.ExpressionList()
		}
		{
			p.SetState(6760)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6762)
			p.FunctionCall()
		}

	case 5:
		localctx = NewOdbcFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6763)
			p.Match(StarRocksParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6764)
			p.Match(StarRocksParserFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6765)
			p.FunctionCall()
		}
		{
			p.SetState(6766)
			p.Match(StarRocksParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6768)
			p.LiteralExpression()
		}

	case 7:
		localctx = NewColumnRefContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6769)
			p.ColumnReference()
		}

	case 8:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6770)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-501)) & ^0x3f) == 0 && ((int64(1)<<(_la-501))&4099) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6771)
			p.primaryExpression(18)
		}

	case 9:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6772)

			var _m = p.Match(StarRocksParserLOGICAL_NOT)

			localctx.(*ArithmeticUnaryContext).operator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6773)
			p.primaryExpression(17)
		}

	case 10:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6774)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6775)
			p.expression(0)
		}
		{
			p.SetState(6776)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6778)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6779)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6780)
			p.QueryRelation()
		}
		{
			p.SetState(6781)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6783)
			p.Subquery()
		}

	case 13:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6784)
			p.Match(StarRocksParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6785)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6786)
			p.expression(0)
		}
		{
			p.SetState(6787)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6788)
			p.Type_()
		}
		{
			p.SetState(6789)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewConvertContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6791)
			p.Match(StarRocksParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6792)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6793)
			p.expression(0)
		}
		{
			p.SetState(6794)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6795)
			p.Type_()
		}
		{
			p.SetState(6796)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6798)
			p.Match(StarRocksParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6799)

			var _x = p.expression(0)

			localctx.(*SimpleCaseContext).caseExpr = _x
		}
		p.SetState(6801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == StarRocksParserWHEN {
			{
				p.SetState(6800)
				p.WhenClause()
			}

			p.SetState(6803)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserELSE {
			{
				p.SetState(6805)
				p.Match(StarRocksParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6806)

				var _x = p.expression(0)

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6809)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6811)
			p.Match(StarRocksParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == StarRocksParserWHEN {
			{
				p.SetState(6812)
				p.WhenClause()
			}

			p.SetState(6815)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserELSE {
			{
				p.SetState(6817)
				p.Match(StarRocksParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6818)

				var _x = p.expression(0)

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6821)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserARRAY {
			{
				p.SetState(6823)
				p.ArrayType()
			}

		}
		{
			p.SetState(6826)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6827)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6830)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6831)
			p.MapType()
		}
		{
			p.SetState(6832)
			p.Match(StarRocksParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6833)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6836)
			p.Match(StarRocksParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6838)
			p.Match(StarRocksParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6839)
			p.Match(StarRocksParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6840)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6843)
			p.Match(StarRocksParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(6844)
				p.Identifier()
			}

		case StarRocksParserT__1:
			{
				p.SetState(6845)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6848)
			p.Match(StarRocksParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6849)
			p.expression(0)
		}

	case 21:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6851)
			p.IdentifierList()
		}
		{
			p.SetState(6852)
			p.Match(StarRocksParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6853)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6854)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6857)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6900)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 805, p.GetParserRuleContext()) {
			case 1:
				localctx = NewConcatContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6861)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(6862)
					p.Match(StarRocksParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6863)

					var _x = p.primaryExpression(20)

					localctx.(*ConcatContext).right = _x
				}

			case 2:
				localctx = NewMatchExprContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*MatchExprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6864)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				p.SetState(6866)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserNOT {
					{
						p.SetState(6865)
						p.Match(StarRocksParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6868)
					p.Match(StarRocksParserMATCH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6869)

					var _x = p.primaryExpression(2)

					localctx.(*MatchExprContext).right = _x
				}

			case 3:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6870)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(6871)
					p.Match(StarRocksParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6874)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
					{
						p.SetState(6872)
						p.Identifier()
					}

				case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
					{
						p.SetState(6873)
						p.String_()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 4:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6876)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				p.SetState(6880)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case StarRocksParserDOT_IDENTIFIER:
					{
						p.SetState(6877)
						p.Match(StarRocksParserDOT_IDENTIFIER)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case StarRocksParserT__0:
					{
						p.SetState(6878)
						p.Match(StarRocksParserT__0)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(6879)

						var _x = p.Identifier()

						localctx.(*DereferenceContext).fieldName = _x
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 5:
				localctx = NewCollectionSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*CollectionSubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6882)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6883)
					p.Match(StarRocksParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6884)

					var _x = p.valueExpression(0)

					localctx.(*CollectionSubscriptContext).index = _x
				}
				{
					p.SetState(6885)
					p.Match(StarRocksParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6887)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6888)
					p.Match(StarRocksParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6890)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserINTEGER_VALUE {
					{
						p.SetState(6889)

						var _m = p.Match(StarRocksParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).start_ = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6892)
					p.Match(StarRocksParserT__7)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6894)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserINTEGER_VALUE {
					{
						p.SetState(6893)

						var _m = p.Match(StarRocksParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).end = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6896)
					p.Match(StarRocksParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 7:
				localctx = NewArrowExpressionContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6897)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6898)
					p.Match(StarRocksParserARROW)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6899)
					p.String_()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionContext is an interface to support dynamic dispatch.
type ILiteralExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralExpressionContext differentiates from other interfaces.
	IsLiteralExpressionContext()
}

type LiteralExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionContext() *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpression
	return p
}

func InitEmptyLiteralExpressionContext(p *LiteralExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpression
}

func (*LiteralExpressionContext) IsLiteralExpressionContext() {}

func NewLiteralExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_literalExpression

	return p
}

func (s *LiteralExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionContext) CopyAll(ctx *LiteralExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BinaryLiteralContext struct {
	LiteralExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) Binary() IBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBinaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	LiteralExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	LiteralExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParameterContext struct {
	LiteralExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARAMETER, 0)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitParameter(s)
	}
}

func (s *ParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

type DateLiteralContext struct {
	LiteralExpressionContext
}

func NewDateLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateLiteralContext {
	var p = new(DateLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *DateLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DateLiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATE, 0)
}

func (s *DateLiteralContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATETIME, 0)
}

func (s *DateLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDateLiteral(s)
	}
}

func (s *DateLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDateLiteral(s)
	}
}

func (s *DateLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDateLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	LiteralExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	LiteralExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalLiteralContext struct {
	LiteralExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnitBoundaryLiteralContext struct {
	LiteralExpressionContext
}

func NewUnitBoundaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnitBoundaryLiteralContext {
	var p = new(UnitBoundaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *UnitBoundaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryLiteralContext) UnitBoundary() IUnitBoundaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitBoundaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitBoundaryContext)
}

func (s *UnitBoundaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnitBoundaryLiteral(s)
	}
}

func (s *UnitBoundaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnitBoundaryLiteral(s)
	}
}

func (s *UnitBoundaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUnitBoundaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LiteralExpression() (localctx ILiteralExpressionContext) {
	localctx = NewLiteralExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, StarRocksParserRULE_literalExpression)
	var _la int

	p.SetState(6915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6905)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFALSE, StarRocksParserTRUE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6906)
			p.BooleanValue()
		}

	case StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6907)
			p.Number()
		}

	case StarRocksParserDATE, StarRocksParserDATETIME:
		localctx = NewDateLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6908)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserDATE || _la == StarRocksParserDATETIME) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6909)
			p.String_()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6910)
			p.String_()
		}

	case StarRocksParserINTERVAL:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6911)
			p.Interval()
		}

	case StarRocksParserCEIL, StarRocksParserFLOOR:
		localctx = NewUnitBoundaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6912)
			p.UnitBoundary()
		}

	case StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6913)
			p.Binary()
		}

	case StarRocksParserPARAMETER:
		localctx = NewParameterContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6914)
			p.Match(StarRocksParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyAll(ctx *FunctionCallContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AggregationFunctionCallContext struct {
	FunctionCallContext
}

func NewAggregationFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregationFunctionCallContext {
	var p = new(AggregationFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregationFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionCallContext) AggregationFunction() IAggregationFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *AggregationFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *AggregationFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggregationFunctionCall(s)
	}
}

func (s *AggregationFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggregationFunctionCall(s)
	}
}

func (s *AggregationFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAggregationFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	FunctionCallContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExtract(s)
	}
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialFunctionContext struct {
	FunctionCallContext
}

func NewSpecialFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionContext) SpecialFunctionExpression() ISpecialFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialFunctionExpressionContext)
}

func (s *SpecialFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSpecialFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFunctionCallContext struct {
	FunctionCallContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SimpleFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSimpleFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SpecialDateTimeContext struct {
	FunctionCallContext
}

func NewSpecialDateTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeContext {
	var p = new(SpecialDateTimeContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialDateTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeContext) SpecialDateTimeExpression() ISpecialDateTimeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialDateTimeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialDateTimeExpressionContext)
}

func (s *SpecialDateTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialDateTime(s)
	}
}

func (s *SpecialDateTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialDateTime(s)
	}
}

func (s *SpecialDateTimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSpecialDateTime(s)

	default:
		return t.VisitChildren(s)
	}
}

type WindowFunctionCallContext struct {
	FunctionCallContext
}

func NewWindowFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *WindowFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionCallContext) WindowFunction() IWindowFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFunctionContext)
}

func (s *WindowFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *WindowFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitWindowFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type InformationFunctionContext struct {
	FunctionCallContext
}

func NewInformationFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InformationFunctionContext {
	var p = new(InformationFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *InformationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionContext) InformationFunctionExpression() IInformationFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInformationFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInformationFunctionExpressionContext)
}

func (s *InformationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInformationFunction(s)
	}
}

func (s *InformationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInformationFunction(s)
	}
}

func (s *InformationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInformationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type TranslateFunctionCallContext struct {
	FunctionCallContext
}

func NewTranslateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranslateFunctionCallContext {
	var p = new(TranslateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *TranslateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateFunctionCallContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSLATE, 0)
}

func (s *TranslateFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TranslateFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TranslateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTranslateFunctionCall(s)
	}
}

func (s *TranslateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTranslateFunctionCall(s)
	}
}

func (s *TranslateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTranslateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type GroupingOperationContext struct {
	FunctionCallContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingOperationContext) GROUPING_ID() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPING_ID, 0)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, StarRocksParserRULE_functionCall)
	var _la int

	p.SetState(6989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExtractContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6917)
			p.Match(StarRocksParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6918)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6919)
			p.Identifier()
		}
		{
			p.SetState(6920)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6921)
			p.valueExpression(0)
		}
		{
			p.SetState(6922)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6924)
			p.Match(StarRocksParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6925)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6926)
				p.expression(0)
			}
			p.SetState(6931)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6927)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6928)
					p.expression(0)
				}

				p.SetState(6933)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6936)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6937)
			p.Match(StarRocksParserGROUPING_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6938)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6939)
				p.expression(0)
			}
			p.SetState(6944)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6940)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6941)
					p.expression(0)
				}

				p.SetState(6946)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6949)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewInformationFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6950)
			p.InformationFunctionExpression()
		}

	case 5:
		localctx = NewSpecialDateTimeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6951)
			p.SpecialDateTimeExpression()
		}

	case 6:
		localctx = NewSpecialFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6952)
			p.SpecialFunctionExpression()
		}

	case 7:
		localctx = NewAggregationFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6953)
			p.AggregationFunction()
		}
		p.SetState(6955)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 812, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6954)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewWindowFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6957)
			p.WindowFunction()
		}
		{
			p.SetState(6958)
			p.Over()
		}

	case 9:
		localctx = NewTranslateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6960)
			p.Match(StarRocksParserTRANSLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6961)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6962)
				p.expression(0)
			}
			p.SetState(6967)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6963)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6964)
					p.expression(0)
				}

				p.SetState(6969)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6972)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6973)
			p.QualifiedName()
		}
		{
			p.SetState(6974)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(6975)
				p.expression(0)
			}
			p.SetState(6980)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6976)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6977)
					p.expression(0)
				}

				p.SetState(6982)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6985)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6987)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 817, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6986)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationFunctionContext is an interface to support dynamic dispatch.
type IAggregationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AVG() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SetQuantifier() ISetQuantifierContext
	COUNT() antlr.TerminalNode
	ASTERISK_SYMBOL() antlr.TerminalNode
	BracketHint() IBracketHintContext
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode

	// IsAggregationFunctionContext differentiates from other interfaces.
	IsAggregationFunctionContext()
}

type AggregationFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionContext() *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggregationFunction
	return p
}

func InitEmptyAggregationFunctionContext(p *AggregationFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggregationFunction
}

func (*AggregationFunctionContext) IsAggregationFunctionContext() {}

func NewAggregationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_aggregationFunction

	return p
}

func (s *AggregationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAVG, 0)
}

func (s *AggregationFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregationFunctionContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *AggregationFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOUNT, 0)
}

func (s *AggregationFunctionContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *AggregationFunctionContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *AggregationFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAX, 0)
}

func (s *AggregationFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMIN, 0)
}

func (s *AggregationFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUM, 0)
}

func (s *AggregationFunctionContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG, 0)
}

func (s *AggregationFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *AggregationFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *AggregationFunctionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *AggregationFunctionContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG_DISTINCT, 0)
}

func (s *AggregationFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP_CONCAT, 0)
}

func (s *AggregationFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEPARATOR, 0)
}

func (s *AggregationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAggregationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AggregationFunction() (localctx IAggregationFunctionContext) {
	localctx = NewAggregationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, StarRocksParserRULE_aggregationFunction)
	var _la int

	p.SetState(7116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6991)
			p.Match(StarRocksParserAVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6992)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(6993)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(6996)
			p.expression(0)
		}
		{
			p.SetState(6997)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6999)
			p.Match(StarRocksParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7000)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserASTERISK_SYMBOL {
			{
				p.SetState(7001)
				p.Match(StarRocksParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7004)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7005)
			p.Match(StarRocksParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7006)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7007)
				p.SetQuantifier()
			}
			p.SetState(7009)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 821, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7008)
					p.BracketHint()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(7021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7013)
				p.expression(0)
			}
			p.SetState(7018)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7014)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7015)
					p.expression(0)
				}

				p.SetState(7020)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7023)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7024)
			p.Match(StarRocksParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7025)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7026)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7029)
			p.expression(0)
		}
		{
			p.SetState(7030)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7032)
			p.Match(StarRocksParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7033)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7034)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7037)
			p.expression(0)
		}
		{
			p.SetState(7038)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7040)
			p.Match(StarRocksParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7041)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7042)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7045)
			p.expression(0)
		}
		{
			p.SetState(7046)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7048)
			p.Match(StarRocksParserARRAY_AGG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7049)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7050)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7053)
			p.expression(0)
		}
		p.SetState(7064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(7054)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7055)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7056)
				p.SortItem()
			}
			p.SetState(7061)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7057)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7058)
					p.SortItem()
				}

				p.SetState(7063)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7066)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7068)
			p.Match(StarRocksParserARRAY_AGG_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7069)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7070)
			p.expression(0)
		}
		p.SetState(7081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(7071)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7072)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7073)
				p.SortItem()
			}
			p.SetState(7078)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7074)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7075)
					p.SortItem()
				}

				p.SetState(7080)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7083)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7085)
			p.Match(StarRocksParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7086)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7087)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7090)
			p.expression(0)
		}
		p.SetState(7095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(7091)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7092)
				p.expression(0)
			}

			p.SetState(7097)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(7108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(7098)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7099)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7100)
				p.SortItem()
			}
			p.SetState(7105)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7101)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7102)
					p.SortItem()
				}

				p.SetState(7107)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(7112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSEPARATOR {
			{
				p.SetState(7110)
				p.Match(StarRocksParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7111)
				p.expression(0)
			}

		}
		{
			p.SetState(7114)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariableContext is an interface to support dynamic dispatch.
type IUserVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUserVariableContext differentiates from other interfaces.
	IsUserVariableContext()
}

type UserVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariableContext() *UserVariableContext {
	var p = new(UserVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userVariable
	return p
}

func InitEmptyUserVariableContext(p *UserVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userVariable
}

func (*UserVariableContext) IsUserVariableContext() {}

func NewUserVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariableContext {
	var p = new(UserVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_userVariable

	return p
}

func (s *UserVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariableContext) AT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, 0)
}

func (s *UserVariableContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

func (s *UserVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUserVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UserVariable() (localctx IUserVariableContext) {
	localctx = NewUserVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, StarRocksParserRULE_userVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7118)
		p.Match(StarRocksParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7119)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemVariableContext is an interface to support dynamic dispatch.
type ISystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	VarType() IVarTypeContext

	// IsSystemVariableContext differentiates from other interfaces.
	IsSystemVariableContext()
}

type SystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemVariableContext() *SystemVariableContext {
	var p = new(SystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_systemVariable
	return p
}

func InitEmptySystemVariableContext(p *SystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_systemVariable
}

func (*SystemVariableContext) IsSystemVariableContext() {}

func NewSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemVariableContext {
	var p = new(SystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_systemVariable

	return p
}

func (s *SystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemVariableContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserAT)
}

func (s *SystemVariableContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, i)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

func (s *SystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SystemVariable() (localctx ISystemVariableContext) {
	localctx = NewSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, StarRocksParserRULE_systemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7121)
		p.Match(StarRocksParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7122)
		p.Match(StarRocksParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7126)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7123)
			p.VarType()
		}
		{
			p.SetState(7124)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7128)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnReferenceContext is an interface to support dynamic dispatch.
type IColumnReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsColumnReferenceContext differentiates from other interfaces.
	IsColumnReferenceContext()
}

type ColumnReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnReferenceContext() *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnReference
	return p
}

func InitEmptyColumnReferenceContext(p *ColumnReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnReference
}

func (*ColumnReferenceContext) IsColumnReferenceContext() {}

func NewColumnReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnReference

	return p
}

func (s *ColumnReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ColumnReference() (localctx IColumnReferenceContext) {
	localctx = NewColumnReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, StarRocksParserRULE_columnReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7130)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInformationFunctionExpressionContext is an interface to support dynamic dispatch.
type IInformationFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	USER() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURRENT_ROLE() antlr.TerminalNode
	CURRENT_GROUP() antlr.TerminalNode

	// IsInformationFunctionExpressionContext differentiates from other interfaces.
	IsInformationFunctionExpressionContext()
}

type InformationFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyInformationFunctionExpressionContext() *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_informationFunctionExpression
	return p
}

func InitEmptyInformationFunctionExpressionContext(p *InformationFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_informationFunctionExpression
}

func (*InformationFunctionExpressionContext) IsInformationFunctionExpressionContext() {}

func NewInformationFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_informationFunctionExpression

	return p
}

func (s *InformationFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InformationFunctionExpressionContext) GetName() antlr.Token { return s.name }

func (s *InformationFunctionExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *InformationFunctionExpressionContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *InformationFunctionExpressionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *InformationFunctionExpressionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *InformationFunctionExpressionContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_USER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_ROLE, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_GROUP, 0)
}

func (s *InformationFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InformationFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInformationFunctionExpression(s)
	}
}

func (s *InformationFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInformationFunctionExpression(s)
	}
}

func (s *InformationFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInformationFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) InformationFunctionExpression() (localctx IInformationFunctionExpressionContext) {
	localctx = NewInformationFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, StarRocksParserRULE_informationFunctionExpression)
	p.SetState(7159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCATALOG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7132)

			var _m = p.Match(StarRocksParserCATALOG)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7133)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7134)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7135)

			var _m = p.Match(StarRocksParserDATABASE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7136)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7137)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSCHEMA:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7138)

			var _m = p.Match(StarRocksParserSCHEMA)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7139)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7140)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUSER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7141)

			var _m = p.Match(StarRocksParserUSER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7142)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7143)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCURRENT_USER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7144)

			var _m = p.Match(StarRocksParserCURRENT_USER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7147)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 840, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7145)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7146)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_ROLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7149)

			var _m = p.Match(StarRocksParserCURRENT_ROLE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7152)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7150)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7151)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_GROUP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7154)

			var _m = p.Match(StarRocksParserCURRENT_GROUP)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7157)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7155)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7156)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialDateTimeExpressionContext is an interface to support dynamic dispatch.
type ISpecialDateTimeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode

	// IsSpecialDateTimeExpressionContext differentiates from other interfaces.
	IsSpecialDateTimeExpressionContext()
}

type SpecialDateTimeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptySpecialDateTimeExpressionContext() *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialDateTimeExpression
	return p
}

func InitEmptySpecialDateTimeExpressionContext(p *SpecialDateTimeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialDateTimeExpression
}

func (*SpecialDateTimeExpressionContext) IsSpecialDateTimeExpressionContext() {}

func NewSpecialDateTimeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_specialDateTimeExpression

	return p
}

func (s *SpecialDateTimeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialDateTimeExpressionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeExpressionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCALTIME, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialDateTimeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialDateTimeExpression(s)
	}
}

func (s *SpecialDateTimeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialDateTimeExpression(s)
	}
}

func (s *SpecialDateTimeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSpecialDateTimeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SpecialDateTimeExpression() (localctx ISpecialDateTimeExpressionContext) {
	localctx = NewSpecialDateTimeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, StarRocksParserRULE_specialDateTimeExpression)
	var _la int

	p.SetState(7189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7161)

			var _m = p.Match(StarRocksParserCURRENT_DATE)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7164)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 844, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7162)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7163)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7166)

			var _m = p.Match(StarRocksParserCURRENT_TIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7169)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7167)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7168)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7171)

			var _m = p.Match(StarRocksParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7177)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 847, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7172)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7174)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserINTEGER_VALUE {
				{
					p.SetState(7173)
					p.Match(StarRocksParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(7176)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserLOCALTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7179)

			var _m = p.Match(StarRocksParserLOCALTIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7182)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 848, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7180)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7181)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7184)

			var _m = p.Match(StarRocksParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7187)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 849, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7185)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7186)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialFunctionExpressionContext is an interface to support dynamic dispatch.
type ISpecialFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	UnitIdentifier() IUnitIdentifierContext
	TIMESTAMPDIFF() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	String_() IStringContext
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsSpecialFunctionExpressionContext differentiates from other interfaces.
	IsSpecialFunctionExpressionContext()
}

type SpecialFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialFunctionExpressionContext() *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialFunctionExpression
	return p
}

func InitEmptySpecialFunctionExpressionContext(p *SpecialFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialFunctionExpression
}

func (*SpecialFunctionExpressionContext) IsSpecialFunctionExpressionContext() {}

func NewSpecialFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_specialFunctionExpression

	return p
}

func (s *SpecialFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialFunctionExpressionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *SpecialFunctionExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialFunctionExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpecialFunctionExpressionContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *SpecialFunctionExpressionContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *SpecialFunctionExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SpecialFunctionExpressionContext) LEFT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEFT, 0)
}

func (s *SpecialFunctionExpressionContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *SpecialFunctionExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMOD, 0)
}

func (s *SpecialFunctionExpressionContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMONTH, 0)
}

func (s *SpecialFunctionExpressionContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUARTER, 0)
}

func (s *SpecialFunctionExpressionContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREGEXP, 0)
}

func (s *SpecialFunctionExpressionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *SpecialFunctionExpressionContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRIGHT, 0)
}

func (s *SpecialFunctionExpressionContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPADD, 0)
}

func (s *SpecialFunctionExpressionContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPDIFF, 0)
}

func (s *SpecialFunctionExpressionContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserYEAR, 0)
}

func (s *SpecialFunctionExpressionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, 0)
}

func (s *SpecialFunctionExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SpecialFunctionExpressionContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOOR, 0)
}

func (s *SpecialFunctionExpressionContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCEIL, 0)
}

func (s *SpecialFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialFunctionExpression(s)
	}
}

func (s *SpecialFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialFunctionExpression(s)
	}
}

func (s *SpecialFunctionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSpecialFunctionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SpecialFunctionExpression() (localctx ISpecialFunctionExpressionContext) {
	localctx = NewSpecialFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, StarRocksParserRULE_specialFunctionExpression)
	var _la int

	p.SetState(7332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7191)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7192)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7193)
			p.expression(0)
		}
		{
			p.SetState(7194)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7196)
			p.Match(StarRocksParserDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7197)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7198)
			p.expression(0)
		}
		{
			p.SetState(7199)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserHOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7201)
			p.Match(StarRocksParserHOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7202)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7203)
			p.expression(0)
		}
		{
			p.SetState(7204)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserIF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7206)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7207)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7208)
				p.expression(0)
			}
			p.SetState(7213)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7209)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7210)
					p.expression(0)
				}

				p.SetState(7215)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7218)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserLEFT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7219)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7220)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7221)
			p.expression(0)
		}
		{
			p.SetState(7222)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7223)
			p.expression(0)
		}
		{
			p.SetState(7224)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserLIKE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7226)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7227)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7228)
			p.expression(0)
		}
		{
			p.SetState(7229)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7230)
			p.expression(0)
		}
		{
			p.SetState(7231)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7233)
			p.Match(StarRocksParserMINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7234)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7235)
			p.expression(0)
		}
		{
			p.SetState(7236)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMOD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7238)
			p.Match(StarRocksParserMOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7239)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7240)
			p.expression(0)
		}
		{
			p.SetState(7241)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7242)
			p.expression(0)
		}
		{
			p.SetState(7243)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMONTH:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7245)
			p.Match(StarRocksParserMONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7246)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7247)
			p.expression(0)
		}
		{
			p.SetState(7248)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserQUARTER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7250)
			p.Match(StarRocksParserQUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7251)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7252)
			p.expression(0)
		}
		{
			p.SetState(7253)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREGEXP:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7255)
			p.Match(StarRocksParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7256)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7257)
			p.expression(0)
		}
		{
			p.SetState(7258)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7259)
			p.expression(0)
		}
		{
			p.SetState(7260)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREPLACE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7262)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7263)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7264)
				p.expression(0)
			}
			p.SetState(7269)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7265)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7266)
					p.expression(0)
				}

				p.SetState(7271)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7274)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRIGHT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7275)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7276)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7277)
			p.expression(0)
		}
		{
			p.SetState(7278)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7279)
			p.expression(0)
		}
		{
			p.SetState(7280)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRLIKE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7282)
			p.Match(StarRocksParserRLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7283)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7284)
			p.expression(0)
		}
		{
			p.SetState(7285)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7286)
			p.expression(0)
		}
		{
			p.SetState(7287)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSECOND:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7289)
			p.Match(StarRocksParserSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7290)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7291)
			p.expression(0)
		}
		{
			p.SetState(7292)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserTIMESTAMPADD:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7294)
			p.Match(StarRocksParserTIMESTAMPADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7295)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7296)
			p.UnitIdentifier()
		}
		{
			p.SetState(7297)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7298)
			p.expression(0)
		}
		{
			p.SetState(7299)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7300)
			p.expression(0)
		}
		{
			p.SetState(7301)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserTIMESTAMPDIFF:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7303)
			p.Match(StarRocksParserTIMESTAMPDIFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7304)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7305)
			p.UnitIdentifier()
		}
		{
			p.SetState(7306)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7307)
			p.expression(0)
		}
		{
			p.SetState(7308)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7309)
			p.expression(0)
		}
		{
			p.SetState(7310)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserYEAR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7312)
			p.Match(StarRocksParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7313)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7314)
			p.expression(0)
		}
		{
			p.SetState(7315)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPASSWORD:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7317)
			p.Match(StarRocksParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7318)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7319)
			p.String_()
		}
		{
			p.SetState(7320)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFLOOR:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7322)
			p.Match(StarRocksParserFLOOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7323)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7324)
			p.expression(0)
		}
		{
			p.SetState(7325)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCEIL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7327)
			p.Match(StarRocksParserCEIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7328)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7329)
			p.expression(0)
		}
		{
			p.SetState(7330)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFunctionContext is an interface to support dynamic dispatch.
type IWindowFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	ROW_NUMBER() antlr.TerminalNode
	RANK() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	LEAD() antlr.TerminalNode
	AllIgnoreNulls() []IIgnoreNullsContext
	IgnoreNulls(i int) IIgnoreNullsContext
	LAG() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode

	// IsWindowFunctionContext differentiates from other interfaces.
	IsWindowFunctionContext()
}

type WindowFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyWindowFunctionContext() *WindowFunctionContext {
	var p = new(WindowFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFunction
	return p
}

func InitEmptyWindowFunctionContext(p *WindowFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFunction
}

func (*WindowFunctionContext) IsWindowFunctionContext() {}

func NewWindowFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFunctionContext {
	var p = new(WindowFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_windowFunction

	return p
}

func (s *WindowFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFunctionContext) GetName() antlr.Token { return s.name }

func (s *WindowFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *WindowFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROW_NUMBER, 0)
}

func (s *WindowFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANK, 0)
}

func (s *WindowFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDENSE_RANK, 0)
}

func (s *WindowFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUME_DIST, 0)
}

func (s *WindowFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENT_RANK, 0)
}

func (s *WindowFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNTILE, 0)
}

func (s *WindowFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WindowFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEAD, 0)
}

func (s *WindowFunctionContext) AllIgnoreNulls() []IIgnoreNullsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			len++
		}
	}

	tst := make([]IIgnoreNullsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIgnoreNullsContext); ok {
			tst[i] = t.(IIgnoreNullsContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) IgnoreNulls(i int) IIgnoreNullsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIgnoreNullsContext)
}

func (s *WindowFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAG, 0)
}

func (s *WindowFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST_VALUE, 0)
}

func (s *WindowFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAST_VALUE, 0)
}

func (s *WindowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWindowFunction(s)
	}
}

func (s *WindowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWindowFunction(s)
	}
}

func (s *WindowFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitWindowFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) WindowFunction() (localctx IWindowFunctionContext) {
	localctx = NewWindowFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, StarRocksParserRULE_windowFunction)
	var _la int

	p.SetState(7431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7334)

			var _m = p.Match(StarRocksParserROW_NUMBER)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7335)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7336)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7337)

			var _m = p.Match(StarRocksParserRANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7338)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7339)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDENSE_RANK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7340)

			var _m = p.Match(StarRocksParserDENSE_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7341)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7342)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCUME_DIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7343)

			var _m = p.Match(StarRocksParserCUME_DIST)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7344)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7345)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPERCENT_RANK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7346)

			var _m = p.Match(StarRocksParserPERCENT_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7347)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7348)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserNTILE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7349)

			var _m = p.Match(StarRocksParserNTILE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7350)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7351)
				p.expression(0)
			}

		}
		{
			p.SetState(7354)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserLEAD:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7355)

			var _m = p.Match(StarRocksParserLEAD)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7356)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7357)
				p.expression(0)
			}
			p.SetState(7359)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7358)
					p.IgnoreNulls()
				}

			}
			p.SetState(7365)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7361)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7362)
					p.expression(0)
				}

				p.SetState(7367)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7370)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7371)
				p.IgnoreNulls()
			}

		}

	case StarRocksParserLAG:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7374)

			var _m = p.Match(StarRocksParserLAG)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7375)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7376)
				p.expression(0)
			}
			p.SetState(7378)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7377)
					p.IgnoreNulls()
				}

			}
			p.SetState(7384)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7380)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7381)
					p.expression(0)
				}

				p.SetState(7386)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7389)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7390)
				p.IgnoreNulls()
			}

		}

	case StarRocksParserFIRST_VALUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7393)

			var _m = p.Match(StarRocksParserFIRST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7394)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7395)
				p.expression(0)
			}
			p.SetState(7397)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7396)
					p.IgnoreNulls()
				}

			}
			p.SetState(7403)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7399)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7400)
					p.expression(0)
				}

				p.SetState(7405)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7408)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7409)
				p.IgnoreNulls()
			}

		}

	case StarRocksParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7412)

			var _m = p.Match(StarRocksParserLAST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7413)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-7020973281075532811) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-2608931654002016413) != 0) || ((int64((_la-193)) & ^0x3f) == 0 && ((int64(1)<<(_la-193))&-1412456610976449) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&-9111798888267829) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-288511856518103175) != 0) || ((int64((_la-385)) & ^0x3f) == 0 && ((int64(1)<<(_la-385))&-81241007747967049) != 0) || ((int64((_la-449)) & ^0x3f) == 0 && ((int64(1)<<(_la-449))&592238738256342323) != 0) || ((int64((_la-513)) & ^0x3f) == 0 && ((int64(1)<<(_la-513))&2162657) != 0) {
			{
				p.SetState(7414)
				p.expression(0)
			}
			p.SetState(7416)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7415)
					p.IgnoreNulls()
				}

			}
			p.SetState(7422)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7418)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7419)
					p.expression(0)
				}

				p.SetState(7424)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7427)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7428)
				p.IgnoreNulls()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, StarRocksParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7433)
		p.Match(StarRocksParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7434)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(7435)
		p.Match(StarRocksParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7436)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	WindowFrame() IWindowFrameContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	BracketHint() IBracketHintContext

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_over
	return p
}

func InitEmptyOverContext(p *OverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_over
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOver(s)
	}
}

func (s *OverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, StarRocksParserRULE_over)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7438)
		p.Match(StarRocksParserOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7439)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__5 || _la == StarRocksParserPARTITION {
		p.SetState(7441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__5 {
			{
				p.SetState(7440)
				p.BracketHint()
			}

		}
		{
			p.SetState(7443)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7444)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7445)

			var _x = p.expression(0)

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(7450)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(7446)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7447)

				var _x = p.expression(0)

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(7452)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(7455)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7456)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7457)
			p.SortItem()
		}
		p.SetState(7462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(7458)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7459)
				p.SortItem()
			}

			p.SetState(7464)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserRANGE || _la == StarRocksParserROWS {
		{
			p.SetState(7467)
			p.WindowFrame()
		}

	}
	{
		p.SetState(7470)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIgnoreNullsContext is an interface to support dynamic dispatch.
type IIgnoreNullsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE() antlr.TerminalNode
	NULLS() antlr.TerminalNode

	// IsIgnoreNullsContext differentiates from other interfaces.
	IsIgnoreNullsContext()
}

type IgnoreNullsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIgnoreNullsContext() *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ignoreNulls
	return p
}

func InitEmptyIgnoreNullsContext(p *IgnoreNullsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ignoreNulls
}

func (*IgnoreNullsContext) IsIgnoreNullsContext() {}

func NewIgnoreNullsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_ignoreNulls

	return p
}

func (s *IgnoreNullsContext) GetParser() antlr.Parser { return s.parser }

func (s *IgnoreNullsContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIGNORE, 0)
}

func (s *IgnoreNullsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULLS, 0)
}

func (s *IgnoreNullsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreNullsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IgnoreNullsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIgnoreNulls(s)
	}
}

func (s *IgnoreNullsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIgnoreNulls(s)
	}
}

func (s *IgnoreNullsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIgnoreNulls(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IgnoreNulls() (localctx IIgnoreNullsContext) {
	localctx = NewIgnoreNullsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, StarRocksParserRULE_ignoreNulls)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7472)
		p.Match(StarRocksParserIGNORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7473)
		p.Match(StarRocksParserNULLS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// Getter signatures
	RANGE() antlr.TerminalNode
	AllFrameBound() []IFrameBoundContext
	FrameBound(i int) IFrameBoundContext
	ROWS() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start_    IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (s *WindowFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitWindowFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, StarRocksParserRULE_windowFrame)
	p.SetState(7491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 880, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7475)

			var _m = p.Match(StarRocksParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7476)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7477)

			var _m = p.Match(StarRocksParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7478)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7479)

			var _m = p.Match(StarRocksParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7480)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7481)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7482)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7483)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7485)

			var _m = p.Match(StarRocksParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7486)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7487)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7488)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7489)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyAll(ctx *FrameBoundContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBoundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnboundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUnboundedFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentRowBoundContext struct {
	FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitCurrentRowBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, StarRocksParserRULE_frameBound)
	var _la int

	p.SetState(7502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 881, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7493)
			p.Match(StarRocksParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7494)

			var _m = p.Match(StarRocksParserPRECEDING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7495)
			p.Match(StarRocksParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7496)

			var _m = p.Match(StarRocksParserFOLLOWING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7497)
			p.Match(StarRocksParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7498)
			p.Match(StarRocksParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7499)
			p.expression(0)
		}
		{
			p.SetState(7500)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFOLLOWING || _la == StarRocksParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreObjectDescContext is an interface to support dynamic dispatch.
type IBackupRestoreObjectDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BackupRestoreTableDesc() IBackupRestoreTableDescContext
	ALL() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode

	// IsBackupRestoreObjectDescContext differentiates from other interfaces.
	IsBackupRestoreObjectDescContext()
}

type BackupRestoreObjectDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreObjectDescContext() *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreObjectDesc
	return p
}

func InitEmptyBackupRestoreObjectDescContext(p *BackupRestoreObjectDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreObjectDesc
}

func (*BackupRestoreObjectDescContext) IsBackupRestoreObjectDescContext() {}

func NewBackupRestoreObjectDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_backupRestoreObjectDesc

	return p
}

func (s *BackupRestoreObjectDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreObjectDescContext) BackupRestoreTableDesc() IBackupRestoreTableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreTableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreTableDescContext)
}

func (s *BackupRestoreObjectDescContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *BackupRestoreObjectDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreObjectDescContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *BackupRestoreObjectDescContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *BackupRestoreObjectDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *BackupRestoreObjectDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreObjectDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *BackupRestoreObjectDescContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *BackupRestoreObjectDescContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *BackupRestoreObjectDescContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *BackupRestoreObjectDescContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *BackupRestoreObjectDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreObjectDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreObjectDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackupRestoreObjectDesc(s)
	}
}

func (s *BackupRestoreObjectDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackupRestoreObjectDesc(s)
	}
}

func (s *BackupRestoreObjectDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBackupRestoreObjectDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BackupRestoreObjectDesc() (localctx IBackupRestoreObjectDescContext) {
	localctx = NewBackupRestoreObjectDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, StarRocksParserRULE_backupRestoreObjectDesc)
	var _la int

	p.SetState(7543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7504)
			p.BackupRestoreTableDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7505)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7506)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFUNCTION || _la == StarRocksParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserFUNCTION, StarRocksParserFUNCTIONS:
			{
				p.SetState(7507)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFUNCTION || _la == StarRocksParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7508)
				p.QualifiedName()
			}
			p.SetState(7511)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(7509)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7510)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7515)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7516)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserTABLE || _la == StarRocksParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserTABLE, StarRocksParserTABLES:
			{
				p.SetState(7517)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserTABLE || _la == StarRocksParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7518)
				p.BackupRestoreTableDesc()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(7531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7521)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7522)
				p.Match(StarRocksParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7523)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserMATERIALIZED:
			{
				p.SetState(7524)
				p.Match(StarRocksParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7525)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7526)
				p.QualifiedName()
			}
			p.SetState(7529)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(7527)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7528)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(7541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7533)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7534)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserVIEW, StarRocksParserVIEWS:
			{
				p.SetState(7535)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7536)
				p.QualifiedName()
			}
			p.SetState(7539)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(7537)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7538)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableDescContext is an interface to support dynamic dispatch.
type ITableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTableDescContext differentiates from other interfaces.
	IsTableDescContext()
}

type TableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableDescContext() *TableDescContext {
	var p = new(TableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableDesc
	return p
}

func InitEmptyTableDescContext(p *TableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableDesc
}

func (*TableDescContext) IsTableDescContext() {}

func NewTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableDescContext {
	var p = new(TableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableDesc

	return p
}

func (s *TableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableDesc(s)
	}
}

func (s *TableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableDesc(s)
	}
}

func (s *TableDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTableDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TableDesc() (localctx ITableDescContext) {
	localctx = NewTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, StarRocksParserRULE_tableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7545)
		p.QualifiedName()
	}
	p.SetState(7547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(7546)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreTableDescContext is an interface to support dynamic dispatch.
type IBackupRestoreTableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsBackupRestoreTableDescContext differentiates from other interfaces.
	IsBackupRestoreTableDescContext()
}

type BackupRestoreTableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreTableDescContext() *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreTableDesc
	return p
}

func InitEmptyBackupRestoreTableDescContext(p *BackupRestoreTableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreTableDesc
}

func (*BackupRestoreTableDescContext) IsBackupRestoreTableDescContext() {}

func NewBackupRestoreTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_backupRestoreTableDesc

	return p
}

func (s *BackupRestoreTableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreTableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreTableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *BackupRestoreTableDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *BackupRestoreTableDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreTableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreTableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreTableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackupRestoreTableDesc(s)
	}
}

func (s *BackupRestoreTableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackupRestoreTableDesc(s)
	}
}

func (s *BackupRestoreTableDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBackupRestoreTableDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BackupRestoreTableDesc() (localctx IBackupRestoreTableDescContext) {
	localctx = NewBackupRestoreTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, StarRocksParserRULE_backupRestoreTableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7549)
		p.QualifiedName()
	}
	p.SetState(7551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(7550)
			p.PartitionNames()
		}

	}
	p.SetState(7555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(7553)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7554)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainDescContext is an interface to support dynamic dispatch.
type IExplainDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode

	// IsExplainDescContext differentiates from other interfaces.
	IsExplainDescContext()
}

type ExplainDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainDescContext() *ExplainDescContext {
	var p = new(ExplainDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_explainDesc
	return p
}

func InitEmptyExplainDescContext(p *ExplainDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_explainDesc
}

func (*ExplainDescContext) IsExplainDescContext() {}

func NewExplainDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainDescContext {
	var p = new(ExplainDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_explainDesc

	return p
}

func (s *ExplainDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainDescContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *ExplainDescContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *ExplainDescContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPLAIN, 0)
}

func (s *ExplainDescContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL, 0)
}

func (s *ExplainDescContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *ExplainDescContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *ExplainDescContext) COSTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOSTS, 0)
}

func (s *ExplainDescContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULER, 0)
}

func (s *ExplainDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExplainDesc(s)
	}
}

func (s *ExplainDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExplainDesc(s)
	}
}

func (s *ExplainDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExplainDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExplainDesc() (localctx IExplainDescContext) {
	localctx = NewExplainDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, StarRocksParserRULE_explainDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7557)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-125)) & ^0x3f) == 0 && ((int64(1)<<(_la-125))&16777219) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserANALYZE || _la == StarRocksParserCOSTS || _la == StarRocksParserLOGICAL || _la == StarRocksParserSCHEDULER || _la == StarRocksParserVERBOSE {
		{
			p.SetState(7558)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserANALYZE || _la == StarRocksParserCOSTS || _la == StarRocksParserLOGICAL || _la == StarRocksParserSCHEDULER || _la == StarRocksParserVERBOSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizerTraceContext is an interface to support dynamic dispatch.
type IOptimizerTraceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRACE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	REASON() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsOptimizerTraceContext differentiates from other interfaces.
	IsOptimizerTraceContext()
}

type OptimizerTraceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizerTraceContext() *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizerTrace
	return p
}

func InitEmptyOptimizerTraceContext(p *OptimizerTraceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizerTrace
}

func (*OptimizerTraceContext) IsOptimizerTraceContext() {}

func NewOptimizerTraceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_optimizerTrace

	return p
}

func (s *OptimizerTraceContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizerTraceContext) TRACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRACE, 0)
}

func (s *OptimizerTraceContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *OptimizerTraceContext) LOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGS, 0)
}

func (s *OptimizerTraceContext) TIMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMES, 0)
}

func (s *OptimizerTraceContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *OptimizerTraceContext) REASON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREASON, 0)
}

func (s *OptimizerTraceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptimizerTraceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizerTraceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizerTraceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOptimizerTrace(s)
	}
}

func (s *OptimizerTraceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOptimizerTrace(s)
	}
}

func (s *OptimizerTraceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOptimizerTrace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) OptimizerTrace() (localctx IOptimizerTraceContext) {
	localctx = NewOptimizerTraceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, StarRocksParserRULE_optimizerTrace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7561)
		p.Match(StarRocksParserTRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7562)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserALL || _la == StarRocksParserLOGS || _la == StarRocksParserREASON || _la == StarRocksParserTIMES || _la == StarRocksParserVALUES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&4534550861405212027) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&141699191925459) != 0) || ((int64((_la-526)) & ^0x3f) == 0 && ((int64(1)<<(_la-526))&263) != 0) {
		{
			p.SetState(7563)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionExprContext is an interface to support dynamic dispatch.
type IPartitionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCall() IFunctionCallContext

	// IsPartitionExprContext differentiates from other interfaces.
	IsPartitionExprContext()
}

type PartitionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionExprContext() *PartitionExprContext {
	var p = new(PartitionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionExpr
	return p
}

func InitEmptyPartitionExprContext(p *PartitionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionExpr
}

func (*PartitionExprContext) IsPartitionExprContext() {}

func NewPartitionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionExprContext {
	var p = new(PartitionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionExpr

	return p
}

func (s *PartitionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionExpr(s)
	}
}

func (s *PartitionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionExpr(s)
	}
}

func (s *PartitionExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionExpr() (localctx IPartitionExprContext) {
	localctx = NewPartitionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, StarRocksParserRULE_partitionExpr)
	p.SetState(7568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 895, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7566)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7567)
			p.FunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDescContext is an interface to support dynamic dispatch.
type IPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AllRangePartitionDesc() []IRangePartitionDescContext
	RangePartitionDesc(i int) IRangePartitionDescContext
	PrimaryExpression() IPrimaryExpressionContext
	LIST() antlr.TerminalNode
	AllListPartitionDesc() []IListPartitionDescContext
	ListPartitionDesc(i int) IListPartitionDescContext
	FunctionCall() IFunctionCallContext
	AllPartitionExpr() []IPartitionExprContext
	PartitionExpr(i int) IPartitionExprContext

	// IsPartitionDescContext differentiates from other interfaces.
	IsPartitionDescContext()
}

type PartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDescContext() *PartitionDescContext {
	var p = new(PartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionDesc
	return p
}

func InitEmptyPartitionDescContext(p *PartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionDesc
}

func (*PartitionDescContext) IsPartitionDescContext() {}

func NewPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDescContext {
	var p = new(PartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionDesc

	return p
}

func (s *PartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *PartitionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *PartitionDescContext) RANGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANGE, 0)
}

func (s *PartitionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDescContext) AllRangePartitionDesc() []IRangePartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IRangePartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangePartitionDescContext); ok {
			tst[i] = t.(IRangePartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) RangePartitionDesc(i int) IRangePartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangePartitionDescContext)
}

func (s *PartitionDescContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PartitionDescContext) LIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIST, 0)
}

func (s *PartitionDescContext) AllListPartitionDesc() []IListPartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionDescContext); ok {
			tst[i] = t.(IListPartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) ListPartitionDesc(i int) IListPartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionDescContext)
}

func (s *PartitionDescContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionDescContext) AllPartitionExpr() []IPartitionExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionExprContext); ok {
			len++
		}
	}

	tst := make([]IPartitionExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionExprContext); ok {
			tst[i] = t.(IPartitionExprContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) PartitionExpr(i int) IPartitionExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionExprContext)
}

func (s *PartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionDesc(s)
	}
}

func (s *PartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionDesc(s)
	}
}

func (s *PartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionDesc() (localctx IPartitionDescContext) {
	localctx = NewPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, StarRocksParserRULE_partitionDesc)
	var _la int

	var _alt int

	p.SetState(7658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 907, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7570)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7571)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7572)
			p.Match(StarRocksParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7573)
			p.IdentifierList()
		}
		{
			p.SetState(7574)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserSTART {
			{
				p.SetState(7575)
				p.RangePartitionDesc()
			}
			p.SetState(7580)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7576)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7577)
					p.RangePartitionDesc()
				}

				p.SetState(7582)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7585)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7587)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7588)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7589)
			p.Match(StarRocksParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7590)
			p.primaryExpression(0)
		}
		{
			p.SetState(7591)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserSTART {
			{
				p.SetState(7592)
				p.RangePartitionDesc()
			}
			p.SetState(7597)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7593)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7594)
					p.RangePartitionDesc()
				}

				p.SetState(7599)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7602)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7604)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7605)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIST {
			{
				p.SetState(7606)
				p.Match(StarRocksParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7609)
			p.IdentifierList()
		}
		{
			p.SetState(7610)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION {
			{
				p.SetState(7611)
				p.ListPartitionDesc()
			}
			p.SetState(7616)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7612)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7613)
					p.ListPartitionDesc()
				}

				p.SetState(7618)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7621)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7623)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7624)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7626)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIST {
			{
				p.SetState(7625)
				p.Match(StarRocksParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7628)
			p.IdentifierList()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7629)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7630)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7631)
			p.FunctionCall()
		}
		{
			p.SetState(7632)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserSTART {
			{
				p.SetState(7633)
				p.RangePartitionDesc()
			}
			p.SetState(7638)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7634)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7635)
					p.RangePartitionDesc()
				}

				p.SetState(7640)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7643)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7645)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7646)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7647)
			p.FunctionCall()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7648)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7649)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7650)
			p.PartitionExpr()
		}
		p.SetState(7655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7651)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7652)
					p.PartitionExpr()
				}

			}
			p.SetState(7657)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 906, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionDescContext is an interface to support dynamic dispatch.
type IListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsListPartitionDescContext differentiates from other interfaces.
	IsListPartitionDescContext()
}

type ListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionDescContext() *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionDesc
	return p
}

func InitEmptyListPartitionDescContext(p *ListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionDesc
}

func (*ListPartitionDescContext) IsListPartitionDescContext() {}

func NewListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_listPartitionDesc

	return p
}

func (s *ListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionDescContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterListPartitionDesc(s)
	}
}

func (s *ListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitListPartitionDesc(s)
	}
}

func (s *ListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ListPartitionDesc() (localctx IListPartitionDescContext) {
	localctx = NewListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, StarRocksParserRULE_listPartitionDesc)
	p.SetState(7662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 908, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7660)
			p.SingleItemListPartitionDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7661)
			p.MultiItemListPartitionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleItemListPartitionDescContext is an interface to support dynamic dispatch.
type ISingleItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	SingleListPartitionValues() ISingleListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleItemListPartitionDescContext differentiates from other interfaces.
	IsSingleItemListPartitionDescContext()
}

type SingleItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleItemListPartitionDescContext() *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleItemListPartitionDesc
	return p
}

func InitEmptySingleItemListPartitionDescContext(p *SingleItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleItemListPartitionDesc
}

func (*SingleItemListPartitionDescContext) IsSingleItemListPartitionDescContext() {}

func NewSingleItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleItemListPartitionDesc

	return p
}

func (s *SingleItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *SingleItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *SingleItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *SingleItemListPartitionDescContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *SingleItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SingleItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *SingleItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *SingleItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleItemListPartitionDesc(s)
	}
}

func (s *SingleItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleItemListPartitionDesc(s)
	}
}

func (s *SingleItemListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSingleItemListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SingleItemListPartitionDesc() (localctx ISingleItemListPartitionDescContext) {
	localctx = NewSingleItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, StarRocksParserRULE_singleItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7664)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(7665)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7666)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7667)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7670)
		p.Identifier()
	}
	{
		p.SetState(7671)
		p.Match(StarRocksParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7672)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7673)
		p.SingleListPartitionValues()
	}
	p.SetState(7675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(7674)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiItemListPartitionDescContext is an interface to support dynamic dispatch.
type IMultiItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	MultiListPartitionValues() IMultiListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsMultiItemListPartitionDescContext differentiates from other interfaces.
	IsMultiItemListPartitionDescContext()
}

type MultiItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiItemListPartitionDescContext() *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiItemListPartitionDesc
	return p
}

func InitEmptyMultiItemListPartitionDescContext(p *MultiItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiItemListPartitionDesc
}

func (*MultiItemListPartitionDescContext) IsMultiItemListPartitionDescContext() {}

func NewMultiItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_multiItemListPartitionDesc

	return p
}

func (s *MultiItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *MultiItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *MultiItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *MultiItemListPartitionDescContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *MultiItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *MultiItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *MultiItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *MultiItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *MultiItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiItemListPartitionDesc(s)
	}
}

func (s *MultiItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiItemListPartitionDesc(s)
	}
}

func (s *MultiItemListPartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMultiItemListPartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MultiItemListPartitionDesc() (localctx IMultiItemListPartitionDescContext) {
	localctx = NewMultiItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, StarRocksParserRULE_multiItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7677)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(7678)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7679)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7680)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7683)
		p.Identifier()
	}
	{
		p.SetState(7684)
		p.Match(StarRocksParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7685)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7686)
		p.MultiListPartitionValues()
	}
	p.SetState(7688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(7687)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiListPartitionValuesContext is an interface to support dynamic dispatch.
type IMultiListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSingleListPartitionValues() []ISingleListPartitionValuesContext
	SingleListPartitionValues(i int) ISingleListPartitionValuesContext

	// IsMultiListPartitionValuesContext differentiates from other interfaces.
	IsMultiListPartitionValuesContext()
}

type MultiListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiListPartitionValuesContext() *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiListPartitionValues
	return p
}

func InitEmptyMultiListPartitionValuesContext(p *MultiListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiListPartitionValues
}

func (*MultiListPartitionValuesContext) IsMultiListPartitionValuesContext() {}

func NewMultiListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_multiListPartitionValues

	return p
}

func (s *MultiListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiListPartitionValuesContext) AllSingleListPartitionValues() []ISingleListPartitionValuesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			len++
		}
	}

	tst := make([]ISingleListPartitionValuesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleListPartitionValuesContext); ok {
			tst[i] = t.(ISingleListPartitionValuesContext)
			i++
		}
	}

	return tst
}

func (s *MultiListPartitionValuesContext) SingleListPartitionValues(i int) ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *MultiListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiListPartitionValues(s)
	}
}

func (s *MultiListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiListPartitionValues(s)
	}
}

func (s *MultiListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMultiListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MultiListPartitionValues() (localctx IMultiListPartitionValuesContext) {
	localctx = NewMultiListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, StarRocksParserRULE_multiListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7690)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7691)
		p.SingleListPartitionValues()
	}
	p.SetState(7696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7692)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7693)
			p.SingleListPartitionValues()
		}

		p.SetState(7698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7699)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleListPartitionValuesContext is an interface to support dynamic dispatch.
type ISingleListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllListPartitionValue() []IListPartitionValueContext
	ListPartitionValue(i int) IListPartitionValueContext

	// IsSingleListPartitionValuesContext differentiates from other interfaces.
	IsSingleListPartitionValuesContext()
}

type SingleListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleListPartitionValuesContext() *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleListPartitionValues
	return p
}

func InitEmptySingleListPartitionValuesContext(p *SingleListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleListPartitionValues
}

func (*SingleListPartitionValuesContext) IsSingleListPartitionValuesContext() {}

func NewSingleListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleListPartitionValues

	return p
}

func (s *SingleListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleListPartitionValuesContext) AllListPartitionValue() []IListPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionValueContext); ok {
			tst[i] = t.(IListPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *SingleListPartitionValuesContext) ListPartitionValue(i int) IListPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValueContext)
}

func (s *SingleListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleListPartitionValues(s)
	}
}

func (s *SingleListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleListPartitionValues(s)
	}
}

func (s *SingleListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSingleListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SingleListPartitionValues() (localctx ISingleListPartitionValuesContext) {
	localctx = NewSingleListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, StarRocksParserRULE_singleListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7701)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7702)
		p.ListPartitionValue()
	}
	p.SetState(7707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7703)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7704)
			p.ListPartitionValue()
		}

		p.SetState(7709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7710)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValuesContext is an interface to support dynamic dispatch.
type IListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleListPartitionValues() ISingleListPartitionValuesContext
	MultiListPartitionValues() IMultiListPartitionValuesContext

	// IsListPartitionValuesContext differentiates from other interfaces.
	IsListPartitionValuesContext()
}

type ListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValuesContext() *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValues
	return p
}

func InitEmptyListPartitionValuesContext(p *ListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValues
}

func (*ListPartitionValuesContext) IsListPartitionValuesContext() {}

func NewListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_listPartitionValues

	return p
}

func (s *ListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValuesContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterListPartitionValues(s)
	}
}

func (s *ListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitListPartitionValues(s)
	}
}

func (s *ListPartitionValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitListPartitionValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ListPartitionValues() (localctx IListPartitionValuesContext) {
	localctx = NewListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, StarRocksParserRULE_listPartitionValues)
	p.SetState(7714)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 915, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7712)
			p.SingleListPartitionValues()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7713)
			p.MultiListPartitionValues()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValueContext is an interface to support dynamic dispatch.
type IListPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	String_() IStringContext

	// IsListPartitionValueContext differentiates from other interfaces.
	IsListPartitionValueContext()
}

type ListPartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValueContext() *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValue
	return p
}

func InitEmptyListPartitionValueContext(p *ListPartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValue
}

func (*ListPartitionValueContext) IsListPartitionValueContext() {}

func NewListPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_listPartitionValue

	return p
}

func (s *ListPartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *ListPartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ListPartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterListPartitionValue(s)
	}
}

func (s *ListPartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitListPartitionValue(s)
	}
}

func (s *ListPartitionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitListPartitionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ListPartitionValue() (localctx IListPartitionValueContext) {
	localctx = NewListPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, StarRocksParserRULE_listPartitionValue)
	p.SetState(7718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7716)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7717)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stringList
	return p
}

func InitEmptyStringListContext(p *StringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stringList
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *StringListContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (s *StringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) StringList() (localctx IStringListContext) {
	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, StarRocksParserRULE_stringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7720)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7721)
		p.String_()
	}
	p.SetState(7726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7722)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7723)
			p.String_()
		}

		p.SetState(7728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7729)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionListContext is an interface to support dynamic dispatch.
type ILiteralExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLiteralExpression() []ILiteralExpressionContext
	LiteralExpression(i int) ILiteralExpressionContext

	// IsLiteralExpressionListContext differentiates from other interfaces.
	IsLiteralExpressionListContext()
}

type LiteralExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionListContext() *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpressionList
	return p
}

func InitEmptyLiteralExpressionListContext(p *LiteralExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpressionList
}

func (*LiteralExpressionListContext) IsLiteralExpressionListContext() {}

func NewLiteralExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_literalExpressionList

	return p
}

func (s *LiteralExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionListContext) AllLiteralExpression() []ILiteralExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILiteralExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralExpressionContext); ok {
			tst[i] = t.(ILiteralExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LiteralExpressionListContext) LiteralExpression(i int) ILiteralExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLiteralExpressionList(s)
	}
}

func (s *LiteralExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLiteralExpressionList(s)
	}
}

func (s *LiteralExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitLiteralExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) LiteralExpressionList() (localctx ILiteralExpressionListContext) {
	localctx = NewLiteralExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, StarRocksParserRULE_literalExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7731)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7732)
		p.LiteralExpression()
	}
	p.SetState(7737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7733)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7734)
			p.LiteralExpression()
		}

		p.SetState(7739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7740)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangePartitionDescContext is an interface to support dynamic dispatch.
type IRangePartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleRangePartition() ISingleRangePartitionContext
	MultiRangePartition() IMultiRangePartitionContext

	// IsRangePartitionDescContext differentiates from other interfaces.
	IsRangePartitionDescContext()
}

type RangePartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangePartitionDescContext() *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rangePartitionDesc
	return p
}

func InitEmptyRangePartitionDescContext(p *RangePartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rangePartitionDesc
}

func (*RangePartitionDescContext) IsRangePartitionDescContext() {}

func NewRangePartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rangePartitionDesc

	return p
}

func (s *RangePartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RangePartitionDescContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *RangePartitionDescContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *RangePartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangePartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangePartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRangePartitionDesc(s)
	}
}

func (s *RangePartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRangePartitionDesc(s)
	}
}

func (s *RangePartitionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRangePartitionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RangePartitionDesc() (localctx IRangePartitionDescContext) {
	localctx = NewRangePartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, StarRocksParserRULE_rangePartitionDesc)
	p.SetState(7744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7742)
			p.SingleRangePartition()
		}

	case StarRocksParserSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7743)
			p.MultiRangePartition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleRangePartitionContext is an interface to support dynamic dispatch.
type ISingleRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	PartitionKeyDesc() IPartitionKeyDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleRangePartitionContext differentiates from other interfaces.
	IsSingleRangePartitionContext()
}

type SingleRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleRangePartitionContext() *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleRangePartition
	return p
}

func InitEmptySingleRangePartitionContext(p *SingleRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleRangePartition
}

func (*SingleRangePartitionContext) IsSingleRangePartitionContext() {}

func NewSingleRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleRangePartition

	return p
}

func (s *SingleRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleRangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *SingleRangePartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleRangePartitionContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *SingleRangePartitionContext) PartitionKeyDesc() IPartitionKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyDescContext)
}

func (s *SingleRangePartitionContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SingleRangePartitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *SingleRangePartitionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *SingleRangePartitionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleRangePartition(s)
	}
}

func (s *SingleRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleRangePartition(s)
	}
}

func (s *SingleRangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSingleRangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SingleRangePartition() (localctx ISingleRangePartitionContext) {
	localctx = NewSingleRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, StarRocksParserRULE_singleRangePartition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7746)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(7747)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7748)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7749)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7752)
		p.Identifier()
	}
	{
		p.SetState(7753)
		p.Match(StarRocksParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7754)
		p.PartitionKeyDesc()
	}
	p.SetState(7756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(7755)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiRangePartitionContext is an interface to support dynamic dispatch.
type IMultiRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsMultiRangePartitionContext differentiates from other interfaces.
	IsMultiRangePartitionContext()
}

type MultiRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiRangePartitionContext() *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiRangePartition
	return p
}

func InitEmptyMultiRangePartitionContext(p *MultiRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiRangePartition
}

func (*MultiRangePartitionContext) IsMultiRangePartitionContext() {}

func NewMultiRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_multiRangePartition

	return p
}

func (s *MultiRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiRangePartitionContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *MultiRangePartitionContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *MultiRangePartitionContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *MultiRangePartitionContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *MultiRangePartitionContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *MultiRangePartitionContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *MultiRangePartitionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *MultiRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiRangePartition(s)
	}
}

func (s *MultiRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiRangePartition(s)
	}
}

func (s *MultiRangePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMultiRangePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MultiRangePartition() (localctx IMultiRangePartitionContext) {
	localctx = NewMultiRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, StarRocksParserRULE_multiRangePartition)
	p.SetState(7784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 922, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7758)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7759)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7760)
			p.String_()
		}
		{
			p.SetState(7761)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7762)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7763)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7764)
			p.String_()
		}
		{
			p.SetState(7765)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7766)
			p.Match(StarRocksParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7767)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7768)
			p.Interval()
		}
		{
			p.SetState(7769)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7771)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7772)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7773)
			p.String_()
		}
		{
			p.SetState(7774)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7775)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7776)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7777)
			p.String_()
		}
		{
			p.SetState(7778)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7779)
			p.Match(StarRocksParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7780)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7781)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7782)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRangeDescContext is an interface to support dynamic dispatch.
type IPartitionRangeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode

	// IsPartitionRangeDescContext differentiates from other interfaces.
	IsPartitionRangeDescContext()
}

type PartitionRangeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionRangeDescContext() *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRangeDesc
	return p
}

func InitEmptyPartitionRangeDescContext(p *PartitionRangeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRangeDesc
}

func (*PartitionRangeDescContext) IsPartitionRangeDescContext() {}

func NewPartitionRangeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionRangeDesc

	return p
}

func (s *PartitionRangeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRangeDescContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *PartitionRangeDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRangeDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionRangeDescContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *PartitionRangeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRangeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRangeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionRangeDesc(s)
	}
}

func (s *PartitionRangeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionRangeDesc(s)
	}
}

func (s *PartitionRangeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionRangeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionRangeDesc() (localctx IPartitionRangeDescContext) {
	localctx = NewPartitionRangeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, StarRocksParserRULE_partitionRangeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7786)
		p.Match(StarRocksParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7787)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7788)
		p.String_()
	}
	{
		p.SetState(7789)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7790)
		p.Match(StarRocksParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7791)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7792)
		p.String_()
	}
	{
		p.SetState(7793)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyDescContext is an interface to support dynamic dispatch.
type IPartitionKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext

	// IsPartitionKeyDescContext differentiates from other interfaces.
	IsPartitionKeyDescContext()
}

type PartitionKeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyDescContext() *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionKeyDesc
	return p
}

func InitEmptyPartitionKeyDescContext(p *PartitionKeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionKeyDesc
}

func (*PartitionKeyDescContext) IsPartitionKeyDescContext() {}

func NewPartitionKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionKeyDesc

	return p
}

func (s *PartitionKeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyDescContext) LESS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLESS, 0)
}

func (s *PartitionKeyDescContext) THAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTHAN, 0)
}

func (s *PartitionKeyDescContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAXVALUE, 0)
}

func (s *PartitionKeyDescContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyDescContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *PartitionKeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionKeyDesc(s)
	}
}

func (s *PartitionKeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionKeyDesc(s)
	}
}

func (s *PartitionKeyDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionKeyDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionKeyDesc() (localctx IPartitionKeyDescContext) {
	localctx = NewPartitionKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, StarRocksParserRULE_partitionKeyDesc)
	p.SetState(7807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7795)
			p.Match(StarRocksParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7796)
			p.Match(StarRocksParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserMAXVALUE:
			{
				p.SetState(7797)
				p.Match(StarRocksParserMAXVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserT__1:
			{
				p.SetState(7798)
				p.PartitionValueList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case StarRocksParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7801)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7802)
			p.PartitionValueList()
		}
		{
			p.SetState(7803)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7804)
			p.PartitionValueList()
		}
		{
			p.SetState(7805)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionValue() []IPartitionValueContext
	PartitionValue(i int) IPartitionValueContext

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) AllPartitionValue() []IPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueContext); ok {
			tst[i] = t.(IPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValue(i int) IPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueContext)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, StarRocksParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7809)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7810)
		p.PartitionValue()
	}
	p.SetState(7815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7811)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7812)
			p.PartitionValue()
		}

		p.SetState(7817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7818)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionContext is an interface to support dynamic dispatch.
type IKeyPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionColName returns the partitionColName rule contexts.
	GetPartitionColName() IIdentifierContext

	// GetPartitionColValue returns the partitionColValue rule contexts.
	GetPartitionColValue() ILiteralExpressionContext

	// SetPartitionColName sets the partitionColName rule contexts.
	SetPartitionColName(IIdentifierContext)

	// SetPartitionColValue sets the partitionColValue rule contexts.
	SetPartitionColValue(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	LiteralExpression() ILiteralExpressionContext

	// IsKeyPartitionContext differentiates from other interfaces.
	IsKeyPartitionContext()
}

type KeyPartitionContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	partitionColName  IIdentifierContext
	partitionColValue ILiteralExpressionContext
}

func NewEmptyKeyPartitionContext() *KeyPartitionContext {
	var p = new(KeyPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartition
	return p
}

func InitEmptyKeyPartitionContext(p *KeyPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartition
}

func (*KeyPartitionContext) IsKeyPartitionContext() {}

func NewKeyPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionContext {
	var p = new(KeyPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_keyPartition

	return p
}

func (s *KeyPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionContext) GetPartitionColName() IIdentifierContext { return s.partitionColName }

func (s *KeyPartitionContext) GetPartitionColValue() ILiteralExpressionContext {
	return s.partitionColValue
}

func (s *KeyPartitionContext) SetPartitionColName(v IIdentifierContext) { s.partitionColName = v }

func (s *KeyPartitionContext) SetPartitionColValue(v ILiteralExpressionContext) {
	s.partitionColValue = v
}

func (s *KeyPartitionContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *KeyPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyPartitionContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *KeyPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKeyPartition(s)
	}
}

func (s *KeyPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKeyPartition(s)
	}
}

func (s *KeyPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitKeyPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) KeyPartition() (localctx IKeyPartitionContext) {
	localctx = NewKeyPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, StarRocksParserRULE_keyPartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7820)

		var _x = p.Identifier()

		localctx.(*KeyPartitionContext).partitionColName = _x
	}
	{
		p.SetState(7821)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7822)

		var _x = p.LiteralExpression()

		localctx.(*KeyPartitionContext).partitionColValue = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueContext is an interface to support dynamic dispatch.
type IPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAXVALUE() antlr.TerminalNode
	String_() IStringContext

	// IsPartitionValueContext differentiates from other interfaces.
	IsPartitionValueContext()
}

type PartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueContext() *PartitionValueContext {
	var p = new(PartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValue
	return p
}

func InitEmptyPartitionValueContext(p *PartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValue
}

func (*PartitionValueContext) IsPartitionValueContext() {}

func NewPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueContext {
	var p = new(PartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionValue

	return p
}

func (s *PartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAXVALUE, 0)
}

func (s *PartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionValue(s)
	}
}

func (s *PartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionValue(s)
	}
}

func (s *PartitionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPartitionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PartitionValue() (localctx IPartitionValueContext) {
	localctx = NewPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, StarRocksParserRULE_partitionValue)
	p.SetState(7826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserMAXVALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7824)
			p.Match(StarRocksParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7825)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionClauseContext is an interface to support dynamic dispatch.
type IDistributionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDistributionClauseContext differentiates from other interfaces.
	IsDistributionClauseContext()
}

type DistributionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionClauseContext() *DistributionClauseContext {
	var p = new(DistributionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionClause
	return p
}

func InitEmptyDistributionClauseContext(p *DistributionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionClause
}

func (*DistributionClauseContext) IsDistributionClauseContext() {}

func NewDistributionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionClauseContext {
	var p = new(DistributionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_distributionClause

	return p
}

func (s *DistributionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTED, 0)
}

func (s *DistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *DistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHASH, 0)
}

func (s *DistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *DistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDistributionClause(s)
	}
}

func (s *DistributionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDistributionClause(s)
	}
}

func (s *DistributionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDistributionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DistributionClause() (localctx IDistributionClauseContext) {
	localctx = NewDistributionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, StarRocksParserRULE_distributionClause)
	var _la int

	p.SetState(7840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 928, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7828)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7829)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7830)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7831)
			p.IdentifierList()
		}
		p.SetState(7834)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBUCKETS {
			{
				p.SetState(7832)
				p.Match(StarRocksParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7833)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7836)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7837)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7838)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7839)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionDescContext is an interface to support dynamic dispatch.
type IDistributionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode

	// IsDistributionDescContext differentiates from other interfaces.
	IsDistributionDescContext()
}

type DistributionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionDescContext() *DistributionDescContext {
	var p = new(DistributionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionDesc
	return p
}

func InitEmptyDistributionDescContext(p *DistributionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionDesc
}

func (*DistributionDescContext) IsDistributionDescContext() {}

func NewDistributionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionDescContext {
	var p = new(DistributionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_distributionDesc

	return p
}

func (s *DistributionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionDescContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTED, 0)
}

func (s *DistributionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *DistributionDescContext) HASH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHASH, 0)
}

func (s *DistributionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionDescContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *DistributionDescContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DistributionDescContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANDOM, 0)
}

func (s *DistributionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDistributionDesc(s)
	}
}

func (s *DistributionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDistributionDesc(s)
	}
}

func (s *DistributionDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDistributionDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DistributionDesc() (localctx IDistributionDescContext) {
	localctx = NewDistributionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, StarRocksParserRULE_distributionDesc)
	var _la int

	p.SetState(7861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7842)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7843)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7844)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7845)
			p.IdentifierList()
		}
		p.SetState(7848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBUCKETS {
			{
				p.SetState(7846)
				p.Match(StarRocksParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7847)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7850)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7851)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7852)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7853)
			p.IdentifierList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7854)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7855)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7856)
			p.Match(StarRocksParserRANDOM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBUCKETS {
			{
				p.SetState(7857)
				p.Match(StarRocksParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7858)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshSchemeDescContext is an interface to support dynamic dispatch.
type IRefreshSchemeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INCREMENTAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	START() antlr.TerminalNode
	String_() IStringContext

	// IsRefreshSchemeDescContext differentiates from other interfaces.
	IsRefreshSchemeDescContext()
}

type RefreshSchemeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshSchemeDescContext() *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshSchemeDesc
	return p
}

func InitEmptyRefreshSchemeDescContext(p *RefreshSchemeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshSchemeDesc
}

func (*RefreshSchemeDescContext) IsRefreshSchemeDescContext() {}

func NewRefreshSchemeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshSchemeDesc

	return p
}

func (s *RefreshSchemeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshSchemeDescContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshSchemeDescContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *RefreshSchemeDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *RefreshSchemeDescContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *RefreshSchemeDescContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINCREMENTAL, 0)
}

func (s *RefreshSchemeDescContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMANUAL, 0)
}

func (s *RefreshSchemeDescContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMMEDIATE, 0)
}

func (s *RefreshSchemeDescContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFERRED, 0)
}

func (s *RefreshSchemeDescContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *RefreshSchemeDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshSchemeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshSchemeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshSchemeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshSchemeDesc(s)
	}
}

func (s *RefreshSchemeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshSchemeDesc(s)
	}
}

func (s *RefreshSchemeDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitRefreshSchemeDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) RefreshSchemeDesc() (localctx IRefreshSchemeDescContext) {
	localctx = NewRefreshSchemeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, StarRocksParserRULE_refreshSchemeDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7863)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFERRED || _la == StarRocksParserIMMEDIATE {
		{
			p.SetState(7864)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserDEFERRED || _la == StarRocksParserIMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(7883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 934, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7867)
			p.Match(StarRocksParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(7868)
			p.Match(StarRocksParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSTART {
			{
				p.SetState(7869)
				p.Match(StarRocksParserSTART)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7870)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7871)
				p.String_()
			}
			{
				p.SetState(7872)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7876)
			p.Match(StarRocksParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7877)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7878)
			p.Interval()
		}
		{
			p.SetState(7879)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(7881)
			p.Match(StarRocksParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(7882)
			p.Match(StarRocksParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatusDescContext is an interface to support dynamic dispatch.
type IStatusDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIVE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode

	// IsStatusDescContext differentiates from other interfaces.
	IsStatusDescContext()
}

type StatusDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatusDescContext() *StatusDescContext {
	var p = new(StatusDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_statusDesc
	return p
}

func InitEmptyStatusDescContext(p *StatusDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_statusDesc
}

func (*StatusDescContext) IsStatusDescContext() {}

func NewStatusDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatusDescContext {
	var p = new(StatusDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_statusDesc

	return p
}

func (s *StatusDescContext) GetParser() antlr.Parser { return s.parser }

func (s *StatusDescContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserACTIVE, 0)
}

func (s *StatusDescContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINACTIVE, 0)
}

func (s *StatusDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatusDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatusDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStatusDesc(s)
	}
}

func (s *StatusDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStatusDesc(s)
	}
}

func (s *StatusDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitStatusDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) StatusDesc() (localctx IStatusDescContext) {
	localctx = NewStatusDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, StarRocksParserRULE_statusDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7885)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserACTIVE || _la == StarRocksParserINACTIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (s *PropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, StarRocksParserRULE_properties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7887)
		p.Match(StarRocksParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7888)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7889)
		p.Property()
	}
	p.SetState(7894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7890)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7891)
			p.Property()
		}

		p.SetState(7896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7897)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtPropertiesContext is an interface to support dynamic dispatch.
type IExtPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BROKER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsExtPropertiesContext differentiates from other interfaces.
	IsExtPropertiesContext()
}

type ExtPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtPropertiesContext() *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_extProperties
	return p
}

func InitEmptyExtPropertiesContext(p *ExtPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_extProperties
}

func (*ExtPropertiesContext) IsExtPropertiesContext() {}

func NewExtPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_extProperties

	return p
}

func (s *ExtPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtPropertiesContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *ExtPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExtPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExtProperties(s)
	}
}

func (s *ExtPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExtProperties(s)
	}
}

func (s *ExtPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitExtProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ExtProperties() (localctx IExtPropertiesContext) {
	localctx = NewExtPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, StarRocksParserRULE_extProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7899)
		p.Match(StarRocksParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7900)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (s *PropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, StarRocksParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7902)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7903)
		p.Property()
	}
	p.SetState(7908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7904)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7905)
			p.Property()
		}

		p.SetState(7910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7911)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPropertyListContext is an interface to support dynamic dispatch.
type IUserPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsUserPropertyListContext differentiates from other interfaces.
	IsUserPropertyListContext()
}

type UserPropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserPropertyListContext() *UserPropertyListContext {
	var p = new(UserPropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userPropertyList
	return p
}

func InitEmptyUserPropertyListContext(p *UserPropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userPropertyList
}

func (*UserPropertyListContext) IsUserPropertyListContext() {}

func NewUserPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPropertyListContext {
	var p = new(UserPropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_userPropertyList

	return p
}

func (s *UserPropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *UserPropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *UserPropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserPropertyList(s)
	}
}

func (s *UserPropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserPropertyList(s)
	}
}

func (s *UserPropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUserPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UserPropertyList() (localctx IUserPropertyListContext) {
	localctx = NewUserPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, StarRocksParserRULE_userPropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7913)
		p.Property()
	}
	p.SetState(7918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7914)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7915)
			p.Property()
		}

		p.SetState(7920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IStringContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IStringContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IStringContext
	value  IStringContext
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) GetKey() IStringContext { return s.key }

func (s *PropertyContext) GetValue() IStringContext { return s.value }

func (s *PropertyContext) SetKey(v IStringContext) { s.key = v }

func (s *PropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *PropertyContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PropertyContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (s *PropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, StarRocksParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7921)

		var _x = p.String_()

		localctx.(*PropertyContext).key = _x
	}
	{
		p.SetState(7922)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7923)

		var _x = p.String_()

		localctx.(*PropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertiesContext is an interface to support dynamic dispatch.
type IInlinePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInlineProperty() []IInlinePropertyContext
	InlineProperty(i int) IInlinePropertyContext

	// IsInlinePropertiesContext differentiates from other interfaces.
	IsInlinePropertiesContext()
}

type InlinePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlinePropertiesContext() *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperties
	return p
}

func InitEmptyInlinePropertiesContext(p *InlinePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperties
}

func (*InlinePropertiesContext) IsInlinePropertiesContext() {}

func NewInlinePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_inlineProperties

	return p
}

func (s *InlinePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertiesContext) AllInlineProperty() []IInlinePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			len++
		}
	}

	tst := make([]IInlinePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInlinePropertyContext); ok {
			tst[i] = t.(IInlinePropertyContext)
			i++
		}
	}

	return tst
}

func (s *InlinePropertiesContext) InlineProperty(i int) IInlinePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertyContext)
}

func (s *InlinePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineProperties(s)
	}
}

func (s *InlinePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineProperties(s)
	}
}

func (s *InlinePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInlineProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) InlineProperties() (localctx IInlinePropertiesContext) {
	localctx = NewInlinePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, StarRocksParserRULE_inlineProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7925)
		p.InlineProperty()
	}
	p.SetState(7929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&4534550861405212027) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&141699191925459) != 0) || ((int64((_la-526)) & ^0x3f) == 0 && ((int64(1)<<(_la-526))&263) != 0) {
		{
			p.SetState(7926)
			p.InlineProperty()
		}

		p.SetState(7931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertyContext is an interface to support dynamic dispatch.
type IInlinePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsInlinePropertyContext differentiates from other interfaces.
	IsInlinePropertyContext()
}

type InlinePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IIdentifierContext
	value  IStringContext
}

func NewEmptyInlinePropertyContext() *InlinePropertyContext {
	var p = new(InlinePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperty
	return p
}

func InitEmptyInlinePropertyContext(p *InlinePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperty
}

func (*InlinePropertyContext) IsInlinePropertyContext() {}

func NewInlinePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertyContext {
	var p = new(InlinePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_inlineProperty

	return p
}

func (s *InlinePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertyContext) GetKey() IIdentifierContext { return s.key }

func (s *InlinePropertyContext) GetValue() IStringContext { return s.value }

func (s *InlinePropertyContext) SetKey(v IIdentifierContext) { s.key = v }

func (s *InlinePropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *InlinePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *InlinePropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlinePropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *InlinePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineProperty(s)
	}
}

func (s *InlinePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineProperty(s)
	}
}

func (s *InlinePropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInlineProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) InlineProperty() (localctx IInlinePropertyContext) {
	localctx = NewInlinePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, StarRocksParserRULE_inlineProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7932)

		var _x = p.Identifier()

		localctx.(*InlinePropertyContext).key = _x
	}
	{
		p.SetState(7933)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7934)

		var _x = p.String_()

		localctx.(*InlinePropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarTypeContext is an interface to support dynamic dispatch.
type IVarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode

	// IsVarTypeContext differentiates from other interfaces.
	IsVarTypeContext()
}

type VarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarTypeContext() *VarTypeContext {
	var p = new(VarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_varType
	return p
}

func InitEmptyVarTypeContext(p *VarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_varType
}

func (*VarTypeContext) IsVarTypeContext() {}

func NewVarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarTypeContext {
	var p = new(VarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_varType

	return p
}

func (s *VarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *VarTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCAL, 0)
}

func (s *VarTypeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *VarTypeContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *VarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterVarType(s)
	}
}

func (s *VarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitVarType(s)
	}
}

func (s *VarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitVarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) VarType() (localctx IVarTypeContext) {
	localctx = NewVarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, StarRocksParserRULE_varType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7936)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	String_() IStringContext

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comment
	return p
}

func InitEmptyCommentContext(p *CommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comment
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *CommentContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitComment(s)
	}
}

func (s *CommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, StarRocksParserRULE_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7938)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7939)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutfileContext is an interface to support dynamic dispatch.
type IOutfileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFile returns the file rule contexts.
	GetFile() IStringContext

	// SetFile sets the file rule contexts.
	SetFile(IStringContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	String_() IStringContext
	FileFormat() IFileFormatContext
	Properties() IPropertiesContext

	// IsOutfileContext differentiates from other interfaces.
	IsOutfileContext()
}

type OutfileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	file   IStringContext
}

func NewEmptyOutfileContext() *OutfileContext {
	var p = new(OutfileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outfile
	return p
}

func InitEmptyOutfileContext(p *OutfileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outfile
}

func (*OutfileContext) IsOutfileContext() {}

func NewOutfileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutfileContext {
	var p = new(OutfileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_outfile

	return p
}

func (s *OutfileContext) GetParser() antlr.Parser { return s.parser }

func (s *OutfileContext) GetFile() IStringContext { return s.file }

func (s *OutfileContext) SetFile(v IStringContext) { s.file = v }

func (s *OutfileContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *OutfileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOUTFILE, 0)
}

func (s *OutfileContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OutfileContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *OutfileContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *OutfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutfileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOutfile(s)
	}
}

func (s *OutfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOutfile(s)
	}
}

func (s *OutfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitOutfile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Outfile() (localctx IOutfileContext) {
	localctx = NewOutfileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, StarRocksParserRULE_outfile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7941)
		p.Match(StarRocksParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7942)
		p.Match(StarRocksParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7943)

		var _x = p.String_()

		localctx.(*OutfileContext).file = _x
	}
	p.SetState(7945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORMAT {
		{
			p.SetState(7944)
			p.FileFormat()
		}

	}
	p.SetState(7948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(7947)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileFormatContext is an interface to support dynamic dispatch.
type IFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsFileFormatContext differentiates from other interfaces.
	IsFileFormatContext()
}

type FileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileFormatContext() *FileFormatContext {
	var p = new(FileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fileFormat
	return p
}

func InitEmptyFileFormatContext(p *FileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fileFormat
}

func (*FileFormatContext) IsFileFormatContext() {}

func NewFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileFormatContext {
	var p = new(FileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_fileFormat

	return p
}

func (s *FileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *FileFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORMAT, 0)
}

func (s *FileFormatContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *FileFormatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileFormatContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFileFormat(s)
	}
}

func (s *FileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFileFormat(s)
	}
}

func (s *FileFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitFileFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) FileFormat() (localctx IFileFormatContext) {
	localctx = NewFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, StarRocksParserRULE_fileFormat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7950)
		p.Match(StarRocksParserFORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7951)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(7952)
			p.Identifier()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(7953)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSINGLE_QUOTED_TEXT, 0)
}

func (s *StringContext) DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOUBLE_QUOTED_TEXT, 0)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitString(s)
	}
}

func (s *StringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, StarRocksParserRULE_string)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7956)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserSINGLE_QUOTED_TEXT || _la == StarRocksParserDOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode
	BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_binary
	return p
}

func InitEmptyBinaryContext(p *BinaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_binary
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY_SINGLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBinary(s)
	}
}

func (s *BinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Binary() (localctx IBinaryContext) {
	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, StarRocksParserRULE_binary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7958)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserBINARY_SINGLE_QUOTED_TEXT || _la == StarRocksParserBINARY_DOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	EQ_FOR_NULL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGTE, 0)
}

func (s *ComparisonOperatorContext) EQ_FOR_NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ_FOR_NULL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, StarRocksParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7960)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-493)) & ^0x3f) == 0 && ((int64(1)<<(_la-493))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, StarRocksParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7962)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFALSE || _la == StarRocksParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetFrom() IUnitIdentifierContext { return s.from }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetFrom(v IUnitIdentifierContext) { s.from = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, StarRocksParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7964)
		p.Match(StarRocksParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7965)

		var _x = p.expression(0)

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(7966)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskIntervalContext is an interface to support dynamic dispatch.
type ITaskIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() ITaskUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(ITaskUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	TaskUnitIdentifier() ITaskUnitIdentifierContext

	// IsTaskIntervalContext differentiates from other interfaces.
	IsTaskIntervalContext()
}

type TaskIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   ITaskUnitIdentifierContext
}

func NewEmptyTaskIntervalContext() *TaskIntervalContext {
	var p = new(TaskIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskInterval
	return p
}

func InitEmptyTaskIntervalContext(p *TaskIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskInterval
}

func (*TaskIntervalContext) IsTaskIntervalContext() {}

func NewTaskIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskIntervalContext {
	var p = new(TaskIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskInterval

	return p
}

func (s *TaskIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskIntervalContext) GetValue() IExpressionContext { return s.value }

func (s *TaskIntervalContext) GetFrom() ITaskUnitIdentifierContext { return s.from }

func (s *TaskIntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *TaskIntervalContext) SetFrom(v ITaskUnitIdentifierContext) { s.from = v }

func (s *TaskIntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERVAL, 0)
}

func (s *TaskIntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TaskIntervalContext) TaskUnitIdentifier() ITaskUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskUnitIdentifierContext)
}

func (s *TaskIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskInterval(s)
	}
}

func (s *TaskIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskInterval(s)
	}
}

func (s *TaskIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTaskInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TaskInterval() (localctx ITaskIntervalContext) {
	localctx = NewTaskIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, StarRocksParserRULE_taskInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7968)
		p.Match(StarRocksParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7969)

		var _x = p.expression(0)

		localctx.(*TaskIntervalContext).value = _x
	}
	{
		p.SetState(7970)

		var _x = p.TaskUnitIdentifier()

		localctx.(*TaskIntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskUnitIdentifierContext is an interface to support dynamic dispatch.
type ITaskUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsTaskUnitIdentifierContext differentiates from other interfaces.
	IsTaskUnitIdentifierContext()
}

type TaskUnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskUnitIdentifierContext() *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskUnitIdentifier
	return p
}

func InitEmptyTaskUnitIdentifierContext(p *TaskUnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskUnitIdentifier
}

func (*TaskUnitIdentifierContext) IsTaskUnitIdentifierContext() {}

func NewTaskUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskUnitIdentifier

	return p
}

func (s *TaskUnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskUnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *TaskUnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *TaskUnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *TaskUnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *TaskUnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskUnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskUnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskUnitIdentifier(s)
	}
}

func (s *TaskUnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskUnitIdentifier(s)
	}
}

func (s *TaskUnitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTaskUnitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TaskUnitIdentifier() (localctx ITaskUnitIdentifierContext) {
	localctx = NewTaskUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, StarRocksParserRULE_taskUnitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7972)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDAY || _la == StarRocksParserHOUR || _la == StarRocksParserMINUTE || _la == StarRocksParserSECOND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserYEAR, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *UnitIdentifierContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUARTER, 0)
}

func (s *UnitIdentifierContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMILLISECOND, 0)
}

func (s *UnitIdentifierContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMICROSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUnitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, StarRocksParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7974)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDAY || _la == StarRocksParserHOUR || ((int64((_la-261)) & ^0x3f) == 0 && ((int64(1)<<(_la-261))&1035) != 0) || _la == StarRocksParserQUARTER || _la == StarRocksParserSECOND || _la == StarRocksParserWEEK || _la == StarRocksParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitBoundaryContext is an interface to support dynamic dispatch.
type IUnitBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsUnitBoundaryContext differentiates from other interfaces.
	IsUnitBoundaryContext()
}

type UnitBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitBoundaryContext() *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitBoundary
	return p
}

func InitEmptyUnitBoundaryContext(p *UnitBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitBoundary
}

func (*UnitBoundaryContext) IsUnitBoundaryContext() {}

func NewUnitBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_unitBoundary

	return p
}

func (s *UnitBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitBoundaryContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOOR, 0)
}

func (s *UnitBoundaryContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCEIL, 0)
}

func (s *UnitBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitBoundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnitBoundary(s)
	}
}

func (s *UnitBoundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnitBoundary(s)
	}
}

func (s *UnitBoundaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUnitBoundary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) UnitBoundary() (localctx IUnitBoundaryContext) {
	localctx = NewUnitBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, StarRocksParserRULE_unitBoundary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7976)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserCEIL || _la == StarRocksParserFLOOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseType() IBaseTypeContext
	DecimalType() IDecimalTypeContext
	ArrayType() IArrayTypeContext
	StructType() IStructTypeContext
	MapType() IMapTypeContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypeContext) DecimalType() IDecimalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalTypeContext)
}

func (s *TypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, StarRocksParserRULE_type)
	p.SetState(7983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserBIGINT, StarRocksParserBINARY, StarRocksParserBITMAP, StarRocksParserBOOLEAN, StarRocksParserCHAR, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDOUBLE, StarRocksParserFLOAT, StarRocksParserHLL, StarRocksParserINT, StarRocksParserINTEGER, StarRocksParserJSON, StarRocksParserLARGEINT, StarRocksParserPERCENTILE, StarRocksParserSIGNED, StarRocksParserSMALLINT, StarRocksParserSTRING, StarRocksParserTEXT, StarRocksParserTIME, StarRocksParserTINYINT, StarRocksParserUNSIGNED, StarRocksParserVARBINARY, StarRocksParserVARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7978)
			p.BaseType()
		}

	case StarRocksParserDECIMAL, StarRocksParserDECIMALV2, StarRocksParserDECIMAL32, StarRocksParserDECIMAL64, StarRocksParserDECIMAL128, StarRocksParserNUMBER, StarRocksParserNUMERIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7979)
			p.DecimalType()
		}

	case StarRocksParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7980)
			p.ArrayType()
		}

	case StarRocksParserSTRUCT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7981)
			p.StructType()
		}

	case StarRocksParserMAP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7982)
			p.MapType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	Type_() ITypeContext
	GT() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY, 0)
}

func (s *ArrayTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, StarRocksParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7985)
		p.Match(StarRocksParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7986)
		p.Match(StarRocksParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7987)
		p.Type_()
	}
	{
		p.SetState(7988)
		p.Match(StarRocksParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	GT() antlr.TerminalNode

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAP, 0)
}

func (s *MapTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *MapTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *MapTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MapTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, StarRocksParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7990)
		p.Match(StarRocksParserMAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7991)
		p.Match(StarRocksParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7992)
		p.Type_()
	}
	{
		p.SetState(7993)
		p.Match(StarRocksParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7994)
		p.Type_()
	}
	{
		p.SetState(7995)
		p.Match(StarRocksParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescContext is an interface to support dynamic dispatch.
type ISubfieldDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	Identifier() IIdentifierContext
	NestedFieldName() INestedFieldNameContext

	// IsSubfieldDescContext differentiates from other interfaces.
	IsSubfieldDescContext()
}

type SubfieldDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescContext() *SubfieldDescContext {
	var p = new(SubfieldDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDesc
	return p
}

func InitEmptySubfieldDescContext(p *SubfieldDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDesc
}

func (*SubfieldDescContext) IsSubfieldDescContext() {}

func NewSubfieldDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescContext {
	var p = new(SubfieldDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subfieldDesc

	return p
}

func (s *SubfieldDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SubfieldDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldDescContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *SubfieldDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubfieldDesc(s)
	}
}

func (s *SubfieldDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubfieldDesc(s)
	}
}

func (s *SubfieldDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSubfieldDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SubfieldDesc() (localctx ISubfieldDescContext) {
	localctx = NewSubfieldDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, StarRocksParserRULE_subfieldDesc)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(7999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 943, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7997)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(7998)
			p.NestedFieldName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(8001)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescsContext is an interface to support dynamic dispatch.
type ISubfieldDescsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldDesc() []ISubfieldDescContext
	SubfieldDesc(i int) ISubfieldDescContext

	// IsSubfieldDescsContext differentiates from other interfaces.
	IsSubfieldDescsContext()
}

type SubfieldDescsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescsContext() *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDescs
	return p
}

func InitEmptySubfieldDescsContext(p *SubfieldDescsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDescs
}

func (*SubfieldDescsContext) IsSubfieldDescsContext() {}

func NewSubfieldDescsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subfieldDescs

	return p
}

func (s *SubfieldDescsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescsContext) AllSubfieldDesc() []ISubfieldDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldDescContext); ok {
			tst[i] = t.(ISubfieldDescContext)
			i++
		}
	}

	return tst
}

func (s *SubfieldDescsContext) SubfieldDesc(i int) ISubfieldDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *SubfieldDescsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubfieldDescs(s)
	}
}

func (s *SubfieldDescsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubfieldDescs(s)
	}
}

func (s *SubfieldDescsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitSubfieldDescs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) SubfieldDescs() (localctx ISubfieldDescsContext) {
	localctx = NewSubfieldDescsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, StarRocksParserRULE_subfieldDescs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8003)
		p.SubfieldDesc()
	}
	p.SetState(8008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8004)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8005)
			p.SubfieldDesc()
		}

		p.SetState(8010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LT() antlr.TerminalNode
	SubfieldDescs() ISubfieldDescsContext
	GT() antlr.TerminalNode

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRUCT, 0)
}

func (s *StructTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *StructTypeContext) SubfieldDescs() ISubfieldDescsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescsContext)
}

func (s *StructTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (s *StructTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitStructType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, StarRocksParserRULE_structType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8011)
		p.Match(StarRocksParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8012)
		p.Match(StarRocksParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8013)
		p.SubfieldDescs()
	}
	{
		p.SetState(8014)
		p.Match(StarRocksParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, StarRocksParserRULE_typeParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8016)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8017)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8018)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	TypeParameter() ITypeParameterContext
	SMALLINT() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	STRING() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	HLL() antlr.TerminalNode
	PERCENTILE() antlr.TerminalNode
	JSON() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	BINARY() antlr.TerminalNode

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_baseType
	return p
}

func InitEmptyBaseTypeContext(p *BaseTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_baseType
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBOOLEAN, 0)
}

func (s *BaseTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTINYINT, 0)
}

func (s *BaseTypeContext) TypeParameter() ITypeParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *BaseTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSMALLINT, 0)
}

func (s *BaseTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSIGNED, 0)
}

func (s *BaseTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINT, 0)
}

func (s *BaseTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER, 0)
}

func (s *BaseTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNSIGNED, 0)
}

func (s *BaseTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIGINT, 0)
}

func (s *BaseTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLARGEINT, 0)
}

func (s *BaseTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOAT, 0)
}

func (s *BaseTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOUBLE, 0)
}

func (s *BaseTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATE, 0)
}

func (s *BaseTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATETIME, 0)
}

func (s *BaseTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIME, 0)
}

func (s *BaseTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *BaseTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARCHAR, 0)
}

func (s *BaseTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRING, 0)
}

func (s *BaseTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEXT, 0)
}

func (s *BaseTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP, 0)
}

func (s *BaseTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHLL, 0)
}

func (s *BaseTypeContext) PERCENTILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENTILE, 0)
}

func (s *BaseTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJSON, 0)
}

func (s *BaseTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARBINARY, 0)
}

func (s *BaseTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY, 0)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (s *BaseTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBaseType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, StarRocksParserRULE_baseType)
	var _la int

	p.SetState(8088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8020)
			p.Match(StarRocksParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8021)
			p.Match(StarRocksParserTINYINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8022)
				p.TypeParameter()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8025)
			p.Match(StarRocksParserSMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8026)
				p.TypeParameter()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8029)
			p.Match(StarRocksParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINT {
			{
				p.SetState(8030)
				p.Match(StarRocksParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(8033)
			p.Match(StarRocksParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINTEGER {
			{
				p.SetState(8034)
				p.Match(StarRocksParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(8037)
			p.Match(StarRocksParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINT {
			{
				p.SetState(8038)
				p.Match(StarRocksParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(8041)
			p.Match(StarRocksParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINTEGER {
			{
				p.SetState(8042)
				p.Match(StarRocksParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(8045)
			p.Match(StarRocksParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8047)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8046)
				p.TypeParameter()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(8049)
			p.Match(StarRocksParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8050)
				p.TypeParameter()
			}

		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(8053)
			p.Match(StarRocksParserBIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8054)
				p.TypeParameter()
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(8057)
			p.Match(StarRocksParserLARGEINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8058)
				p.TypeParameter()
			}

		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(8061)
			p.Match(StarRocksParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(8062)
			p.Match(StarRocksParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(8063)
			p.Match(StarRocksParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(8064)
			p.Match(StarRocksParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(8065)
			p.Match(StarRocksParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(8066)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8067)
				p.TypeParameter()
			}

		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(8070)
			p.Match(StarRocksParserVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8071)
				p.TypeParameter()
			}

		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(8074)
			p.Match(StarRocksParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(8075)
			p.Match(StarRocksParserTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(8076)
			p.Match(StarRocksParserBITMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(8077)
			p.Match(StarRocksParserHLL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(8078)
			p.Match(StarRocksParserPERCENTILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(8079)
			p.Match(StarRocksParserJSON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(8080)
			p.Match(StarRocksParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8081)
				p.TypeParameter()
			}

		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(8084)
			p.Match(StarRocksParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8085)
				p.TypeParameter()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalTypeContext is an interface to support dynamic dispatch.
type IDecimalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrecision returns the precision token.
	GetPrecision() antlr.Token

	// GetScale returns the scale token.
	GetScale() antlr.Token

	// SetPrecision sets the precision token.
	SetPrecision(antlr.Token)

	// SetScale sets the scale token.
	SetScale(antlr.Token)

	// Getter signatures
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMAL32() antlr.TerminalNode
	DECIMAL64() antlr.TerminalNode
	DECIMAL128() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDecimalTypeContext differentiates from other interfaces.
	IsDecimalTypeContext()
}

type DecimalTypeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	precision antlr.Token
	scale     antlr.Token
}

func NewEmptyDecimalTypeContext() *DecimalTypeContext {
	var p = new(DecimalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decimalType
	return p
}

func InitEmptyDecimalTypeContext(p *DecimalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decimalType
}

func (*DecimalTypeContext) IsDecimalTypeContext() {}

func NewDecimalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalTypeContext {
	var p = new(DecimalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_decimalType

	return p
}

func (s *DecimalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalTypeContext) GetPrecision() antlr.Token { return s.precision }

func (s *DecimalTypeContext) GetScale() antlr.Token { return s.scale }

func (s *DecimalTypeContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *DecimalTypeContext) SetScale(v antlr.Token) { s.scale = v }

func (s *DecimalTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL, 0)
}

func (s *DecimalTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMALV2, 0)
}

func (s *DecimalTypeContext) DECIMAL32() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL32, 0)
}

func (s *DecimalTypeContext) DECIMAL64() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL64, 0)
}

func (s *DecimalTypeContext) DECIMAL128() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL128, 0)
}

func (s *DecimalTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMERIC, 0)
}

func (s *DecimalTypeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMBER, 0)
}

func (s *DecimalTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *DecimalTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *DecimalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecimalType(s)
	}
}

func (s *DecimalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecimalType(s)
	}
}

func (s *DecimalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDecimalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) DecimalType() (localctx IDecimalTypeContext) {
	localctx = NewDecimalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, StarRocksParserRULE_decimalType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8090)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-111)) & ^0x3f) == 0 && ((int64(1)<<(_la-111))&31) != 0) || _la == StarRocksParserNUMBER || _la == StarRocksParserNUMERIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(8098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(8091)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8092)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*DecimalTypeContext).precision = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__2 {
			{
				p.SetState(8093)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8094)

				var _m = p.Match(StarRocksParserINTEGER_VALUE)

				localctx.(*DecimalTypeContext).scale = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8097)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserDOT_IDENTIFIER)
}

func (s *QualifiedNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOT_IDENTIFIER, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, StarRocksParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8100)
		p.Identifier()
	}
	p.SetState(8106)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(8104)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case StarRocksParserDOT_IDENTIFIER:
				{
					p.SetState(8101)
					p.Match(StarRocksParserDOT_IDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case StarRocksParserT__0:
				{
					p.SetState(8102)
					p.Match(StarRocksParserT__0)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(8103)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(8108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, StarRocksParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8109)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWriteBranchContext is an interface to support dynamic dispatch.
type IWriteBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode

	// IsWriteBranchContext differentiates from other interfaces.
	IsWriteBranchContext()
}

type WriteBranchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteBranchContext() *WriteBranchContext {
	var p = new(WriteBranchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_writeBranch
	return p
}

func InitEmptyWriteBranchContext(p *WriteBranchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_writeBranch
}

func (*WriteBranchContext) IsWriteBranchContext() {}

func NewWriteBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteBranchContext {
	var p = new(WriteBranchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_writeBranch

	return p
}

func (s *WriteBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteBranchContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *WriteBranchContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *WriteBranchContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *WriteBranchContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteBranchContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *WriteBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWriteBranch(s)
	}
}

func (s *WriteBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWriteBranch(s)
	}
}

func (s *WriteBranchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitWriteBranch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) WriteBranch() (localctx IWriteBranchContext) {
	localctx = NewWriteBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, StarRocksParserRULE_writeBranch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(8112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(8111)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(8114)
		p.Match(StarRocksParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8115)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8116)
		p.Match(StarRocksParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8117)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitBackQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type DigitIdentifierContext struct {
	IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDigitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) LETTER_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLETTER_IDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, StarRocksParserRULE_identifier)
	p.SetState(8123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLETTER_IDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8119)
			p.Match(StarRocksParserLETTER_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserDOTDOTDOT:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8120)
			p.NonReserved()
		}

	case StarRocksParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8121)
			p.Match(StarRocksParserDIGIT_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8122)
			p.Match(StarRocksParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOriginalName returns the originalName rule contexts.
	GetOriginalName() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetOriginalName sets the originalName rule contexts.
	SetOriginalName(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AS() antlr.TerminalNode

	// IsIdentifierWithAliasContext differentiates from other interfaces.
	IsIdentifierWithAliasContext()
}

type IdentifierWithAliasContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	originalName IIdentifierContext
	alias        IIdentifierContext
}

func NewEmptyIdentifierWithAliasContext() *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAlias
	return p
}

func InitEmptyIdentifierWithAliasContext(p *IdentifierWithAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAlias
}

func (*IdentifierWithAliasContext) IsIdentifierWithAliasContext() {}

func NewIdentifierWithAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierWithAlias

	return p
}

func (s *IdentifierWithAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasContext) GetOriginalName() IIdentifierContext { return s.originalName }

func (s *IdentifierWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *IdentifierWithAliasContext) SetOriginalName(v IIdentifierContext) { s.originalName = v }

func (s *IdentifierWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *IdentifierWithAliasContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *IdentifierWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierWithAlias(s)
	}
}

func (s *IdentifierWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierWithAlias(s)
	}
}

func (s *IdentifierWithAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIdentifierWithAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IdentifierWithAlias() (localctx IIdentifierWithAliasContext) {
	localctx = NewIdentifierWithAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, StarRocksParserRULE_identifierWithAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8125)

		var _x = p.Identifier()

		localctx.(*IdentifierWithAliasContext).originalName = _x
	}
	p.SetState(8128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(8126)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8127)

			var _x = p.Identifier()

			localctx.(*IdentifierWithAliasContext).alias = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasListContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierWithAlias() []IIdentifierWithAliasContext
	IdentifierWithAlias(i int) IIdentifierWithAliasContext

	// IsIdentifierWithAliasListContext differentiates from other interfaces.
	IsIdentifierWithAliasListContext()
}

type IdentifierWithAliasListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierWithAliasListContext() *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAliasList
	return p
}

func InitEmptyIdentifierWithAliasListContext(p *IdentifierWithAliasListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAliasList
}

func (*IdentifierWithAliasListContext) IsIdentifierWithAliasListContext() {}

func NewIdentifierWithAliasListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierWithAliasList

	return p
}

func (s *IdentifierWithAliasListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasListContext) AllIdentifierWithAlias() []IIdentifierWithAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierWithAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierWithAliasContext); ok {
			tst[i] = t.(IIdentifierWithAliasContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasListContext) IdentifierWithAlias(i int) IIdentifierWithAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasContext)
}

func (s *IdentifierWithAliasListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierWithAliasList(s)
	}
}

func (s *IdentifierWithAliasListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierWithAliasList(s)
	}
}

func (s *IdentifierWithAliasListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIdentifierWithAliasList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IdentifierWithAliasList() (localctx IIdentifierWithAliasListContext) {
	localctx = NewIdentifierWithAliasListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, StarRocksParserRULE_identifierWithAliasList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8130)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8131)
		p.IdentifierWithAlias()
	}
	p.SetState(8136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8132)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8133)
			p.IdentifierWithAlias()
		}

		p.SetState(8138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8139)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, StarRocksParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8141)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8142)
		p.Identifier()
	}
	p.SetState(8147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8143)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8144)
			p.Identifier()
		}

		p.SetState(8149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8150)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringContext is an interface to support dynamic dispatch.
type IIdentifierOrStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringContext differentiates from other interfaces.
	IsIdentifierOrStringContext()
}

type IdentifierOrStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringContext() *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrString
	return p
}

func InitEmptyIdentifierOrStringContext(p *IdentifierOrStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrString
}

func (*IdentifierOrStringContext) IsIdentifierOrStringContext() {}

func NewIdentifierOrStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierOrString

	return p
}

func (s *IdentifierOrStringContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierOrString(s)
	}
}

func (s *IdentifierOrStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierOrString(s)
	}
}

func (s *IdentifierOrStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIdentifierOrString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IdentifierOrString() (localctx IIdentifierOrStringContext) {
	localctx = NewIdentifierOrStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, StarRocksParserRULE_identifierOrString)
	p.SetState(8154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8152)
			p.Identifier()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8153)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringListContext is an interface to support dynamic dispatch.
type IIdentifierOrStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsIdentifierOrStringListContext differentiates from other interfaces.
	IsIdentifierOrStringListContext()
}

type IdentifierOrStringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringListContext() *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringList
	return p
}

func InitEmptyIdentifierOrStringListContext(p *IdentifierOrStringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringList
}

func (*IdentifierOrStringListContext) IsIdentifierOrStringListContext() {}

func NewIdentifierOrStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierOrStringList

	return p
}

func (s *IdentifierOrStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierOrStringListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *IdentifierOrStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierOrStringList(s)
	}
}

func (s *IdentifierOrStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierOrStringList(s)
	}
}

func (s *IdentifierOrStringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIdentifierOrStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IdentifierOrStringList() (localctx IIdentifierOrStringListContext) {
	localctx = NewIdentifierOrStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, StarRocksParserRULE_identifierOrStringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8156)
		p.IdentifierOrString()
	}
	p.SetState(8161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8157)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8158)
			p.IdentifierOrString()
		}

		p.SetState(8163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringOrStarContext is an interface to support dynamic dispatch.
type IIdentifierOrStringOrStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringOrStarContext differentiates from other interfaces.
	IsIdentifierOrStringOrStarContext()
}

type IdentifierOrStringOrStarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringOrStarContext() *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringOrStar
	return p
}

func InitEmptyIdentifierOrStringOrStarContext(p *IdentifierOrStringOrStarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringOrStar
}

func (*IdentifierOrStringOrStarContext) IsIdentifierOrStringOrStarContext() {}

func NewIdentifierOrStringOrStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierOrStringOrStar

	return p
}

func (s *IdentifierOrStringOrStarContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringOrStarContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *IdentifierOrStringOrStarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringOrStarContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringOrStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringOrStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringOrStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierOrStringOrStar(s)
	}
}

func (s *IdentifierOrStringOrStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierOrStringOrStar(s)
	}
}

func (s *IdentifierOrStringOrStarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIdentifierOrStringOrStar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) IdentifierOrStringOrStar() (localctx IIdentifierOrStringOrStarContext) {
	localctx = NewIdentifierOrStringOrStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, StarRocksParserRULE_identifierOrStringOrStar)
	p.SetState(8167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserASTERISK_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8164)
			p.Match(StarRocksParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCNGROUP, StarRocksParserCNGROUPS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXCEPT, StarRocksParserEXCLUDE, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8165)
			p.Identifier()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8166)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) CopyAll(ctx *UserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UserWithHostAndBlanketContext struct {
	UserContext
}

func NewUserWithHostAndBlanketContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostAndBlanketContext {
	var p = new(UserWithHostAndBlanketContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostAndBlanketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostAndBlanketContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostAndBlanketContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostAndBlanketContext) AT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, 0)
}

func (s *UserWithHostAndBlanketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserWithHostAndBlanket(s)
	}
}

func (s *UserWithHostAndBlanketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserWithHostAndBlanket(s)
	}
}

func (s *UserWithHostAndBlanketContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUserWithHostAndBlanket(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserWithHostContext struct {
	UserContext
}

func NewUserWithHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostContext {
	var p = new(UserWithHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostContext) AT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, 0)
}

func (s *UserWithHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserWithHost(s)
	}
}

func (s *UserWithHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserWithHost(s)
	}
}

func (s *UserWithHostContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUserWithHost(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserWithoutHostContext struct {
	UserContext
}

func NewUserWithoutHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithoutHostContext {
	var p = new(UserWithoutHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithoutHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithoutHostContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithoutHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserWithoutHost(s)
	}
}

func (s *UserWithoutHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserWithoutHost(s)
	}
}

func (s *UserWithoutHostContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitUserWithoutHost(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, StarRocksParserRULE_user)
	p.SetState(8180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 972, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserWithoutHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8169)
			p.IdentifierOrString()
		}

	case 2:
		localctx = NewUserWithHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8170)
			p.IdentifierOrString()
		}
		{
			p.SetState(8171)
			p.Match(StarRocksParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8172)
			p.IdentifierOrString()
		}

	case 3:
		localctx = NewUserWithHostAndBlanketContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8174)
			p.IdentifierOrString()
		}
		{
			p.SetState(8175)
			p.Match(StarRocksParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8176)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8177)
			p.IdentifierOrString()
		}
		{
			p.SetState(8178)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	ExpressionOrDefault() IExpressionOrDefaultContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *AssignmentContext) ExpressionOrDefault() IExpressionOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (s *AssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, StarRocksParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8182)
		p.Identifier()
	}
	{
		p.SetState(8183)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8184)
		p.ExpressionOrDefault()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (s *AssignmentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitAssignmentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, StarRocksParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8186)
		p.Assignment()
	}
	p.SetState(8191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8187)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8188)
			p.Assignment()
		}

		p.SetState(8193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalValueContext struct {
	NumberContext
}

func NewDecimalValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalValueContext {
	var p = new(DecimalValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalValueContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL_VALUE, 0)
}

func (s *DecimalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecimalValue(s)
	}
}

func (s *DecimalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecimalValue(s)
	}
}

func (s *DecimalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDecimalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerValueContext struct {
	NumberContext
}

func NewIntegerValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerValueContext {
	var p = new(IntegerValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerValueContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *IntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIntegerValue(s)
	}
}

func (s *IntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIntegerValue(s)
	}
}

func (s *IntegerValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitIntegerValue(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoubleValueContext struct {
	NumberContext
}

func NewDoubleValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleValueContext {
	var p = new(DoubleValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleValueContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOUBLE_VALUE, 0)
}

func (s *DoubleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDoubleValue(s)
	}
}

func (s *DoubleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDoubleValue(s)
	}
}

func (s *DoubleValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitDoubleValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, StarRocksParserRULE_number)
	p.SetState(8197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserDECIMAL_VALUE:
		localctx = NewDecimalValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8194)
			p.Match(StarRocksParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDOUBLE_VALUE:
		localctx = NewDoubleValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8195)
			p.Match(StarRocksParserDOUBLE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserINTEGER_VALUE:
		localctx = NewIntegerValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8196)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCESS() antlr.TerminalNode
	ACTIVE() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AVG() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	AUTHENTICATION() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	BODY() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BASE() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CLEAN() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	CNGROUP() antlr.TerminalNode
	CNGROUPS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DIALECT() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DICTIONARY_GET() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	END() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FN() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FOLLOWER() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IMAGE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode
	INTERMEDIATE() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOCATIONS() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MAPPING() antlr.TerminalNode
	MAPPINGS() antlr.TerminalNode
	MASKING() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	META() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NO() antlr.TerminalNode
	NODE() antlr.TerminalNode
	NODES() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTIMIZER() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	OFF() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PENDING() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	PIVOT() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PREDICATE() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	REASON() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REWRITE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	RULE() antlr.TerminalNode
	RULES() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SNAPSHOTS() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	START() antlr.TerminalNode
	STARROCKS() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	SUM() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SKIP_HEADER() antlr.TerminalNode
	SWAP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	STATS() antlr.TerminalNode
	SUBMIT() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	TAG() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRACE() antlr.TerminalNode
	TRANSLATE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	DOTDOTDOT() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	ARRAY_ELEMENT() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserACCESS, 0)
}

func (s *NonReservedContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserACTIVE, 0)
}

func (s *NonReservedContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAGGREGATE, 0)
}

func (s *NonReservedContext) APPLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAPPLY, 0)
}

func (s *NonReservedContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHORS, 0)
}

func (s *NonReservedContext) AVG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAVG, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *NonReservedContext) ANTI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANTI, 0)
}

func (s *NonReservedContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHENTICATION, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTOMATED, 0)
}

func (s *NonReservedContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG, 0)
}

func (s *NonReservedContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG_DISTINCT, 0)
}

func (s *NonReservedContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEGIN, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *NonReservedContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKHOLE, 0)
}

func (s *NonReservedContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY, 0)
}

func (s *NonReservedContext) BODY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBODY, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBRANCH, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUILTIN, 0)
}

func (s *NonReservedContext) BASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASE, 0)
}

func (s *NonReservedContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEFORE, 0)
}

func (s *NonReservedContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCACHE, 0)
}

func (s *NonReservedContext) CAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCAST, 0)
}

func (s *NonReservedContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *NonReservedContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCEIL, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAIN, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *NonReservedContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAN, 0)
}

func (s *NonReservedContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAR, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTERS, 0)
}

func (s *NonReservedContext) CNGROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUP, 0)
}

func (s *NonReservedContext) CNGROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCNGROUPS, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATION, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *NonReservedContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUME_DIST, 0)
}

func (s *NonReservedContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUMULATIVE, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONNECTION, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONSISTENT, 0)
}

func (s *NonReservedContext) COSTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOSTS, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOUNT, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONFIG, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPACT, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATE, 0)
}

func (s *NonReservedContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATETIME, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *NonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAYS, 0)
}

func (s *NonReservedContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *NonReservedContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDIALECT, 0)
}

func (s *NonReservedContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *NonReservedContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *NonReservedContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTION, 0)
}

func (s *NonReservedContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUPLICATE, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDYNAMIC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *NonReservedContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY_GET, 0)
}

func (s *NonReservedContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEALLOCATE, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENABLE, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserERRORS, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVENTS, 0)
}

func (s *NonReservedContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *NonReservedContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTRACT, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *NonReservedContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENCLOSE, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserESCAPE, 0)
}

func (s *NonReservedContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *NonReservedContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINT, 0)
}

func (s *NonReservedContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINTS, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *NonReservedContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOOR, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORMAT, 0)
}

func (s *NonReservedContext) FN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFN, 0)
}

func (s *NonReservedContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTENDS, 0)
}

func (s *NonReservedContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWER, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFREE, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANTS, 0)
}

func (s *NonReservedContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP_CONCAT, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHASH, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHELP, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOST, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *NonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOURS, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMAGE, 0)
}

func (s *NonReservedContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *NonReservedContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINACTIVE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEXES, 0)
}

func (s *NonReservedContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSTALL, 0)
}

func (s *NonReservedContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *NonReservedContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATIONS, 0)
}

func (s *NonReservedContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERMEDIATE, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERVAL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAST, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEVEL, 0)
}

func (s *NonReservedContext) LIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIST, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCAL, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATION, 0)
}

func (s *NonReservedContext) LOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGS, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL, 0)
}

func (s *NonReservedContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOW_PRIORITY, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCK, 0)
}

func (s *NonReservedContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATIONS, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAP, 0)
}

func (s *NonReservedContext) MAPPING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAPPING, 0)
}

func (s *NonReservedContext) MAPPINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAPPINGS, 0)
}

func (s *NonReservedContext) MASKING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMASKING, 0)
}

func (s *NonReservedContext) MATCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATCH, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAX, 0)
}

func (s *NonReservedContext) META() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMETA, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *NonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTES, 0)
}

func (s *NonReservedContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMONTH, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMERGE, 0)
}

func (s *NonReservedContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS, 0)
}

func (s *NonReservedContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNEGATIVE, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, 0)
}

func (s *NonReservedContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *NonReservedContext) NODES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODES, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULLS, 0)
}

func (s *NonReservedContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMBER, 0)
}

func (s *NonReservedContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMERIC, 0)
}

func (s *NonReservedContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOBSERVER, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserONLY, 0)
}

func (s *NonReservedContext) OPTIMIZER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTIMIZER, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPEN, 0)
}

func (s *NonReservedContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPERATE, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *NonReservedContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOVERWRITE, 0)
}

func (s *NonReservedContext) OFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFF, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPAUSE, 0)
}

func (s *NonReservedContext) PENDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPENDING, 0)
}

func (s *NonReservedContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENTILE_UNION, 0)
}

func (s *NonReservedContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIVOT, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPOLICY, 0)
}

func (s *NonReservedContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPOLICIES, 0)
}

func (s *NonReservedContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENT_RANK, 0)
}

func (s *NonReservedContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREDICATE, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIORITY, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROC, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILE, 0)
}

func (s *NonReservedContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILELIST, 0)
}

func (s *NonReservedContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *NonReservedContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDERS, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROBABILITY, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTY, 0)
}

func (s *NonReservedContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *NonReservedContext) PIPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPES, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERY, 0)
}

func (s *NonReservedContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERIES, 0)
}

func (s *NonReservedContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUEUE, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUOTA, 0)
}

func (s *NonReservedContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUALIFY, 0)
}

func (s *NonReservedContext) REASON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREASON, 0)
}

func (s *NonReservedContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREMOVE, 0)
}

func (s *NonReservedContext) REWRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREWRITE, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANDOM, 0)
}

func (s *NonReservedContext) RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANK, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *NonReservedContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPAIR, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORIES, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *NonReservedContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETAIN, 0)
}

func (s *NonReservedContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETENTION, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETURNS, 0)
}

func (s *NonReservedContext) RETRY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETRY, 0)
}

func (s *NonReservedContext) REVERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVERT, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLES, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLBACK, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROW, 0)
}

func (s *NonReservedContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRUNNING, 0)
}

func (s *NonReservedContext) RULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULE, 0)
}

func (s *NonReservedContext) RULES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULES, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULER, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *NonReservedContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEPARATOR, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SEMI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMI, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSETS, 0)
}

func (s *NonReservedContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSIGNED, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOTS, 0)
}

func (s *NonReservedContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *NonReservedContext) STARROCKS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTARROCKS, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTREAM, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUM, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTOP, 0)
}

func (s *NonReservedContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSKIP_HEADER, 0)
}

func (s *NonReservedContext) SWAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSWAP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRUCT, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATS, 0)
}

func (s *NonReservedContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUBMIT, 0)
}

func (s *NonReservedContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUSPEND, 0)
}

func (s *NonReservedContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *NonReservedContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM_TIME, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *NonReservedContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *NonReservedContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLETS, 0)
}

func (s *NonReservedContext) TAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTAG, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPADD, 0)
}

func (s *NonReservedContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPDIFF, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIME, 0)
}

func (s *NonReservedContext) TIMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMES, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRACE, 0)
}

func (s *NonReservedContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSLATE, 0)
}

func (s *NonReservedContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIM_SPACE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTYPES, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNSET, 0)
}

func (s *NonReservedContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNINSTALL, 0)
}

func (s *NonReservedContext) USAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSAGE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *NonReservedContext) USERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSERS, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNLOCK, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUE, 0)
}

func (s *NonReservedContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARBINARY, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARIABLES, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *NonReservedContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *NonReservedContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUMES, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWEEK, 0)
}

func (s *NonReservedContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHITELIST, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWRITE, 0)
}

func (s *NonReservedContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *NonReservedContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserYEAR, 0)
}

func (s *NonReservedContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOTDOTDOT, 0)
}

func (s *NonReservedContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNGRAMBF, 0)
}

func (s *NonReservedContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVECTOR, 0)
}

func (s *NonReservedContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELD, 0)
}

func (s *NonReservedContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_ELEMENT, 0)
}

func (s *NonReservedContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERSISTENT, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCEPT, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case StarRocksVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *StarRocksParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, StarRocksParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8199)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&-6664167256628462851) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&-1331487429127569487) != 0) || ((int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&-7546427580836201) != 0) || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&-4573491655345179) != 0) || ((int64((_la-324)) & ^0x3f) == 0 && ((int64(1)<<(_la-324))&9114828243924942831) != 0) || ((int64((_la-389)) & ^0x3f) == 0 && ((int64(1)<<(_la-389))&4534550861405212027) != 0) || ((int64((_la-453)) & ^0x3f) == 0 && ((int64(1)<<(_la-453))&141699191925459) != 0) || _la == StarRocksParserDOTDOTDOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *StarRocksParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 381:
		var t *QueryPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*QueryPrimaryContext)
		}
		return p.QueryPrimary_Sempred(t, predIndex)

	case 425:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 427:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 431:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 432:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *StarRocksParser) QueryPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
